State 0:
## Known stack suffix:
##
## LR(1) items:
p4program' -> . p4program [ # ]
## Transitions:
-- On VOID shift to state 1
-- On VARBIT shift to state 2
-- On TYPEDEF shift to state 200
-- On TYPE shift to state 407
-- On TUPLE shift to state 16
-- On STRUCT shift to state 201
-- On STRING shift to state 18
-- On SEMICOLON shift to state 414
-- On PRAGMA shift to state 207
-- On PARSER shift to state 415
-- On PACKAGE shift to state 449
-- On NAME shift to state 11
-- On MATCH_KIND shift to state 455
-- On INT shift to state 20
-- On HEADER_UNION shift to state 332
-- On HEADER shift to state 337
-- On EXTERN shift to state 459
-- On ERROR shift to state 510
-- On ENUM shift to state 342
-- On DOT shift to state 38
-- On CONTROL shift to state 514
-- On CONST shift to state 520
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On ACTION shift to state 527
-- On varName shift to state 479
-- On typedefDeclaration shift to state 671
-- On typeRef shift to state 630
-- On typeOrVoid shift to state 462
-- On typeName shift to state 138
-- On typeDeclaration shift to state 672
-- On tupleType shift to state 128
-- On topDeclarationList shift to state 976
-- On topDeclaration shift to state 674
-- On structTypeDeclaration shift to state 371
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parserTypeDeclaration shift to state 676
-- On parserDeclaration shift to state 810
-- On packageTypeDeclaration shift to state 811
-- On p4program shift to state 978
-- On nonempty_list_aux(annotation) shift to state 325
-- On matchKindDeclaration shift to state 814
-- On instantiation shift to state 815
-- On headerUnionDeclaration shift to state 372
-- On headerTypeDeclaration shift to state 373
-- On headerStackType shift to state 142
-- On functionPrototype shift to state 633
-- On functionDeclaration shift to state 816
-- On externDeclaration shift to state 817
-- On errorDeclaration shift to state 818
-- On enumDeclaration shift to state 374
-- On dotPrefix shift to state 143
-- On derivedTypeDeclaration shift to state 819
-- On controlTypeDeclaration shift to state 820
-- On controlDeclaration shift to state 930
-- On constantDeclaration shift to state 931
-- On baseType shift to state 146
-- On annotations shift to state 932
-- On annotation shift to state 331
-- On actionDeclaration shift to state 975
## Reductions:
-- On END
--   reduce production topDeclarationList ->

State 1:
## Known stack suffix:
## VOID
## LR(1) items:
typeOrVoid -> VOID . [ TYPE STATE NAME KEY ENTRIES APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeOrVoid -> VOID

State 2:
## Known stack suffix:
## VARBIT
## LR(1) items:
baseType -> VARBIT . L_ANGLE INTEGER R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
baseType -> VARBIT . L_ANGLE L_PAREN expression R_PAREN R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On L_ANGLE shift to state 3
## Reductions:

State 3:
## Known stack suffix:
## VARBIT L_ANGLE
## LR(1) items:
baseType -> VARBIT L_ANGLE . INTEGER R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
baseType -> VARBIT L_ANGLE . L_PAREN expression R_PAREN R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On L_PAREN shift to state 4
-- On INTEGER shift to state 198
## Reductions:

State 4:
## Known stack suffix:
## VARBIT L_ANGLE L_PAREN
## LR(1) items:
baseType -> VARBIT L_ANGLE L_PAREN . expression R_PAREN R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 195
-- On dotPrefix shift to state 91
## Reductions:

State 5:
## Known stack suffix:
## TYPE
## LR(1) items:
nonTypeName -> TYPE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTypeName -> TYPE

State 6:
## Known stack suffix:
## TRUE
## LR(1) items:
expression -> TRUE . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> TRUE

State 7:
## Known stack suffix:
## STRING_LITERAL
## LR(1) items:
expression -> STRING_LITERAL . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> STRING_LITERAL

State 8:
## Known stack suffix:
## STATE
## LR(1) items:
nonTypeName -> STATE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTypeName -> STATE

State 9:
## Known stack suffix:
## PLUS
## LR(1) items:
expression -> PLUS . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 194
-- On dotPrefix shift to state 91
## Reductions:

State 10:
## Known stack suffix:
## NOT
## LR(1) items:
expression -> NOT . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 193
-- On dotPrefix shift to state 91
## Reductions:

State 11:
## Known stack suffix:
## NAME
## LR(1) items:
prefixedType -> NAME . TYPENAME [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN L_BRACKET L_ANGLE KEY ENTRIES DOT COMMA APPLY ACTIONS ]
varName -> NAME . IDENTIFIER [ TYPE STATE SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE NAME MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY GE EQ ENTRIES DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND ASSIGN APPLY AND ACTIONS ]
## Transitions:
-- On TYPENAME shift to state 12
-- On IDENTIFIER shift to state 13
## Reductions:

State 12:
## Known stack suffix:
## NAME TYPENAME
## LR(1) items:
prefixedType -> NAME TYPENAME . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN L_BRACKET L_ANGLE KEY ENTRIES DOT COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production prefixedType -> NAME TYPENAME

State 13:
## Known stack suffix:
## NAME IDENTIFIER
## LR(1) items:
varName -> NAME IDENTIFIER . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production varName -> NAME IDENTIFIER

State 14:
## Known stack suffix:
## MINUS
## LR(1) items:
expression -> MINUS . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 192
-- On dotPrefix shift to state 91
## Reductions:

State 15:
## Known stack suffix:
## L_PAREN
## LR(1) items:
expression -> L_PAREN . expression R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> L_PAREN . typeRef R_PAREN expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On INT shift to state 20
-- On FALSE shift to state 25
-- On ERROR shift to state 107
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeRef shift to state 187
-- On typeName shift to state 110
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 129
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On headerStackType shift to state 142
-- On expression shift to state 190
-- On dotPrefix shift to state 91
-- On baseType shift to state 146
## Reductions:

State 16:
## Known stack suffix:
## TUPLE
## LR(1) items:
tupleType -> TUPLE . L_ANGLE typeArgumentList R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On L_ANGLE shift to state 17
## Reductions:

State 17:
## Known stack suffix:
## TUPLE L_ANGLE
## LR(1) items:
tupleType -> TUPLE L_ANGLE . typeArgumentList R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On NAME shift to state 11
-- On KEY shift to state 19
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 47
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeRef shift to state 137
-- On typeName shift to state 138
-- On typeArgumentList shift to state 185
-- On typeArg shift to state 167
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 140
-- On separated_list_aux(COMMA,typeArg) shift to state 168
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,typeArg) shift to state 171
-- On nonTypeName shift to state 141
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:
-- On R_ANGLE COMMA
--   reduce production separated_list_aux(COMMA,typeArg) ->

State 18:
## Known stack suffix:
## STRING
## LR(1) items:
baseType -> STRING . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production baseType -> STRING

State 19:
## Known stack suffix:
## KEY
## LR(1) items:
tableKwName -> KEY . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tableKwName -> KEY

State 20:
## Known stack suffix:
## INT
## LR(1) items:
baseType -> INT . L_ANGLE INTEGER R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
baseType -> INT . L_ANGLE L_PAREN expression R_PAREN R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
baseType -> INT . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On L_ANGLE shift to state 21
## Reductions:
-- On TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS
--   reduce production baseType -> INT

State 21:
## Known stack suffix:
## INT L_ANGLE
## LR(1) items:
baseType -> INT L_ANGLE . INTEGER R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
baseType -> INT L_ANGLE . L_PAREN expression R_PAREN R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On L_PAREN shift to state 22
-- On INTEGER shift to state 183
## Reductions:

State 22:
## Known stack suffix:
## INT L_ANGLE L_PAREN
## LR(1) items:
baseType -> INT L_ANGLE L_PAREN . expression R_PAREN R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 180
-- On dotPrefix shift to state 91
## Reductions:

State 23:
## Known stack suffix:
## L_BRACE
## LR(1) items:
expression -> L_BRACE . expressionList R_BRACE [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_list_aux(COMMA,expression) shift to state 173
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,expression) shift to state 176
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expressionList shift to state 177
-- On expression shift to state 179
-- On dotPrefix shift to state 91
## Reductions:
-- On R_BRACE COMMA
--   reduce production separated_list_aux(COMMA,expression) ->

State 24:
## Known stack suffix:
## INTEGER
## LR(1) items:
expression -> INTEGER . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> INTEGER

State 25:
## Known stack suffix:
## FALSE
## LR(1) items:
expression -> FALSE . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> FALSE

State 26:
## Known stack suffix:
## ERROR
## LR(1) items:
expression -> ERROR . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On DOT shift to state 27
## Reductions:

State 27:
## Known stack suffix:
## ERROR DOT
## LR(1) items:
expression -> ERROR DOT . member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 36
-- On member shift to state 37
## Reductions:

State 28:
## Known stack suffix:
## NAME
## LR(1) items:
name -> NAME . TYPENAME [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
varName -> NAME . IDENTIFIER [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
-- On TYPENAME shift to state 29
-- On IDENTIFIER shift to state 13
## Reductions:

State 29:
## Known stack suffix:
## NAME TYPENAME
## LR(1) items:
name -> NAME TYPENAME . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name -> NAME TYPENAME

State 30:
## Known stack suffix:
## ENTRIES
## LR(1) items:
tableKwName -> ENTRIES . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tableKwName -> ENTRIES

State 31:
## Known stack suffix:
## APPLY
## LR(1) items:
nonTypeName -> APPLY . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTypeName -> APPLY

State 32:
## Known stack suffix:
## ACTIONS
## LR(1) items:
tableKwName -> ACTIONS . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tableKwName -> ACTIONS

State 33:
## Known stack suffix:
## varName
## LR(1) items:
nonTypeName -> varName . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTypeName -> varName

State 34:
## Known stack suffix:
## tableKwName
## LR(1) items:
nonTypeName -> tableKwName . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTypeName -> tableKwName

State 35:
## Known stack suffix:
## nonTypeName
## LR(1) items:
name -> nonTypeName . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production name -> nonTypeName

State 36:
## Known stack suffix:
## name
## LR(1) items:
member -> name . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND ASSIGN AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production member -> name

State 37:
## Known stack suffix:
## ERROR DOT member
## LR(1) items:
expression -> ERROR DOT member . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> ERROR DOT member

State 38:
## Known stack suffix:
## DOT
## LR(1) items:
dotPrefix -> DOT . [ TYPE STATE NAME KEY ENTRIES APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production dotPrefix -> DOT

State 39:
## Known stack suffix:
## COMPLEMENT
## LR(1) items:
expression -> COMPLEMENT . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 172
-- On dotPrefix shift to state 91
## Reductions:

State 40:
## Known stack suffix:
## typeName
## LR(1) items:
expression -> typeName . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
namedType -> typeName . [ L_PAREN ]
## Transitions:
-- On DOT shift to state 41
## Reductions:
-- On L_PAREN
--   reduce production namedType -> typeName

State 41:
## Known stack suffix:
## typeName DOT
## LR(1) items:
expression -> typeName DOT . member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 36
-- On member shift to state 42
## Reductions:

State 42:
## Known stack suffix:
## typeName DOT member
## LR(1) items:
expression -> typeName DOT member . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> typeName DOT member

State 43:
## Known stack suffix:
## specializedType
## LR(1) items:
namedType -> specializedType . [ L_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production namedType -> specializedType

State 44:
## Known stack suffix:
## prefixedType
## LR(1) items:
specializedType -> prefixedType . L_ANGLE typeArgumentList R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
typeName -> prefixedType . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN L_BRACKET KEY ENTRIES DOT COMMA APPLY ACTIONS ]
## Transitions:
-- On L_ANGLE shift to state 45
## Reductions:
-- On TYPE STATE R_PAREN R_ANGLE NAME L_PAREN L_BRACKET KEY ENTRIES DOT COMMA APPLY ACTIONS
--   reduce production typeName -> prefixedType

State 45:
## Known stack suffix:
## prefixedType L_ANGLE
## LR(1) items:
specializedType -> prefixedType L_ANGLE . typeArgumentList R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On NAME shift to state 11
-- On KEY shift to state 19
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 47
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeRef shift to state 137
-- On typeName shift to state 138
-- On typeArgumentList shift to state 165
-- On typeArg shift to state 167
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 140
-- On separated_list_aux(COMMA,typeArg) shift to state 168
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,typeArg) shift to state 171
-- On nonTypeName shift to state 141
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:
-- On R_ANGLE COMMA
--   reduce production separated_list_aux(COMMA,typeArg) ->

State 46:
## Known stack suffix:
## ERROR
## LR(1) items:
baseType -> ERROR . [ TYPE STATE R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production baseType -> ERROR

State 47:
## Known stack suffix:
## DONTCARE
## LR(1) items:
typeArg -> DONTCARE . [ R_ANGLE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeArg -> DONTCARE

State 48:
## Known stack suffix:
## BOOL
## LR(1) items:
baseType -> BOOL . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production baseType -> BOOL

State 49:
## Known stack suffix:
## BIT
## LR(1) items:
baseType -> BIT . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
baseType -> BIT . L_ANGLE INTEGER R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
baseType -> BIT . L_ANGLE L_PAREN expression R_PAREN R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On L_ANGLE shift to state 50
## Reductions:
-- On TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS
--   reduce production baseType -> BIT

State 50:
## Known stack suffix:
## BIT L_ANGLE
## LR(1) items:
baseType -> BIT L_ANGLE . INTEGER R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
baseType -> BIT L_ANGLE . L_PAREN expression R_PAREN R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On L_PAREN shift to state 51
-- On INTEGER shift to state 163
## Reductions:

State 51:
## Known stack suffix:
## BIT L_ANGLE L_PAREN
## LR(1) items:
baseType -> BIT L_ANGLE L_PAREN . expression R_PAREN R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 160
-- On dotPrefix shift to state 91
## Reductions:

State 52:
## Known stack suffix:
## nonTypeName
## LR(1) items:
expression -> nonTypeName . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> nonTypeName

State 53:
## Known stack suffix:
## namedType
## LR(1) items:
expression -> namedType . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On L_PAREN shift to state 54
## Reductions:

State 54:
## Known stack suffix:
## namedType L_PAREN
## LR(1) items:
expression -> namedType L_PAREN . argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 55
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 57
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_list_aux(COMMA,argument) shift to state 58
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,argument) shift to state 71
-- On nonTypeName shift to state 60
-- On namedType shift to state 53
-- On name shift to state 61
-- On expression shift to state 72
-- On dotPrefix shift to state 91
-- On argumentList shift to state 158
-- On argument shift to state 135
## Reductions:
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,argument) ->

State 55:
## Known stack suffix:
## NAME
## LR(1) items:
name -> NAME . TYPENAME [ EQ ASSIGN ]
prefixedType -> NAME . TYPENAME [ L_PAREN L_ANGLE DOT ]
varName -> NAME . IDENTIFIER [ SHL R_PAREN R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND ASSIGN AND ]
## Transitions:
-- On TYPENAME shift to state 56
-- On IDENTIFIER shift to state 13
## Reductions:

State 56:
## Known stack suffix:
## NAME TYPENAME
## LR(1) items:
name -> NAME TYPENAME . [ EQ ASSIGN ]
prefixedType -> NAME TYPENAME . [ L_PAREN L_ANGLE DOT ]
## Transitions:
## Reductions:
-- On EQ ASSIGN
--   reduce production name -> NAME TYPENAME
-- On L_PAREN L_ANGLE DOT
--   reduce production prefixedType -> NAME TYPENAME

State 57:
## Known stack suffix:
## DONTCARE
## LR(1) items:
argument -> DONTCARE . [ R_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production argument -> DONTCARE

State 58:
## Known stack suffix:
## separated_list_aux(COMMA,argument)
## LR(1) items:
petr4_separated_list(COMMA,argument) -> separated_list_aux(COMMA,argument) . [ R_PAREN ]
separated_list_aux(COMMA,argument) -> separated_list_aux(COMMA,argument) . COMMA argument [ R_PAREN COMMA ]
## Transitions:
-- On COMMA shift to state 59
## Reductions:
-- On R_PAREN
--   reduce production petr4_separated_list(COMMA,argument) -> separated_list_aux(COMMA,argument)

State 59:
## Known stack suffix:
## separated_list_aux(COMMA,argument) COMMA
## LR(1) items:
separated_list_aux(COMMA,argument) -> separated_list_aux(COMMA,argument) COMMA . argument [ R_PAREN COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 55
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 57
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 60
-- On namedType shift to state 53
-- On name shift to state 61
-- On expression shift to state 72
-- On dotPrefix shift to state 91
-- On argument shift to state 157
## Reductions:

State 60:
## Known stack suffix:
## nonTypeName
## LR(1) items:
expression -> nonTypeName . [ SHL R_PAREN R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
name -> nonTypeName . [ EQ ASSIGN ]
## Transitions:
## Reductions:
-- On SHL R_PAREN R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> nonTypeName
-- On EQ ASSIGN
--   reduce production name -> nonTypeName

State 61:
## Known stack suffix:
## name
## LR(1) items:
argument -> name . ASSIGN expression [ R_PAREN COMMA ]
## Transitions:
-- On ASSIGN shift to state 62
## Reductions:

State 62:
## Known stack suffix:
## name ASSIGN
## LR(1) items:
argument -> name ASSIGN . expression [ R_PAREN COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 63
-- On dotPrefix shift to state 91
## Reductions:

State 63:
## Known stack suffix:
## name ASSIGN expression
## LR(1) items:
argument -> name ASSIGN expression . [ R_PAREN COMMA ]
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On R_PAREN COMMA
--   reduce production argument -> name ASSIGN expression

State 64:
## Known stack suffix:
## expression SHL
## LR(1) items:
expression -> expression SHL . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 65
-- On dotPrefix shift to state 91
## Reductions:

State 65:
## Known stack suffix:
## expression SHL expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression SHL expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION OR NE MASK L_ANGLE LE GE EQ COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> expression SHL expression

State 66:
## Known stack suffix:
## expression PLUS_SAT
## LR(1) items:
expression -> expression PLUS_SAT . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 67
-- On dotPrefix shift to state 91
## Reductions:

State 67:
## Known stack suffix:
## expression PLUS_SAT expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression PLUS_SAT expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MINUS_SAT MINUS MASK L_ANGLE LE GE EQ COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> expression PLUS_SAT expression

State 68:
## Known stack suffix:
## expression MUL
## LR(1) items:
expression -> expression MUL . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 69
-- On dotPrefix shift to state 91
## Reductions:

State 69:
## Known stack suffix:
## expression MUL expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression MUL expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_ANGLE LE GE EQ DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> expression MUL expression

State 70:
## Known stack suffix:
## expression L_PAREN
## LR(1) items:
expression -> expression L_PAREN . argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 55
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 57
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_list_aux(COMMA,argument) shift to state 58
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,argument) shift to state 71
-- On nonTypeName shift to state 60
-- On namedType shift to state 53
-- On name shift to state 61
-- On expression shift to state 72
-- On dotPrefix shift to state 91
-- On argumentList shift to state 155
-- On argument shift to state 135
## Reductions:
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,argument) ->

State 71:
## Known stack suffix:
## petr4_separated_list(COMMA,argument)
## LR(1) items:
argumentList -> petr4_separated_list(COMMA,argument) . [ R_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production argumentList -> petr4_separated_list(COMMA,argument)

State 72:
## Known stack suffix:
## expression
## LR(1) items:
argument -> expression . [ R_PAREN COMMA ]
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On R_PAREN COMMA
--   reduce production argument -> expression

State 73:
## Known stack suffix:
## expression R_ANGLE
## LR(1) items:
expression -> expression R_ANGLE . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression R_ANGLE . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On R_ANGLE shift to state 74
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 154
-- On dotPrefix shift to state 91
## Reductions:

State 74:
## Known stack suffix:
## expression R_ANGLE R_ANGLE
## LR(1) items:
expression -> expression R_ANGLE R_ANGLE . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 75
-- On dotPrefix shift to state 91
## Reductions:

State 75:
## Known stack suffix:
## expression R_ANGLE R_ANGLE expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression R_ANGLE R_ANGLE expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION OR NE MASK L_ANGLE LE GE EQ COMMA COLON AND
--   reduce production expression -> expression R_ANGLE R_ANGLE expression

State 76:
## Known stack suffix:
## expression PLUSPLUS
## LR(1) items:
expression -> expression PLUSPLUS . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 77
-- On dotPrefix shift to state 91
## Reductions:

State 77:
## Known stack suffix:
## expression PLUSPLUS expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression PLUSPLUS expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MINUS_SAT MINUS MASK L_ANGLE LE GE EQ COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> expression PLUSPLUS expression

State 78:
## Known stack suffix:
## expression MOD
## LR(1) items:
expression -> expression MOD . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 79
-- On dotPrefix shift to state 91
## Reductions:

State 79:
## Known stack suffix:
## expression MOD expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression MOD expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_ANGLE LE GE EQ DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> expression MOD expression

State 80:
## Known stack suffix:
## expression L_BRACKET
## LR(1) items:
expression -> expression L_BRACKET . expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression L_BRACKET . expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 81
-- On dotPrefix shift to state 91
## Reductions:

State 81:
## Known stack suffix:
## expression L_BRACKET expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression L_BRACKET expression . R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression L_BRACKET expression . COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_BRACKET shift to state 82
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On COLON shift to state 151
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 82:
## Known stack suffix:
## expression L_BRACKET expression R_BRACKET
## LR(1) items:
expression -> expression L_BRACKET expression R_BRACKET . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> expression L_BRACKET expression R_BRACKET

State 83:
## Known stack suffix:
## expression QUESTION
## LR(1) items:
expression -> expression QUESTION . expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 84
-- On dotPrefix shift to state 91
## Reductions:

State 84:
## Known stack suffix:
## expression QUESTION expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression QUESTION expression . COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On COLON shift to state 149
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 85:
## Known stack suffix:
## expression PLUS
## LR(1) items:
expression -> expression PLUS . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 86
-- On dotPrefix shift to state 91
## Reductions:

State 86:
## Known stack suffix:
## expression PLUS expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression PLUS expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MINUS_SAT MINUS MASK L_ANGLE LE GE EQ COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> expression PLUS expression

State 87:
## Known stack suffix:
## expression DOT
## LR(1) items:
expression -> expression DOT . member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 36
-- On member shift to state 88
## Reductions:

State 88:
## Known stack suffix:
## expression DOT member
## LR(1) items:
expression -> expression DOT member . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> expression DOT member

State 89:
## Known stack suffix:
## expression DIV
## LR(1) items:
expression -> expression DIV . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 90
-- On dotPrefix shift to state 91
## Reductions:

State 90:
## Known stack suffix:
## expression DIV expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression DIV expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_ANGLE LE GE EQ DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> expression DIV expression

State 91:
## Known stack suffix:
## dotPrefix
## LR(1) items:
expression -> dotPrefix . go_toplevel nonTypeName go_local [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
prefixedType -> dotPrefix . go_toplevel NAME TYPENAME go_local [ R_PAREN R_ANGLE L_PAREN L_BRACKET L_ANGLE DOT COMMA ]
## Transitions:
-- On go_toplevel shift to state 92
## Default reduction:
-- After reading the next token, reduce production go_toplevel ->

State 92:
## Known stack suffix:
## dotPrefix go_toplevel
## LR(1) items:
expression -> dotPrefix go_toplevel . nonTypeName go_local [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
prefixedType -> dotPrefix go_toplevel . NAME TYPENAME go_local [ R_PAREN R_ANGLE L_PAREN L_BRACKET L_ANGLE DOT COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 93
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 96
## Reductions:

State 93:
## Known stack suffix:
## dotPrefix go_toplevel NAME
## LR(1) items:
prefixedType -> dotPrefix go_toplevel NAME . TYPENAME go_local [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN L_BRACKET L_ANGLE KEY ENTRIES DOT COMMA APPLY ACTIONS ]
varName -> NAME . IDENTIFIER [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND ASSIGN AND ]
## Transitions:
-- On TYPENAME shift to state 94
-- On IDENTIFIER shift to state 13
## Reductions:

State 94:
## Known stack suffix:
## dotPrefix go_toplevel NAME TYPENAME
## LR(1) items:
prefixedType -> dotPrefix go_toplevel NAME TYPENAME . go_local [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN L_BRACKET L_ANGLE KEY ENTRIES DOT COMMA APPLY ACTIONS ]
## Transitions:
-- On go_local shift to state 95
## Default reduction:
-- After reading the next token, reduce production go_local ->

State 95:
## Known stack suffix:
## dotPrefix go_toplevel NAME TYPENAME go_local
## LR(1) items:
prefixedType -> dotPrefix go_toplevel NAME TYPENAME go_local . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN L_BRACKET L_ANGLE KEY ENTRIES DOT COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production prefixedType -> dotPrefix go_toplevel NAME TYPENAME go_local

State 96:
## Known stack suffix:
## dotPrefix go_toplevel nonTypeName
## LR(1) items:
expression -> dotPrefix go_toplevel nonTypeName . go_local [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On go_local shift to state 97
## Default reduction:
-- After reading the next token, reduce production go_local ->

State 97:
## Known stack suffix:
## dotPrefix go_toplevel nonTypeName go_local
## LR(1) items:
expression -> dotPrefix go_toplevel nonTypeName go_local . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> dotPrefix go_toplevel nonTypeName go_local

State 98:
## Known stack suffix:
## expression OR
## LR(1) items:
expression -> expression OR . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 99
-- On dotPrefix shift to state 91
## Reductions:

State 99:
## Known stack suffix:
## expression OR expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression OR expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE RANGE QUESTION OR MASK COMMA COLON
--   reduce production expression -> expression OR expression

State 100:
## Known stack suffix:
## expression NE
## LR(1) items:
expression -> expression NE . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 101
-- On dotPrefix shift to state 91
## Reductions:

State 101:
## Known stack suffix:
## expression NE expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression NE expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE RANGE QUESTION OR NE MASK EQ COMMA COLON AND
--   reduce production expression -> expression NE expression

State 102:
## Known stack suffix:
## expression MINUS_SAT
## LR(1) items:
expression -> expression MINUS_SAT . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 103
-- On dotPrefix shift to state 91
## Reductions:

State 103:
## Known stack suffix:
## expression MINUS_SAT expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression MINUS_SAT expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MINUS_SAT MINUS MASK L_ANGLE LE GE EQ COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> expression MINUS_SAT expression

State 104:
## Known stack suffix:
## expression MINUS
## LR(1) items:
expression -> expression MINUS . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 105
-- On dotPrefix shift to state 91
## Reductions:

State 105:
## Known stack suffix:
## expression MINUS expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression MINUS expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MINUS_SAT MINUS MASK L_ANGLE LE GE EQ COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> expression MINUS expression

State 106:
## Known stack suffix:
## expression L_ANGLE
## LR(1) items:
expression -> expression L_ANGLE . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression L_ANGLE . realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On INT shift to state 20
-- On FALSE shift to state 25
-- On ERROR shift to state 107
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 108
-- On COMPLEMENT shift to state 39
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeRef shift to state 109
-- On typeName shift to state 110
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 129
-- On realTypeArgumentList shift to state 130
-- On realTypeArg shift to state 147
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On headerStackType shift to state 142
-- On expression shift to state 148
-- On dotPrefix shift to state 91
-- On baseType shift to state 146
## Reductions:

State 107:
## Known stack suffix:
## ERROR
## LR(1) items:
baseType -> ERROR . [ R_PAREN R_ANGLE COMMA ]
expression -> ERROR . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On DOT shift to state 27
## Reductions:
-- On R_PAREN R_ANGLE COMMA
--   reduce production baseType -> ERROR

State 108:
## Known stack suffix:
## DONTCARE
## LR(1) items:
realTypeArg -> DONTCARE . [ R_ANGLE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production realTypeArg -> DONTCARE

State 109:
## Known stack suffix:
## typeRef
## LR(1) items:
realTypeArg -> typeRef . [ R_ANGLE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production realTypeArg -> typeRef

State 110:
## Known stack suffix:
## typeName
## LR(1) items:
expression -> typeName . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
headerStackType -> typeName . L_BRACKET expression R_BRACKET [ R_PAREN R_ANGLE COMMA ]
namedType -> typeName . [ L_PAREN ]
typeRef -> typeName . [ R_PAREN R_ANGLE COMMA ]
## Transitions:
-- On L_BRACKET shift to state 111
-- On DOT shift to state 41
## Reductions:
-- On L_PAREN
--   reduce production namedType -> typeName
-- On R_PAREN R_ANGLE COMMA
--   reduce production typeRef -> typeName

State 111:
## Known stack suffix:
## typeName L_BRACKET
## LR(1) items:
headerStackType -> typeName L_BRACKET . expression R_BRACKET [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 112
-- On dotPrefix shift to state 91
## Reductions:

State 112:
## Known stack suffix:
## typeName L_BRACKET expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
headerStackType -> typeName L_BRACKET expression . R_BRACKET [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On SHL shift to state 64
-- On R_BRACKET shift to state 113
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 113:
## Known stack suffix:
## typeName L_BRACKET expression R_BRACKET
## LR(1) items:
headerStackType -> typeName L_BRACKET expression R_BRACKET . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production headerStackType -> typeName L_BRACKET expression R_BRACKET

State 114:
## Known stack suffix:
## expression LE
## LR(1) items:
expression -> expression LE . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 115
-- On dotPrefix shift to state 91
## Reductions:

State 115:
## Known stack suffix:
## expression LE expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression LE expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION OR NE MASK L_ANGLE LE GE EQ COMMA COLON AND
--   reduce production expression -> expression LE expression

State 116:
## Known stack suffix:
## expression BIT_XOR
## LR(1) items:
expression -> expression BIT_XOR . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 117
-- On dotPrefix shift to state 91
## Reductions:

State 117:
## Known stack suffix:
## expression BIT_XOR expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression BIT_XOR expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_AND shift to state 118
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION OR NE MASK L_ANGLE LE GE EQ COMMA COLON BIT_XOR BIT_OR AND
--   reduce production expression -> expression BIT_XOR expression

State 118:
## Known stack suffix:
## expression BIT_AND
## LR(1) items:
expression -> expression BIT_AND . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 119
-- On dotPrefix shift to state 91
## Reductions:

State 119:
## Known stack suffix:
## expression BIT_AND expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression BIT_AND expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION OR NE MASK L_ANGLE LE GE EQ COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> expression BIT_AND expression

State 120:
## Known stack suffix:
## expression BIT_OR
## LR(1) items:
expression -> expression BIT_OR . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 121
-- On dotPrefix shift to state 91
## Reductions:

State 121:
## Known stack suffix:
## expression BIT_OR expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression BIT_OR expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_AND shift to state 118
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION OR NE MASK L_ANGLE LE GE EQ COMMA COLON BIT_OR AND
--   reduce production expression -> expression BIT_OR expression

State 122:
## Known stack suffix:
## expression GE
## LR(1) items:
expression -> expression GE . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 123
-- On dotPrefix shift to state 91
## Reductions:

State 123:
## Known stack suffix:
## expression GE expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression GE expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION OR NE MASK L_ANGLE LE GE EQ COMMA COLON AND
--   reduce production expression -> expression GE expression

State 124:
## Known stack suffix:
## expression EQ
## LR(1) items:
expression -> expression EQ . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 125
-- On dotPrefix shift to state 91
## Reductions:

State 125:
## Known stack suffix:
## expression EQ expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression EQ expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE RANGE QUESTION OR NE MASK EQ COMMA COLON AND
--   reduce production expression -> expression EQ expression

State 126:
## Known stack suffix:
## expression AND
## LR(1) items:
expression -> expression AND . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 127
-- On dotPrefix shift to state 91
## Reductions:

State 127:
## Known stack suffix:
## expression AND expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression AND expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE RANGE QUESTION OR MASK COMMA COLON AND
--   reduce production expression -> expression AND expression

State 128:
## Known stack suffix:
## tupleType
## LR(1) items:
typeRef -> tupleType . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeRef -> tupleType

State 129:
## Known stack suffix:
## specializedType
## LR(1) items:
namedType -> specializedType . [ L_PAREN ]
typeRef -> specializedType . [ R_PAREN R_ANGLE COMMA ]
## Transitions:
## Reductions:
-- On L_PAREN
--   reduce production namedType -> specializedType
-- On R_PAREN R_ANGLE COMMA
--   reduce production typeRef -> specializedType

State 130:
## Known stack suffix:
## expression L_ANGLE realTypeArgumentList
## LR(1) items:
expression -> expression L_ANGLE realTypeArgumentList . R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
realTypeArgumentList -> realTypeArgumentList . COMMA typeArg [ R_ANGLE COMMA ]
## Transitions:
-- On R_ANGLE shift to state 131
-- On COMMA shift to state 136
## Reductions:

State 131:
## Known stack suffix:
## expression L_ANGLE realTypeArgumentList R_ANGLE
## LR(1) items:
expression -> expression L_ANGLE realTypeArgumentList R_ANGLE . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On L_PAREN shift to state 132
## Reductions:

State 132:
## Known stack suffix:
## expression L_ANGLE realTypeArgumentList R_ANGLE L_PAREN
## LR(1) items:
expression -> expression L_ANGLE realTypeArgumentList R_ANGLE L_PAREN . argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 55
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 57
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_list_aux(COMMA,argument) shift to state 58
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,argument) shift to state 71
-- On nonTypeName shift to state 60
-- On namedType shift to state 53
-- On name shift to state 61
-- On expression shift to state 72
-- On dotPrefix shift to state 91
-- On argumentList shift to state 133
-- On argument shift to state 135
## Reductions:
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,argument) ->

State 133:
## Known stack suffix:
## expression L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList
## LR(1) items:
expression -> expression L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList . R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On R_PAREN shift to state 134
## Reductions:

State 134:
## Known stack suffix:
## expression L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN
## LR(1) items:
expression -> expression L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> expression L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN

State 135:
## Known stack suffix:
## argument
## LR(1) items:
separated_list_aux(COMMA,argument) -> argument . [ R_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_list_aux(COMMA,argument) -> argument

State 136:
## Known stack suffix:
## realTypeArgumentList COMMA
## LR(1) items:
realTypeArgumentList -> realTypeArgumentList COMMA . typeArg [ R_ANGLE COMMA ]
## Transitions:
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On NAME shift to state 11
-- On KEY shift to state 19
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 47
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeRef shift to state 137
-- On typeName shift to state 138
-- On typeArg shift to state 139
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 141
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 137:
## Known stack suffix:
## typeRef
## LR(1) items:
typeArg -> typeRef . [ R_ANGLE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeArg -> typeRef

State 138:
## Known stack suffix:
## typeName
## LR(1) items:
headerStackType -> typeName . L_BRACKET expression R_BRACKET [ TYPE STATE R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
typeRef -> typeName . [ TYPE STATE R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On L_BRACKET shift to state 111
## Reductions:
-- On TYPE STATE R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS
--   reduce production typeRef -> typeName

State 139:
## Known stack suffix:
## realTypeArgumentList COMMA typeArg
## LR(1) items:
realTypeArgumentList -> realTypeArgumentList COMMA typeArg . [ R_ANGLE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production realTypeArgumentList -> realTypeArgumentList COMMA typeArg

State 140:
## Known stack suffix:
## specializedType
## LR(1) items:
typeRef -> specializedType . [ TYPE STATE R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeRef -> specializedType

State 141:
## Known stack suffix:
## nonTypeName
## LR(1) items:
typeArg -> nonTypeName . [ R_ANGLE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeArg -> nonTypeName

State 142:
## Known stack suffix:
## headerStackType
## LR(1) items:
typeRef -> headerStackType . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeRef -> headerStackType

State 143:
## Known stack suffix:
## dotPrefix
## LR(1) items:
prefixedType -> dotPrefix . go_toplevel NAME TYPENAME go_local [ TYPE STATE R_ANGLE NAME L_PAREN L_BRACKET L_ANGLE KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On go_toplevel shift to state 144
## Default reduction:
-- After reading the next token, reduce production go_toplevel ->

State 144:
## Known stack suffix:
## dotPrefix go_toplevel
## LR(1) items:
prefixedType -> dotPrefix go_toplevel . NAME TYPENAME go_local [ TYPE STATE R_ANGLE NAME L_PAREN L_BRACKET L_ANGLE KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On NAME shift to state 145
## Reductions:

State 145:
## Known stack suffix:
## dotPrefix go_toplevel NAME
## LR(1) items:
prefixedType -> dotPrefix go_toplevel NAME . TYPENAME go_local [ TYPE STATE R_ANGLE NAME L_PAREN L_BRACKET L_ANGLE KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On TYPENAME shift to state 94
## Reductions:

State 146:
## Known stack suffix:
## baseType
## LR(1) items:
typeRef -> baseType . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeRef -> baseType

State 147:
## Known stack suffix:
## realTypeArg
## LR(1) items:
realTypeArgumentList -> realTypeArg . [ R_ANGLE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production realTypeArgumentList -> realTypeArg

State 148:
## Known stack suffix:
## expression L_ANGLE expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression L_ANGLE expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION OR NE MASK L_ANGLE LE GE EQ COMMA COLON AND
--   reduce production expression -> expression L_ANGLE expression

State 149:
## Known stack suffix:
## expression QUESTION expression COLON
## LR(1) items:
expression -> expression QUESTION expression COLON . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 150
-- On dotPrefix shift to state 91
## Reductions:

State 150:
## Known stack suffix:
## expression QUESTION expression COLON expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression QUESTION expression COLON expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE RANGE QUESTION MASK COMMA COLON
--   reduce production expression -> expression QUESTION expression COLON expression

State 151:
## Known stack suffix:
## expression L_BRACKET expression COLON
## LR(1) items:
expression -> expression L_BRACKET expression COLON . expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 152
-- On dotPrefix shift to state 91
## Reductions:

State 152:
## Known stack suffix:
## expression L_BRACKET expression COLON expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression L_BRACKET expression COLON expression . R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_BRACKET shift to state 153
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 153:
## Known stack suffix:
## expression L_BRACKET expression COLON expression R_BRACKET
## LR(1) items:
expression -> expression L_BRACKET expression COLON expression R_BRACKET . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> expression L_BRACKET expression COLON expression R_BRACKET

State 154:
## Known stack suffix:
## expression R_ANGLE expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression R_ANGLE expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
## Reductions:
-- On SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION OR NE MASK L_ANGLE LE GE EQ COMMA COLON AND
--   reduce production expression -> expression R_ANGLE expression

State 155:
## Known stack suffix:
## expression L_PAREN argumentList
## LR(1) items:
expression -> expression L_PAREN argumentList . R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On R_PAREN shift to state 156
## Reductions:

State 156:
## Known stack suffix:
## expression L_PAREN argumentList R_PAREN
## LR(1) items:
expression -> expression L_PAREN argumentList R_PAREN . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> expression L_PAREN argumentList R_PAREN

State 157:
## Known stack suffix:
## separated_list_aux(COMMA,argument) COMMA argument
## LR(1) items:
separated_list_aux(COMMA,argument) -> separated_list_aux(COMMA,argument) COMMA argument . [ R_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_list_aux(COMMA,argument) -> separated_list_aux(COMMA,argument) COMMA argument

State 158:
## Known stack suffix:
## namedType L_PAREN argumentList
## LR(1) items:
expression -> namedType L_PAREN argumentList . R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On R_PAREN shift to state 159
## Reductions:

State 159:
## Known stack suffix:
## namedType L_PAREN argumentList R_PAREN
## LR(1) items:
expression -> namedType L_PAREN argumentList R_PAREN . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> namedType L_PAREN argumentList R_PAREN

State 160:
## Known stack suffix:
## BIT L_ANGLE L_PAREN expression
## LR(1) items:
baseType -> BIT L_ANGLE L_PAREN expression . R_PAREN R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 161
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 161:
## Known stack suffix:
## BIT L_ANGLE L_PAREN expression R_PAREN
## LR(1) items:
baseType -> BIT L_ANGLE L_PAREN expression R_PAREN . R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On R_ANGLE shift to state 162
## Reductions:

State 162:
## Known stack suffix:
## BIT L_ANGLE L_PAREN expression R_PAREN R_ANGLE
## LR(1) items:
baseType -> BIT L_ANGLE L_PAREN expression R_PAREN R_ANGLE . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production baseType -> BIT L_ANGLE L_PAREN expression R_PAREN R_ANGLE

State 163:
## Known stack suffix:
## BIT L_ANGLE INTEGER
## LR(1) items:
baseType -> BIT L_ANGLE INTEGER . R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On R_ANGLE shift to state 164
## Reductions:

State 164:
## Known stack suffix:
## BIT L_ANGLE INTEGER R_ANGLE
## LR(1) items:
baseType -> BIT L_ANGLE INTEGER R_ANGLE . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production baseType -> BIT L_ANGLE INTEGER R_ANGLE

State 165:
## Known stack suffix:
## prefixedType L_ANGLE typeArgumentList
## LR(1) items:
specializedType -> prefixedType L_ANGLE typeArgumentList . R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On R_ANGLE shift to state 166
## Reductions:

State 166:
## Known stack suffix:
## prefixedType L_ANGLE typeArgumentList R_ANGLE
## LR(1) items:
specializedType -> prefixedType L_ANGLE typeArgumentList R_ANGLE . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specializedType -> prefixedType L_ANGLE typeArgumentList R_ANGLE

State 167:
## Known stack suffix:
## typeArg
## LR(1) items:
separated_list_aux(COMMA,typeArg) -> typeArg . [ R_ANGLE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_list_aux(COMMA,typeArg) -> typeArg

State 168:
## Known stack suffix:
## separated_list_aux(COMMA,typeArg)
## LR(1) items:
petr4_separated_list(COMMA,typeArg) -> separated_list_aux(COMMA,typeArg) . [ R_ANGLE ]
separated_list_aux(COMMA,typeArg) -> separated_list_aux(COMMA,typeArg) . COMMA typeArg [ R_ANGLE COMMA ]
## Transitions:
-- On COMMA shift to state 169
## Reductions:
-- On R_ANGLE
--   reduce production petr4_separated_list(COMMA,typeArg) -> separated_list_aux(COMMA,typeArg)

State 169:
## Known stack suffix:
## separated_list_aux(COMMA,typeArg) COMMA
## LR(1) items:
separated_list_aux(COMMA,typeArg) -> separated_list_aux(COMMA,typeArg) COMMA . typeArg [ R_ANGLE COMMA ]
## Transitions:
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On NAME shift to state 11
-- On KEY shift to state 19
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 47
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeRef shift to state 137
-- On typeName shift to state 138
-- On typeArg shift to state 170
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 141
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 170:
## Known stack suffix:
## separated_list_aux(COMMA,typeArg) COMMA typeArg
## LR(1) items:
separated_list_aux(COMMA,typeArg) -> separated_list_aux(COMMA,typeArg) COMMA typeArg . [ R_ANGLE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_list_aux(COMMA,typeArg) -> separated_list_aux(COMMA,typeArg) COMMA typeArg

State 171:
## Known stack suffix:
## petr4_separated_list(COMMA,typeArg)
## LR(1) items:
typeArgumentList -> petr4_separated_list(COMMA,typeArg) . [ R_ANGLE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeArgumentList -> petr4_separated_list(COMMA,typeArg)

State 172:
## Known stack suffix:
## COMPLEMENT expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> COMPLEMENT expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_ANGLE LE GE EQ DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> COMPLEMENT expression

State 173:
## Known stack suffix:
## separated_list_aux(COMMA,expression)
## LR(1) items:
petr4_separated_list(COMMA,expression) -> separated_list_aux(COMMA,expression) . [ R_PAREN R_BRACKET R_BRACE ]
separated_list_aux(COMMA,expression) -> separated_list_aux(COMMA,expression) . COMMA expression [ R_PAREN R_BRACKET R_BRACE COMMA ]
## Transitions:
-- On COMMA shift to state 174
## Reductions:
-- On R_PAREN R_BRACKET R_BRACE
--   reduce production petr4_separated_list(COMMA,expression) -> separated_list_aux(COMMA,expression)

State 174:
## Known stack suffix:
## separated_list_aux(COMMA,expression) COMMA
## LR(1) items:
separated_list_aux(COMMA,expression) -> separated_list_aux(COMMA,expression) COMMA . expression [ R_PAREN R_BRACKET R_BRACE COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 175
-- On dotPrefix shift to state 91
## Reductions:

State 175:
## Known stack suffix:
## separated_list_aux(COMMA,expression) COMMA expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
separated_list_aux(COMMA,expression) -> separated_list_aux(COMMA,expression) COMMA expression . [ R_PAREN R_BRACKET R_BRACE COMMA ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On R_PAREN R_BRACKET R_BRACE COMMA
--   reduce production separated_list_aux(COMMA,expression) -> separated_list_aux(COMMA,expression) COMMA expression

State 176:
## Known stack suffix:
## petr4_separated_list(COMMA,expression)
## LR(1) items:
expressionList -> petr4_separated_list(COMMA,expression) . [ R_PAREN R_BRACKET R_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expressionList -> petr4_separated_list(COMMA,expression)

State 177:
## Known stack suffix:
## L_BRACE expressionList
## LR(1) items:
expression -> L_BRACE expressionList . R_BRACE [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On R_BRACE shift to state 178
## Reductions:

State 178:
## Known stack suffix:
## L_BRACE expressionList R_BRACE
## LR(1) items:
expression -> L_BRACE expressionList R_BRACE . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> L_BRACE expressionList R_BRACE

State 179:
## Known stack suffix:
## expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_BRACKET R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
separated_list_aux(COMMA,expression) -> expression . [ R_PAREN R_BRACKET R_BRACE COMMA ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On R_PAREN R_BRACKET R_BRACE COMMA
--   reduce production separated_list_aux(COMMA,expression) -> expression

State 180:
## Known stack suffix:
## INT L_ANGLE L_PAREN expression
## LR(1) items:
baseType -> INT L_ANGLE L_PAREN expression . R_PAREN R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 181
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 181:
## Known stack suffix:
## INT L_ANGLE L_PAREN expression R_PAREN
## LR(1) items:
baseType -> INT L_ANGLE L_PAREN expression R_PAREN . R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On R_ANGLE shift to state 182
## Reductions:

State 182:
## Known stack suffix:
## INT L_ANGLE L_PAREN expression R_PAREN R_ANGLE
## LR(1) items:
baseType -> INT L_ANGLE L_PAREN expression R_PAREN R_ANGLE . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production baseType -> INT L_ANGLE L_PAREN expression R_PAREN R_ANGLE

State 183:
## Known stack suffix:
## INT L_ANGLE INTEGER
## LR(1) items:
baseType -> INT L_ANGLE INTEGER . R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On R_ANGLE shift to state 184
## Reductions:

State 184:
## Known stack suffix:
## INT L_ANGLE INTEGER R_ANGLE
## LR(1) items:
baseType -> INT L_ANGLE INTEGER R_ANGLE . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production baseType -> INT L_ANGLE INTEGER R_ANGLE

State 185:
## Known stack suffix:
## TUPLE L_ANGLE typeArgumentList
## LR(1) items:
tupleType -> TUPLE L_ANGLE typeArgumentList . R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On R_ANGLE shift to state 186
## Reductions:

State 186:
## Known stack suffix:
## TUPLE L_ANGLE typeArgumentList R_ANGLE
## LR(1) items:
tupleType -> TUPLE L_ANGLE typeArgumentList R_ANGLE . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tupleType -> TUPLE L_ANGLE typeArgumentList R_ANGLE

State 187:
## Known stack suffix:
## L_PAREN typeRef
## LR(1) items:
expression -> L_PAREN typeRef . R_PAREN expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On R_PAREN shift to state 188
## Reductions:

State 188:
## Known stack suffix:
## L_PAREN typeRef R_PAREN
## LR(1) items:
expression -> L_PAREN typeRef R_PAREN . expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 189
-- On dotPrefix shift to state 91
## Reductions:

State 189:
## Known stack suffix:
## L_PAREN typeRef R_PAREN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> L_PAREN typeRef R_PAREN expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_ANGLE LE GE EQ DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> L_PAREN typeRef R_PAREN expression

State 190:
## Known stack suffix:
## L_PAREN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> L_PAREN expression . R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 191
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 191:
## Known stack suffix:
## L_PAREN expression R_PAREN
## LR(1) items:
expression -> L_PAREN expression R_PAREN . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expression -> L_PAREN expression R_PAREN

State 192:
## Known stack suffix:
## MINUS expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> MINUS expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_ANGLE LE GE EQ DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> MINUS expression

State 193:
## Known stack suffix:
## NOT expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> NOT expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_ANGLE LE GE EQ DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> NOT expression

State 194:
## Known stack suffix:
## PLUS expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> PLUS expression . [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On DOT shift to state 87
## Reductions:
-- On SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_ANGLE LE GE EQ DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND
--   reduce production expression -> PLUS expression

State 195:
## Known stack suffix:
## VARBIT L_ANGLE L_PAREN expression
## LR(1) items:
baseType -> VARBIT L_ANGLE L_PAREN expression . R_PAREN R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 196
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 196:
## Known stack suffix:
## VARBIT L_ANGLE L_PAREN expression R_PAREN
## LR(1) items:
baseType -> VARBIT L_ANGLE L_PAREN expression R_PAREN . R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On R_ANGLE shift to state 197
## Reductions:

State 197:
## Known stack suffix:
## VARBIT L_ANGLE L_PAREN expression R_PAREN R_ANGLE
## LR(1) items:
baseType -> VARBIT L_ANGLE L_PAREN expression R_PAREN R_ANGLE . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production baseType -> VARBIT L_ANGLE L_PAREN expression R_PAREN R_ANGLE

State 198:
## Known stack suffix:
## VARBIT L_ANGLE INTEGER
## LR(1) items:
baseType -> VARBIT L_ANGLE INTEGER . R_ANGLE [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
-- On R_ANGLE shift to state 199
## Reductions:

State 199:
## Known stack suffix:
## VARBIT L_ANGLE INTEGER R_ANGLE
## LR(1) items:
baseType -> VARBIT L_ANGLE INTEGER R_ANGLE . [ TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production baseType -> VARBIT L_ANGLE INTEGER R_ANGLE

State 200:
## Known stack suffix:
## TYPEDEF
## LR(1) items:
typedefDeclaration -> TYPEDEF . typeRef name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
typedefDeclaration -> TYPEDEF . derivedTypeDeclaration name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRUCT shift to state 201
-- On STRING shift to state 18
-- On PRAGMA shift to state 207
-- On NAME shift to state 301
-- On INT shift to state 20
-- On HEADER_UNION shift to state 332
-- On HEADER shift to state 337
-- On ERROR shift to state 46
-- On ENUM shift to state 342
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On typeRef shift to state 368
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On structTypeDeclaration shift to state 371
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On headerUnionDeclaration shift to state 372
-- On headerTypeDeclaration shift to state 373
-- On headerStackType shift to state 142
-- On enumDeclaration shift to state 374
-- On dotPrefix shift to state 143
-- On derivedTypeDeclaration shift to state 375
-- On baseType shift to state 146
-- On annotations shift to state 378
-- On annotation shift to state 331
## Reductions:

State 201:
## Known stack suffix:
## STRUCT
## LR(1) items:
structTypeDeclaration -> STRUCT . name L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 202
## Reductions:

State 202:
## Known stack suffix:
## STRUCT name
## LR(1) items:
structTypeDeclaration -> STRUCT name . L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 203
## Reductions:

State 203:
## Known stack suffix:
## STRUCT name L_BRACE
## LR(1) items:
structTypeDeclaration -> STRUCT name L_BRACE . petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On petr4_list(structField) shift to state 204
-- On list_aux(structField) shift to state 206
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) ->

State 204:
## Known stack suffix:
## STRUCT name L_BRACE petr4_list(structField)
## LR(1) items:
structTypeDeclaration -> STRUCT name L_BRACE petr4_list(structField) . R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_BRACE shift to state 205
## Reductions:

State 205:
## Known stack suffix:
## STRUCT name L_BRACE petr4_list(structField) R_BRACE
## LR(1) items:
structTypeDeclaration -> STRUCT name L_BRACE petr4_list(structField) R_BRACE . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production structTypeDeclaration -> STRUCT name L_BRACE petr4_list(structField) R_BRACE

State 206:
## Known stack suffix:
## list_aux(structField)
## LR(1) items:
list_aux(structField) -> list_aux(structField) . structField [ VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
petr4_list(structField) -> list_aux(structField) . [ R_BRACE ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On PRAGMA shift to state 207
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On typeRef shift to state 320
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On structField shift to state 323
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
-- On annotations shift to state 327
-- On annotation shift to state 331
## Reductions:
-- On R_BRACE
--   reduce production petr4_list(structField) -> list_aux(structField)

State 207:
## Known stack suffix:
## PRAGMA
## LR(1) items:
annotation -> PRAGMA . name annotationBody PRAGMA_END [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 208
## Reductions:

State 208:
## Known stack suffix:
## PRAGMA name
## LR(1) items:
annotation -> PRAGMA name . annotationBody PRAGMA_END [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
-- On petr4_list(annotationToken) shift to state 209
-- On list_aux(annotationToken) shift to state 210
-- On annotationBody shift to state 296
## Default reduction:
-- After reading the next token, reduce production list_aux(annotationToken) ->

State 209:
## Known stack suffix:
## petr4_list(annotationToken)
## LR(1) items:
annotationBody -> petr4_list(annotationToken) . [ R_PAREN PRAGMA_END L_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationBody -> petr4_list(annotationToken)

State 210:
## Known stack suffix:
## list_aux(annotationToken)
## LR(1) items:
list_aux(annotationToken) -> list_aux(annotationToken) . annotationToken [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
petr4_list(annotationToken) -> list_aux(annotationToken) . [ R_PAREN PRAGMA_END L_PAREN ]
## Transitions:
-- On VOID shift to state 211
-- On VARBIT shift to state 212
-- On VALUESET shift to state 213
-- On TYPEDEF shift to state 214
-- On TYPE shift to state 215
-- On TUPLE shift to state 216
-- On TRUE shift to state 217
-- On TRANSITION shift to state 218
-- On TABLE shift to state 219
-- On SWITCH shift to state 220
-- On STRUCT shift to state 221
-- On STRING_LITERAL shift to state 222
-- On STRING shift to state 223
-- On STATE shift to state 224
-- On SHL shift to state 225
-- On SEMICOLON shift to state 226
-- On SELECT shift to state 227
-- On R_BRACKET shift to state 228
-- On R_BRACE shift to state 229
-- On R_ANGLE shift to state 230
-- On RETURN shift to state 231
-- On RANGE shift to state 232
-- On QUESTION shift to state 233
-- On PRAGMA shift to state 234
-- On PLUS_SAT shift to state 235
-- On PLUSPLUS shift to state 236
-- On PLUS shift to state 237
-- On PARSER shift to state 238
-- On PACKAGE shift to state 239
-- On OUT shift to state 240
-- On OR shift to state 241
-- On NOT shift to state 242
-- On NE shift to state 243
-- On NAME shift to state 244
-- On MUL shift to state 247
-- On MOD shift to state 248
-- On MINUS_SAT shift to state 249
-- On MINUS shift to state 250
-- On MATCH_KIND shift to state 251
-- On MASK shift to state 252
-- On L_BRACKET shift to state 253
-- On L_BRACE shift to state 254
-- On L_ANGLE shift to state 255
-- On LE shift to state 256
-- On KEY shift to state 257
-- On INTEGER shift to state 258
-- On INT shift to state 259
-- On INOUT shift to state 260
-- On IN shift to state 261
-- On IF shift to state 262
-- On HEADER_UNION shift to state 263
-- On HEADER shift to state 264
-- On GE shift to state 265
-- On FALSE shift to state 266
-- On EXTERN shift to state 267
-- On EXIT shift to state 268
-- On ERROR shift to state 269
-- On EQ shift to state 270
-- On ENUM shift to state 271
-- On ENTRIES shift to state 272
-- On ELSE shift to state 273
-- On DOT shift to state 274
-- On DONTCARE shift to state 275
-- On DIV shift to state 276
-- On DEFAULT shift to state 277
-- On CONTROL shift to state 278
-- On CONST shift to state 279
-- On COMPLEMENT shift to state 280
-- On COMMA shift to state 281
-- On COLON shift to state 282
-- On BOOL shift to state 283
-- On BIT_XOR shift to state 284
-- On BIT_OR shift to state 285
-- On BIT_AND shift to state 286
-- On BIT shift to state 287
-- On AT shift to state 288
-- On ASSIGN shift to state 289
-- On APPLY shift to state 290
-- On AND shift to state 291
-- On ACTIONS shift to state 292
-- On ACTION shift to state 293
-- On ABSTRACT shift to state 294
-- On annotationToken shift to state 295
## Reductions:
-- On R_PAREN PRAGMA_END L_PAREN
--   reduce production petr4_list(annotationToken) -> list_aux(annotationToken)

State 211:
## Known stack suffix:
## VOID
## LR(1) items:
annotationToken -> VOID . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> VOID

State 212:
## Known stack suffix:
## VARBIT
## LR(1) items:
annotationToken -> VARBIT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> VARBIT

State 213:
## Known stack suffix:
## VALUESET
## LR(1) items:
annotationToken -> VALUESET . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> VALUESET

State 214:
## Known stack suffix:
## TYPEDEF
## LR(1) items:
annotationToken -> TYPEDEF . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> TYPEDEF

State 215:
## Known stack suffix:
## TYPE
## LR(1) items:
annotationToken -> TYPE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> TYPE

State 216:
## Known stack suffix:
## TUPLE
## LR(1) items:
annotationToken -> TUPLE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> TUPLE

State 217:
## Known stack suffix:
## TRUE
## LR(1) items:
annotationToken -> TRUE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> TRUE

State 218:
## Known stack suffix:
## TRANSITION
## LR(1) items:
annotationToken -> TRANSITION . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> TRANSITION

State 219:
## Known stack suffix:
## TABLE
## LR(1) items:
annotationToken -> TABLE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> TABLE

State 220:
## Known stack suffix:
## SWITCH
## LR(1) items:
annotationToken -> SWITCH . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> SWITCH

State 221:
## Known stack suffix:
## STRUCT
## LR(1) items:
annotationToken -> STRUCT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> STRUCT

State 222:
## Known stack suffix:
## STRING_LITERAL
## LR(1) items:
annotationToken -> STRING_LITERAL . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> STRING_LITERAL

State 223:
## Known stack suffix:
## STRING
## LR(1) items:
annotationToken -> STRING . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> STRING

State 224:
## Known stack suffix:
## STATE
## LR(1) items:
annotationToken -> STATE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> STATE

State 225:
## Known stack suffix:
## SHL
## LR(1) items:
annotationToken -> SHL . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> SHL

State 226:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
annotationToken -> SEMICOLON . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> SEMICOLON

State 227:
## Known stack suffix:
## SELECT
## LR(1) items:
annotationToken -> SELECT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> SELECT

State 228:
## Known stack suffix:
## R_BRACKET
## LR(1) items:
annotationToken -> R_BRACKET . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> R_BRACKET

State 229:
## Known stack suffix:
## R_BRACE
## LR(1) items:
annotationToken -> R_BRACE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> R_BRACE

State 230:
## Known stack suffix:
## R_ANGLE
## LR(1) items:
annotationToken -> R_ANGLE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> R_ANGLE

State 231:
## Known stack suffix:
## RETURN
## LR(1) items:
annotationToken -> RETURN . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> RETURN

State 232:
## Known stack suffix:
## RANGE
## LR(1) items:
annotationToken -> RANGE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> RANGE

State 233:
## Known stack suffix:
## QUESTION
## LR(1) items:
annotationToken -> QUESTION . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> QUESTION

State 234:
## Known stack suffix:
## PRAGMA
## LR(1) items:
annotationToken -> PRAGMA . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> PRAGMA

State 235:
## Known stack suffix:
## PLUS_SAT
## LR(1) items:
annotationToken -> PLUS_SAT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> PLUS_SAT

State 236:
## Known stack suffix:
## PLUSPLUS
## LR(1) items:
annotationToken -> PLUSPLUS . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> PLUSPLUS

State 237:
## Known stack suffix:
## PLUS
## LR(1) items:
annotationToken -> PLUS . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> PLUS

State 238:
## Known stack suffix:
## PARSER
## LR(1) items:
annotationToken -> PARSER . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> PARSER

State 239:
## Known stack suffix:
## PACKAGE
## LR(1) items:
annotationToken -> PACKAGE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> PACKAGE

State 240:
## Known stack suffix:
## OUT
## LR(1) items:
annotationToken -> OUT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> OUT

State 241:
## Known stack suffix:
## OR
## LR(1) items:
annotationToken -> OR . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> OR

State 242:
## Known stack suffix:
## NOT
## LR(1) items:
annotationToken -> NOT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> NOT

State 243:
## Known stack suffix:
## NE
## LR(1) items:
annotationToken -> NE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> NE

State 244:
## Known stack suffix:
## NAME
## LR(1) items:
annotationToken -> NAME . IDENTIFIER [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
annotationToken -> NAME . TYPENAME [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
-- On TYPENAME shift to state 245
-- On IDENTIFIER shift to state 246
## Reductions:

State 245:
## Known stack suffix:
## NAME TYPENAME
## LR(1) items:
annotationToken -> NAME TYPENAME . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> NAME TYPENAME

State 246:
## Known stack suffix:
## NAME IDENTIFIER
## LR(1) items:
annotationToken -> NAME IDENTIFIER . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> NAME IDENTIFIER

State 247:
## Known stack suffix:
## MUL
## LR(1) items:
annotationToken -> MUL . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> MUL

State 248:
## Known stack suffix:
## MOD
## LR(1) items:
annotationToken -> MOD . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> MOD

State 249:
## Known stack suffix:
## MINUS_SAT
## LR(1) items:
annotationToken -> MINUS_SAT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> MINUS_SAT

State 250:
## Known stack suffix:
## MINUS
## LR(1) items:
annotationToken -> MINUS . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> MINUS

State 251:
## Known stack suffix:
## MATCH_KIND
## LR(1) items:
annotationToken -> MATCH_KIND . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> MATCH_KIND

State 252:
## Known stack suffix:
## MASK
## LR(1) items:
annotationToken -> MASK . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> MASK

State 253:
## Known stack suffix:
## L_BRACKET
## LR(1) items:
annotationToken -> L_BRACKET . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> L_BRACKET

State 254:
## Known stack suffix:
## L_BRACE
## LR(1) items:
annotationToken -> L_BRACE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> L_BRACE

State 255:
## Known stack suffix:
## L_ANGLE
## LR(1) items:
annotationToken -> L_ANGLE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> L_ANGLE

State 256:
## Known stack suffix:
## LE
## LR(1) items:
annotationToken -> LE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> LE

State 257:
## Known stack suffix:
## KEY
## LR(1) items:
annotationToken -> KEY . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> KEY

State 258:
## Known stack suffix:
## INTEGER
## LR(1) items:
annotationToken -> INTEGER . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> INTEGER

State 259:
## Known stack suffix:
## INT
## LR(1) items:
annotationToken -> INT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> INT

State 260:
## Known stack suffix:
## INOUT
## LR(1) items:
annotationToken -> INOUT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> INOUT

State 261:
## Known stack suffix:
## IN
## LR(1) items:
annotationToken -> IN . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> IN

State 262:
## Known stack suffix:
## IF
## LR(1) items:
annotationToken -> IF . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> IF

State 263:
## Known stack suffix:
## HEADER_UNION
## LR(1) items:
annotationToken -> HEADER_UNION . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> HEADER_UNION

State 264:
## Known stack suffix:
## HEADER
## LR(1) items:
annotationToken -> HEADER . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> HEADER

State 265:
## Known stack suffix:
## GE
## LR(1) items:
annotationToken -> GE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> GE

State 266:
## Known stack suffix:
## FALSE
## LR(1) items:
annotationToken -> FALSE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> FALSE

State 267:
## Known stack suffix:
## EXTERN
## LR(1) items:
annotationToken -> EXTERN . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> EXTERN

State 268:
## Known stack suffix:
## EXIT
## LR(1) items:
annotationToken -> EXIT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> EXIT

State 269:
## Known stack suffix:
## ERROR
## LR(1) items:
annotationToken -> ERROR . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> ERROR

State 270:
## Known stack suffix:
## EQ
## LR(1) items:
annotationToken -> EQ . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> EQ

State 271:
## Known stack suffix:
## ENUM
## LR(1) items:
annotationToken -> ENUM . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> ENUM

State 272:
## Known stack suffix:
## ENTRIES
## LR(1) items:
annotationToken -> ENTRIES . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> ENTRIES

State 273:
## Known stack suffix:
## ELSE
## LR(1) items:
annotationToken -> ELSE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> ELSE

State 274:
## Known stack suffix:
## DOT
## LR(1) items:
annotationToken -> DOT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> DOT

State 275:
## Known stack suffix:
## DONTCARE
## LR(1) items:
annotationToken -> DONTCARE . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> DONTCARE

State 276:
## Known stack suffix:
## DIV
## LR(1) items:
annotationToken -> DIV . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> DIV

State 277:
## Known stack suffix:
## DEFAULT
## LR(1) items:
annotationToken -> DEFAULT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> DEFAULT

State 278:
## Known stack suffix:
## CONTROL
## LR(1) items:
annotationToken -> CONTROL . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> CONTROL

State 279:
## Known stack suffix:
## CONST
## LR(1) items:
annotationToken -> CONST . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> CONST

State 280:
## Known stack suffix:
## COMPLEMENT
## LR(1) items:
annotationToken -> COMPLEMENT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> COMPLEMENT

State 281:
## Known stack suffix:
## COMMA
## LR(1) items:
annotationToken -> COMMA . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> COMMA

State 282:
## Known stack suffix:
## COLON
## LR(1) items:
annotationToken -> COLON . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> COLON

State 283:
## Known stack suffix:
## BOOL
## LR(1) items:
annotationToken -> BOOL . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> BOOL

State 284:
## Known stack suffix:
## BIT_XOR
## LR(1) items:
annotationToken -> BIT_XOR . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> BIT_XOR

State 285:
## Known stack suffix:
## BIT_OR
## LR(1) items:
annotationToken -> BIT_OR . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> BIT_OR

State 286:
## Known stack suffix:
## BIT_AND
## LR(1) items:
annotationToken -> BIT_AND . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> BIT_AND

State 287:
## Known stack suffix:
## BIT
## LR(1) items:
annotationToken -> BIT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> BIT

State 288:
## Known stack suffix:
## AT
## LR(1) items:
annotationToken -> AT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> AT

State 289:
## Known stack suffix:
## ASSIGN
## LR(1) items:
annotationToken -> ASSIGN . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> ASSIGN

State 290:
## Known stack suffix:
## APPLY
## LR(1) items:
annotationToken -> APPLY . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> APPLY

State 291:
## Known stack suffix:
## AND
## LR(1) items:
annotationToken -> AND . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> AND

State 292:
## Known stack suffix:
## ACTIONS
## LR(1) items:
annotationToken -> ACTIONS . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> ACTIONS

State 293:
## Known stack suffix:
## ACTION
## LR(1) items:
annotationToken -> ACTION . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> ACTION

State 294:
## Known stack suffix:
## ABSTRACT
## LR(1) items:
annotationToken -> ABSTRACT . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationToken -> ABSTRACT

State 295:
## Known stack suffix:
## list_aux(annotationToken) annotationToken
## LR(1) items:
list_aux(annotationToken) -> list_aux(annotationToken) annotationToken . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_aux(annotationToken) -> list_aux(annotationToken) annotationToken

State 296:
## Known stack suffix:
## PRAGMA name annotationBody
## LR(1) items:
annotation -> PRAGMA name annotationBody . PRAGMA_END [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
annotationBody -> annotationBody . L_PAREN annotationBody R_PAREN [ PRAGMA_END L_PAREN ]
## Transitions:
-- On PRAGMA_END shift to state 297
-- On L_PAREN shift to state 298
## Reductions:

State 297:
## Known stack suffix:
## PRAGMA name annotationBody PRAGMA_END
## LR(1) items:
annotation -> PRAGMA name annotationBody PRAGMA_END . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation -> PRAGMA name annotationBody PRAGMA_END

State 298:
## Known stack suffix:
## annotationBody L_PAREN
## LR(1) items:
annotationBody -> annotationBody L_PAREN . annotationBody R_PAREN [ R_PAREN PRAGMA_END L_PAREN ]
## Transitions:
-- On petr4_list(annotationToken) shift to state 209
-- On list_aux(annotationToken) shift to state 210
-- On annotationBody shift to state 299
## Default reduction:
-- After reading the next token, reduce production list_aux(annotationToken) ->

State 299:
## Known stack suffix:
## annotationBody L_PAREN annotationBody
## LR(1) items:
annotationBody -> annotationBody . L_PAREN annotationBody R_PAREN [ R_PAREN L_PAREN ]
annotationBody -> annotationBody L_PAREN annotationBody . R_PAREN [ R_PAREN PRAGMA_END L_PAREN ]
## Transitions:
-- On R_PAREN shift to state 300
-- On L_PAREN shift to state 298
## Reductions:

State 300:
## Known stack suffix:
## annotationBody L_PAREN annotationBody R_PAREN
## LR(1) items:
annotationBody -> annotationBody L_PAREN annotationBody R_PAREN . [ R_PAREN PRAGMA_END L_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotationBody -> annotationBody L_PAREN annotationBody R_PAREN

State 301:
## Known stack suffix:
## NAME
## LR(1) items:
prefixedType -> NAME . TYPENAME [ TYPE STATE R_ANGLE NAME L_PAREN L_BRACKET L_ANGLE KEY ENTRIES APPLY ACTIONS ]
## Transitions:
-- On TYPENAME shift to state 12
## Reductions:

State 302:
## Known stack suffix:
## AT
## LR(1) items:
annotation -> AT . name [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
annotation -> AT . name L_PAREN annotationBody R_PAREN [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
annotation -> AT . name L_BRACKET expressionList R_BRACKET [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
annotation -> AT . name L_BRACKET kvList R_BRACKET [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 303
## Reductions:

State 303:
## Known stack suffix:
## AT name
## LR(1) items:
annotation -> AT name . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
annotation -> AT name . L_PAREN annotationBody R_PAREN [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
annotation -> AT name . L_BRACKET expressionList R_BRACKET [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
annotation -> AT name . L_BRACKET kvList R_BRACKET [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
-- On L_PAREN shift to state 304
-- On L_BRACKET shift to state 307
## Reductions:
-- On VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT
--   reduce production annotation -> AT name

State 304:
## Known stack suffix:
## AT name L_PAREN
## LR(1) items:
annotation -> AT name L_PAREN . annotationBody R_PAREN [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
-- On petr4_list(annotationToken) shift to state 209
-- On list_aux(annotationToken) shift to state 210
-- On annotationBody shift to state 305
## Default reduction:
-- After reading the next token, reduce production list_aux(annotationToken) ->

State 305:
## Known stack suffix:
## AT name L_PAREN annotationBody
## LR(1) items:
annotation -> AT name L_PAREN annotationBody . R_PAREN [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
annotationBody -> annotationBody . L_PAREN annotationBody R_PAREN [ R_PAREN L_PAREN ]
## Transitions:
-- On R_PAREN shift to state 306
-- On L_PAREN shift to state 298
## Reductions:

State 306:
## Known stack suffix:
## AT name L_PAREN annotationBody R_PAREN
## LR(1) items:
annotation -> AT name L_PAREN annotationBody R_PAREN . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation -> AT name L_PAREN annotationBody R_PAREN

State 307:
## Known stack suffix:
## AT name L_BRACKET
## LR(1) items:
annotation -> AT name L_BRACKET . expressionList R_BRACKET [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
annotation -> AT name L_BRACKET . kvList R_BRACKET [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 55
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_nonempty_list_aux(COMMA,kvPair) shift to state 308
-- On separated_list_aux(COMMA,expression) shift to state 173
-- On prefixedType shift to state 44
-- On petr4_separated_nonempty_list(COMMA,kvPair) shift to state 314
-- On petr4_separated_list(COMMA,expression) shift to state 176
-- On nonTypeName shift to state 60
-- On namedType shift to state 53
-- On name shift to state 310
-- On kvPair shift to state 315
-- On kvList shift to state 316
-- On expressionList shift to state 318
-- On expression shift to state 179
-- On dotPrefix shift to state 91
## Reductions:
-- On R_BRACKET COMMA
--   reduce production separated_list_aux(COMMA,expression) ->

State 308:
## Known stack suffix:
## separated_nonempty_list_aux(COMMA,kvPair)
## LR(1) items:
petr4_separated_nonempty_list(COMMA,kvPair) -> separated_nonempty_list_aux(COMMA,kvPair) . [ R_BRACKET ]
separated_nonempty_list_aux(COMMA,kvPair) -> separated_nonempty_list_aux(COMMA,kvPair) . COMMA kvPair [ R_BRACKET COMMA ]
## Transitions:
-- On COMMA shift to state 309
## Reductions:
-- On R_BRACKET
--   reduce production petr4_separated_nonempty_list(COMMA,kvPair) -> separated_nonempty_list_aux(COMMA,kvPair)

State 309:
## Known stack suffix:
## separated_nonempty_list_aux(COMMA,kvPair) COMMA
## LR(1) items:
separated_nonempty_list_aux(COMMA,kvPair) -> separated_nonempty_list_aux(COMMA,kvPair) COMMA . kvPair [ R_BRACKET COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 310
-- On kvPair shift to state 313
## Reductions:

State 310:
## Known stack suffix:
## name
## LR(1) items:
kvPair -> name . EQ expression [ R_BRACKET COMMA ]
## Transitions:
-- On EQ shift to state 311
## Reductions:

State 311:
## Known stack suffix:
## name EQ
## LR(1) items:
kvPair -> name EQ . expression [ R_BRACKET COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 312
-- On dotPrefix shift to state 91
## Reductions:

State 312:
## Known stack suffix:
## name EQ expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
kvPair -> name EQ expression . [ R_BRACKET COMMA ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On R_BRACKET COMMA
--   reduce production kvPair -> name EQ expression

State 313:
## Known stack suffix:
## separated_nonempty_list_aux(COMMA,kvPair) COMMA kvPair
## LR(1) items:
separated_nonempty_list_aux(COMMA,kvPair) -> separated_nonempty_list_aux(COMMA,kvPair) COMMA kvPair . [ R_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list_aux(COMMA,kvPair) -> separated_nonempty_list_aux(COMMA,kvPair) COMMA kvPair

State 314:
## Known stack suffix:
## petr4_separated_nonempty_list(COMMA,kvPair)
## LR(1) items:
kvList -> petr4_separated_nonempty_list(COMMA,kvPair) . [ R_BRACKET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production kvList -> petr4_separated_nonempty_list(COMMA,kvPair)

State 315:
## Known stack suffix:
## kvPair
## LR(1) items:
separated_nonempty_list_aux(COMMA,kvPair) -> kvPair . [ R_BRACKET COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list_aux(COMMA,kvPair) -> kvPair

State 316:
## Known stack suffix:
## AT name L_BRACKET kvList
## LR(1) items:
annotation -> AT name L_BRACKET kvList . R_BRACKET [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
-- On R_BRACKET shift to state 317
## Reductions:

State 317:
## Known stack suffix:
## AT name L_BRACKET kvList R_BRACKET
## LR(1) items:
annotation -> AT name L_BRACKET kvList R_BRACKET . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation -> AT name L_BRACKET kvList R_BRACKET

State 318:
## Known stack suffix:
## AT name L_BRACKET expressionList
## LR(1) items:
annotation -> AT name L_BRACKET expressionList . R_BRACKET [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
-- On R_BRACKET shift to state 319
## Reductions:

State 319:
## Known stack suffix:
## AT name L_BRACKET expressionList R_BRACKET
## LR(1) items:
annotation -> AT name L_BRACKET expressionList R_BRACKET . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotation -> AT name L_BRACKET expressionList R_BRACKET

State 320:
## Known stack suffix:
## typeRef
## LR(1) items:
structField -> typeRef . name SEMICOLON [ VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 321
## Reductions:

State 321:
## Known stack suffix:
## typeRef name
## LR(1) items:
structField -> typeRef name . SEMICOLON [ VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
## Transitions:
-- On SEMICOLON shift to state 322
## Reductions:

State 322:
## Known stack suffix:
## typeRef name SEMICOLON
## LR(1) items:
structField -> typeRef name SEMICOLON . [ VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production structField -> typeRef name SEMICOLON

State 323:
## Known stack suffix:
## list_aux(structField) structField
## LR(1) items:
list_aux(structField) -> list_aux(structField) structField . [ VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) -> list_aux(structField) structField

State 324:
## Known stack suffix:
## petr4_nonempty_list(annotation)
## LR(1) items:
annotations -> petr4_nonempty_list(annotation) . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production annotations -> petr4_nonempty_list(annotation)

State 325:
## Known stack suffix:
## nonempty_list_aux(annotation)
## LR(1) items:
nonempty_list_aux(annotation) -> nonempty_list_aux(annotation) . annotation [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
petr4_nonempty_list(annotation) -> nonempty_list_aux(annotation) . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
-- On PRAGMA shift to state 207
-- On AT shift to state 302
-- On annotation shift to state 326
## Reductions:
-- On VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT APPLY ACTIONS ACTION ABSTRACT
--   reduce production petr4_nonempty_list(annotation) -> nonempty_list_aux(annotation)

State 326:
## Known stack suffix:
## nonempty_list_aux(annotation) annotation
## LR(1) items:
nonempty_list_aux(annotation) -> nonempty_list_aux(annotation) annotation . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list_aux(annotation) -> nonempty_list_aux(annotation) annotation

State 327:
## Known stack suffix:
## annotations
## LR(1) items:
structField -> annotations . typeRef name SEMICOLON [ VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On typeRef shift to state 328
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 328:
## Known stack suffix:
## annotations typeRef
## LR(1) items:
structField -> annotations typeRef . name SEMICOLON [ VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 329
## Reductions:

State 329:
## Known stack suffix:
## annotations typeRef name
## LR(1) items:
structField -> annotations typeRef name . SEMICOLON [ VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
## Transitions:
-- On SEMICOLON shift to state 330
## Reductions:

State 330:
## Known stack suffix:
## annotations typeRef name SEMICOLON
## LR(1) items:
structField -> annotations typeRef name SEMICOLON . [ VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production structField -> annotations typeRef name SEMICOLON

State 331:
## Known stack suffix:
## annotation
## LR(1) items:
nonempty_list_aux(annotation) -> annotation . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list_aux(annotation) -> annotation

State 332:
## Known stack suffix:
## HEADER_UNION
## LR(1) items:
headerUnionDeclaration -> HEADER_UNION . name L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 333
## Reductions:

State 333:
## Known stack suffix:
## HEADER_UNION name
## LR(1) items:
headerUnionDeclaration -> HEADER_UNION name . L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 334
## Reductions:

State 334:
## Known stack suffix:
## HEADER_UNION name L_BRACE
## LR(1) items:
headerUnionDeclaration -> HEADER_UNION name L_BRACE . petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On petr4_list(structField) shift to state 335
-- On list_aux(structField) shift to state 206
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) ->

State 335:
## Known stack suffix:
## HEADER_UNION name L_BRACE petr4_list(structField)
## LR(1) items:
headerUnionDeclaration -> HEADER_UNION name L_BRACE petr4_list(structField) . R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_BRACE shift to state 336
## Reductions:

State 336:
## Known stack suffix:
## HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE
## LR(1) items:
headerUnionDeclaration -> HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production headerUnionDeclaration -> HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE

State 337:
## Known stack suffix:
## HEADER
## LR(1) items:
headerTypeDeclaration -> HEADER . name L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 338
## Reductions:

State 338:
## Known stack suffix:
## HEADER name
## LR(1) items:
headerTypeDeclaration -> HEADER name . L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 339
## Reductions:

State 339:
## Known stack suffix:
## HEADER name L_BRACE
## LR(1) items:
headerTypeDeclaration -> HEADER name L_BRACE . petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On petr4_list(structField) shift to state 340
-- On list_aux(structField) shift to state 206
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) ->

State 340:
## Known stack suffix:
## HEADER name L_BRACE petr4_list(structField)
## LR(1) items:
headerTypeDeclaration -> HEADER name L_BRACE petr4_list(structField) . R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_BRACE shift to state 341
## Reductions:

State 341:
## Known stack suffix:
## HEADER name L_BRACE petr4_list(structField) R_BRACE
## LR(1) items:
headerTypeDeclaration -> HEADER name L_BRACE petr4_list(structField) R_BRACE . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production headerTypeDeclaration -> HEADER name L_BRACE petr4_list(structField) R_BRACE

State 342:
## Known stack suffix:
## ENUM
## LR(1) items:
enumDeclaration -> ENUM . name L_BRACE identifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
enumDeclaration -> ENUM . BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On BIT shift to state 343
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 359
## Reductions:

State 343:
## Known stack suffix:
## ENUM BIT
## LR(1) items:
enumDeclaration -> ENUM BIT . L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_ANGLE shift to state 344
## Reductions:

State 344:
## Known stack suffix:
## ENUM BIT L_ANGLE
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE . INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On INTEGER shift to state 345
## Reductions:

State 345:
## Known stack suffix:
## ENUM BIT L_ANGLE INTEGER
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE INTEGER . R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_ANGLE shift to state 346
## Reductions:

State 346:
## Known stack suffix:
## ENUM BIT L_ANGLE INTEGER R_ANGLE
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE INTEGER R_ANGLE . name L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 347
## Reductions:

State 347:
## Known stack suffix:
## ENUM BIT L_ANGLE INTEGER R_ANGLE name
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE INTEGER R_ANGLE name . L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 348
## Reductions:

State 348:
## Known stack suffix:
## ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE . specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On specifiedIdentifierList shift to state 349
-- On specifiedIdentifier shift to state 351
-- On separated_nonempty_list_aux(COMMA,__anonymous_1) shift to state 352
-- On petr4_separated_nonempty_list(COMMA,__anonymous_1) shift to state 358
-- On nonTypeName shift to state 35
-- On name shift to state 355
## Reductions:

State 349:
## Known stack suffix:
## ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList . R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_BRACE shift to state 350
## Reductions:

State 350:
## Known stack suffix:
## ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enumDeclaration -> ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE

State 351:
## Known stack suffix:
## specifiedIdentifier
## LR(1) items:
separated_nonempty_list_aux(COMMA,__anonymous_1) -> specifiedIdentifier . [ R_BRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list_aux(COMMA,__anonymous_1) -> specifiedIdentifier

State 352:
## Known stack suffix:
## separated_nonempty_list_aux(COMMA,__anonymous_1)
## LR(1) items:
petr4_separated_nonempty_list(COMMA,__anonymous_1) -> separated_nonempty_list_aux(COMMA,__anonymous_1) . [ R_BRACE ]
separated_nonempty_list_aux(COMMA,__anonymous_1) -> separated_nonempty_list_aux(COMMA,__anonymous_1) . COMMA specifiedIdentifier [ R_BRACE COMMA ]
## Transitions:
-- On COMMA shift to state 353
## Reductions:
-- On R_BRACE
--   reduce production petr4_separated_nonempty_list(COMMA,__anonymous_1) -> separated_nonempty_list_aux(COMMA,__anonymous_1)

State 353:
## Known stack suffix:
## separated_nonempty_list_aux(COMMA,__anonymous_1) COMMA
## LR(1) items:
separated_nonempty_list_aux(COMMA,__anonymous_1) -> separated_nonempty_list_aux(COMMA,__anonymous_1) COMMA . specifiedIdentifier [ R_BRACE COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On specifiedIdentifier shift to state 354
-- On nonTypeName shift to state 35
-- On name shift to state 355
## Reductions:

State 354:
## Known stack suffix:
## separated_nonempty_list_aux(COMMA,__anonymous_1) COMMA specifiedIdentifier
## LR(1) items:
separated_nonempty_list_aux(COMMA,__anonymous_1) -> separated_nonempty_list_aux(COMMA,__anonymous_1) COMMA specifiedIdentifier . [ R_BRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list_aux(COMMA,__anonymous_1) -> separated_nonempty_list_aux(COMMA,__anonymous_1) COMMA specifiedIdentifier

State 355:
## Known stack suffix:
## name
## LR(1) items:
specifiedIdentifier -> name . ASSIGN expression [ R_BRACE COMMA ]
## Transitions:
-- On ASSIGN shift to state 356
## Reductions:

State 356:
## Known stack suffix:
## name ASSIGN
## LR(1) items:
specifiedIdentifier -> name ASSIGN . expression [ R_BRACE COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 357
-- On dotPrefix shift to state 91
## Reductions:

State 357:
## Known stack suffix:
## name ASSIGN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_BRACE R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
specifiedIdentifier -> name ASSIGN expression . [ R_BRACE COMMA ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On R_BRACE COMMA
--   reduce production specifiedIdentifier -> name ASSIGN expression

State 358:
## Known stack suffix:
## petr4_separated_nonempty_list(COMMA,__anonymous_1)
## LR(1) items:
specifiedIdentifierList -> petr4_separated_nonempty_list(COMMA,__anonymous_1) . [ R_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production specifiedIdentifierList -> petr4_separated_nonempty_list(COMMA,__anonymous_1)

State 359:
## Known stack suffix:
## ENUM name
## LR(1) items:
enumDeclaration -> ENUM name . L_BRACE identifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 360
## Reductions:

State 360:
## Known stack suffix:
## ENUM name L_BRACE
## LR(1) items:
enumDeclaration -> ENUM name L_BRACE . identifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On separated_nonempty_list_aux(COMMA,__anonymous_0) shift to state 361
-- On petr4_separated_nonempty_list(COMMA,__anonymous_0) shift to state 364
-- On nonTypeName shift to state 35
-- On name shift to state 365
-- On identifierList shift to state 366
## Reductions:

State 361:
## Known stack suffix:
## separated_nonempty_list_aux(COMMA,__anonymous_0)
## LR(1) items:
petr4_separated_nonempty_list(COMMA,__anonymous_0) -> separated_nonempty_list_aux(COMMA,__anonymous_0) . [ R_BRACE ]
separated_nonempty_list_aux(COMMA,__anonymous_0) -> separated_nonempty_list_aux(COMMA,__anonymous_0) . COMMA name [ R_BRACE COMMA ]
## Transitions:
-- On COMMA shift to state 362
## Reductions:
-- On R_BRACE
--   reduce production petr4_separated_nonempty_list(COMMA,__anonymous_0) -> separated_nonempty_list_aux(COMMA,__anonymous_0)

State 362:
## Known stack suffix:
## separated_nonempty_list_aux(COMMA,__anonymous_0) COMMA
## LR(1) items:
separated_nonempty_list_aux(COMMA,__anonymous_0) -> separated_nonempty_list_aux(COMMA,__anonymous_0) COMMA . name [ R_BRACE COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 363
## Reductions:

State 363:
## Known stack suffix:
## separated_nonempty_list_aux(COMMA,__anonymous_0) COMMA name
## LR(1) items:
separated_nonempty_list_aux(COMMA,__anonymous_0) -> separated_nonempty_list_aux(COMMA,__anonymous_0) COMMA name . [ R_BRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list_aux(COMMA,__anonymous_0) -> separated_nonempty_list_aux(COMMA,__anonymous_0) COMMA name

State 364:
## Known stack suffix:
## petr4_separated_nonempty_list(COMMA,__anonymous_0)
## LR(1) items:
identifierList -> petr4_separated_nonempty_list(COMMA,__anonymous_0) . [ R_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production identifierList -> petr4_separated_nonempty_list(COMMA,__anonymous_0)

State 365:
## Known stack suffix:
## name
## LR(1) items:
separated_nonempty_list_aux(COMMA,__anonymous_0) -> name . [ R_BRACE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list_aux(COMMA,__anonymous_0) -> name

State 366:
## Known stack suffix:
## ENUM name L_BRACE identifierList
## LR(1) items:
enumDeclaration -> ENUM name L_BRACE identifierList . R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_BRACE shift to state 367
## Reductions:

State 367:
## Known stack suffix:
## ENUM name L_BRACE identifierList R_BRACE
## LR(1) items:
enumDeclaration -> ENUM name L_BRACE identifierList R_BRACE . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enumDeclaration -> ENUM name L_BRACE identifierList R_BRACE

State 368:
## Known stack suffix:
## TYPEDEF typeRef
## LR(1) items:
typedefDeclaration -> TYPEDEF typeRef . name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 369
## Reductions:

State 369:
## Known stack suffix:
## TYPEDEF typeRef name
## LR(1) items:
typedefDeclaration -> TYPEDEF typeRef name . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 370
## Reductions:

State 370:
## Known stack suffix:
## TYPEDEF typeRef name SEMICOLON
## LR(1) items:
typedefDeclaration -> TYPEDEF typeRef name SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typedefDeclaration -> TYPEDEF typeRef name SEMICOLON

State 371:
## Known stack suffix:
## structTypeDeclaration
## LR(1) items:
derivedTypeDeclaration -> structTypeDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production derivedTypeDeclaration -> structTypeDeclaration

State 372:
## Known stack suffix:
## headerUnionDeclaration
## LR(1) items:
derivedTypeDeclaration -> headerUnionDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production derivedTypeDeclaration -> headerUnionDeclaration

State 373:
## Known stack suffix:
## headerTypeDeclaration
## LR(1) items:
derivedTypeDeclaration -> headerTypeDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production derivedTypeDeclaration -> headerTypeDeclaration

State 374:
## Known stack suffix:
## enumDeclaration
## LR(1) items:
derivedTypeDeclaration -> enumDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production derivedTypeDeclaration -> enumDeclaration

State 375:
## Known stack suffix:
## TYPEDEF derivedTypeDeclaration
## LR(1) items:
typedefDeclaration -> TYPEDEF derivedTypeDeclaration . name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 376
## Reductions:

State 376:
## Known stack suffix:
## TYPEDEF derivedTypeDeclaration name
## LR(1) items:
typedefDeclaration -> TYPEDEF derivedTypeDeclaration name . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 377
## Reductions:

State 377:
## Known stack suffix:
## TYPEDEF derivedTypeDeclaration name SEMICOLON
## LR(1) items:
typedefDeclaration -> TYPEDEF derivedTypeDeclaration name SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typedefDeclaration -> TYPEDEF derivedTypeDeclaration name SEMICOLON

State 378:
## Known stack suffix:
## annotations
## LR(1) items:
enumDeclaration -> annotations . ENUM name L_BRACE identifierList R_BRACE [ TYPE STATE NAME KEY ENTRIES APPLY ACTIONS ]
enumDeclaration -> annotations . ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ TYPE STATE NAME KEY ENTRIES APPLY ACTIONS ]
headerTypeDeclaration -> annotations . HEADER name L_BRACE petr4_list(structField) R_BRACE [ TYPE STATE NAME KEY ENTRIES APPLY ACTIONS ]
headerUnionDeclaration -> annotations . HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE [ TYPE STATE NAME KEY ENTRIES APPLY ACTIONS ]
structTypeDeclaration -> annotations . STRUCT name L_BRACE petr4_list(structField) R_BRACE [ TYPE STATE NAME KEY ENTRIES APPLY ACTIONS ]
## Transitions:
-- On STRUCT shift to state 379
-- On HEADER_UNION shift to state 384
-- On HEADER shift to state 389
-- On ENUM shift to state 394
## Reductions:

State 379:
## Known stack suffix:
## annotations STRUCT
## LR(1) items:
structTypeDeclaration -> annotations STRUCT . name L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 380
## Reductions:

State 380:
## Known stack suffix:
## annotations STRUCT name
## LR(1) items:
structTypeDeclaration -> annotations STRUCT name . L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 381
## Reductions:

State 381:
## Known stack suffix:
## annotations STRUCT name L_BRACE
## LR(1) items:
structTypeDeclaration -> annotations STRUCT name L_BRACE . petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On petr4_list(structField) shift to state 382
-- On list_aux(structField) shift to state 206
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) ->

State 382:
## Known stack suffix:
## annotations STRUCT name L_BRACE petr4_list(structField)
## LR(1) items:
structTypeDeclaration -> annotations STRUCT name L_BRACE petr4_list(structField) . R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_BRACE shift to state 383
## Reductions:

State 383:
## Known stack suffix:
## annotations STRUCT name L_BRACE petr4_list(structField) R_BRACE
## LR(1) items:
structTypeDeclaration -> annotations STRUCT name L_BRACE petr4_list(structField) R_BRACE . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production structTypeDeclaration -> annotations STRUCT name L_BRACE petr4_list(structField) R_BRACE

State 384:
## Known stack suffix:
## annotations HEADER_UNION
## LR(1) items:
headerUnionDeclaration -> annotations HEADER_UNION . name L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 385
## Reductions:

State 385:
## Known stack suffix:
## annotations HEADER_UNION name
## LR(1) items:
headerUnionDeclaration -> annotations HEADER_UNION name . L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 386
## Reductions:

State 386:
## Known stack suffix:
## annotations HEADER_UNION name L_BRACE
## LR(1) items:
headerUnionDeclaration -> annotations HEADER_UNION name L_BRACE . petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On petr4_list(structField) shift to state 387
-- On list_aux(structField) shift to state 206
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) ->

State 387:
## Known stack suffix:
## annotations HEADER_UNION name L_BRACE petr4_list(structField)
## LR(1) items:
headerUnionDeclaration -> annotations HEADER_UNION name L_BRACE petr4_list(structField) . R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_BRACE shift to state 388
## Reductions:

State 388:
## Known stack suffix:
## annotations HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE
## LR(1) items:
headerUnionDeclaration -> annotations HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production headerUnionDeclaration -> annotations HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE

State 389:
## Known stack suffix:
## annotations HEADER
## LR(1) items:
headerTypeDeclaration -> annotations HEADER . name L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 390
## Reductions:

State 390:
## Known stack suffix:
## annotations HEADER name
## LR(1) items:
headerTypeDeclaration -> annotations HEADER name . L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 391
## Reductions:

State 391:
## Known stack suffix:
## annotations HEADER name L_BRACE
## LR(1) items:
headerTypeDeclaration -> annotations HEADER name L_BRACE . petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On petr4_list(structField) shift to state 392
-- On list_aux(structField) shift to state 206
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) ->

State 392:
## Known stack suffix:
## annotations HEADER name L_BRACE petr4_list(structField)
## LR(1) items:
headerTypeDeclaration -> annotations HEADER name L_BRACE petr4_list(structField) . R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_BRACE shift to state 393
## Reductions:

State 393:
## Known stack suffix:
## annotations HEADER name L_BRACE petr4_list(structField) R_BRACE
## LR(1) items:
headerTypeDeclaration -> annotations HEADER name L_BRACE petr4_list(structField) R_BRACE . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production headerTypeDeclaration -> annotations HEADER name L_BRACE petr4_list(structField) R_BRACE

State 394:
## Known stack suffix:
## annotations ENUM
## LR(1) items:
enumDeclaration -> annotations ENUM . name L_BRACE identifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
enumDeclaration -> annotations ENUM . BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On BIT shift to state 395
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 403
## Reductions:

State 395:
## Known stack suffix:
## annotations ENUM BIT
## LR(1) items:
enumDeclaration -> annotations ENUM BIT . L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_ANGLE shift to state 396
## Reductions:

State 396:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE . INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On INTEGER shift to state 397
## Reductions:

State 397:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE INTEGER
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER . R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_ANGLE shift to state 398
## Reductions:

State 398:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE INTEGER R_ANGLE
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER R_ANGLE . name L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 399
## Reductions:

State 399:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name . L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 400
## Reductions:

State 400:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE . specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On specifiedIdentifierList shift to state 401
-- On specifiedIdentifier shift to state 351
-- On separated_nonempty_list_aux(COMMA,__anonymous_1) shift to state 352
-- On petr4_separated_nonempty_list(COMMA,__anonymous_1) shift to state 358
-- On nonTypeName shift to state 35
-- On name shift to state 355
## Reductions:

State 401:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList . R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_BRACE shift to state 402
## Reductions:

State 402:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE

State 403:
## Known stack suffix:
## annotations ENUM name
## LR(1) items:
enumDeclaration -> annotations ENUM name . L_BRACE identifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 404
## Reductions:

State 404:
## Known stack suffix:
## annotations ENUM name L_BRACE
## LR(1) items:
enumDeclaration -> annotations ENUM name L_BRACE . identifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On separated_nonempty_list_aux(COMMA,__anonymous_0) shift to state 361
-- On petr4_separated_nonempty_list(COMMA,__anonymous_0) shift to state 364
-- On nonTypeName shift to state 35
-- On name shift to state 365
-- On identifierList shift to state 405
## Reductions:

State 405:
## Known stack suffix:
## annotations ENUM name L_BRACE identifierList
## LR(1) items:
enumDeclaration -> annotations ENUM name L_BRACE identifierList . R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_BRACE shift to state 406
## Reductions:

State 406:
## Known stack suffix:
## annotations ENUM name L_BRACE identifierList R_BRACE
## LR(1) items:
enumDeclaration -> annotations ENUM name L_BRACE identifierList R_BRACE . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production enumDeclaration -> annotations ENUM name L_BRACE identifierList R_BRACE

State 407:
## Known stack suffix:
## TYPE
## LR(1) items:
typedefDeclaration -> TYPE . typeRef name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
typedefDeclaration -> TYPE . derivedTypeDeclaration name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRUCT shift to state 201
-- On STRING shift to state 18
-- On PRAGMA shift to state 207
-- On NAME shift to state 301
-- On INT shift to state 20
-- On HEADER_UNION shift to state 332
-- On HEADER shift to state 337
-- On ERROR shift to state 46
-- On ENUM shift to state 342
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On typeRef shift to state 408
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On structTypeDeclaration shift to state 371
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On headerUnionDeclaration shift to state 372
-- On headerTypeDeclaration shift to state 373
-- On headerStackType shift to state 142
-- On enumDeclaration shift to state 374
-- On dotPrefix shift to state 143
-- On derivedTypeDeclaration shift to state 411
-- On baseType shift to state 146
-- On annotations shift to state 378
-- On annotation shift to state 331
## Reductions:

State 408:
## Known stack suffix:
## TYPE typeRef
## LR(1) items:
typedefDeclaration -> TYPE typeRef . name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 409
## Reductions:

State 409:
## Known stack suffix:
## TYPE typeRef name
## LR(1) items:
typedefDeclaration -> TYPE typeRef name . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 410
## Reductions:

State 410:
## Known stack suffix:
## TYPE typeRef name SEMICOLON
## LR(1) items:
typedefDeclaration -> TYPE typeRef name SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typedefDeclaration -> TYPE typeRef name SEMICOLON

State 411:
## Known stack suffix:
## TYPE derivedTypeDeclaration
## LR(1) items:
typedefDeclaration -> TYPE derivedTypeDeclaration . name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 412
## Reductions:

State 412:
## Known stack suffix:
## TYPE derivedTypeDeclaration name
## LR(1) items:
typedefDeclaration -> TYPE derivedTypeDeclaration name . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 413
## Reductions:

State 413:
## Known stack suffix:
## TYPE derivedTypeDeclaration name SEMICOLON
## LR(1) items:
typedefDeclaration -> TYPE derivedTypeDeclaration name SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typedefDeclaration -> TYPE derivedTypeDeclaration name SEMICOLON

State 414:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
topDeclarationList -> SEMICOLON . topDeclarationList [ END ]
## Transitions:
-- On VOID shift to state 1
-- On VARBIT shift to state 2
-- On TYPEDEF shift to state 200
-- On TYPE shift to state 407
-- On TUPLE shift to state 16
-- On STRUCT shift to state 201
-- On STRING shift to state 18
-- On SEMICOLON shift to state 414
-- On PRAGMA shift to state 207
-- On PARSER shift to state 415
-- On PACKAGE shift to state 449
-- On NAME shift to state 11
-- On MATCH_KIND shift to state 455
-- On INT shift to state 20
-- On HEADER_UNION shift to state 332
-- On HEADER shift to state 337
-- On EXTERN shift to state 459
-- On ERROR shift to state 510
-- On ENUM shift to state 342
-- On DOT shift to state 38
-- On CONTROL shift to state 514
-- On CONST shift to state 520
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On ACTION shift to state 527
-- On varName shift to state 479
-- On typedefDeclaration shift to state 671
-- On typeRef shift to state 630
-- On typeOrVoid shift to state 462
-- On typeName shift to state 138
-- On typeDeclaration shift to state 672
-- On tupleType shift to state 128
-- On topDeclarationList shift to state 673
-- On topDeclaration shift to state 674
-- On structTypeDeclaration shift to state 371
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parserTypeDeclaration shift to state 676
-- On parserDeclaration shift to state 810
-- On packageTypeDeclaration shift to state 811
-- On nonempty_list_aux(annotation) shift to state 325
-- On matchKindDeclaration shift to state 814
-- On instantiation shift to state 815
-- On headerUnionDeclaration shift to state 372
-- On headerTypeDeclaration shift to state 373
-- On headerStackType shift to state 142
-- On functionPrototype shift to state 633
-- On functionDeclaration shift to state 816
-- On externDeclaration shift to state 817
-- On errorDeclaration shift to state 818
-- On enumDeclaration shift to state 374
-- On dotPrefix shift to state 143
-- On derivedTypeDeclaration shift to state 819
-- On controlTypeDeclaration shift to state 820
-- On controlDeclaration shift to state 930
-- On constantDeclaration shift to state 931
-- On baseType shift to state 146
-- On annotations shift to state 932
-- On annotation shift to state 331
-- On actionDeclaration shift to state 975
## Reductions:
-- On END
--   reduce production topDeclarationList ->

State 415:
## Known stack suffix:
## PARSER
## LR(1) items:
parserTypeDeclaration -> PARSER . push_name optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On push_name shift to state 416
-- On nonTypeName shift to state 35
-- On name shift to state 448
## Reductions:

State 416:
## Known stack suffix:
## PARSER push_name
## LR(1) items:
parserTypeDeclaration -> PARSER push_name . optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On L_ANGLE shift to state 417
-- On optTypeParameters shift to state 425
## Reductions:
-- On L_PAREN
--   reduce production optTypeParameters ->

State 417:
## Known stack suffix:
## L_ANGLE
## LR(1) items:
optTypeParameters -> L_ANGLE . petr4_separated_list(COMMA,typeParameter) R_ANGLE [ L_PAREN L_BRACE ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeParameter shift to state 418
-- On tableKwName shift to state 34
-- On separated_list_aux(COMMA,typeParameter) shift to state 419
-- On petr4_separated_list(COMMA,typeParameter) shift to state 423
-- On nonTypeName shift to state 35
-- On name shift to state 422
## Reductions:
-- On R_ANGLE COMMA
--   reduce production separated_list_aux(COMMA,typeParameter) ->

State 418:
## Known stack suffix:
## typeParameter
## LR(1) items:
separated_list_aux(COMMA,typeParameter) -> typeParameter . [ R_ANGLE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_list_aux(COMMA,typeParameter) -> typeParameter

State 419:
## Known stack suffix:
## separated_list_aux(COMMA,typeParameter)
## LR(1) items:
petr4_separated_list(COMMA,typeParameter) -> separated_list_aux(COMMA,typeParameter) . [ R_ANGLE ]
separated_list_aux(COMMA,typeParameter) -> separated_list_aux(COMMA,typeParameter) . COMMA typeParameter [ R_ANGLE COMMA ]
## Transitions:
-- On COMMA shift to state 420
## Reductions:
-- On R_ANGLE
--   reduce production petr4_separated_list(COMMA,typeParameter) -> separated_list_aux(COMMA,typeParameter)

State 420:
## Known stack suffix:
## separated_list_aux(COMMA,typeParameter) COMMA
## LR(1) items:
separated_list_aux(COMMA,typeParameter) -> separated_list_aux(COMMA,typeParameter) COMMA . typeParameter [ R_ANGLE COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeParameter shift to state 421
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 422
## Reductions:

State 421:
## Known stack suffix:
## separated_list_aux(COMMA,typeParameter) COMMA typeParameter
## LR(1) items:
separated_list_aux(COMMA,typeParameter) -> separated_list_aux(COMMA,typeParameter) COMMA typeParameter . [ R_ANGLE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_list_aux(COMMA,typeParameter) -> separated_list_aux(COMMA,typeParameter) COMMA typeParameter

State 422:
## Known stack suffix:
## name
## LR(1) items:
typeParameter -> name . [ R_ANGLE COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeParameter -> name

State 423:
## Known stack suffix:
## L_ANGLE petr4_separated_list(COMMA,typeParameter)
## LR(1) items:
optTypeParameters -> L_ANGLE petr4_separated_list(COMMA,typeParameter) . R_ANGLE [ L_PAREN L_BRACE ]
## Transitions:
-- On R_ANGLE shift to state 424
## Reductions:

State 424:
## Known stack suffix:
## L_ANGLE petr4_separated_list(COMMA,typeParameter) R_ANGLE
## LR(1) items:
optTypeParameters -> L_ANGLE petr4_separated_list(COMMA,typeParameter) R_ANGLE . [ L_PAREN L_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production optTypeParameters -> L_ANGLE petr4_separated_list(COMMA,typeParameter) R_ANGLE

State 425:
## Known stack suffix:
## PARSER push_name optTypeParameters
## LR(1) items:
parserTypeDeclaration -> PARSER push_name optTypeParameters . L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On L_PAREN shift to state 426
## Reductions:

State 426:
## Known stack suffix:
## PARSER push_name optTypeParameters L_PAREN
## LR(1) items:
parserTypeDeclaration -> PARSER push_name optTypeParameters L_PAREN . parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On separated_list_aux(COMMA,parameter) shift to state 430
-- On petr4_separated_list(COMMA,parameter) shift to state 444
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameterList shift to state 445
-- On parameter shift to state 447
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,parameter) ->

State 427:
## Known stack suffix:
## OUT
## LR(1) items:
direction -> OUT . [ VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production direction -> OUT

State 428:
## Known stack suffix:
## INOUT
## LR(1) items:
direction -> INOUT . [ VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production direction -> INOUT

State 429:
## Known stack suffix:
## IN
## LR(1) items:
direction -> IN . [ VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production direction -> IN

State 430:
## Known stack suffix:
## separated_list_aux(COMMA,parameter)
## LR(1) items:
petr4_separated_list(COMMA,parameter) -> separated_list_aux(COMMA,parameter) . [ R_PAREN ]
separated_list_aux(COMMA,parameter) -> separated_list_aux(COMMA,parameter) . COMMA parameter [ R_PAREN COMMA ]
## Transitions:
-- On COMMA shift to state 431
## Reductions:
-- On R_PAREN
--   reduce production petr4_separated_list(COMMA,parameter) -> separated_list_aux(COMMA,parameter)

State 431:
## Known stack suffix:
## separated_list_aux(COMMA,parameter) COMMA
## LR(1) items:
separated_list_aux(COMMA,parameter) -> separated_list_aux(COMMA,parameter) COMMA . parameter [ R_PAREN COMMA ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameter shift to state 432
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->

State 432:
## Known stack suffix:
## separated_list_aux(COMMA,parameter) COMMA parameter
## LR(1) items:
separated_list_aux(COMMA,parameter) -> separated_list_aux(COMMA,parameter) COMMA parameter . [ R_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_list_aux(COMMA,parameter) -> separated_list_aux(COMMA,parameter) COMMA parameter

State 433:
## Known stack suffix:
## direction
## LR(1) items:
parameter -> direction . typeRef name [ R_PAREN COMMA ]
parameter -> direction . typeRef name ASSIGN expression [ R_PAREN COMMA ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On typeRef shift to state 434
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 434:
## Known stack suffix:
## direction typeRef
## LR(1) items:
parameter -> direction typeRef . name [ R_PAREN COMMA ]
parameter -> direction typeRef . name ASSIGN expression [ R_PAREN COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 435
## Reductions:

State 435:
## Known stack suffix:
## direction typeRef name
## LR(1) items:
parameter -> direction typeRef name . [ R_PAREN COMMA ]
parameter -> direction typeRef name . ASSIGN expression [ R_PAREN COMMA ]
## Transitions:
-- On ASSIGN shift to state 436
## Reductions:
-- On R_PAREN COMMA
--   reduce production parameter -> direction typeRef name

State 436:
## Known stack suffix:
## direction typeRef name ASSIGN
## LR(1) items:
parameter -> direction typeRef name ASSIGN . expression [ R_PAREN COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 437
-- On dotPrefix shift to state 91
## Reductions:

State 437:
## Known stack suffix:
## direction typeRef name ASSIGN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
parameter -> direction typeRef name ASSIGN expression . [ R_PAREN COMMA ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On R_PAREN COMMA
--   reduce production parameter -> direction typeRef name ASSIGN expression

State 438:
## Known stack suffix:
## annotations
## LR(1) items:
parameter -> annotations . direction typeRef name [ R_PAREN COMMA ]
parameter -> annotations . direction typeRef name ASSIGN expression [ R_PAREN COMMA ]
## Transitions:
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On direction shift to state 439
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->

State 439:
## Known stack suffix:
## annotations direction
## LR(1) items:
parameter -> annotations direction . typeRef name [ R_PAREN COMMA ]
parameter -> annotations direction . typeRef name ASSIGN expression [ R_PAREN COMMA ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On typeRef shift to state 440
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 440:
## Known stack suffix:
## annotations direction typeRef
## LR(1) items:
parameter -> annotations direction typeRef . name [ R_PAREN COMMA ]
parameter -> annotations direction typeRef . name ASSIGN expression [ R_PAREN COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 441
## Reductions:

State 441:
## Known stack suffix:
## annotations direction typeRef name
## LR(1) items:
parameter -> annotations direction typeRef name . [ R_PAREN COMMA ]
parameter -> annotations direction typeRef name . ASSIGN expression [ R_PAREN COMMA ]
## Transitions:
-- On ASSIGN shift to state 442
## Reductions:
-- On R_PAREN COMMA
--   reduce production parameter -> annotations direction typeRef name

State 442:
## Known stack suffix:
## annotations direction typeRef name ASSIGN
## LR(1) items:
parameter -> annotations direction typeRef name ASSIGN . expression [ R_PAREN COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 443
-- On dotPrefix shift to state 91
## Reductions:

State 443:
## Known stack suffix:
## annotations direction typeRef name ASSIGN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
parameter -> annotations direction typeRef name ASSIGN expression . [ R_PAREN COMMA ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On R_PAREN COMMA
--   reduce production parameter -> annotations direction typeRef name ASSIGN expression

State 444:
## Known stack suffix:
## petr4_separated_list(COMMA,parameter)
## LR(1) items:
parameterList -> petr4_separated_list(COMMA,parameter) . [ R_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parameterList -> petr4_separated_list(COMMA,parameter)

State 445:
## Known stack suffix:
## PARSER push_name optTypeParameters L_PAREN parameterList
## LR(1) items:
parserTypeDeclaration -> PARSER push_name optTypeParameters L_PAREN parameterList . R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On R_PAREN shift to state 446
## Reductions:

State 446:
## Known stack suffix:
## PARSER push_name optTypeParameters L_PAREN parameterList R_PAREN
## LR(1) items:
parserTypeDeclaration -> PARSER push_name optTypeParameters L_PAREN parameterList R_PAREN . [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserTypeDeclaration -> PARSER push_name optTypeParameters L_PAREN parameterList R_PAREN

State 447:
## Known stack suffix:
## parameter
## LR(1) items:
separated_list_aux(COMMA,parameter) -> parameter . [ R_PAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_list_aux(COMMA,parameter) -> parameter

State 448:
## Known stack suffix:
## name
## LR(1) items:
push_name -> name . [ L_PAREN L_BRACE L_ANGLE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production push_name -> name

State 449:
## Known stack suffix:
## PACKAGE
## LR(1) items:
packageTypeDeclaration -> PACKAGE . push_name optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On push_name shift to state 450
-- On nonTypeName shift to state 35
-- On name shift to state 448
## Reductions:

State 450:
## Known stack suffix:
## PACKAGE push_name
## LR(1) items:
packageTypeDeclaration -> PACKAGE push_name . optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON ]
## Transitions:
-- On L_ANGLE shift to state 417
-- On optTypeParameters shift to state 451
## Reductions:
-- On L_PAREN
--   reduce production optTypeParameters ->

State 451:
## Known stack suffix:
## PACKAGE push_name optTypeParameters
## LR(1) items:
packageTypeDeclaration -> PACKAGE push_name optTypeParameters . L_PAREN parameterList R_PAREN [ SEMICOLON ]
## Transitions:
-- On L_PAREN shift to state 452
## Reductions:

State 452:
## Known stack suffix:
## PACKAGE push_name optTypeParameters L_PAREN
## LR(1) items:
packageTypeDeclaration -> PACKAGE push_name optTypeParameters L_PAREN . parameterList R_PAREN [ SEMICOLON ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On separated_list_aux(COMMA,parameter) shift to state 430
-- On petr4_separated_list(COMMA,parameter) shift to state 444
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameterList shift to state 453
-- On parameter shift to state 447
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,parameter) ->

State 453:
## Known stack suffix:
## PACKAGE push_name optTypeParameters L_PAREN parameterList
## LR(1) items:
packageTypeDeclaration -> PACKAGE push_name optTypeParameters L_PAREN parameterList . R_PAREN [ SEMICOLON ]
## Transitions:
-- On R_PAREN shift to state 454
## Reductions:

State 454:
## Known stack suffix:
## PACKAGE push_name optTypeParameters L_PAREN parameterList R_PAREN
## LR(1) items:
packageTypeDeclaration -> PACKAGE push_name optTypeParameters L_PAREN parameterList R_PAREN . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production packageTypeDeclaration -> PACKAGE push_name optTypeParameters L_PAREN parameterList R_PAREN

State 455:
## Known stack suffix:
## MATCH_KIND
## LR(1) items:
matchKindDeclaration -> MATCH_KIND . L_BRACE identifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On L_BRACE shift to state 456
## Reductions:

State 456:
## Known stack suffix:
## MATCH_KIND L_BRACE
## LR(1) items:
matchKindDeclaration -> MATCH_KIND L_BRACE . identifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On separated_nonempty_list_aux(COMMA,__anonymous_0) shift to state 361
-- On petr4_separated_nonempty_list(COMMA,__anonymous_0) shift to state 364
-- On nonTypeName shift to state 35
-- On name shift to state 365
-- On identifierList shift to state 457
## Reductions:

State 457:
## Known stack suffix:
## MATCH_KIND L_BRACE identifierList
## LR(1) items:
matchKindDeclaration -> MATCH_KIND L_BRACE identifierList . R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On R_BRACE shift to state 458
## Reductions:

State 458:
## Known stack suffix:
## MATCH_KIND L_BRACE identifierList R_BRACE
## LR(1) items:
matchKindDeclaration -> MATCH_KIND L_BRACE identifierList R_BRACE . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production matchKindDeclaration -> MATCH_KIND L_BRACE identifierList R_BRACE

State 459:
## Known stack suffix:
## EXTERN
## LR(1) items:
externDeclaration -> EXTERN . push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
externDeclaration -> EXTERN . functionPrototype pop_scope SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On VOID shift to state 1
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On NAME shift to state 11
-- On KEY shift to state 19
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 460
-- On typeRef shift to state 461
-- On typeOrVoid shift to state 462
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 140
-- On push_externName shift to state 469
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 505
-- On headerStackType shift to state 142
-- On functionPrototype shift to state 506
-- On externName shift to state 509
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 460:
## Known stack suffix:
## varName
## LR(1) items:
nonTypeName -> varName . [ L_PAREN L_BRACE L_ANGLE ]
typeOrVoid -> varName . [ TYPE STATE NAME KEY ENTRIES APPLY ACTIONS ]
## Transitions:
## Reductions:
-- On L_PAREN L_BRACE L_ANGLE
--   reduce production nonTypeName -> varName
-- On TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
--   reduce production typeOrVoid -> varName

State 461:
## Known stack suffix:
## typeRef
## LR(1) items:
typeOrVoid -> typeRef . [ TYPE STATE NAME KEY ENTRIES APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeOrVoid -> typeRef

State 462:
## Known stack suffix:
## typeOrVoid
## LR(1) items:
functionPrototype -> typeOrVoid . name push_scope optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON PRAGMA L_BRACE AT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 463
## Reductions:

State 463:
## Known stack suffix:
## typeOrVoid name
## LR(1) items:
functionPrototype -> typeOrVoid name . push_scope optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON PRAGMA L_BRACE AT ]
## Transitions:
-- On push_scope shift to state 464
## Default reduction:
-- After reading the next token, reduce production push_scope ->

State 464:
## Known stack suffix:
## typeOrVoid name push_scope
## LR(1) items:
functionPrototype -> typeOrVoid name push_scope . optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON PRAGMA L_BRACE AT ]
## Transitions:
-- On L_ANGLE shift to state 417
-- On optTypeParameters shift to state 465
## Reductions:
-- On L_PAREN
--   reduce production optTypeParameters ->

State 465:
## Known stack suffix:
## typeOrVoid name push_scope optTypeParameters
## LR(1) items:
functionPrototype -> typeOrVoid name push_scope optTypeParameters . L_PAREN parameterList R_PAREN [ SEMICOLON PRAGMA L_BRACE AT ]
## Transitions:
-- On L_PAREN shift to state 466
## Reductions:

State 466:
## Known stack suffix:
## typeOrVoid name push_scope optTypeParameters L_PAREN
## LR(1) items:
functionPrototype -> typeOrVoid name push_scope optTypeParameters L_PAREN . parameterList R_PAREN [ SEMICOLON PRAGMA L_BRACE AT ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On separated_list_aux(COMMA,parameter) shift to state 430
-- On petr4_separated_list(COMMA,parameter) shift to state 444
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameterList shift to state 467
-- On parameter shift to state 447
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,parameter) ->

State 467:
## Known stack suffix:
## typeOrVoid name push_scope optTypeParameters L_PAREN parameterList
## LR(1) items:
functionPrototype -> typeOrVoid name push_scope optTypeParameters L_PAREN parameterList . R_PAREN [ SEMICOLON PRAGMA L_BRACE AT ]
## Transitions:
-- On R_PAREN shift to state 468
## Reductions:

State 468:
## Known stack suffix:
## typeOrVoid name push_scope optTypeParameters L_PAREN parameterList R_PAREN
## LR(1) items:
functionPrototype -> typeOrVoid name push_scope optTypeParameters L_PAREN parameterList R_PAREN . [ SEMICOLON PRAGMA L_BRACE AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production functionPrototype -> typeOrVoid name push_scope optTypeParameters L_PAREN parameterList R_PAREN

State 469:
## Known stack suffix:
## EXTERN push_externName
## LR(1) items:
externDeclaration -> EXTERN push_externName . optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On L_ANGLE shift to state 417
-- On optTypeParameters shift to state 470
## Reductions:
-- On L_BRACE
--   reduce production optTypeParameters ->

State 470:
## Known stack suffix:
## EXTERN push_externName optTypeParameters
## LR(1) items:
externDeclaration -> EXTERN push_externName optTypeParameters . L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On L_BRACE shift to state 471
## Reductions:

State 471:
## Known stack suffix:
## EXTERN push_externName optTypeParameters L_BRACE
## LR(1) items:
externDeclaration -> EXTERN push_externName optTypeParameters L_BRACE . petr4_list(methodPrototype) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On petr4_list(methodPrototype) shift to state 472
-- On list_aux(methodPrototype) shift to state 475
## Default reduction:
-- After reading the next token, reduce production list_aux(methodPrototype) ->

State 472:
## Known stack suffix:
## EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype)
## LR(1) items:
externDeclaration -> EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) . R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On R_BRACE shift to state 473
## Reductions:

State 473:
## Known stack suffix:
## EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE
## LR(1) items:
externDeclaration -> EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE . pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On pop_scope shift to state 474
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 474:
## Known stack suffix:
## EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope
## LR(1) items:
externDeclaration -> EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production externDeclaration -> EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope

State 475:
## Known stack suffix:
## list_aux(methodPrototype)
## LR(1) items:
list_aux(methodPrototype) -> list_aux(methodPrototype) . methodPrototype [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
petr4_list(methodPrototype) -> list_aux(methodPrototype) . [ R_BRACE ]
## Transitions:
-- On VOID shift to state 1
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On PRAGMA shift to state 207
-- On NAME shift to state 476
-- On KEY shift to state 19
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On ABSTRACT shift to state 478
-- On varName shift to state 460
-- On typeRef shift to state 461
-- On typeOrVoid shift to state 462
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On nonTypeName shift to state 35
-- On name shift to state 483
-- On methodPrototype shift to state 488
-- On headerStackType shift to state 142
-- On functionPrototype shift to state 489
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
-- On annotations shift to state 492
-- On annotation shift to state 331
## Reductions:
-- On R_BRACE
--   reduce production petr4_list(methodPrototype) -> list_aux(methodPrototype)

State 476:
## Known stack suffix:
## NAME
## LR(1) items:
name -> NAME . TYPENAME [ L_PAREN ]
prefixedType -> NAME . TYPENAME [ TYPE STATE NAME L_BRACKET L_ANGLE KEY ENTRIES APPLY ACTIONS ]
varName -> NAME . IDENTIFIER [ TYPE STATE NAME L_PAREN KEY ENTRIES APPLY ACTIONS ]
## Transitions:
-- On TYPENAME shift to state 477
-- On IDENTIFIER shift to state 13
## Reductions:

State 477:
## Known stack suffix:
## NAME TYPENAME
## LR(1) items:
name -> NAME TYPENAME . [ L_PAREN ]
prefixedType -> NAME TYPENAME . [ TYPE STATE NAME L_BRACKET L_ANGLE KEY ENTRIES APPLY ACTIONS ]
## Transitions:
## Reductions:
-- On L_PAREN
--   reduce production name -> NAME TYPENAME
-- On TYPE STATE NAME L_BRACKET L_ANGLE KEY ENTRIES APPLY ACTIONS
--   reduce production prefixedType -> NAME TYPENAME

State 478:
## Known stack suffix:
## ABSTRACT
## LR(1) items:
methodPrototype -> ABSTRACT . functionPrototype pop_scope SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On VOID shift to state 1
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 11
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On varName shift to state 479
-- On typeRef shift to state 461
-- On typeOrVoid shift to state 462
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On functionPrototype shift to state 480
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 479:
## Known stack suffix:
## varName
## LR(1) items:
typeOrVoid -> varName . [ TYPE STATE NAME KEY ENTRIES APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeOrVoid -> varName

State 480:
## Known stack suffix:
## ABSTRACT functionPrototype
## LR(1) items:
methodPrototype -> ABSTRACT functionPrototype . pop_scope SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On pop_scope shift to state 481
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 481:
## Known stack suffix:
## ABSTRACT functionPrototype pop_scope
## LR(1) items:
methodPrototype -> ABSTRACT functionPrototype pop_scope . SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 482
## Reductions:

State 482:
## Known stack suffix:
## ABSTRACT functionPrototype pop_scope SEMICOLON
## LR(1) items:
methodPrototype -> ABSTRACT functionPrototype pop_scope SEMICOLON . [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production methodPrototype -> ABSTRACT functionPrototype pop_scope SEMICOLON

State 483:
## Known stack suffix:
## name
## LR(1) items:
methodPrototype -> name . L_PAREN parameterList R_PAREN SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On L_PAREN shift to state 484
## Reductions:

State 484:
## Known stack suffix:
## name L_PAREN
## LR(1) items:
methodPrototype -> name L_PAREN . parameterList R_PAREN SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On separated_list_aux(COMMA,parameter) shift to state 430
-- On petr4_separated_list(COMMA,parameter) shift to state 444
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameterList shift to state 485
-- On parameter shift to state 447
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,parameter) ->

State 485:
## Known stack suffix:
## name L_PAREN parameterList
## LR(1) items:
methodPrototype -> name L_PAREN parameterList . R_PAREN SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On R_PAREN shift to state 486
## Reductions:

State 486:
## Known stack suffix:
## name L_PAREN parameterList R_PAREN
## LR(1) items:
methodPrototype -> name L_PAREN parameterList R_PAREN . SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 487
## Reductions:

State 487:
## Known stack suffix:
## name L_PAREN parameterList R_PAREN SEMICOLON
## LR(1) items:
methodPrototype -> name L_PAREN parameterList R_PAREN SEMICOLON . [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production methodPrototype -> name L_PAREN parameterList R_PAREN SEMICOLON

State 488:
## Known stack suffix:
## list_aux(methodPrototype) methodPrototype
## LR(1) items:
list_aux(methodPrototype) -> list_aux(methodPrototype) methodPrototype . [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_aux(methodPrototype) -> list_aux(methodPrototype) methodPrototype

State 489:
## Known stack suffix:
## functionPrototype
## LR(1) items:
methodPrototype -> functionPrototype . pop_scope SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On pop_scope shift to state 490
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 490:
## Known stack suffix:
## functionPrototype pop_scope
## LR(1) items:
methodPrototype -> functionPrototype pop_scope . SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 491
## Reductions:

State 491:
## Known stack suffix:
## functionPrototype pop_scope SEMICOLON
## LR(1) items:
methodPrototype -> functionPrototype pop_scope SEMICOLON . [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production methodPrototype -> functionPrototype pop_scope SEMICOLON

State 492:
## Known stack suffix:
## annotations
## LR(1) items:
methodPrototype -> annotations . functionPrototype pop_scope SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
methodPrototype -> annotations . ABSTRACT functionPrototype pop_scope SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
methodPrototype -> annotations . name L_PAREN parameterList R_PAREN SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On VOID shift to state 1
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On NAME shift to state 476
-- On KEY shift to state 19
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On ABSTRACT shift to state 493
-- On varName shift to state 460
-- On typeRef shift to state 461
-- On typeOrVoid shift to state 462
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 35
-- On name shift to state 497
-- On headerStackType shift to state 142
-- On functionPrototype shift to state 502
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 493:
## Known stack suffix:
## annotations ABSTRACT
## LR(1) items:
methodPrototype -> annotations ABSTRACT . functionPrototype pop_scope SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On VOID shift to state 1
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 11
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On varName shift to state 479
-- On typeRef shift to state 461
-- On typeOrVoid shift to state 462
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On functionPrototype shift to state 494
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 494:
## Known stack suffix:
## annotations ABSTRACT functionPrototype
## LR(1) items:
methodPrototype -> annotations ABSTRACT functionPrototype . pop_scope SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On pop_scope shift to state 495
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 495:
## Known stack suffix:
## annotations ABSTRACT functionPrototype pop_scope
## LR(1) items:
methodPrototype -> annotations ABSTRACT functionPrototype pop_scope . SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 496
## Reductions:

State 496:
## Known stack suffix:
## annotations ABSTRACT functionPrototype pop_scope SEMICOLON
## LR(1) items:
methodPrototype -> annotations ABSTRACT functionPrototype pop_scope SEMICOLON . [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production methodPrototype -> annotations ABSTRACT functionPrototype pop_scope SEMICOLON

State 497:
## Known stack suffix:
## annotations name
## LR(1) items:
methodPrototype -> annotations name . L_PAREN parameterList R_PAREN SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On L_PAREN shift to state 498
## Reductions:

State 498:
## Known stack suffix:
## annotations name L_PAREN
## LR(1) items:
methodPrototype -> annotations name L_PAREN . parameterList R_PAREN SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On separated_list_aux(COMMA,parameter) shift to state 430
-- On petr4_separated_list(COMMA,parameter) shift to state 444
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameterList shift to state 499
-- On parameter shift to state 447
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,parameter) ->

State 499:
## Known stack suffix:
## annotations name L_PAREN parameterList
## LR(1) items:
methodPrototype -> annotations name L_PAREN parameterList . R_PAREN SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On R_PAREN shift to state 500
## Reductions:

State 500:
## Known stack suffix:
## annotations name L_PAREN parameterList R_PAREN
## LR(1) items:
methodPrototype -> annotations name L_PAREN parameterList R_PAREN . SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 501
## Reductions:

State 501:
## Known stack suffix:
## annotations name L_PAREN parameterList R_PAREN SEMICOLON
## LR(1) items:
methodPrototype -> annotations name L_PAREN parameterList R_PAREN SEMICOLON . [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production methodPrototype -> annotations name L_PAREN parameterList R_PAREN SEMICOLON

State 502:
## Known stack suffix:
## annotations functionPrototype
## LR(1) items:
methodPrototype -> annotations functionPrototype . pop_scope SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On pop_scope shift to state 503
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 503:
## Known stack suffix:
## annotations functionPrototype pop_scope
## LR(1) items:
methodPrototype -> annotations functionPrototype pop_scope . SEMICOLON [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
-- On SEMICOLON shift to state 504
## Reductions:

State 504:
## Known stack suffix:
## annotations functionPrototype pop_scope SEMICOLON
## LR(1) items:
methodPrototype -> annotations functionPrototype pop_scope SEMICOLON . [ VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production methodPrototype -> annotations functionPrototype pop_scope SEMICOLON

State 505:
## Known stack suffix:
## nonTypeName
## LR(1) items:
externName -> nonTypeName . [ L_BRACE L_ANGLE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production externName -> nonTypeName

State 506:
## Known stack suffix:
## EXTERN functionPrototype
## LR(1) items:
externDeclaration -> EXTERN functionPrototype . pop_scope SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On pop_scope shift to state 507
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 507:
## Known stack suffix:
## EXTERN functionPrototype pop_scope
## LR(1) items:
externDeclaration -> EXTERN functionPrototype pop_scope . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 508
## Reductions:

State 508:
## Known stack suffix:
## EXTERN functionPrototype pop_scope SEMICOLON
## LR(1) items:
externDeclaration -> EXTERN functionPrototype pop_scope SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production externDeclaration -> EXTERN functionPrototype pop_scope SEMICOLON

State 509:
## Known stack suffix:
## externName
## LR(1) items:
push_externName -> externName . [ L_BRACE L_ANGLE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production push_externName -> externName

State 510:
## Known stack suffix:
## ERROR
## LR(1) items:
baseType -> ERROR . [ TYPE STATE NAME L_PAREN KEY ENTRIES APPLY ACTIONS ]
errorDeclaration -> ERROR . L_BRACE identifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On L_BRACE shift to state 511
## Reductions:
-- On TYPE STATE NAME L_PAREN KEY ENTRIES APPLY ACTIONS
--   reduce production baseType -> ERROR

State 511:
## Known stack suffix:
## ERROR L_BRACE
## LR(1) items:
errorDeclaration -> ERROR L_BRACE . identifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On separated_nonempty_list_aux(COMMA,__anonymous_0) shift to state 361
-- On petr4_separated_nonempty_list(COMMA,__anonymous_0) shift to state 364
-- On nonTypeName shift to state 35
-- On name shift to state 365
-- On identifierList shift to state 512
## Reductions:

State 512:
## Known stack suffix:
## ERROR L_BRACE identifierList
## LR(1) items:
errorDeclaration -> ERROR L_BRACE identifierList . R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On R_BRACE shift to state 513
## Reductions:

State 513:
## Known stack suffix:
## ERROR L_BRACE identifierList R_BRACE
## LR(1) items:
errorDeclaration -> ERROR L_BRACE identifierList R_BRACE . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production errorDeclaration -> ERROR L_BRACE identifierList R_BRACE

State 514:
## Known stack suffix:
## CONTROL
## LR(1) items:
controlTypeDeclaration -> CONTROL . push_name optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On push_name shift to state 515
-- On nonTypeName shift to state 35
-- On name shift to state 448
## Reductions:

State 515:
## Known stack suffix:
## CONTROL push_name
## LR(1) items:
controlTypeDeclaration -> CONTROL push_name . optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On L_ANGLE shift to state 417
-- On optTypeParameters shift to state 516
## Reductions:
-- On L_PAREN
--   reduce production optTypeParameters ->

State 516:
## Known stack suffix:
## CONTROL push_name optTypeParameters
## LR(1) items:
controlTypeDeclaration -> CONTROL push_name optTypeParameters . L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On L_PAREN shift to state 517
## Reductions:

State 517:
## Known stack suffix:
## CONTROL push_name optTypeParameters L_PAREN
## LR(1) items:
controlTypeDeclaration -> CONTROL push_name optTypeParameters L_PAREN . parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On separated_list_aux(COMMA,parameter) shift to state 430
-- On petr4_separated_list(COMMA,parameter) shift to state 444
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameterList shift to state 518
-- On parameter shift to state 447
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,parameter) ->

State 518:
## Known stack suffix:
## CONTROL push_name optTypeParameters L_PAREN parameterList
## LR(1) items:
controlTypeDeclaration -> CONTROL push_name optTypeParameters L_PAREN parameterList . R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On R_PAREN shift to state 519
## Reductions:

State 519:
## Known stack suffix:
## CONTROL push_name optTypeParameters L_PAREN parameterList R_PAREN
## LR(1) items:
controlTypeDeclaration -> CONTROL push_name optTypeParameters L_PAREN parameterList R_PAREN . [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production controlTypeDeclaration -> CONTROL push_name optTypeParameters L_PAREN parameterList R_PAREN

State 520:
## Known stack suffix:
## CONST
## LR(1) items:
constantDeclaration -> CONST . typeRef name ASSIGN initialValue SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On typeRef shift to state 521
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 521:
## Known stack suffix:
## CONST typeRef
## LR(1) items:
constantDeclaration -> CONST typeRef . name ASSIGN initialValue SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 522
## Reductions:

State 522:
## Known stack suffix:
## CONST typeRef name
## LR(1) items:
constantDeclaration -> CONST typeRef name . ASSIGN initialValue SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On ASSIGN shift to state 523
## Reductions:

State 523:
## Known stack suffix:
## CONST typeRef name ASSIGN
## LR(1) items:
constantDeclaration -> CONST typeRef name ASSIGN . initialValue SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On initialValue shift to state 524
-- On expression shift to state 526
-- On dotPrefix shift to state 91
## Reductions:

State 524:
## Known stack suffix:
## CONST typeRef name ASSIGN initialValue
## LR(1) items:
constantDeclaration -> CONST typeRef name ASSIGN initialValue . SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On SEMICOLON shift to state 525
## Reductions:

State 525:
## Known stack suffix:
## CONST typeRef name ASSIGN initialValue SEMICOLON
## LR(1) items:
constantDeclaration -> CONST typeRef name ASSIGN initialValue SEMICOLON . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constantDeclaration -> CONST typeRef name ASSIGN initialValue SEMICOLON

State 526:
## Known stack suffix:
## expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
initialValue -> expression . [ SEMICOLON ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On SEMICOLON
--   reduce production initialValue -> expression

State 527:
## Known stack suffix:
## ACTION
## LR(1) items:
actionDeclaration -> ACTION . name L_PAREN parameterList R_PAREN blockStatement [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 528
## Reductions:

State 528:
## Known stack suffix:
## ACTION name
## LR(1) items:
actionDeclaration -> ACTION name . L_PAREN parameterList R_PAREN blockStatement [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On L_PAREN shift to state 529
## Reductions:

State 529:
## Known stack suffix:
## ACTION name L_PAREN
## LR(1) items:
actionDeclaration -> ACTION name L_PAREN . parameterList R_PAREN blockStatement [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On separated_list_aux(COMMA,parameter) shift to state 430
-- On petr4_separated_list(COMMA,parameter) shift to state 444
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameterList shift to state 530
-- On parameter shift to state 447
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,parameter) ->

State 530:
## Known stack suffix:
## ACTION name L_PAREN parameterList
## LR(1) items:
actionDeclaration -> ACTION name L_PAREN parameterList . R_PAREN blockStatement [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On R_PAREN shift to state 531
## Reductions:

State 531:
## Known stack suffix:
## ACTION name L_PAREN parameterList R_PAREN
## LR(1) items:
actionDeclaration -> ACTION name L_PAREN parameterList R_PAREN . blockStatement [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On PRAGMA shift to state 207
-- On L_BRACE shift to state 532
-- On AT shift to state 302
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On blockStatement shift to state 670
-- On annotations shift to state 551
-- On annotation shift to state 331
## Reductions:

State 532:
## Known stack suffix:
## L_BRACE
## LR(1) items:
blockStatement -> L_BRACE . push_scope petr4_list(statementOrDeclaration) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On push_scope shift to state 533
## Default reduction:
-- After reading the next token, reduce production push_scope ->

State 533:
## Known stack suffix:
## L_BRACE push_scope
## LR(1) items:
blockStatement -> L_BRACE push_scope . petr4_list(statementOrDeclaration) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On petr4_list(statementOrDeclaration) shift to state 534
-- On list_aux(statementOrDeclaration) shift to state 537
## Default reduction:
-- After reading the next token, reduce production list_aux(statementOrDeclaration) ->

State 534:
## Known stack suffix:
## L_BRACE push_scope petr4_list(statementOrDeclaration)
## LR(1) items:
blockStatement -> L_BRACE push_scope petr4_list(statementOrDeclaration) . R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_BRACE shift to state 535
## Reductions:

State 535:
## Known stack suffix:
## L_BRACE push_scope petr4_list(statementOrDeclaration) R_BRACE
## LR(1) items:
blockStatement -> L_BRACE push_scope petr4_list(statementOrDeclaration) R_BRACE . pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On pop_scope shift to state 536
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 536:
## Known stack suffix:
## L_BRACE push_scope petr4_list(statementOrDeclaration) R_BRACE pop_scope
## LR(1) items:
blockStatement -> L_BRACE push_scope petr4_list(statementOrDeclaration) R_BRACE pop_scope . [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production blockStatement -> L_BRACE push_scope petr4_list(statementOrDeclaration) R_BRACE pop_scope

State 537:
## Known stack suffix:
## list_aux(statementOrDeclaration)
## LR(1) items:
list_aux(statementOrDeclaration) -> list_aux(statementOrDeclaration) . statementOrDeclaration [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
petr4_list(statementOrDeclaration) -> list_aux(statementOrDeclaration) . [ R_BRACE ]
## Transitions:
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On SWITCH shift to state 538
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On SEMICOLON shift to state 559
-- On RETURN shift to state 560
-- On PRAGMA shift to state 207
-- On NAME shift to state 11
-- On L_BRACE shift to state 532
-- On KEY shift to state 19
-- On INT shift to state 20
-- On IF shift to state 564
-- On EXIT shift to state 568
-- On ERROR shift to state 46
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On CONST shift to state 520
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On variableDeclaration shift to state 618
-- On varName shift to state 33
-- On typeRef shift to state 619
-- On typeName shift to state 654
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On switchStatement shift to state 577
-- On statementOrDeclaration shift to state 655
-- On statement shift to state 656
-- On specializedType shift to state 140
-- On returnStatement shift to state 581
-- On prefixedType shift to state 44
-- On prefixedNonTypeName shift to state 583
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On nonTypeName shift to state 584
-- On lvalue shift to state 585
-- On instantiation shift to state 657
-- On headerStackType shift to state 142
-- On exitStatement shift to state 608
-- On emptyStatement shift to state 609
-- On dotPrefix shift to state 610
-- On directApplication shift to state 614
-- On constantDeclaration shift to state 658
-- On conditionalStatement shift to state 615
-- On blockStatement shift to state 616
-- On baseType shift to state 146
-- On assignmentOrMethodCallStatement shift to state 617
-- On annotations shift to state 659
-- On annotation shift to state 331
## Reductions:
-- On R_BRACE
--   reduce production petr4_list(statementOrDeclaration) -> list_aux(statementOrDeclaration)

State 538:
## Known stack suffix:
## SWITCH
## LR(1) items:
switchStatement -> SWITCH . L_PAREN expression R_PAREN L_BRACE switchCases R_BRACE [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On L_PAREN shift to state 539
## Reductions:

State 539:
## Known stack suffix:
## SWITCH L_PAREN
## LR(1) items:
switchStatement -> SWITCH L_PAREN . expression R_PAREN L_BRACE switchCases R_BRACE [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 540
-- On dotPrefix shift to state 91
## Reductions:

State 540:
## Known stack suffix:
## SWITCH L_PAREN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
switchStatement -> SWITCH L_PAREN expression . R_PAREN L_BRACE switchCases R_BRACE [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 541
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 541:
## Known stack suffix:
## SWITCH L_PAREN expression R_PAREN
## LR(1) items:
switchStatement -> SWITCH L_PAREN expression R_PAREN . L_BRACE switchCases R_BRACE [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On L_BRACE shift to state 542
## Reductions:

State 542:
## Known stack suffix:
## SWITCH L_PAREN expression R_PAREN L_BRACE
## LR(1) items:
switchStatement -> SWITCH L_PAREN expression R_PAREN L_BRACE . switchCases R_BRACE [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On switchCases shift to state 543
-- On petr4_list(switchCase) shift to state 545
-- On list_aux(switchCase) shift to state 546
## Default reduction:
-- After reading the next token, reduce production list_aux(switchCase) ->

State 543:
## Known stack suffix:
## SWITCH L_PAREN expression R_PAREN L_BRACE switchCases
## LR(1) items:
switchStatement -> SWITCH L_PAREN expression R_PAREN L_BRACE switchCases . R_BRACE [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On R_BRACE shift to state 544
## Reductions:

State 544:
## Known stack suffix:
## SWITCH L_PAREN expression R_PAREN L_BRACE switchCases R_BRACE
## LR(1) items:
switchStatement -> SWITCH L_PAREN expression R_PAREN L_BRACE switchCases R_BRACE . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switchStatement -> SWITCH L_PAREN expression R_PAREN L_BRACE switchCases R_BRACE

State 545:
## Known stack suffix:
## petr4_list(switchCase)
## LR(1) items:
switchCases -> petr4_list(switchCase) . [ R_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switchCases -> petr4_list(switchCase)

State 546:
## Known stack suffix:
## list_aux(switchCase)
## LR(1) items:
list_aux(switchCase) -> list_aux(switchCase) . switchCase [ TYPE STATE R_BRACE NAME KEY ENTRIES DEFAULT APPLY ACTIONS ]
petr4_list(switchCase) -> list_aux(switchCase) . [ R_BRACE ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On DEFAULT shift to state 547
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On switchLabel shift to state 548
-- On switchCase shift to state 557
-- On nonTypeName shift to state 35
-- On name shift to state 558
## Reductions:
-- On R_BRACE
--   reduce production petr4_list(switchCase) -> list_aux(switchCase)

State 547:
## Known stack suffix:
## DEFAULT
## LR(1) items:
switchLabel -> DEFAULT . [ COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switchLabel -> DEFAULT

State 548:
## Known stack suffix:
## switchLabel
## LR(1) items:
switchCase -> switchLabel . COLON blockStatement [ TYPE STATE R_BRACE NAME KEY ENTRIES DEFAULT APPLY ACTIONS ]
switchCase -> switchLabel . COLON [ TYPE STATE R_BRACE NAME KEY ENTRIES DEFAULT APPLY ACTIONS ]
## Transitions:
-- On COLON shift to state 549
## Reductions:

State 549:
## Known stack suffix:
## switchLabel COLON
## LR(1) items:
switchCase -> switchLabel COLON . blockStatement [ TYPE STATE R_BRACE NAME KEY ENTRIES DEFAULT APPLY ACTIONS ]
switchCase -> switchLabel COLON . [ TYPE STATE R_BRACE NAME KEY ENTRIES DEFAULT APPLY ACTIONS ]
## Transitions:
-- On PRAGMA shift to state 207
-- On L_BRACE shift to state 532
-- On AT shift to state 302
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On blockStatement shift to state 550
-- On annotations shift to state 551
-- On annotation shift to state 331
## Reductions:
-- On TYPE STATE R_BRACE NAME KEY ENTRIES DEFAULT APPLY ACTIONS
--   reduce production switchCase -> switchLabel COLON

State 550:
## Known stack suffix:
## switchLabel COLON blockStatement
## LR(1) items:
switchCase -> switchLabel COLON blockStatement . [ TYPE STATE R_BRACE NAME KEY ENTRIES DEFAULT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switchCase -> switchLabel COLON blockStatement

State 551:
## Known stack suffix:
## annotations
## LR(1) items:
blockStatement -> annotations . L_BRACE push_scope petr4_list(statementOrDeclaration) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 552
## Reductions:

State 552:
## Known stack suffix:
## annotations L_BRACE
## LR(1) items:
blockStatement -> annotations L_BRACE . push_scope petr4_list(statementOrDeclaration) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On push_scope shift to state 553
## Default reduction:
-- After reading the next token, reduce production push_scope ->

State 553:
## Known stack suffix:
## annotations L_BRACE push_scope
## LR(1) items:
blockStatement -> annotations L_BRACE push_scope . petr4_list(statementOrDeclaration) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On petr4_list(statementOrDeclaration) shift to state 554
-- On list_aux(statementOrDeclaration) shift to state 537
## Default reduction:
-- After reading the next token, reduce production list_aux(statementOrDeclaration) ->

State 554:
## Known stack suffix:
## annotations L_BRACE push_scope petr4_list(statementOrDeclaration)
## LR(1) items:
blockStatement -> annotations L_BRACE push_scope petr4_list(statementOrDeclaration) . R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_BRACE shift to state 555
## Reductions:

State 555:
## Known stack suffix:
## annotations L_BRACE push_scope petr4_list(statementOrDeclaration) R_BRACE
## LR(1) items:
blockStatement -> annotations L_BRACE push_scope petr4_list(statementOrDeclaration) R_BRACE . pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On pop_scope shift to state 556
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 556:
## Known stack suffix:
## annotations L_BRACE push_scope petr4_list(statementOrDeclaration) R_BRACE pop_scope
## LR(1) items:
blockStatement -> annotations L_BRACE push_scope petr4_list(statementOrDeclaration) R_BRACE pop_scope . [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production blockStatement -> annotations L_BRACE push_scope petr4_list(statementOrDeclaration) R_BRACE pop_scope

State 557:
## Known stack suffix:
## list_aux(switchCase) switchCase
## LR(1) items:
list_aux(switchCase) -> list_aux(switchCase) switchCase . [ TYPE STATE R_BRACE NAME KEY ENTRIES DEFAULT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_aux(switchCase) -> list_aux(switchCase) switchCase

State 558:
## Known stack suffix:
## name
## LR(1) items:
switchLabel -> name . [ COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production switchLabel -> name

State 559:
## Known stack suffix:
## SEMICOLON
## LR(1) items:
emptyStatement -> SEMICOLON . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production emptyStatement -> SEMICOLON

State 560:
## Known stack suffix:
## RETURN
## LR(1) items:
returnStatement -> RETURN . SEMICOLON [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
returnStatement -> RETURN . expression SEMICOLON [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On SEMICOLON shift to state 561
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 562
-- On dotPrefix shift to state 91
## Reductions:

State 561:
## Known stack suffix:
## RETURN SEMICOLON
## LR(1) items:
returnStatement -> RETURN SEMICOLON . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production returnStatement -> RETURN SEMICOLON

State 562:
## Known stack suffix:
## RETURN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
returnStatement -> RETURN expression . SEMICOLON [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On SHL shift to state 64
-- On SEMICOLON shift to state 563
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 563:
## Known stack suffix:
## RETURN expression SEMICOLON
## LR(1) items:
returnStatement -> RETURN expression SEMICOLON . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production returnStatement -> RETURN expression SEMICOLON

State 564:
## Known stack suffix:
## IF
## LR(1) items:
conditionalStatement -> IF . L_PAREN expression R_PAREN statement ELSE statement [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
conditionalStatement -> IF . L_PAREN expression R_PAREN statement [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On L_PAREN shift to state 565
## Reductions:

State 565:
## Known stack suffix:
## IF L_PAREN
## LR(1) items:
conditionalStatement -> IF L_PAREN . expression R_PAREN statement ELSE statement [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
conditionalStatement -> IF L_PAREN . expression R_PAREN statement [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 566
-- On dotPrefix shift to state 91
## Reductions:

State 566:
## Known stack suffix:
## IF L_PAREN expression
## LR(1) items:
conditionalStatement -> IF L_PAREN expression . R_PAREN statement ELSE statement [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
conditionalStatement -> IF L_PAREN expression . R_PAREN statement [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 567
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 567:
## Known stack suffix:
## IF L_PAREN expression R_PAREN
## LR(1) items:
conditionalStatement -> IF L_PAREN expression R_PAREN . statement ELSE statement [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
conditionalStatement -> IF L_PAREN expression R_PAREN . statement [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On SWITCH shift to state 538
-- On STATE shift to state 8
-- On SEMICOLON shift to state 559
-- On RETURN shift to state 560
-- On PRAGMA shift to state 207
-- On NAME shift to state 11
-- On L_BRACE shift to state 532
-- On KEY shift to state 19
-- On IF shift to state 564
-- On EXIT shift to state 568
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On AT shift to state 302
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 570
-- On tableKwName shift to state 34
-- On switchStatement shift to state 577
-- On statement shift to state 578
-- On returnStatement shift to state 581
-- On prefixedType shift to state 582
-- On prefixedNonTypeName shift to state 583
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On nonTypeName shift to state 584
-- On lvalue shift to state 585
-- On exitStatement shift to state 608
-- On emptyStatement shift to state 609
-- On dotPrefix shift to state 610
-- On directApplication shift to state 614
-- On conditionalStatement shift to state 615
-- On blockStatement shift to state 616
-- On assignmentOrMethodCallStatement shift to state 617
-- On annotations shift to state 551
-- On annotation shift to state 331
## Reductions:

State 568:
## Known stack suffix:
## EXIT
## LR(1) items:
exitStatement -> EXIT . SEMICOLON [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 569
## Reductions:

State 569:
## Known stack suffix:
## EXIT SEMICOLON
## LR(1) items:
exitStatement -> EXIT SEMICOLON . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production exitStatement -> EXIT SEMICOLON

State 570:
## Known stack suffix:
## typeName
## LR(1) items:
directApplication -> typeName . DOT APPLY L_PAREN argumentList R_PAREN SEMICOLON [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On DOT shift to state 571
## Reductions:

State 571:
## Known stack suffix:
## typeName DOT
## LR(1) items:
directApplication -> typeName DOT . APPLY L_PAREN argumentList R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On APPLY shift to state 572
## Reductions:

State 572:
## Known stack suffix:
## typeName DOT APPLY
## LR(1) items:
directApplication -> typeName DOT APPLY . L_PAREN argumentList R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On L_PAREN shift to state 573
## Reductions:

State 573:
## Known stack suffix:
## typeName DOT APPLY L_PAREN
## LR(1) items:
directApplication -> typeName DOT APPLY L_PAREN . argumentList R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 55
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 57
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_list_aux(COMMA,argument) shift to state 58
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,argument) shift to state 71
-- On nonTypeName shift to state 60
-- On namedType shift to state 53
-- On name shift to state 61
-- On expression shift to state 72
-- On dotPrefix shift to state 91
-- On argumentList shift to state 574
-- On argument shift to state 135
## Reductions:
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,argument) ->

State 574:
## Known stack suffix:
## typeName DOT APPLY L_PAREN argumentList
## LR(1) items:
directApplication -> typeName DOT APPLY L_PAREN argumentList . R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On R_PAREN shift to state 575
## Reductions:

State 575:
## Known stack suffix:
## typeName DOT APPLY L_PAREN argumentList R_PAREN
## LR(1) items:
directApplication -> typeName DOT APPLY L_PAREN argumentList R_PAREN . SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 576
## Reductions:

State 576:
## Known stack suffix:
## typeName DOT APPLY L_PAREN argumentList R_PAREN SEMICOLON
## LR(1) items:
directApplication -> typeName DOT APPLY L_PAREN argumentList R_PAREN SEMICOLON . [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production directApplication -> typeName DOT APPLY L_PAREN argumentList R_PAREN SEMICOLON

State 577:
## Known stack suffix:
## switchStatement
## LR(1) items:
statement -> switchStatement . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> switchStatement

State 578:
## Known stack suffix:
## IF L_PAREN expression R_PAREN statement
## LR(1) items:
conditionalStatement -> IF L_PAREN expression R_PAREN statement . ELSE statement [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
conditionalStatement -> IF L_PAREN expression R_PAREN statement . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On ELSE shift to state 579
## Reductions:
-- On VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
--   reduce production conditionalStatement -> IF L_PAREN expression R_PAREN statement

State 579:
## Known stack suffix:
## IF L_PAREN expression R_PAREN statement ELSE
## LR(1) items:
conditionalStatement -> IF L_PAREN expression R_PAREN statement ELSE . statement [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On SWITCH shift to state 538
-- On STATE shift to state 8
-- On SEMICOLON shift to state 559
-- On RETURN shift to state 560
-- On PRAGMA shift to state 207
-- On NAME shift to state 11
-- On L_BRACE shift to state 532
-- On KEY shift to state 19
-- On IF shift to state 564
-- On EXIT shift to state 568
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On AT shift to state 302
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 570
-- On tableKwName shift to state 34
-- On switchStatement shift to state 577
-- On statement shift to state 580
-- On returnStatement shift to state 581
-- On prefixedType shift to state 582
-- On prefixedNonTypeName shift to state 583
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On nonTypeName shift to state 584
-- On lvalue shift to state 585
-- On exitStatement shift to state 608
-- On emptyStatement shift to state 609
-- On dotPrefix shift to state 610
-- On directApplication shift to state 614
-- On conditionalStatement shift to state 615
-- On blockStatement shift to state 616
-- On assignmentOrMethodCallStatement shift to state 617
-- On annotations shift to state 551
-- On annotation shift to state 331
## Reductions:

State 580:
## Known stack suffix:
## IF L_PAREN expression R_PAREN statement ELSE statement
## LR(1) items:
conditionalStatement -> IF L_PAREN expression R_PAREN statement ELSE statement . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production conditionalStatement -> IF L_PAREN expression R_PAREN statement ELSE statement

State 581:
## Known stack suffix:
## returnStatement
## LR(1) items:
statement -> returnStatement . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> returnStatement

State 582:
## Known stack suffix:
## prefixedType
## LR(1) items:
typeName -> prefixedType . [ R_ANGLE DOT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeName -> prefixedType

State 583:
## Known stack suffix:
## prefixedNonTypeName
## LR(1) items:
lvalue -> prefixedNonTypeName . [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lvalue -> prefixedNonTypeName

State 584:
## Known stack suffix:
## nonTypeName
## LR(1) items:
prefixedNonTypeName -> nonTypeName . [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production prefixedNonTypeName -> nonTypeName

State 585:
## Known stack suffix:
## lvalue
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue . L_PAREN argumentList R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
assignmentOrMethodCallStatement -> lvalue . L_ANGLE typeArgumentList R_ANGLE L_PAREN argumentList R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
assignmentOrMethodCallStatement -> lvalue . ASSIGN expression SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
lvalue -> lvalue . DOT member [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
lvalue -> lvalue . L_BRACKET expression R_BRACKET [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
lvalue -> lvalue . L_BRACKET expression COLON expression R_BRACKET [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
-- On L_PAREN shift to state 586
-- On L_BRACKET shift to state 590
-- On L_ANGLE shift to state 596
-- On DOT shift to state 603
-- On ASSIGN shift to state 605
## Reductions:

State 586:
## Known stack suffix:
## lvalue L_PAREN
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue L_PAREN . argumentList R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 55
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 57
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_list_aux(COMMA,argument) shift to state 58
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,argument) shift to state 71
-- On nonTypeName shift to state 60
-- On namedType shift to state 53
-- On name shift to state 61
-- On expression shift to state 72
-- On dotPrefix shift to state 91
-- On argumentList shift to state 587
-- On argument shift to state 135
## Reductions:
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,argument) ->

State 587:
## Known stack suffix:
## lvalue L_PAREN argumentList
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue L_PAREN argumentList . R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On R_PAREN shift to state 588
## Reductions:

State 588:
## Known stack suffix:
## lvalue L_PAREN argumentList R_PAREN
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue L_PAREN argumentList R_PAREN . SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 589
## Reductions:

State 589:
## Known stack suffix:
## lvalue L_PAREN argumentList R_PAREN SEMICOLON
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue L_PAREN argumentList R_PAREN SEMICOLON . [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignmentOrMethodCallStatement -> lvalue L_PAREN argumentList R_PAREN SEMICOLON

State 590:
## Known stack suffix:
## lvalue L_BRACKET
## LR(1) items:
lvalue -> lvalue L_BRACKET . expression R_BRACKET [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
lvalue -> lvalue L_BRACKET . expression COLON expression R_BRACKET [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 591
-- On dotPrefix shift to state 91
## Reductions:

State 591:
## Known stack suffix:
## lvalue L_BRACKET expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
lvalue -> lvalue L_BRACKET expression . R_BRACKET [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
lvalue -> lvalue L_BRACKET expression . COLON expression R_BRACKET [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
-- On SHL shift to state 64
-- On R_BRACKET shift to state 592
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On COLON shift to state 593
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 592:
## Known stack suffix:
## lvalue L_BRACKET expression R_BRACKET
## LR(1) items:
lvalue -> lvalue L_BRACKET expression R_BRACKET . [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lvalue -> lvalue L_BRACKET expression R_BRACKET

State 593:
## Known stack suffix:
## lvalue L_BRACKET expression COLON
## LR(1) items:
lvalue -> lvalue L_BRACKET expression COLON . expression R_BRACKET [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 594
-- On dotPrefix shift to state 91
## Reductions:

State 594:
## Known stack suffix:
## lvalue L_BRACKET expression COLON expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_BRACKET R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
lvalue -> lvalue L_BRACKET expression COLON expression . R_BRACKET [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
-- On SHL shift to state 64
-- On R_BRACKET shift to state 595
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 595:
## Known stack suffix:
## lvalue L_BRACKET expression COLON expression R_BRACKET
## LR(1) items:
lvalue -> lvalue L_BRACKET expression COLON expression R_BRACKET . [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lvalue -> lvalue L_BRACKET expression COLON expression R_BRACKET

State 596:
## Known stack suffix:
## lvalue L_ANGLE
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue L_ANGLE . typeArgumentList R_ANGLE L_PAREN argumentList R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On NAME shift to state 11
-- On KEY shift to state 19
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 47
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeRef shift to state 137
-- On typeName shift to state 138
-- On typeArgumentList shift to state 597
-- On typeArg shift to state 167
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 140
-- On separated_list_aux(COMMA,typeArg) shift to state 168
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,typeArg) shift to state 171
-- On nonTypeName shift to state 141
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:
-- On R_ANGLE COMMA
--   reduce production separated_list_aux(COMMA,typeArg) ->

State 597:
## Known stack suffix:
## lvalue L_ANGLE typeArgumentList
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue L_ANGLE typeArgumentList . R_ANGLE L_PAREN argumentList R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On R_ANGLE shift to state 598
## Reductions:

State 598:
## Known stack suffix:
## lvalue L_ANGLE typeArgumentList R_ANGLE
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue L_ANGLE typeArgumentList R_ANGLE . L_PAREN argumentList R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On L_PAREN shift to state 599
## Reductions:

State 599:
## Known stack suffix:
## lvalue L_ANGLE typeArgumentList R_ANGLE L_PAREN
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue L_ANGLE typeArgumentList R_ANGLE L_PAREN . argumentList R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 55
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 57
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_list_aux(COMMA,argument) shift to state 58
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,argument) shift to state 71
-- On nonTypeName shift to state 60
-- On namedType shift to state 53
-- On name shift to state 61
-- On expression shift to state 72
-- On dotPrefix shift to state 91
-- On argumentList shift to state 600
-- On argument shift to state 135
## Reductions:
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,argument) ->

State 600:
## Known stack suffix:
## lvalue L_ANGLE typeArgumentList R_ANGLE L_PAREN argumentList
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue L_ANGLE typeArgumentList R_ANGLE L_PAREN argumentList . R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On R_PAREN shift to state 601
## Reductions:

State 601:
## Known stack suffix:
## lvalue L_ANGLE typeArgumentList R_ANGLE L_PAREN argumentList R_PAREN
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue L_ANGLE typeArgumentList R_ANGLE L_PAREN argumentList R_PAREN . SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 602
## Reductions:

State 602:
## Known stack suffix:
## lvalue L_ANGLE typeArgumentList R_ANGLE L_PAREN argumentList R_PAREN SEMICOLON
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue L_ANGLE typeArgumentList R_ANGLE L_PAREN argumentList R_PAREN SEMICOLON . [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignmentOrMethodCallStatement -> lvalue L_ANGLE typeArgumentList R_ANGLE L_PAREN argumentList R_PAREN SEMICOLON

State 603:
## Known stack suffix:
## lvalue DOT
## LR(1) items:
lvalue -> lvalue DOT . member [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 36
-- On member shift to state 604
## Reductions:

State 604:
## Known stack suffix:
## lvalue DOT member
## LR(1) items:
lvalue -> lvalue DOT member . [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production lvalue -> lvalue DOT member

State 605:
## Known stack suffix:
## lvalue ASSIGN
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue ASSIGN . expression SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 606
-- On dotPrefix shift to state 91
## Reductions:

State 606:
## Known stack suffix:
## lvalue ASSIGN expression
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue ASSIGN expression . SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
expression -> expression . L_BRACKET expression R_BRACKET [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL SEMICOLON R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
## Transitions:
-- On SHL shift to state 64
-- On SEMICOLON shift to state 607
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 607:
## Known stack suffix:
## lvalue ASSIGN expression SEMICOLON
## LR(1) items:
assignmentOrMethodCallStatement -> lvalue ASSIGN expression SEMICOLON . [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production assignmentOrMethodCallStatement -> lvalue ASSIGN expression SEMICOLON

State 608:
## Known stack suffix:
## exitStatement
## LR(1) items:
statement -> exitStatement . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> exitStatement

State 609:
## Known stack suffix:
## emptyStatement
## LR(1) items:
statement -> emptyStatement . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> emptyStatement

State 610:
## Known stack suffix:
## dotPrefix
## LR(1) items:
prefixedNonTypeName -> dotPrefix . go_toplevel nonTypeName go_local [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
prefixedType -> dotPrefix . go_toplevel NAME TYPENAME go_local [ TYPE STATE NAME L_PAREN L_BRACKET L_ANGLE KEY ENTRIES DOT APPLY ACTIONS ]
## Transitions:
-- On go_toplevel shift to state 611
## Default reduction:
-- After reading the next token, reduce production go_toplevel ->

State 611:
## Known stack suffix:
## dotPrefix go_toplevel
## LR(1) items:
prefixedNonTypeName -> dotPrefix go_toplevel . nonTypeName go_local [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
prefixedType -> dotPrefix go_toplevel . NAME TYPENAME go_local [ TYPE STATE NAME L_PAREN L_BRACKET L_ANGLE KEY ENTRIES DOT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 93
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 612
## Reductions:

State 612:
## Known stack suffix:
## dotPrefix go_toplevel nonTypeName
## LR(1) items:
prefixedNonTypeName -> dotPrefix go_toplevel nonTypeName . go_local [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
-- On go_local shift to state 613
## Default reduction:
-- After reading the next token, reduce production go_local ->

State 613:
## Known stack suffix:
## dotPrefix go_toplevel nonTypeName go_local
## LR(1) items:
prefixedNonTypeName -> dotPrefix go_toplevel nonTypeName go_local . [ L_PAREN L_BRACKET L_ANGLE DOT ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production prefixedNonTypeName -> dotPrefix go_toplevel nonTypeName go_local

State 614:
## Known stack suffix:
## directApplication
## LR(1) items:
statement -> directApplication . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> directApplication

State 615:
## Known stack suffix:
## conditionalStatement
## LR(1) items:
statement -> conditionalStatement . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> conditionalStatement

State 616:
## Known stack suffix:
## blockStatement
## LR(1) items:
statement -> blockStatement . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> blockStatement

State 617:
## Known stack suffix:
## assignmentOrMethodCallStatement
## LR(1) items:
statement -> assignmentOrMethodCallStatement . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> assignmentOrMethodCallStatement

State 618:
## Known stack suffix:
## variableDeclaration
## LR(1) items:
statementOrDeclaration -> variableDeclaration . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statementOrDeclaration -> variableDeclaration

State 619:
## Known stack suffix:
## typeRef
## LR(1) items:
instantiation -> typeRef . L_PAREN argumentList R_PAREN name SEMICOLON [ VARBIT VALUESET TYPE TUPLE TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION ]
instantiation -> typeRef . L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON [ VARBIT VALUESET TYPE TUPLE TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION ]
variableDeclaration -> typeRef . name optInitialValue SEMICOLON [ VARBIT VALUESET TYPE TUPLE TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On L_PAREN shift to state 620
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 649
## Reductions:

State 620:
## Known stack suffix:
## typeRef L_PAREN
## LR(1) items:
instantiation -> typeRef L_PAREN . argumentList R_PAREN name SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
instantiation -> typeRef L_PAREN . argumentList R_PAREN name ASSIGN objInitializer SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 55
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 57
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_list_aux(COMMA,argument) shift to state 58
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,argument) shift to state 71
-- On nonTypeName shift to state 60
-- On namedType shift to state 53
-- On name shift to state 61
-- On expression shift to state 72
-- On dotPrefix shift to state 91
-- On argumentList shift to state 621
-- On argument shift to state 135
## Reductions:
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,argument) ->

State 621:
## Known stack suffix:
## typeRef L_PAREN argumentList
## LR(1) items:
instantiation -> typeRef L_PAREN argumentList . R_PAREN name SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
instantiation -> typeRef L_PAREN argumentList . R_PAREN name ASSIGN objInitializer SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_PAREN shift to state 622
## Reductions:

State 622:
## Known stack suffix:
## typeRef L_PAREN argumentList R_PAREN
## LR(1) items:
instantiation -> typeRef L_PAREN argumentList R_PAREN . name SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
instantiation -> typeRef L_PAREN argumentList R_PAREN . name ASSIGN objInitializer SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 623
## Reductions:

State 623:
## Known stack suffix:
## typeRef L_PAREN argumentList R_PAREN name
## LR(1) items:
instantiation -> typeRef L_PAREN argumentList R_PAREN name . SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
instantiation -> typeRef L_PAREN argumentList R_PAREN name . ASSIGN objInitializer SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On SEMICOLON shift to state 624
-- On ASSIGN shift to state 625
## Reductions:

State 624:
## Known stack suffix:
## typeRef L_PAREN argumentList R_PAREN name SEMICOLON
## LR(1) items:
instantiation -> typeRef L_PAREN argumentList R_PAREN name SEMICOLON . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instantiation -> typeRef L_PAREN argumentList R_PAREN name SEMICOLON

State 625:
## Known stack suffix:
## typeRef L_PAREN argumentList R_PAREN name ASSIGN
## LR(1) items:
instantiation -> typeRef L_PAREN argumentList R_PAREN name ASSIGN . objInitializer SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 626
-- On objInitializer shift to state 647
## Reductions:

State 626:
## Known stack suffix:
## L_BRACE
## LR(1) items:
objInitializer -> L_BRACE . petr4_list(objDeclaration) R_BRACE [ SEMICOLON ]
## Transitions:
-- On petr4_list(objDeclaration) shift to state 627
-- On list_aux(objDeclaration) shift to state 629
## Default reduction:
-- After reading the next token, reduce production list_aux(objDeclaration) ->

State 627:
## Known stack suffix:
## L_BRACE petr4_list(objDeclaration)
## LR(1) items:
objInitializer -> L_BRACE petr4_list(objDeclaration) . R_BRACE [ SEMICOLON ]
## Transitions:
-- On R_BRACE shift to state 628
## Reductions:

State 628:
## Known stack suffix:
## L_BRACE petr4_list(objDeclaration) R_BRACE
## LR(1) items:
objInitializer -> L_BRACE petr4_list(objDeclaration) R_BRACE . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production objInitializer -> L_BRACE petr4_list(objDeclaration) R_BRACE

State 629:
## Known stack suffix:
## list_aux(objDeclaration)
## LR(1) items:
list_aux(objDeclaration) -> list_aux(objDeclaration) . objDeclaration [ VOID VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
petr4_list(objDeclaration) -> list_aux(objDeclaration) . [ R_BRACE ]
## Transitions:
-- On VOID shift to state 1
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On PRAGMA shift to state 207
-- On NAME shift to state 11
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On varName shift to state 479
-- On typeRef shift to state 630
-- On typeOrVoid shift to state 462
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On objDeclaration shift to state 631
-- On nonempty_list_aux(annotation) shift to state 325
-- On instantiation shift to state 632
-- On headerStackType shift to state 142
-- On functionPrototype shift to state 633
-- On functionDeclaration shift to state 636
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
-- On annotations shift to state 637
-- On annotation shift to state 331
## Reductions:
-- On R_BRACE
--   reduce production petr4_list(objDeclaration) -> list_aux(objDeclaration)

State 630:
## Known stack suffix:
## typeRef
## LR(1) items:
instantiation -> typeRef . L_PAREN argumentList R_PAREN name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON R_BRACE PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
instantiation -> typeRef . L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON R_BRACE PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
typeOrVoid -> typeRef . [ TYPE STATE NAME KEY ENTRIES APPLY ACTIONS ]
## Transitions:
-- On L_PAREN shift to state 620
## Reductions:
-- On TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
--   reduce production typeOrVoid -> typeRef

State 631:
## Known stack suffix:
## list_aux(objDeclaration) objDeclaration
## LR(1) items:
list_aux(objDeclaration) -> list_aux(objDeclaration) objDeclaration . [ VOID VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_aux(objDeclaration) -> list_aux(objDeclaration) objDeclaration

State 632:
## Known stack suffix:
## instantiation
## LR(1) items:
objDeclaration -> instantiation . [ VOID VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production objDeclaration -> instantiation

State 633:
## Known stack suffix:
## functionPrototype
## LR(1) items:
functionDeclaration -> functionPrototype . blockStatement pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON R_BRACE PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On PRAGMA shift to state 207
-- On L_BRACE shift to state 532
-- On AT shift to state 302
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On blockStatement shift to state 634
-- On annotations shift to state 551
-- On annotation shift to state 331
## Reductions:

State 634:
## Known stack suffix:
## functionPrototype blockStatement
## LR(1) items:
functionDeclaration -> functionPrototype blockStatement . pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON R_BRACE PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On pop_scope shift to state 635
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 635:
## Known stack suffix:
## functionPrototype blockStatement pop_scope
## LR(1) items:
functionDeclaration -> functionPrototype blockStatement pop_scope . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON R_BRACE PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production functionDeclaration -> functionPrototype blockStatement pop_scope

State 636:
## Known stack suffix:
## functionDeclaration
## LR(1) items:
objDeclaration -> functionDeclaration . [ VOID VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production objDeclaration -> functionDeclaration

State 637:
## Known stack suffix:
## annotations
## LR(1) items:
instantiation -> annotations . typeRef L_PAREN argumentList R_PAREN name SEMICOLON [ VOID VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
instantiation -> annotations . typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON [ VOID VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On typeRef shift to state 638
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 638:
## Known stack suffix:
## annotations typeRef
## LR(1) items:
instantiation -> annotations typeRef . L_PAREN argumentList R_PAREN name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON R_BRACE PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
instantiation -> annotations typeRef . L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON R_BRACE PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On L_PAREN shift to state 639
## Reductions:

State 639:
## Known stack suffix:
## annotations typeRef L_PAREN
## LR(1) items:
instantiation -> annotations typeRef L_PAREN . argumentList R_PAREN name SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
instantiation -> annotations typeRef L_PAREN . argumentList R_PAREN name ASSIGN objInitializer SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 55
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 57
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_list_aux(COMMA,argument) shift to state 58
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,argument) shift to state 71
-- On nonTypeName shift to state 60
-- On namedType shift to state 53
-- On name shift to state 61
-- On expression shift to state 72
-- On dotPrefix shift to state 91
-- On argumentList shift to state 640
-- On argument shift to state 135
## Reductions:
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,argument) ->

State 640:
## Known stack suffix:
## annotations typeRef L_PAREN argumentList
## LR(1) items:
instantiation -> annotations typeRef L_PAREN argumentList . R_PAREN name SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
instantiation -> annotations typeRef L_PAREN argumentList . R_PAREN name ASSIGN objInitializer SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On R_PAREN shift to state 641
## Reductions:

State 641:
## Known stack suffix:
## annotations typeRef L_PAREN argumentList R_PAREN
## LR(1) items:
instantiation -> annotations typeRef L_PAREN argumentList R_PAREN . name SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
instantiation -> annotations typeRef L_PAREN argumentList R_PAREN . name ASSIGN objInitializer SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 642
## Reductions:

State 642:
## Known stack suffix:
## annotations typeRef L_PAREN argumentList R_PAREN name
## LR(1) items:
instantiation -> annotations typeRef L_PAREN argumentList R_PAREN name . SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
instantiation -> annotations typeRef L_PAREN argumentList R_PAREN name . ASSIGN objInitializer SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On SEMICOLON shift to state 643
-- On ASSIGN shift to state 644
## Reductions:

State 643:
## Known stack suffix:
## annotations typeRef L_PAREN argumentList R_PAREN name SEMICOLON
## LR(1) items:
instantiation -> annotations typeRef L_PAREN argumentList R_PAREN name SEMICOLON . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instantiation -> annotations typeRef L_PAREN argumentList R_PAREN name SEMICOLON

State 644:
## Known stack suffix:
## annotations typeRef L_PAREN argumentList R_PAREN name ASSIGN
## LR(1) items:
instantiation -> annotations typeRef L_PAREN argumentList R_PAREN name ASSIGN . objInitializer SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On L_BRACE shift to state 626
-- On objInitializer shift to state 645
## Reductions:

State 645:
## Known stack suffix:
## annotations typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer
## LR(1) items:
instantiation -> annotations typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer . SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On SEMICOLON shift to state 646
## Reductions:

State 646:
## Known stack suffix:
## annotations typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON
## LR(1) items:
instantiation -> annotations typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instantiation -> annotations typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON

State 647:
## Known stack suffix:
## typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer
## LR(1) items:
instantiation -> typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer . SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On SEMICOLON shift to state 648
## Reductions:

State 648:
## Known stack suffix:
## typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON
## LR(1) items:
instantiation -> typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production instantiation -> typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON

State 649:
## Known stack suffix:
## typeRef name
## LR(1) items:
variableDeclaration -> typeRef name . optInitialValue SEMICOLON [ VARBIT VALUESET TYPE TUPLE TRANSITION TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On ASSIGN shift to state 650
-- On optInitialValue shift to state 652
## Reductions:
-- On SEMICOLON
--   reduce production optInitialValue ->

State 650:
## Known stack suffix:
## ASSIGN
## LR(1) items:
optInitialValue -> ASSIGN . initialValue [ SEMICOLON ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On initialValue shift to state 651
-- On expression shift to state 526
-- On dotPrefix shift to state 91
## Reductions:

State 651:
## Known stack suffix:
## ASSIGN initialValue
## LR(1) items:
optInitialValue -> ASSIGN initialValue . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production optInitialValue -> ASSIGN initialValue

State 652:
## Known stack suffix:
## typeRef name optInitialValue
## LR(1) items:
variableDeclaration -> typeRef name optInitialValue . SEMICOLON [ VARBIT VALUESET TYPE TUPLE TRANSITION TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On SEMICOLON shift to state 653
## Reductions:

State 653:
## Known stack suffix:
## typeRef name optInitialValue SEMICOLON
## LR(1) items:
variableDeclaration -> typeRef name optInitialValue SEMICOLON . [ VARBIT VALUESET TYPE TUPLE TRANSITION TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variableDeclaration -> typeRef name optInitialValue SEMICOLON

State 654:
## Known stack suffix:
## typeName
## LR(1) items:
directApplication -> typeName . DOT APPLY L_PAREN argumentList R_PAREN SEMICOLON [ VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
headerStackType -> typeName . L_BRACKET expression R_BRACKET [ TYPE STATE NAME L_PAREN KEY ENTRIES APPLY ACTIONS ]
typeRef -> typeName . [ TYPE STATE NAME L_PAREN KEY ENTRIES APPLY ACTIONS ]
## Transitions:
-- On L_BRACKET shift to state 111
-- On DOT shift to state 571
## Reductions:
-- On TYPE STATE NAME L_PAREN KEY ENTRIES APPLY ACTIONS
--   reduce production typeRef -> typeName

State 655:
## Known stack suffix:
## list_aux(statementOrDeclaration) statementOrDeclaration
## LR(1) items:
list_aux(statementOrDeclaration) -> list_aux(statementOrDeclaration) statementOrDeclaration . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_aux(statementOrDeclaration) -> list_aux(statementOrDeclaration) statementOrDeclaration

State 656:
## Known stack suffix:
## statement
## LR(1) items:
statementOrDeclaration -> statement . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statementOrDeclaration -> statement

State 657:
## Known stack suffix:
## instantiation
## LR(1) items:
statementOrDeclaration -> instantiation . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statementOrDeclaration -> instantiation

State 658:
## Known stack suffix:
## constantDeclaration
## LR(1) items:
statementOrDeclaration -> constantDeclaration . [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statementOrDeclaration -> constantDeclaration

State 659:
## Known stack suffix:
## annotations
## LR(1) items:
blockStatement -> annotations . L_BRACE push_scope petr4_list(statementOrDeclaration) R_BRACE pop_scope [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
constantDeclaration -> annotations . CONST typeRef name ASSIGN initialValue SEMICOLON [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
instantiation -> annotations . typeRef L_PAREN argumentList R_PAREN name SEMICOLON [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
instantiation -> annotations . typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
variableDeclaration -> annotations . typeRef name optInitialValue SEMICOLON [ VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 301
-- On L_BRACE shift to state 552
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On CONST shift to state 660
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On typeRef shift to state 666
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 660:
## Known stack suffix:
## annotations CONST
## LR(1) items:
constantDeclaration -> annotations CONST . typeRef name ASSIGN initialValue SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On typeRef shift to state 661
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 661:
## Known stack suffix:
## annotations CONST typeRef
## LR(1) items:
constantDeclaration -> annotations CONST typeRef . name ASSIGN initialValue SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 662
## Reductions:

State 662:
## Known stack suffix:
## annotations CONST typeRef name
## LR(1) items:
constantDeclaration -> annotations CONST typeRef name . ASSIGN initialValue SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On ASSIGN shift to state 663
## Reductions:

State 663:
## Known stack suffix:
## annotations CONST typeRef name ASSIGN
## LR(1) items:
constantDeclaration -> annotations CONST typeRef name ASSIGN . initialValue SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On initialValue shift to state 664
-- On expression shift to state 526
-- On dotPrefix shift to state 91
## Reductions:

State 664:
## Known stack suffix:
## annotations CONST typeRef name ASSIGN initialValue
## LR(1) items:
constantDeclaration -> annotations CONST typeRef name ASSIGN initialValue . SEMICOLON [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On SEMICOLON shift to state 665
## Reductions:

State 665:
## Known stack suffix:
## annotations CONST typeRef name ASSIGN initialValue SEMICOLON
## LR(1) items:
constantDeclaration -> annotations CONST typeRef name ASSIGN initialValue SEMICOLON . [ VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production constantDeclaration -> annotations CONST typeRef name ASSIGN initialValue SEMICOLON

State 666:
## Known stack suffix:
## annotations typeRef
## LR(1) items:
instantiation -> annotations typeRef . L_PAREN argumentList R_PAREN name SEMICOLON [ VARBIT VALUESET TYPE TUPLE TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION ]
instantiation -> annotations typeRef . L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON [ VARBIT VALUESET TYPE TUPLE TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION ]
variableDeclaration -> annotations typeRef . name optInitialValue SEMICOLON [ VARBIT VALUESET TYPE TUPLE TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On L_PAREN shift to state 639
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 667
## Reductions:

State 667:
## Known stack suffix:
## annotations typeRef name
## LR(1) items:
variableDeclaration -> annotations typeRef name . optInitialValue SEMICOLON [ VARBIT VALUESET TYPE TUPLE TRANSITION TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On ASSIGN shift to state 650
-- On optInitialValue shift to state 668
## Reductions:
-- On SEMICOLON
--   reduce production optInitialValue ->

State 668:
## Known stack suffix:
## annotations typeRef name optInitialValue
## LR(1) items:
variableDeclaration -> annotations typeRef name optInitialValue . SEMICOLON [ VARBIT VALUESET TYPE TUPLE TRANSITION TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
-- On SEMICOLON shift to state 669
## Reductions:

State 669:
## Known stack suffix:
## annotations typeRef name optInitialValue SEMICOLON
## LR(1) items:
variableDeclaration -> annotations typeRef name optInitialValue SEMICOLON . [ VARBIT VALUESET TYPE TUPLE TRANSITION TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production variableDeclaration -> annotations typeRef name optInitialValue SEMICOLON

State 670:
## Known stack suffix:
## ACTION name L_PAREN parameterList R_PAREN blockStatement
## LR(1) items:
actionDeclaration -> ACTION name L_PAREN parameterList R_PAREN blockStatement . [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production actionDeclaration -> ACTION name L_PAREN parameterList R_PAREN blockStatement

State 671:
## Known stack suffix:
## typedefDeclaration
## LR(1) items:
typeDeclaration -> typedefDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeDeclaration -> typedefDeclaration

State 672:
## Known stack suffix:
## typeDeclaration
## LR(1) items:
topDeclaration -> typeDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production topDeclaration -> typeDeclaration

State 673:
## Known stack suffix:
## SEMICOLON topDeclarationList
## LR(1) items:
topDeclarationList -> SEMICOLON topDeclarationList . [ END ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production topDeclarationList -> SEMICOLON topDeclarationList

State 674:
## Known stack suffix:
## topDeclaration
## LR(1) items:
topDeclarationList -> topDeclaration . topDeclarationList [ END ]
## Transitions:
-- On VOID shift to state 1
-- On VARBIT shift to state 2
-- On TYPEDEF shift to state 200
-- On TYPE shift to state 407
-- On TUPLE shift to state 16
-- On STRUCT shift to state 201
-- On STRING shift to state 18
-- On SEMICOLON shift to state 414
-- On PRAGMA shift to state 207
-- On PARSER shift to state 415
-- On PACKAGE shift to state 449
-- On NAME shift to state 11
-- On MATCH_KIND shift to state 455
-- On INT shift to state 20
-- On HEADER_UNION shift to state 332
-- On HEADER shift to state 337
-- On EXTERN shift to state 459
-- On ERROR shift to state 510
-- On ENUM shift to state 342
-- On DOT shift to state 38
-- On CONTROL shift to state 514
-- On CONST shift to state 520
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On ACTION shift to state 527
-- On varName shift to state 479
-- On typedefDeclaration shift to state 671
-- On typeRef shift to state 630
-- On typeOrVoid shift to state 462
-- On typeName shift to state 138
-- On typeDeclaration shift to state 672
-- On tupleType shift to state 128
-- On topDeclarationList shift to state 675
-- On topDeclaration shift to state 674
-- On structTypeDeclaration shift to state 371
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parserTypeDeclaration shift to state 676
-- On parserDeclaration shift to state 810
-- On packageTypeDeclaration shift to state 811
-- On nonempty_list_aux(annotation) shift to state 325
-- On matchKindDeclaration shift to state 814
-- On instantiation shift to state 815
-- On headerUnionDeclaration shift to state 372
-- On headerTypeDeclaration shift to state 373
-- On headerStackType shift to state 142
-- On functionPrototype shift to state 633
-- On functionDeclaration shift to state 816
-- On externDeclaration shift to state 817
-- On errorDeclaration shift to state 818
-- On enumDeclaration shift to state 374
-- On dotPrefix shift to state 143
-- On derivedTypeDeclaration shift to state 819
-- On controlTypeDeclaration shift to state 820
-- On controlDeclaration shift to state 930
-- On constantDeclaration shift to state 931
-- On baseType shift to state 146
-- On annotations shift to state 932
-- On annotation shift to state 331
-- On actionDeclaration shift to state 975
## Reductions:
-- On END
--   reduce production topDeclarationList ->

State 675:
## Known stack suffix:
## topDeclaration topDeclarationList
## LR(1) items:
topDeclarationList -> topDeclaration topDeclarationList . [ END ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production topDeclarationList -> topDeclaration topDeclarationList

State 676:
## Known stack suffix:
## parserTypeDeclaration
## LR(1) items:
parserDeclaration -> parserTypeDeclaration . optConstructorParameters L_BRACE list_aux(parserLocalElement) petr4_nonempty_list(parserState) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
typeDeclaration -> parserTypeDeclaration . pop_scope SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On L_PAREN shift to state 677
-- On pop_scope shift to state 680
-- On optConstructorParameters shift to state 682
## Reductions:
-- On L_BRACE
--   reduce production optConstructorParameters ->
-- On SEMICOLON
--   reduce production pop_scope ->

State 677:
## Known stack suffix:
## L_PAREN
## LR(1) items:
optConstructorParameters -> L_PAREN . parameterList R_PAREN [ L_BRACE ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On separated_list_aux(COMMA,parameter) shift to state 430
-- On petr4_separated_list(COMMA,parameter) shift to state 444
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameterList shift to state 678
-- On parameter shift to state 447
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,parameter) ->

State 678:
## Known stack suffix:
## L_PAREN parameterList
## LR(1) items:
optConstructorParameters -> L_PAREN parameterList . R_PAREN [ L_BRACE ]
## Transitions:
-- On R_PAREN shift to state 679
## Reductions:

State 679:
## Known stack suffix:
## L_PAREN parameterList R_PAREN
## LR(1) items:
optConstructorParameters -> L_PAREN parameterList R_PAREN . [ L_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production optConstructorParameters -> L_PAREN parameterList R_PAREN

State 680:
## Known stack suffix:
## parserTypeDeclaration pop_scope
## LR(1) items:
typeDeclaration -> parserTypeDeclaration pop_scope . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 681
## Reductions:

State 681:
## Known stack suffix:
## parserTypeDeclaration pop_scope SEMICOLON
## LR(1) items:
typeDeclaration -> parserTypeDeclaration pop_scope SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeDeclaration -> parserTypeDeclaration pop_scope SEMICOLON

State 682:
## Known stack suffix:
## parserTypeDeclaration optConstructorParameters
## LR(1) items:
parserDeclaration -> parserTypeDeclaration optConstructorParameters . L_BRACE list_aux(parserLocalElement) petr4_nonempty_list(parserState) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On L_BRACE shift to state 683
## Reductions:

State 683:
## Known stack suffix:
## parserTypeDeclaration optConstructorParameters L_BRACE
## LR(1) items:
parserDeclaration -> parserTypeDeclaration optConstructorParameters L_BRACE . list_aux(parserLocalElement) petr4_nonempty_list(parserState) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On list_aux(parserLocalElement) shift to state 684
## Default reduction:
-- After reading the next token, reduce production list_aux(parserLocalElement) ->

State 684:
## Known stack suffix:
## parserTypeDeclaration optConstructorParameters L_BRACE list_aux(parserLocalElement)
## LR(1) items:
list_aux(parserLocalElement) -> list_aux(parserLocalElement) . parserLocalElement [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
parserDeclaration -> parserTypeDeclaration optConstructorParameters L_BRACE list_aux(parserLocalElement) . petr4_nonempty_list(parserState) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On VARBIT shift to state 2
-- On VALUESET shift to state 685
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On STATE shift to state 708
-- On PRAGMA shift to state 207
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On CONST shift to state 520
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On variableDeclaration shift to state 767
-- On valueSetDeclaration shift to state 768
-- On typeRef shift to state 619
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(parserState) shift to state 769
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parserState shift to state 772
-- On parserLocalElement shift to state 773
-- On nonempty_list_aux(parserState) shift to state 774
-- On nonempty_list_aux(annotation) shift to state 325
-- On instantiation shift to state 784
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On constantDeclaration shift to state 785
-- On baseType shift to state 146
-- On annotations shift to state 786
-- On annotation shift to state 331
## Reductions:

State 685:
## Known stack suffix:
## VALUESET
## LR(1) items:
valueSetDeclaration -> VALUESET . L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
valueSetDeclaration -> VALUESET . L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
valueSetDeclaration -> VALUESET . L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On L_ANGLE shift to state 686
## Reductions:

State 686:
## Known stack suffix:
## VALUESET L_ANGLE
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE . baseType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
valueSetDeclaration -> VALUESET L_ANGLE . tupleType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
valueSetDeclaration -> VALUESET L_ANGLE . typeName R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On typeName shift to state 687
-- On tupleType shift to state 694
-- On prefixedType shift to state 582
-- On dotPrefix shift to state 143
-- On baseType shift to state 701
## Reductions:

State 687:
## Known stack suffix:
## VALUESET L_ANGLE typeName
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE typeName . R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On R_ANGLE shift to state 688
## Reductions:

State 688:
## Known stack suffix:
## VALUESET L_ANGLE typeName R_ANGLE
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE typeName R_ANGLE . L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On L_PAREN shift to state 689
## Reductions:

State 689:
## Known stack suffix:
## VALUESET L_ANGLE typeName R_ANGLE L_PAREN
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE typeName R_ANGLE L_PAREN . expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 690
-- On dotPrefix shift to state 91
## Reductions:

State 690:
## Known stack suffix:
## VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
valueSetDeclaration -> VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression . R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 691
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 691:
## Known stack suffix:
## VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN . name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 692
## Reductions:

State 692:
## Known stack suffix:
## VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name . SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On SEMICOLON shift to state 693
## Reductions:

State 693:
## Known stack suffix:
## VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name SEMICOLON
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name SEMICOLON . [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production valueSetDeclaration -> VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name SEMICOLON

State 694:
## Known stack suffix:
## VALUESET L_ANGLE tupleType
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE tupleType . R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On R_ANGLE shift to state 695
## Reductions:

State 695:
## Known stack suffix:
## VALUESET L_ANGLE tupleType R_ANGLE
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE tupleType R_ANGLE . L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On L_PAREN shift to state 696
## Reductions:

State 696:
## Known stack suffix:
## VALUESET L_ANGLE tupleType R_ANGLE L_PAREN
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE tupleType R_ANGLE L_PAREN . expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 697
-- On dotPrefix shift to state 91
## Reductions:

State 697:
## Known stack suffix:
## VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
valueSetDeclaration -> VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression . R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 698
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 698:
## Known stack suffix:
## VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN . name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 699
## Reductions:

State 699:
## Known stack suffix:
## VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name . SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On SEMICOLON shift to state 700
## Reductions:

State 700:
## Known stack suffix:
## VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON . [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production valueSetDeclaration -> VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON

State 701:
## Known stack suffix:
## VALUESET L_ANGLE baseType
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE baseType . R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On R_ANGLE shift to state 702
## Reductions:

State 702:
## Known stack suffix:
## VALUESET L_ANGLE baseType R_ANGLE
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE baseType R_ANGLE . L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On L_PAREN shift to state 703
## Reductions:

State 703:
## Known stack suffix:
## VALUESET L_ANGLE baseType R_ANGLE L_PAREN
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE baseType R_ANGLE L_PAREN . expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 704
-- On dotPrefix shift to state 91
## Reductions:

State 704:
## Known stack suffix:
## VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
valueSetDeclaration -> VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression . R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 705
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 705:
## Known stack suffix:
## VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN . name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 706
## Reductions:

State 706:
## Known stack suffix:
## VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name . SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On SEMICOLON shift to state 707
## Reductions:

State 707:
## Known stack suffix:
## VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON
## LR(1) items:
valueSetDeclaration -> VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON . [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production valueSetDeclaration -> VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON

State 708:
## Known stack suffix:
## STATE
## LR(1) items:
parserState -> STATE . push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On push_name shift to state 709
-- On nonTypeName shift to state 35
-- On name shift to state 448
## Reductions:

State 709:
## Known stack suffix:
## STATE push_name
## LR(1) items:
parserState -> STATE push_name . L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On L_BRACE shift to state 710
## Reductions:

State 710:
## Known stack suffix:
## STATE push_name L_BRACE
## LR(1) items:
parserState -> STATE push_name L_BRACE . petr4_list(parserStatement) transitionStatement R_BRACE pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On petr4_list(parserStatement) shift to state 711
-- On list_aux(parserStatement) shift to state 751
## Default reduction:
-- After reading the next token, reduce production list_aux(parserStatement) ->

State 711:
## Known stack suffix:
## STATE push_name L_BRACE petr4_list(parserStatement)
## LR(1) items:
parserState -> STATE push_name L_BRACE petr4_list(parserStatement) . transitionStatement R_BRACE pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On TRANSITION shift to state 712
-- On transitionStatement shift to state 748
## Reductions:
-- On R_BRACE
--   reduce production transitionStatement ->

State 712:
## Known stack suffix:
## TRANSITION
## LR(1) items:
transitionStatement -> TRANSITION . stateExpression [ R_BRACE ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On SELECT shift to state 713
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On stateExpression shift to state 744
-- On selectExpression shift to state 745
-- On nonTypeName shift to state 35
-- On name shift to state 746
## Reductions:

State 713:
## Known stack suffix:
## SELECT
## LR(1) items:
selectExpression -> SELECT . L_PAREN expressionList R_PAREN L_BRACE petr4_list(selectCase) R_BRACE [ R_BRACE ]
## Transitions:
-- On L_PAREN shift to state 714
## Reductions:

State 714:
## Known stack suffix:
## SELECT L_PAREN
## LR(1) items:
selectExpression -> SELECT L_PAREN . expressionList R_PAREN L_BRACE petr4_list(selectCase) R_BRACE [ R_BRACE ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_list_aux(COMMA,expression) shift to state 173
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,expression) shift to state 176
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expressionList shift to state 715
-- On expression shift to state 179
-- On dotPrefix shift to state 91
## Reductions:
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,expression) ->

State 715:
## Known stack suffix:
## SELECT L_PAREN expressionList
## LR(1) items:
selectExpression -> SELECT L_PAREN expressionList . R_PAREN L_BRACE petr4_list(selectCase) R_BRACE [ R_BRACE ]
## Transitions:
-- On R_PAREN shift to state 716
## Reductions:

State 716:
## Known stack suffix:
## SELECT L_PAREN expressionList R_PAREN
## LR(1) items:
selectExpression -> SELECT L_PAREN expressionList R_PAREN . L_BRACE petr4_list(selectCase) R_BRACE [ R_BRACE ]
## Transitions:
-- On L_BRACE shift to state 717
## Reductions:

State 717:
## Known stack suffix:
## SELECT L_PAREN expressionList R_PAREN L_BRACE
## LR(1) items:
selectExpression -> SELECT L_PAREN expressionList R_PAREN L_BRACE . petr4_list(selectCase) R_BRACE [ R_BRACE ]
## Transitions:
-- On petr4_list(selectCase) shift to state 718
-- On list_aux(selectCase) shift to state 720
## Default reduction:
-- After reading the next token, reduce production list_aux(selectCase) ->

State 718:
## Known stack suffix:
## SELECT L_PAREN expressionList R_PAREN L_BRACE petr4_list(selectCase)
## LR(1) items:
selectExpression -> SELECT L_PAREN expressionList R_PAREN L_BRACE petr4_list(selectCase) . R_BRACE [ R_BRACE ]
## Transitions:
-- On R_BRACE shift to state 719
## Reductions:

State 719:
## Known stack suffix:
## SELECT L_PAREN expressionList R_PAREN L_BRACE petr4_list(selectCase) R_BRACE
## LR(1) items:
selectExpression -> SELECT L_PAREN expressionList R_PAREN L_BRACE petr4_list(selectCase) R_BRACE . [ R_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production selectExpression -> SELECT L_PAREN expressionList R_PAREN L_BRACE petr4_list(selectCase) R_BRACE

State 720:
## Known stack suffix:
## list_aux(selectCase)
## LR(1) items:
list_aux(selectCase) -> list_aux(selectCase) . selectCase [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
petr4_list(selectCase) -> list_aux(selectCase) . [ R_BRACE ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 721
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 722
-- On DEFAULT shift to state 723
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tupleKeysetExpression shift to state 737
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On simpleKeysetExpression shift to state 738
-- On selectCase shift to state 739
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On keysetExpression shift to state 740
-- On expression shift to state 728
-- On dotPrefix shift to state 91
## Reductions:
-- On R_BRACE
--   reduce production petr4_list(selectCase) -> list_aux(selectCase)

State 721:
## Known stack suffix:
## L_PAREN
## LR(1) items:
expression -> L_PAREN . expression R_PAREN [ SHL R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> L_PAREN . typeRef R_PAREN expression [ SHL R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
tupleKeysetExpression -> L_PAREN . separated_atLeastTwo_list(COMMA,simpleKeysetExpression) R_PAREN [ COLON ]
## Transitions:
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On INT shift to state 20
-- On FALSE shift to state 25
-- On ERROR shift to state 107
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 722
-- On DEFAULT shift to state 723
-- On COMPLEMENT shift to state 39
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeRef shift to state 187
-- On typeName shift to state 110
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 129
-- On simpleKeysetExpression shift to state 724
-- On separated_nonempty_list_aux(COMMA,simpleKeysetExpression) shift to state 725
-- On separated_atLeastTwo_list_aux(COMMA,simpleKeysetExpression) shift to state 733
-- On separated_atLeastTwo_list(COMMA,simpleKeysetExpression) shift to state 734
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On headerStackType shift to state 142
-- On expression shift to state 736
-- On dotPrefix shift to state 91
-- On baseType shift to state 146
## Reductions:

State 722:
## Known stack suffix:
## DONTCARE
## LR(1) items:
simpleKeysetExpression -> DONTCARE . [ R_PAREN COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simpleKeysetExpression -> DONTCARE

State 723:
## Known stack suffix:
## DEFAULT
## LR(1) items:
simpleKeysetExpression -> DEFAULT . [ R_PAREN COMMA COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production simpleKeysetExpression -> DEFAULT

State 724:
## Known stack suffix:
## simpleKeysetExpression
## LR(1) items:
separated_nonempty_list_aux(COMMA,simpleKeysetExpression) -> simpleKeysetExpression . [ COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list_aux(COMMA,simpleKeysetExpression) -> simpleKeysetExpression

State 725:
## Known stack suffix:
## separated_nonempty_list_aux(COMMA,simpleKeysetExpression)
## LR(1) items:
separated_atLeastTwo_list_aux(COMMA,simpleKeysetExpression) -> separated_nonempty_list_aux(COMMA,simpleKeysetExpression) . COMMA simpleKeysetExpression [ R_PAREN ]
separated_nonempty_list_aux(COMMA,simpleKeysetExpression) -> separated_nonempty_list_aux(COMMA,simpleKeysetExpression) . COMMA simpleKeysetExpression [ COMMA ]
## Transitions:
-- On COMMA shift to state 726
## Reductions:

State 726:
## Known stack suffix:
## separated_nonempty_list_aux(COMMA,simpleKeysetExpression) COMMA
## LR(1) items:
separated_atLeastTwo_list_aux(COMMA,simpleKeysetExpression) -> separated_nonempty_list_aux(COMMA,simpleKeysetExpression) COMMA . simpleKeysetExpression [ R_PAREN ]
separated_nonempty_list_aux(COMMA,simpleKeysetExpression) -> separated_nonempty_list_aux(COMMA,simpleKeysetExpression) COMMA . simpleKeysetExpression [ COMMA ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 722
-- On DEFAULT shift to state 723
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On simpleKeysetExpression shift to state 727
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 728
-- On dotPrefix shift to state 91
## Reductions:

State 727:
## Known stack suffix:
## separated_nonempty_list_aux(COMMA,simpleKeysetExpression) COMMA simpleKeysetExpression
## LR(1) items:
separated_atLeastTwo_list_aux(COMMA,simpleKeysetExpression) -> separated_nonempty_list_aux(COMMA,simpleKeysetExpression) COMMA simpleKeysetExpression . [ R_PAREN ]
separated_nonempty_list_aux(COMMA,simpleKeysetExpression) -> separated_nonempty_list_aux(COMMA,simpleKeysetExpression) COMMA simpleKeysetExpression . [ COMMA ]
## Transitions:
## Reductions:
-- On R_PAREN
--   reduce production separated_atLeastTwo_list_aux(COMMA,simpleKeysetExpression) -> separated_nonempty_list_aux(COMMA,simpleKeysetExpression) COMMA simpleKeysetExpression
-- On COMMA
--   reduce production separated_nonempty_list_aux(COMMA,simpleKeysetExpression) -> separated_nonempty_list_aux(COMMA,simpleKeysetExpression) COMMA simpleKeysetExpression

State 728:
## Known stack suffix:
## expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
simpleKeysetExpression -> expression . [ R_PAREN COMMA COLON ]
simpleKeysetExpression -> expression . MASK expression [ R_PAREN COMMA COLON ]
simpleKeysetExpression -> expression . RANGE expression [ R_PAREN COMMA COLON ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On RANGE shift to state 729
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On MASK shift to state 731
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On R_PAREN COMMA COLON
--   reduce production simpleKeysetExpression -> expression

State 729:
## Known stack suffix:
## expression RANGE
## LR(1) items:
simpleKeysetExpression -> expression RANGE . expression [ R_PAREN COMMA COLON ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 730
-- On dotPrefix shift to state 91
## Reductions:

State 730:
## Known stack suffix:
## expression RANGE expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
simpleKeysetExpression -> expression RANGE expression . [ R_PAREN COMMA COLON ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On R_PAREN COMMA COLON
--   reduce production simpleKeysetExpression -> expression RANGE expression

State 731:
## Known stack suffix:
## expression MASK
## LR(1) items:
simpleKeysetExpression -> expression MASK . expression [ R_PAREN COMMA COLON ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 732
-- On dotPrefix shift to state 91
## Reductions:

State 732:
## Known stack suffix:
## expression MASK expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND ]
simpleKeysetExpression -> expression MASK expression . [ R_PAREN COMMA COLON ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On R_PAREN COMMA COLON
--   reduce production simpleKeysetExpression -> expression MASK expression

State 733:
## Known stack suffix:
## separated_atLeastTwo_list_aux(COMMA,simpleKeysetExpression)
## LR(1) items:
separated_atLeastTwo_list(COMMA,simpleKeysetExpression) -> separated_atLeastTwo_list_aux(COMMA,simpleKeysetExpression) . [ R_PAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_atLeastTwo_list(COMMA,simpleKeysetExpression) -> separated_atLeastTwo_list_aux(COMMA,simpleKeysetExpression)

State 734:
## Known stack suffix:
## L_PAREN separated_atLeastTwo_list(COMMA,simpleKeysetExpression)
## LR(1) items:
tupleKeysetExpression -> L_PAREN separated_atLeastTwo_list(COMMA,simpleKeysetExpression) . R_PAREN [ COLON ]
## Transitions:
-- On R_PAREN shift to state 735
## Reductions:

State 735:
## Known stack suffix:
## L_PAREN separated_atLeastTwo_list(COMMA,simpleKeysetExpression) R_PAREN
## LR(1) items:
tupleKeysetExpression -> L_PAREN separated_atLeastTwo_list(COMMA,simpleKeysetExpression) R_PAREN . [ COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tupleKeysetExpression -> L_PAREN separated_atLeastTwo_list(COMMA,simpleKeysetExpression) R_PAREN

State 736:
## Known stack suffix:
## L_PAREN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> L_PAREN expression . R_PAREN [ SHL R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA BIT_XOR BIT_OR BIT_AND AND ]
simpleKeysetExpression -> expression . [ COMMA ]
simpleKeysetExpression -> expression . MASK expression [ COMMA ]
simpleKeysetExpression -> expression . RANGE expression [ COMMA ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 191
-- On R_ANGLE shift to state 73
-- On RANGE shift to state 729
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On MASK shift to state 731
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:
-- On COMMA
--   reduce production simpleKeysetExpression -> expression

State 737:
## Known stack suffix:
## tupleKeysetExpression
## LR(1) items:
keysetExpression -> tupleKeysetExpression . [ COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production keysetExpression -> tupleKeysetExpression

State 738:
## Known stack suffix:
## simpleKeysetExpression
## LR(1) items:
keysetExpression -> simpleKeysetExpression . [ COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production keysetExpression -> simpleKeysetExpression

State 739:
## Known stack suffix:
## list_aux(selectCase) selectCase
## LR(1) items:
list_aux(selectCase) -> list_aux(selectCase) selectCase . [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_aux(selectCase) -> list_aux(selectCase) selectCase

State 740:
## Known stack suffix:
## keysetExpression
## LR(1) items:
selectCase -> keysetExpression . COLON name SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
## Transitions:
-- On COLON shift to state 741
## Reductions:

State 741:
## Known stack suffix:
## keysetExpression COLON
## LR(1) items:
selectCase -> keysetExpression COLON . name SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 742
## Reductions:

State 742:
## Known stack suffix:
## keysetExpression COLON name
## LR(1) items:
selectCase -> keysetExpression COLON name . SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 743
## Reductions:

State 743:
## Known stack suffix:
## keysetExpression COLON name SEMICOLON
## LR(1) items:
selectCase -> keysetExpression COLON name SEMICOLON . [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production selectCase -> keysetExpression COLON name SEMICOLON

State 744:
## Known stack suffix:
## TRANSITION stateExpression
## LR(1) items:
transitionStatement -> TRANSITION stateExpression . [ R_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production transitionStatement -> TRANSITION stateExpression

State 745:
## Known stack suffix:
## selectExpression
## LR(1) items:
stateExpression -> selectExpression . [ R_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production stateExpression -> selectExpression

State 746:
## Known stack suffix:
## name
## LR(1) items:
stateExpression -> name . SEMICOLON [ R_BRACE ]
## Transitions:
-- On SEMICOLON shift to state 747
## Reductions:

State 747:
## Known stack suffix:
## name SEMICOLON
## LR(1) items:
stateExpression -> name SEMICOLON . [ R_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production stateExpression -> name SEMICOLON

State 748:
## Known stack suffix:
## STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement
## LR(1) items:
parserState -> STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement . R_BRACE pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On R_BRACE shift to state 749
## Reductions:

State 749:
## Known stack suffix:
## STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE
## LR(1) items:
parserState -> STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE . pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On pop_scope shift to state 750
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 750:
## Known stack suffix:
## STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE pop_scope
## LR(1) items:
parserState -> STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE pop_scope . [ STATE R_BRACE PRAGMA AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserState -> STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE pop_scope

State 751:
## Known stack suffix:
## list_aux(parserStatement)
## LR(1) items:
list_aux(parserStatement) -> list_aux(parserStatement) . parserStatement [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
petr4_list(parserStatement) -> list_aux(parserStatement) . [ TRANSITION R_BRACE ]
## Transitions:
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On PRAGMA shift to state 207
-- On NAME shift to state 11
-- On L_BRACE shift to state 752
-- On KEY shift to state 19
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On CONST shift to state 520
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On variableDeclaration shift to state 755
-- On varName shift to state 33
-- On typeRef shift to state 756
-- On typeName shift to state 654
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On prefixedNonTypeName shift to state 583
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parserStatement shift to state 757
-- On parserBlockStatement shift to state 758
-- On nonempty_list_aux(annotation) shift to state 325
-- On nonTypeName shift to state 584
-- On lvalue shift to state 585
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 610
-- On directApplication shift to state 759
-- On constantDeclaration shift to state 760
-- On baseType shift to state 146
-- On assignmentOrMethodCallStatement shift to state 761
-- On annotations shift to state 762
-- On annotation shift to state 331
## Reductions:
-- On TRANSITION R_BRACE
--   reduce production petr4_list(parserStatement) -> list_aux(parserStatement)

State 752:
## Known stack suffix:
## L_BRACE
## LR(1) items:
parserBlockStatement -> L_BRACE . petr4_list(parserStatement) R_BRACE [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On petr4_list(parserStatement) shift to state 753
-- On list_aux(parserStatement) shift to state 751
## Default reduction:
-- After reading the next token, reduce production list_aux(parserStatement) ->

State 753:
## Known stack suffix:
## L_BRACE petr4_list(parserStatement)
## LR(1) items:
parserBlockStatement -> L_BRACE petr4_list(parserStatement) . R_BRACE [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On R_BRACE shift to state 754
## Reductions:

State 754:
## Known stack suffix:
## L_BRACE petr4_list(parserStatement) R_BRACE
## LR(1) items:
parserBlockStatement -> L_BRACE petr4_list(parserStatement) R_BRACE . [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserBlockStatement -> L_BRACE petr4_list(parserStatement) R_BRACE

State 755:
## Known stack suffix:
## variableDeclaration
## LR(1) items:
parserStatement -> variableDeclaration . [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserStatement -> variableDeclaration

State 756:
## Known stack suffix:
## typeRef
## LR(1) items:
variableDeclaration -> typeRef . name optInitialValue SEMICOLON [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 649
## Reductions:

State 757:
## Known stack suffix:
## list_aux(parserStatement) parserStatement
## LR(1) items:
list_aux(parserStatement) -> list_aux(parserStatement) parserStatement . [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_aux(parserStatement) -> list_aux(parserStatement) parserStatement

State 758:
## Known stack suffix:
## parserBlockStatement
## LR(1) items:
parserStatement -> parserBlockStatement . [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserStatement -> parserBlockStatement

State 759:
## Known stack suffix:
## directApplication
## LR(1) items:
parserStatement -> directApplication . [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserStatement -> directApplication

State 760:
## Known stack suffix:
## constantDeclaration
## LR(1) items:
parserStatement -> constantDeclaration . [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserStatement -> constantDeclaration

State 761:
## Known stack suffix:
## assignmentOrMethodCallStatement
## LR(1) items:
parserStatement -> assignmentOrMethodCallStatement . [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserStatement -> assignmentOrMethodCallStatement

State 762:
## Known stack suffix:
## annotations
## LR(1) items:
constantDeclaration -> annotations . CONST typeRef name ASSIGN initialValue SEMICOLON [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
parserBlockStatement -> annotations . L_BRACE petr4_list(parserStatement) R_BRACE [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
variableDeclaration -> annotations . typeRef name optInitialValue SEMICOLON [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 301
-- On L_BRACE shift to state 763
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On CONST shift to state 660
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On typeRef shift to state 766
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 763:
## Known stack suffix:
## annotations L_BRACE
## LR(1) items:
parserBlockStatement -> annotations L_BRACE . petr4_list(parserStatement) R_BRACE [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On petr4_list(parserStatement) shift to state 764
-- On list_aux(parserStatement) shift to state 751
## Default reduction:
-- After reading the next token, reduce production list_aux(parserStatement) ->

State 764:
## Known stack suffix:
## annotations L_BRACE petr4_list(parserStatement)
## LR(1) items:
parserBlockStatement -> annotations L_BRACE petr4_list(parserStatement) . R_BRACE [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On R_BRACE shift to state 765
## Reductions:

State 765:
## Known stack suffix:
## annotations L_BRACE petr4_list(parserStatement) R_BRACE
## LR(1) items:
parserBlockStatement -> annotations L_BRACE petr4_list(parserStatement) R_BRACE . [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserBlockStatement -> annotations L_BRACE petr4_list(parserStatement) R_BRACE

State 766:
## Known stack suffix:
## annotations typeRef
## LR(1) items:
variableDeclaration -> annotations typeRef . name optInitialValue SEMICOLON [ VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 667
## Reductions:

State 767:
## Known stack suffix:
## variableDeclaration
## LR(1) items:
parserLocalElement -> variableDeclaration . [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserLocalElement -> variableDeclaration

State 768:
## Known stack suffix:
## valueSetDeclaration
## LR(1) items:
parserLocalElement -> valueSetDeclaration . [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserLocalElement -> valueSetDeclaration

State 769:
## Known stack suffix:
## parserTypeDeclaration optConstructorParameters L_BRACE list_aux(parserLocalElement) petr4_nonempty_list(parserState)
## LR(1) items:
parserDeclaration -> parserTypeDeclaration optConstructorParameters L_BRACE list_aux(parserLocalElement) petr4_nonempty_list(parserState) . R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On R_BRACE shift to state 770
## Reductions:

State 770:
## Known stack suffix:
## parserTypeDeclaration optConstructorParameters L_BRACE list_aux(parserLocalElement) petr4_nonempty_list(parserState) R_BRACE
## LR(1) items:
parserDeclaration -> parserTypeDeclaration optConstructorParameters L_BRACE list_aux(parserLocalElement) petr4_nonempty_list(parserState) R_BRACE . pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On pop_scope shift to state 771
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 771:
## Known stack suffix:
## parserTypeDeclaration optConstructorParameters L_BRACE list_aux(parserLocalElement) petr4_nonempty_list(parserState) R_BRACE pop_scope
## LR(1) items:
parserDeclaration -> parserTypeDeclaration optConstructorParameters L_BRACE list_aux(parserLocalElement) petr4_nonempty_list(parserState) R_BRACE pop_scope . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserDeclaration -> parserTypeDeclaration optConstructorParameters L_BRACE list_aux(parserLocalElement) petr4_nonempty_list(parserState) R_BRACE pop_scope

State 772:
## Known stack suffix:
## parserState
## LR(1) items:
nonempty_list_aux(parserState) -> parserState . [ STATE R_BRACE PRAGMA AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list_aux(parserState) -> parserState

State 773:
## Known stack suffix:
## list_aux(parserLocalElement) parserLocalElement
## LR(1) items:
list_aux(parserLocalElement) -> list_aux(parserLocalElement) parserLocalElement . [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_aux(parserLocalElement) -> list_aux(parserLocalElement) parserLocalElement

State 774:
## Known stack suffix:
## nonempty_list_aux(parserState)
## LR(1) items:
nonempty_list_aux(parserState) -> nonempty_list_aux(parserState) . parserState [ STATE R_BRACE PRAGMA AT ]
petr4_nonempty_list(parserState) -> nonempty_list_aux(parserState) . [ R_BRACE ]
## Transitions:
-- On STATE shift to state 708
-- On PRAGMA shift to state 207
-- On AT shift to state 302
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parserState shift to state 775
-- On nonempty_list_aux(annotation) shift to state 325
-- On annotations shift to state 776
-- On annotation shift to state 331
## Reductions:
-- On R_BRACE
--   reduce production petr4_nonempty_list(parserState) -> nonempty_list_aux(parserState)

State 775:
## Known stack suffix:
## nonempty_list_aux(parserState) parserState
## LR(1) items:
nonempty_list_aux(parserState) -> nonempty_list_aux(parserState) parserState . [ STATE R_BRACE PRAGMA AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list_aux(parserState) -> nonempty_list_aux(parserState) parserState

State 776:
## Known stack suffix:
## annotations
## LR(1) items:
parserState -> annotations . STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On STATE shift to state 777
## Reductions:

State 777:
## Known stack suffix:
## annotations STATE
## LR(1) items:
parserState -> annotations STATE . push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On push_name shift to state 778
-- On nonTypeName shift to state 35
-- On name shift to state 448
## Reductions:

State 778:
## Known stack suffix:
## annotations STATE push_name
## LR(1) items:
parserState -> annotations STATE push_name . L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On L_BRACE shift to state 779
## Reductions:

State 779:
## Known stack suffix:
## annotations STATE push_name L_BRACE
## LR(1) items:
parserState -> annotations STATE push_name L_BRACE . petr4_list(parserStatement) transitionStatement R_BRACE pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On petr4_list(parserStatement) shift to state 780
-- On list_aux(parserStatement) shift to state 751
## Default reduction:
-- After reading the next token, reduce production list_aux(parserStatement) ->

State 780:
## Known stack suffix:
## annotations STATE push_name L_BRACE petr4_list(parserStatement)
## LR(1) items:
parserState -> annotations STATE push_name L_BRACE petr4_list(parserStatement) . transitionStatement R_BRACE pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On TRANSITION shift to state 712
-- On transitionStatement shift to state 781
## Reductions:
-- On R_BRACE
--   reduce production transitionStatement ->

State 781:
## Known stack suffix:
## annotations STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement
## LR(1) items:
parserState -> annotations STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement . R_BRACE pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On R_BRACE shift to state 782
## Reductions:

State 782:
## Known stack suffix:
## annotations STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE
## LR(1) items:
parserState -> annotations STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE . pop_scope [ STATE R_BRACE PRAGMA AT ]
## Transitions:
-- On pop_scope shift to state 783
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 783:
## Known stack suffix:
## annotations STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE pop_scope
## LR(1) items:
parserState -> annotations STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE pop_scope . [ STATE R_BRACE PRAGMA AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserState -> annotations STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE pop_scope

State 784:
## Known stack suffix:
## instantiation
## LR(1) items:
parserLocalElement -> instantiation . [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserLocalElement -> instantiation

State 785:
## Known stack suffix:
## constantDeclaration
## LR(1) items:
parserLocalElement -> constantDeclaration . [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserLocalElement -> constantDeclaration

State 786:
## Known stack suffix:
## annotations
## LR(1) items:
constantDeclaration -> annotations . CONST typeRef name ASSIGN initialValue SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
instantiation -> annotations . typeRef L_PAREN argumentList R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
instantiation -> annotations . typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
parserState -> annotations . STATE push_name L_BRACE petr4_list(parserStatement) transitionStatement R_BRACE pop_scope [ STATE R_BRACE PRAGMA AT ]
valueSetDeclaration -> annotations . VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
valueSetDeclaration -> annotations . VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
valueSetDeclaration -> annotations . VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
variableDeclaration -> annotations . typeRef name optInitialValue SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On VARBIT shift to state 2
-- On VALUESET shift to state 787
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On STATE shift to state 777
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On CONST shift to state 660
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On typeRef shift to state 666
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 787:
## Known stack suffix:
## annotations VALUESET
## LR(1) items:
valueSetDeclaration -> annotations VALUESET . L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
valueSetDeclaration -> annotations VALUESET . L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
valueSetDeclaration -> annotations VALUESET . L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On L_ANGLE shift to state 788
## Reductions:

State 788:
## Known stack suffix:
## annotations VALUESET L_ANGLE
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE . baseType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
valueSetDeclaration -> annotations VALUESET L_ANGLE . tupleType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
valueSetDeclaration -> annotations VALUESET L_ANGLE . typeName R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On typeName shift to state 789
-- On tupleType shift to state 796
-- On prefixedType shift to state 582
-- On dotPrefix shift to state 143
-- On baseType shift to state 803
## Reductions:

State 789:
## Known stack suffix:
## annotations VALUESET L_ANGLE typeName
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE typeName . R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On R_ANGLE shift to state 790
## Reductions:

State 790:
## Known stack suffix:
## annotations VALUESET L_ANGLE typeName R_ANGLE
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE typeName R_ANGLE . L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On L_PAREN shift to state 791
## Reductions:

State 791:
## Known stack suffix:
## annotations VALUESET L_ANGLE typeName R_ANGLE L_PAREN
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE typeName R_ANGLE L_PAREN . expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 792
-- On dotPrefix shift to state 91
## Reductions:

State 792:
## Known stack suffix:
## annotations VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
valueSetDeclaration -> annotations VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression . R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 793
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 793:
## Known stack suffix:
## annotations VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN . name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 794
## Reductions:

State 794:
## Known stack suffix:
## annotations VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name . SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On SEMICOLON shift to state 795
## Reductions:

State 795:
## Known stack suffix:
## annotations VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name SEMICOLON
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name SEMICOLON . [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production valueSetDeclaration -> annotations VALUESET L_ANGLE typeName R_ANGLE L_PAREN expression R_PAREN name SEMICOLON

State 796:
## Known stack suffix:
## annotations VALUESET L_ANGLE tupleType
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE tupleType . R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On R_ANGLE shift to state 797
## Reductions:

State 797:
## Known stack suffix:
## annotations VALUESET L_ANGLE tupleType R_ANGLE
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE tupleType R_ANGLE . L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On L_PAREN shift to state 798
## Reductions:

State 798:
## Known stack suffix:
## annotations VALUESET L_ANGLE tupleType R_ANGLE L_PAREN
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE tupleType R_ANGLE L_PAREN . expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 799
-- On dotPrefix shift to state 91
## Reductions:

State 799:
## Known stack suffix:
## annotations VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
valueSetDeclaration -> annotations VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression . R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 800
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 800:
## Known stack suffix:
## annotations VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN . name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 801
## Reductions:

State 801:
## Known stack suffix:
## annotations VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name . SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On SEMICOLON shift to state 802
## Reductions:

State 802:
## Known stack suffix:
## annotations VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON . [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production valueSetDeclaration -> annotations VALUESET L_ANGLE tupleType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON

State 803:
## Known stack suffix:
## annotations VALUESET L_ANGLE baseType
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE baseType . R_ANGLE L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On R_ANGLE shift to state 804
## Reductions:

State 804:
## Known stack suffix:
## annotations VALUESET L_ANGLE baseType R_ANGLE
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE baseType R_ANGLE . L_PAREN expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On L_PAREN shift to state 805
## Reductions:

State 805:
## Known stack suffix:
## annotations VALUESET L_ANGLE baseType R_ANGLE L_PAREN
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE baseType R_ANGLE L_PAREN . expression R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On expression shift to state 806
-- On dotPrefix shift to state 91
## Reductions:

State 806:
## Known stack suffix:
## annotations VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_PAREN R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV BIT_XOR BIT_OR BIT_AND AND ]
valueSetDeclaration -> annotations VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression . R_PAREN name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On SHL shift to state 64
-- On R_PAREN shift to state 807
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 807:
## Known stack suffix:
## annotations VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN . name SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 808
## Reductions:

State 808:
## Known stack suffix:
## annotations VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name . SEMICOLON [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
-- On SEMICOLON shift to state 809
## Reductions:

State 809:
## Known stack suffix:
## annotations VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON
## LR(1) items:
valueSetDeclaration -> annotations VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON . [ VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production valueSetDeclaration -> annotations VALUESET L_ANGLE baseType R_ANGLE L_PAREN expression R_PAREN name SEMICOLON

State 810:
## Known stack suffix:
## parserDeclaration
## LR(1) items:
topDeclaration -> parserDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production topDeclaration -> parserDeclaration

State 811:
## Known stack suffix:
## packageTypeDeclaration
## LR(1) items:
typeDeclaration -> packageTypeDeclaration . pop_scope SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On pop_scope shift to state 812
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 812:
## Known stack suffix:
## packageTypeDeclaration pop_scope
## LR(1) items:
typeDeclaration -> packageTypeDeclaration pop_scope . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 813
## Reductions:

State 813:
## Known stack suffix:
## packageTypeDeclaration pop_scope SEMICOLON
## LR(1) items:
typeDeclaration -> packageTypeDeclaration pop_scope SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeDeclaration -> packageTypeDeclaration pop_scope SEMICOLON

State 814:
## Known stack suffix:
## matchKindDeclaration
## LR(1) items:
topDeclaration -> matchKindDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production topDeclaration -> matchKindDeclaration

State 815:
## Known stack suffix:
## instantiation
## LR(1) items:
topDeclaration -> instantiation . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production topDeclaration -> instantiation

State 816:
## Known stack suffix:
## functionDeclaration
## LR(1) items:
topDeclaration -> functionDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production topDeclaration -> functionDeclaration

State 817:
## Known stack suffix:
## externDeclaration
## LR(1) items:
topDeclaration -> externDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production topDeclaration -> externDeclaration

State 818:
## Known stack suffix:
## errorDeclaration
## LR(1) items:
topDeclaration -> errorDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production topDeclaration -> errorDeclaration

State 819:
## Known stack suffix:
## derivedTypeDeclaration
## LR(1) items:
typeDeclaration -> derivedTypeDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeDeclaration -> derivedTypeDeclaration

State 820:
## Known stack suffix:
## controlTypeDeclaration
## LR(1) items:
controlDeclaration -> controlTypeDeclaration . optConstructorParameters L_BRACE petr4_list(controlLocalDeclaration) APPLY controlBody R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
typeDeclaration -> controlTypeDeclaration . pop_scope SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On L_PAREN shift to state 677
-- On pop_scope shift to state 821
-- On optConstructorParameters shift to state 823
## Reductions:
-- On L_BRACE
--   reduce production optConstructorParameters ->
-- On SEMICOLON
--   reduce production pop_scope ->

State 821:
## Known stack suffix:
## controlTypeDeclaration pop_scope
## LR(1) items:
typeDeclaration -> controlTypeDeclaration pop_scope . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 822
## Reductions:

State 822:
## Known stack suffix:
## controlTypeDeclaration pop_scope SEMICOLON
## LR(1) items:
typeDeclaration -> controlTypeDeclaration pop_scope SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typeDeclaration -> controlTypeDeclaration pop_scope SEMICOLON

State 823:
## Known stack suffix:
## controlTypeDeclaration optConstructorParameters
## LR(1) items:
controlDeclaration -> controlTypeDeclaration optConstructorParameters . L_BRACE petr4_list(controlLocalDeclaration) APPLY controlBody R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On L_BRACE shift to state 824
## Reductions:

State 824:
## Known stack suffix:
## controlTypeDeclaration optConstructorParameters L_BRACE
## LR(1) items:
controlDeclaration -> controlTypeDeclaration optConstructorParameters L_BRACE . petr4_list(controlLocalDeclaration) APPLY controlBody R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On petr4_list(controlLocalDeclaration) shift to state 825
-- On list_aux(controlLocalDeclaration) shift to state 831
## Default reduction:
-- After reading the next token, reduce production list_aux(controlLocalDeclaration) ->

State 825:
## Known stack suffix:
## controlTypeDeclaration optConstructorParameters L_BRACE petr4_list(controlLocalDeclaration)
## LR(1) items:
controlDeclaration -> controlTypeDeclaration optConstructorParameters L_BRACE petr4_list(controlLocalDeclaration) . APPLY controlBody R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On APPLY shift to state 826
## Reductions:

State 826:
## Known stack suffix:
## controlTypeDeclaration optConstructorParameters L_BRACE petr4_list(controlLocalDeclaration) APPLY
## LR(1) items:
controlDeclaration -> controlTypeDeclaration optConstructorParameters L_BRACE petr4_list(controlLocalDeclaration) APPLY . controlBody R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On PRAGMA shift to state 207
-- On L_BRACE shift to state 532
-- On AT shift to state 302
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On controlBody shift to state 827
-- On blockStatement shift to state 830
-- On annotations shift to state 551
-- On annotation shift to state 331
## Reductions:

State 827:
## Known stack suffix:
## controlTypeDeclaration optConstructorParameters L_BRACE petr4_list(controlLocalDeclaration) APPLY controlBody
## LR(1) items:
controlDeclaration -> controlTypeDeclaration optConstructorParameters L_BRACE petr4_list(controlLocalDeclaration) APPLY controlBody . R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On R_BRACE shift to state 828
## Reductions:

State 828:
## Known stack suffix:
## controlTypeDeclaration optConstructorParameters L_BRACE petr4_list(controlLocalDeclaration) APPLY controlBody R_BRACE
## LR(1) items:
controlDeclaration -> controlTypeDeclaration optConstructorParameters L_BRACE petr4_list(controlLocalDeclaration) APPLY controlBody R_BRACE . pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On pop_scope shift to state 829
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 829:
## Known stack suffix:
## controlTypeDeclaration optConstructorParameters L_BRACE petr4_list(controlLocalDeclaration) APPLY controlBody R_BRACE pop_scope
## LR(1) items:
controlDeclaration -> controlTypeDeclaration optConstructorParameters L_BRACE petr4_list(controlLocalDeclaration) APPLY controlBody R_BRACE pop_scope . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production controlDeclaration -> controlTypeDeclaration optConstructorParameters L_BRACE petr4_list(controlLocalDeclaration) APPLY controlBody R_BRACE pop_scope

State 830:
## Known stack suffix:
## blockStatement
## LR(1) items:
controlBody -> blockStatement . [ R_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production controlBody -> blockStatement

State 831:
## Known stack suffix:
## list_aux(controlLocalDeclaration)
## LR(1) items:
list_aux(controlLocalDeclaration) -> list_aux(controlLocalDeclaration) . controlLocalDeclaration [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
petr4_list(controlLocalDeclaration) -> list_aux(controlLocalDeclaration) . [ APPLY ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On TABLE shift to state 832
-- On STRING shift to state 18
-- On PRAGMA shift to state 207
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On CONST shift to state 520
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On ACTION shift to state 527
-- On variableDeclaration shift to state 912
-- On typeRef shift to state 619
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On tableDeclaration shift to state 913
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On instantiation shift to state 914
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On controlLocalDeclaration shift to state 915
-- On constantDeclaration shift to state 916
-- On baseType shift to state 146
-- On annotations shift to state 917
-- On annotation shift to state 331
-- On actionDeclaration shift to state 929
## Reductions:
-- On APPLY
--   reduce production petr4_list(controlLocalDeclaration) -> list_aux(controlLocalDeclaration)

State 832:
## Known stack suffix:
## TABLE
## LR(1) items:
tableDeclaration -> TABLE . name L_BRACE tablePropertyList R_BRACE [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 833
## Reductions:

State 833:
## Known stack suffix:
## TABLE name
## LR(1) items:
tableDeclaration -> TABLE name . L_BRACE tablePropertyList R_BRACE [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On L_BRACE shift to state 834
## Reductions:

State 834:
## Known stack suffix:
## TABLE name L_BRACE
## LR(1) items:
tableDeclaration -> TABLE name L_BRACE . tablePropertyList R_BRACE [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On TYPE shift to state 835
-- On STATE shift to state 836
-- On PRAGMA shift to state 207
-- On NAME shift to state 837
-- On KEY shift to state 839
-- On CONST shift to state 853
-- On AT shift to state 302
-- On APPLY shift to state 877
-- On ACTIONS shift to state 883
-- On varName shift to state 878
-- On tablePropertyList shift to state 892
-- On tableProperty shift to state 894
-- On petr4_nonempty_list(tableProperty) shift to state 895
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(tableProperty) shift to state 896
-- On nonempty_list_aux(annotation) shift to state 325
-- On nonTableKwName shift to state 898
-- On annotations shift to state 902
-- On annotation shift to state 331
## Reductions:

State 835:
## Known stack suffix:
## TYPE
## LR(1) items:
nonTableKwName -> TYPE . [ ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTableKwName -> TYPE

State 836:
## Known stack suffix:
## STATE
## LR(1) items:
nonTableKwName -> STATE . [ ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTableKwName -> STATE

State 837:
## Known stack suffix:
## NAME
## LR(1) items:
nonTableKwName -> NAME . TYPENAME [ ASSIGN ]
varName -> NAME . IDENTIFIER [ ASSIGN ]
## Transitions:
-- On TYPENAME shift to state 838
-- On IDENTIFIER shift to state 13
## Reductions:

State 838:
## Known stack suffix:
## NAME TYPENAME
## LR(1) items:
nonTableKwName -> NAME TYPENAME . [ ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTableKwName -> NAME TYPENAME

State 839:
## Known stack suffix:
## KEY
## LR(1) items:
tableProperty -> KEY . ASSIGN L_BRACE keyElementList R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On ASSIGN shift to state 840
## Reductions:

State 840:
## Known stack suffix:
## KEY ASSIGN
## LR(1) items:
tableProperty -> KEY ASSIGN . L_BRACE keyElementList R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On L_BRACE shift to state 841
## Reductions:

State 841:
## Known stack suffix:
## KEY ASSIGN L_BRACE
## LR(1) items:
tableProperty -> KEY ASSIGN L_BRACE . keyElementList R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On petr4_list(keyElement) shift to state 842
-- On list_aux(keyElement) shift to state 843
-- On keyElementList shift to state 851
## Default reduction:
-- After reading the next token, reduce production list_aux(keyElement) ->

State 842:
## Known stack suffix:
## petr4_list(keyElement)
## LR(1) items:
keyElementList -> petr4_list(keyElement) . [ R_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production keyElementList -> petr4_list(keyElement)

State 843:
## Known stack suffix:
## list_aux(keyElement)
## LR(1) items:
list_aux(keyElement) -> list_aux(keyElement) . keyElement [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS ]
petr4_list(keyElement) -> list_aux(keyElement) . [ R_BRACE ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On keyElement shift to state 844
-- On expression shift to state 845
-- On dotPrefix shift to state 91
## Reductions:
-- On R_BRACE
--   reduce production petr4_list(keyElement) -> list_aux(keyElement)

State 844:
## Known stack suffix:
## list_aux(keyElement) keyElement
## LR(1) items:
list_aux(keyElement) -> list_aux(keyElement) keyElement . [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_aux(keyElement) -> list_aux(keyElement) keyElement

State 845:
## Known stack suffix:
## expression
## LR(1) items:
expression -> expression . L_BRACKET expression R_BRACKET [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_BRACKET expression COLON expression R_BRACKET [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DOT member [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MUL expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . DIV expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MOD expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUS_SAT expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . MINUS_SAT expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . SHL expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE R_ANGLE expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . LE expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . GE expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . R_ANGLE expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . NE expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . EQ expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_AND expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_XOR expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . BIT_OR expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . PLUSPLUS expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . AND expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . OR expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . QUESTION expression COLON expression [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_ANGLE realTypeArgumentList R_ANGLE L_PAREN argumentList R_PAREN [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
expression -> expression . L_PAREN argumentList R_PAREN [ SHL R_ANGLE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COLON BIT_XOR BIT_OR BIT_AND AND ]
keyElement -> expression . COLON name SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS ]
keyElement -> expression . COLON name annotations SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS ]
## Transitions:
-- On SHL shift to state 64
-- On R_ANGLE shift to state 73
-- On QUESTION shift to state 83
-- On PLUS_SAT shift to state 66
-- On PLUSPLUS shift to state 76
-- On PLUS shift to state 85
-- On OR shift to state 98
-- On NE shift to state 100
-- On MUL shift to state 68
-- On MOD shift to state 78
-- On MINUS_SAT shift to state 102
-- On MINUS shift to state 104
-- On L_PAREN shift to state 70
-- On L_BRACKET shift to state 80
-- On L_ANGLE shift to state 106
-- On LE shift to state 114
-- On GE shift to state 122
-- On EQ shift to state 124
-- On DOT shift to state 87
-- On DIV shift to state 89
-- On COLON shift to state 846
-- On BIT_XOR shift to state 116
-- On BIT_OR shift to state 120
-- On BIT_AND shift to state 118
-- On AND shift to state 126
## Reductions:

State 846:
## Known stack suffix:
## expression COLON
## LR(1) items:
keyElement -> expression COLON . name SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS ]
keyElement -> expression COLON . name annotations SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 847
## Reductions:

State 847:
## Known stack suffix:
## expression COLON name
## LR(1) items:
keyElement -> expression COLON name . SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS ]
keyElement -> expression COLON name . annotations SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 848
-- On PRAGMA shift to state 207
-- On AT shift to state 302
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On annotations shift to state 849
-- On annotation shift to state 331
## Reductions:

State 848:
## Known stack suffix:
## expression COLON name SEMICOLON
## LR(1) items:
keyElement -> expression COLON name SEMICOLON . [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production keyElement -> expression COLON name SEMICOLON

State 849:
## Known stack suffix:
## expression COLON name annotations
## LR(1) items:
keyElement -> expression COLON name annotations . SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 850
## Reductions:

State 850:
## Known stack suffix:
## expression COLON name annotations SEMICOLON
## LR(1) items:
keyElement -> expression COLON name annotations SEMICOLON . [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production keyElement -> expression COLON name annotations SEMICOLON

State 851:
## Known stack suffix:
## KEY ASSIGN L_BRACE keyElementList
## LR(1) items:
tableProperty -> KEY ASSIGN L_BRACE keyElementList . R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On R_BRACE shift to state 852
## Reductions:

State 852:
## Known stack suffix:
## KEY ASSIGN L_BRACE keyElementList R_BRACE
## LR(1) items:
tableProperty -> KEY ASSIGN L_BRACE keyElementList R_BRACE . [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tableProperty -> KEY ASSIGN L_BRACE keyElementList R_BRACE

State 853:
## Known stack suffix:
## CONST
## LR(1) items:
tableProperty -> CONST . ENTRIES ASSIGN L_BRACE entriesList R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
tableProperty -> CONST . nonTableKwName ASSIGN initialValue SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 835
-- On STATE shift to state 836
-- On NAME shift to state 837
-- On ENTRIES shift to state 854
-- On APPLY shift to state 877
-- On varName shift to state 878
-- On nonTableKwName shift to state 879
## Reductions:

State 854:
## Known stack suffix:
## CONST ENTRIES
## LR(1) items:
tableProperty -> CONST ENTRIES . ASSIGN L_BRACE entriesList R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On ASSIGN shift to state 855
## Reductions:

State 855:
## Known stack suffix:
## CONST ENTRIES ASSIGN
## LR(1) items:
tableProperty -> CONST ENTRIES ASSIGN . L_BRACE entriesList R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On L_BRACE shift to state 856
## Reductions:

State 856:
## Known stack suffix:
## CONST ENTRIES ASSIGN L_BRACE
## LR(1) items:
tableProperty -> CONST ENTRIES ASSIGN L_BRACE . entriesList R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On petr4_list(entry) shift to state 857
-- On list_aux(entry) shift to state 858
-- On entriesList shift to state 875
## Default reduction:
-- After reading the next token, reduce production list_aux(entry) ->

State 857:
## Known stack suffix:
## petr4_list(entry)
## LR(1) items:
entriesList -> petr4_list(entry) . [ R_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production entriesList -> petr4_list(entry)

State 858:
## Known stack suffix:
## list_aux(entry)
## LR(1) items:
list_aux(entry) -> list_aux(entry) . entry [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
petr4_list(entry) -> list_aux(entry) . [ R_BRACE ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 721
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 722
-- On DEFAULT shift to state 723
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tupleKeysetExpression shift to state 737
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On simpleKeysetExpression shift to state 738
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On keysetExpression shift to state 859
-- On expression shift to state 728
-- On entry shift to state 874
-- On dotPrefix shift to state 91
## Reductions:
-- On R_BRACE
--   reduce production petr4_list(entry) -> list_aux(entry)

State 859:
## Known stack suffix:
## keysetExpression
## LR(1) items:
entry -> keysetExpression . COLON actionRef SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
entry -> keysetExpression . COLON actionRef annotations SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
## Transitions:
-- On COLON shift to state 860
## Reductions:

State 860:
## Known stack suffix:
## keysetExpression COLON
## LR(1) items:
entry -> keysetExpression COLON . actionRef SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
entry -> keysetExpression COLON . actionRef annotations SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On PRAGMA shift to state 207
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On AT shift to state 302
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On nonTypeName shift to state 35
-- On name shift to state 861
-- On annotations shift to state 865
-- On annotation shift to state 331
-- On actionRef shift to state 870
## Reductions:

State 861:
## Known stack suffix:
## name
## LR(1) items:
actionRef -> name . [ SEMICOLON PRAGMA AT ]
actionRef -> name . L_PAREN argumentList R_PAREN [ SEMICOLON PRAGMA AT ]
## Transitions:
-- On L_PAREN shift to state 862
## Reductions:
-- On SEMICOLON PRAGMA AT
--   reduce production actionRef -> name

State 862:
## Known stack suffix:
## name L_PAREN
## LR(1) items:
actionRef -> name L_PAREN . argumentList R_PAREN [ SEMICOLON PRAGMA AT ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 55
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 57
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_list_aux(COMMA,argument) shift to state 58
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,argument) shift to state 71
-- On nonTypeName shift to state 60
-- On namedType shift to state 53
-- On name shift to state 61
-- On expression shift to state 72
-- On dotPrefix shift to state 91
-- On argumentList shift to state 863
-- On argument shift to state 135
## Reductions:
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,argument) ->

State 863:
## Known stack suffix:
## name L_PAREN argumentList
## LR(1) items:
actionRef -> name L_PAREN argumentList . R_PAREN [ SEMICOLON PRAGMA AT ]
## Transitions:
-- On R_PAREN shift to state 864
## Reductions:

State 864:
## Known stack suffix:
## name L_PAREN argumentList R_PAREN
## LR(1) items:
actionRef -> name L_PAREN argumentList R_PAREN . [ SEMICOLON PRAGMA AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production actionRef -> name L_PAREN argumentList R_PAREN

State 865:
## Known stack suffix:
## annotations
## LR(1) items:
actionRef -> annotations . name [ SEMICOLON PRAGMA AT ]
actionRef -> annotations . name L_PAREN argumentList R_PAREN [ SEMICOLON PRAGMA AT ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 866
## Reductions:

State 866:
## Known stack suffix:
## annotations name
## LR(1) items:
actionRef -> annotations name . [ SEMICOLON PRAGMA AT ]
actionRef -> annotations name . L_PAREN argumentList R_PAREN [ SEMICOLON PRAGMA AT ]
## Transitions:
-- On L_PAREN shift to state 867
## Reductions:
-- On SEMICOLON PRAGMA AT
--   reduce production actionRef -> annotations name

State 867:
## Known stack suffix:
## annotations name L_PAREN
## LR(1) items:
actionRef -> annotations name L_PAREN . argumentList R_PAREN [ SEMICOLON PRAGMA AT ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 55
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On DONTCARE shift to state 57
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On separated_list_aux(COMMA,argument) shift to state 58
-- On prefixedType shift to state 44
-- On petr4_separated_list(COMMA,argument) shift to state 71
-- On nonTypeName shift to state 60
-- On namedType shift to state 53
-- On name shift to state 61
-- On expression shift to state 72
-- On dotPrefix shift to state 91
-- On argumentList shift to state 868
-- On argument shift to state 135
## Reductions:
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,argument) ->

State 868:
## Known stack suffix:
## annotations name L_PAREN argumentList
## LR(1) items:
actionRef -> annotations name L_PAREN argumentList . R_PAREN [ SEMICOLON PRAGMA AT ]
## Transitions:
-- On R_PAREN shift to state 869
## Reductions:

State 869:
## Known stack suffix:
## annotations name L_PAREN argumentList R_PAREN
## LR(1) items:
actionRef -> annotations name L_PAREN argumentList R_PAREN . [ SEMICOLON PRAGMA AT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production actionRef -> annotations name L_PAREN argumentList R_PAREN

State 870:
## Known stack suffix:
## keysetExpression COLON actionRef
## LR(1) items:
entry -> keysetExpression COLON actionRef . SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
entry -> keysetExpression COLON actionRef . annotations SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 871
-- On PRAGMA shift to state 207
-- On AT shift to state 302
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On annotations shift to state 872
-- On annotation shift to state 331
## Reductions:

State 871:
## Known stack suffix:
## keysetExpression COLON actionRef SEMICOLON
## LR(1) items:
entry -> keysetExpression COLON actionRef SEMICOLON . [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production entry -> keysetExpression COLON actionRef SEMICOLON

State 872:
## Known stack suffix:
## keysetExpression COLON actionRef annotations
## LR(1) items:
entry -> keysetExpression COLON actionRef annotations . SEMICOLON [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 873
## Reductions:

State 873:
## Known stack suffix:
## keysetExpression COLON actionRef annotations SEMICOLON
## LR(1) items:
entry -> keysetExpression COLON actionRef annotations SEMICOLON . [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production entry -> keysetExpression COLON actionRef annotations SEMICOLON

State 874:
## Known stack suffix:
## list_aux(entry) entry
## LR(1) items:
list_aux(entry) -> list_aux(entry) entry . [ TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_aux(entry) -> list_aux(entry) entry

State 875:
## Known stack suffix:
## CONST ENTRIES ASSIGN L_BRACE entriesList
## LR(1) items:
tableProperty -> CONST ENTRIES ASSIGN L_BRACE entriesList . R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On R_BRACE shift to state 876
## Reductions:

State 876:
## Known stack suffix:
## CONST ENTRIES ASSIGN L_BRACE entriesList R_BRACE
## LR(1) items:
tableProperty -> CONST ENTRIES ASSIGN L_BRACE entriesList R_BRACE . [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tableProperty -> CONST ENTRIES ASSIGN L_BRACE entriesList R_BRACE

State 877:
## Known stack suffix:
## APPLY
## LR(1) items:
nonTableKwName -> APPLY . [ ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTableKwName -> APPLY

State 878:
## Known stack suffix:
## varName
## LR(1) items:
nonTableKwName -> varName . [ ASSIGN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonTableKwName -> varName

State 879:
## Known stack suffix:
## CONST nonTableKwName
## LR(1) items:
tableProperty -> CONST nonTableKwName . ASSIGN initialValue SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On ASSIGN shift to state 880
## Reductions:

State 880:
## Known stack suffix:
## CONST nonTableKwName ASSIGN
## LR(1) items:
tableProperty -> CONST nonTableKwName ASSIGN . initialValue SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On initialValue shift to state 881
-- On expression shift to state 526
-- On dotPrefix shift to state 91
## Reductions:

State 881:
## Known stack suffix:
## CONST nonTableKwName ASSIGN initialValue
## LR(1) items:
tableProperty -> CONST nonTableKwName ASSIGN initialValue . SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 882
## Reductions:

State 882:
## Known stack suffix:
## CONST nonTableKwName ASSIGN initialValue SEMICOLON
## LR(1) items:
tableProperty -> CONST nonTableKwName ASSIGN initialValue SEMICOLON . [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tableProperty -> CONST nonTableKwName ASSIGN initialValue SEMICOLON

State 883:
## Known stack suffix:
## ACTIONS
## LR(1) items:
tableProperty -> ACTIONS . ASSIGN L_BRACE actionList R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On ASSIGN shift to state 884
## Reductions:

State 884:
## Known stack suffix:
## ACTIONS ASSIGN
## LR(1) items:
tableProperty -> ACTIONS ASSIGN . L_BRACE actionList R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On L_BRACE shift to state 885
## Reductions:

State 885:
## Known stack suffix:
## ACTIONS ASSIGN L_BRACE
## LR(1) items:
tableProperty -> ACTIONS ASSIGN L_BRACE . actionList R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On PRAGMA shift to state 207
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On AT shift to state 302
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On separated_nonempty_list_aux(SEMICOLON,actionRef) shift to state 886
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On nonTypeName shift to state 35
-- On name shift to state 861
-- On annotations shift to state 865
-- On annotation shift to state 331
-- On actionRef shift to state 889
-- On actionList shift to state 890
## Reductions:
-- On R_BRACE
--   reduce production actionList ->

State 886:
## Known stack suffix:
## separated_nonempty_list_aux(SEMICOLON,actionRef)
## LR(1) items:
actionList -> separated_nonempty_list_aux(SEMICOLON,actionRef) . SEMICOLON [ R_BRACE ]
separated_nonempty_list_aux(SEMICOLON,actionRef) -> separated_nonempty_list_aux(SEMICOLON,actionRef) . SEMICOLON actionRef [ SEMICOLON ]
## Transitions:
-- On SEMICOLON shift to state 887
## Reductions:

State 887:
## Known stack suffix:
## separated_nonempty_list_aux(SEMICOLON,actionRef) SEMICOLON
## LR(1) items:
actionList -> separated_nonempty_list_aux(SEMICOLON,actionRef) SEMICOLON . [ R_BRACE ]
separated_nonempty_list_aux(SEMICOLON,actionRef) -> separated_nonempty_list_aux(SEMICOLON,actionRef) SEMICOLON . actionRef [ SEMICOLON ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On PRAGMA shift to state 207
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On AT shift to state 302
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On nonTypeName shift to state 35
-- On name shift to state 861
-- On annotations shift to state 865
-- On annotation shift to state 331
-- On actionRef shift to state 888
## Reductions:
-- On R_BRACE
--   reduce production actionList -> separated_nonempty_list_aux(SEMICOLON,actionRef) SEMICOLON

State 888:
## Known stack suffix:
## separated_nonempty_list_aux(SEMICOLON,actionRef) SEMICOLON actionRef
## LR(1) items:
separated_nonempty_list_aux(SEMICOLON,actionRef) -> separated_nonempty_list_aux(SEMICOLON,actionRef) SEMICOLON actionRef . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list_aux(SEMICOLON,actionRef) -> separated_nonempty_list_aux(SEMICOLON,actionRef) SEMICOLON actionRef

State 889:
## Known stack suffix:
## actionRef
## LR(1) items:
separated_nonempty_list_aux(SEMICOLON,actionRef) -> actionRef . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list_aux(SEMICOLON,actionRef) -> actionRef

State 890:
## Known stack suffix:
## ACTIONS ASSIGN L_BRACE actionList
## LR(1) items:
tableProperty -> ACTIONS ASSIGN L_BRACE actionList . R_BRACE [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On R_BRACE shift to state 891
## Reductions:

State 891:
## Known stack suffix:
## ACTIONS ASSIGN L_BRACE actionList R_BRACE
## LR(1) items:
tableProperty -> ACTIONS ASSIGN L_BRACE actionList R_BRACE . [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tableProperty -> ACTIONS ASSIGN L_BRACE actionList R_BRACE

State 892:
## Known stack suffix:
## TABLE name L_BRACE tablePropertyList
## LR(1) items:
tableDeclaration -> TABLE name L_BRACE tablePropertyList . R_BRACE [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On R_BRACE shift to state 893
## Reductions:

State 893:
## Known stack suffix:
## TABLE name L_BRACE tablePropertyList R_BRACE
## LR(1) items:
tableDeclaration -> TABLE name L_BRACE tablePropertyList R_BRACE . [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tableDeclaration -> TABLE name L_BRACE tablePropertyList R_BRACE

State 894:
## Known stack suffix:
## tableProperty
## LR(1) items:
nonempty_list_aux(tableProperty) -> tableProperty . [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list_aux(tableProperty) -> tableProperty

State 895:
## Known stack suffix:
## petr4_nonempty_list(tableProperty)
## LR(1) items:
tablePropertyList -> petr4_nonempty_list(tableProperty) . [ R_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tablePropertyList -> petr4_nonempty_list(tableProperty)

State 896:
## Known stack suffix:
## nonempty_list_aux(tableProperty)
## LR(1) items:
nonempty_list_aux(tableProperty) -> nonempty_list_aux(tableProperty) . tableProperty [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
petr4_nonempty_list(tableProperty) -> nonempty_list_aux(tableProperty) . [ R_BRACE ]
## Transitions:
-- On TYPE shift to state 835
-- On STATE shift to state 836
-- On PRAGMA shift to state 207
-- On NAME shift to state 837
-- On KEY shift to state 839
-- On CONST shift to state 853
-- On AT shift to state 302
-- On APPLY shift to state 877
-- On ACTIONS shift to state 883
-- On varName shift to state 878
-- On tableProperty shift to state 897
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On nonTableKwName shift to state 898
-- On annotations shift to state 902
-- On annotation shift to state 331
## Reductions:
-- On R_BRACE
--   reduce production petr4_nonempty_list(tableProperty) -> nonempty_list_aux(tableProperty)

State 897:
## Known stack suffix:
## nonempty_list_aux(tableProperty) tableProperty
## LR(1) items:
nonempty_list_aux(tableProperty) -> nonempty_list_aux(tableProperty) tableProperty . [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list_aux(tableProperty) -> nonempty_list_aux(tableProperty) tableProperty

State 898:
## Known stack suffix:
## nonTableKwName
## LR(1) items:
tableProperty -> nonTableKwName . ASSIGN initialValue SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On ASSIGN shift to state 899
## Reductions:

State 899:
## Known stack suffix:
## nonTableKwName ASSIGN
## LR(1) items:
tableProperty -> nonTableKwName ASSIGN . initialValue SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On initialValue shift to state 900
-- On expression shift to state 526
-- On dotPrefix shift to state 91
## Reductions:

State 900:
## Known stack suffix:
## nonTableKwName ASSIGN initialValue
## LR(1) items:
tableProperty -> nonTableKwName ASSIGN initialValue . SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 901
## Reductions:

State 901:
## Known stack suffix:
## nonTableKwName ASSIGN initialValue SEMICOLON
## LR(1) items:
tableProperty -> nonTableKwName ASSIGN initialValue SEMICOLON . [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tableProperty -> nonTableKwName ASSIGN initialValue SEMICOLON

State 902:
## Known stack suffix:
## annotations
## LR(1) items:
tableProperty -> annotations . CONST nonTableKwName ASSIGN initialValue SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
tableProperty -> annotations . nonTableKwName ASSIGN initialValue SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 835
-- On STATE shift to state 836
-- On NAME shift to state 837
-- On CONST shift to state 903
-- On APPLY shift to state 877
-- On varName shift to state 878
-- On nonTableKwName shift to state 908
## Reductions:

State 903:
## Known stack suffix:
## annotations CONST
## LR(1) items:
tableProperty -> annotations CONST . nonTableKwName ASSIGN initialValue SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 835
-- On STATE shift to state 836
-- On NAME shift to state 837
-- On APPLY shift to state 877
-- On varName shift to state 878
-- On nonTableKwName shift to state 904
## Reductions:

State 904:
## Known stack suffix:
## annotations CONST nonTableKwName
## LR(1) items:
tableProperty -> annotations CONST nonTableKwName . ASSIGN initialValue SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On ASSIGN shift to state 905
## Reductions:

State 905:
## Known stack suffix:
## annotations CONST nonTableKwName ASSIGN
## LR(1) items:
tableProperty -> annotations CONST nonTableKwName ASSIGN . initialValue SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On initialValue shift to state 906
-- On expression shift to state 526
-- On dotPrefix shift to state 91
## Reductions:

State 906:
## Known stack suffix:
## annotations CONST nonTableKwName ASSIGN initialValue
## LR(1) items:
tableProperty -> annotations CONST nonTableKwName ASSIGN initialValue . SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 907
## Reductions:

State 907:
## Known stack suffix:
## annotations CONST nonTableKwName ASSIGN initialValue SEMICOLON
## LR(1) items:
tableProperty -> annotations CONST nonTableKwName ASSIGN initialValue SEMICOLON . [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tableProperty -> annotations CONST nonTableKwName ASSIGN initialValue SEMICOLON

State 908:
## Known stack suffix:
## annotations nonTableKwName
## LR(1) items:
tableProperty -> annotations nonTableKwName . ASSIGN initialValue SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On ASSIGN shift to state 909
## Reductions:

State 909:
## Known stack suffix:
## annotations nonTableKwName ASSIGN
## LR(1) items:
tableProperty -> annotations nonTableKwName ASSIGN . initialValue SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On TYPE shift to state 5
-- On TRUE shift to state 6
-- On STRING_LITERAL shift to state 7
-- On STATE shift to state 8
-- On PLUS shift to state 9
-- On NOT shift to state 10
-- On NAME shift to state 11
-- On MINUS shift to state 14
-- On L_PAREN shift to state 15
-- On L_BRACE shift to state 23
-- On KEY shift to state 19
-- On INTEGER shift to state 24
-- On FALSE shift to state 25
-- On ERROR shift to state 26
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On COMPLEMENT shift to state 39
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On typeName shift to state 40
-- On tableKwName shift to state 34
-- On specializedType shift to state 43
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 52
-- On namedType shift to state 53
-- On initialValue shift to state 910
-- On expression shift to state 526
-- On dotPrefix shift to state 91
## Reductions:

State 910:
## Known stack suffix:
## annotations nonTableKwName ASSIGN initialValue
## LR(1) items:
tableProperty -> annotations nonTableKwName ASSIGN initialValue . SEMICOLON [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
-- On SEMICOLON shift to state 911
## Reductions:

State 911:
## Known stack suffix:
## annotations nonTableKwName ASSIGN initialValue SEMICOLON
## LR(1) items:
tableProperty -> annotations nonTableKwName ASSIGN initialValue SEMICOLON . [ TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tableProperty -> annotations nonTableKwName ASSIGN initialValue SEMICOLON

State 912:
## Known stack suffix:
## variableDeclaration
## LR(1) items:
controlLocalDeclaration -> variableDeclaration . [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production controlLocalDeclaration -> variableDeclaration

State 913:
## Known stack suffix:
## tableDeclaration
## LR(1) items:
controlLocalDeclaration -> tableDeclaration . [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production controlLocalDeclaration -> tableDeclaration

State 914:
## Known stack suffix:
## instantiation
## LR(1) items:
controlLocalDeclaration -> instantiation . [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production controlLocalDeclaration -> instantiation

State 915:
## Known stack suffix:
## list_aux(controlLocalDeclaration) controlLocalDeclaration
## LR(1) items:
list_aux(controlLocalDeclaration) -> list_aux(controlLocalDeclaration) controlLocalDeclaration . [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list_aux(controlLocalDeclaration) -> list_aux(controlLocalDeclaration) controlLocalDeclaration

State 916:
## Known stack suffix:
## constantDeclaration
## LR(1) items:
controlLocalDeclaration -> constantDeclaration . [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production controlLocalDeclaration -> constantDeclaration

State 917:
## Known stack suffix:
## annotations
## LR(1) items:
actionDeclaration -> annotations . ACTION name L_PAREN parameterList R_PAREN blockStatement [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
constantDeclaration -> annotations . CONST typeRef name ASSIGN initialValue SEMICOLON [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
instantiation -> annotations . typeRef L_PAREN argumentList R_PAREN name SEMICOLON [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
instantiation -> annotations . typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
tableDeclaration -> annotations . TABLE name L_BRACE tablePropertyList R_BRACE [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
variableDeclaration -> annotations . typeRef name optInitialValue SEMICOLON [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On TABLE shift to state 918
-- On STRING shift to state 18
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On CONST shift to state 660
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On ACTION shift to state 923
-- On typeRef shift to state 666
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 918:
## Known stack suffix:
## annotations TABLE
## LR(1) items:
tableDeclaration -> annotations TABLE . name L_BRACE tablePropertyList R_BRACE [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 919
## Reductions:

State 919:
## Known stack suffix:
## annotations TABLE name
## LR(1) items:
tableDeclaration -> annotations TABLE name . L_BRACE tablePropertyList R_BRACE [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On L_BRACE shift to state 920
## Reductions:

State 920:
## Known stack suffix:
## annotations TABLE name L_BRACE
## LR(1) items:
tableDeclaration -> annotations TABLE name L_BRACE . tablePropertyList R_BRACE [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On TYPE shift to state 835
-- On STATE shift to state 836
-- On PRAGMA shift to state 207
-- On NAME shift to state 837
-- On KEY shift to state 839
-- On CONST shift to state 853
-- On AT shift to state 302
-- On APPLY shift to state 877
-- On ACTIONS shift to state 883
-- On varName shift to state 878
-- On tablePropertyList shift to state 921
-- On tableProperty shift to state 894
-- On petr4_nonempty_list(tableProperty) shift to state 895
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(tableProperty) shift to state 896
-- On nonempty_list_aux(annotation) shift to state 325
-- On nonTableKwName shift to state 898
-- On annotations shift to state 902
-- On annotation shift to state 331
## Reductions:

State 921:
## Known stack suffix:
## annotations TABLE name L_BRACE tablePropertyList
## LR(1) items:
tableDeclaration -> annotations TABLE name L_BRACE tablePropertyList . R_BRACE [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On R_BRACE shift to state 922
## Reductions:

State 922:
## Known stack suffix:
## annotations TABLE name L_BRACE tablePropertyList R_BRACE
## LR(1) items:
tableDeclaration -> annotations TABLE name L_BRACE tablePropertyList R_BRACE . [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production tableDeclaration -> annotations TABLE name L_BRACE tablePropertyList R_BRACE

State 923:
## Known stack suffix:
## annotations ACTION
## LR(1) items:
actionDeclaration -> annotations ACTION . name L_PAREN parameterList R_PAREN blockStatement [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 924
## Reductions:

State 924:
## Known stack suffix:
## annotations ACTION name
## LR(1) items:
actionDeclaration -> annotations ACTION name . L_PAREN parameterList R_PAREN blockStatement [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On L_PAREN shift to state 925
## Reductions:

State 925:
## Known stack suffix:
## annotations ACTION name L_PAREN
## LR(1) items:
actionDeclaration -> annotations ACTION name L_PAREN . parameterList R_PAREN blockStatement [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On separated_list_aux(COMMA,parameter) shift to state 430
-- On petr4_separated_list(COMMA,parameter) shift to state 444
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameterList shift to state 926
-- On parameter shift to state 447
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,parameter) ->

State 926:
## Known stack suffix:
## annotations ACTION name L_PAREN parameterList
## LR(1) items:
actionDeclaration -> annotations ACTION name L_PAREN parameterList . R_PAREN blockStatement [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On R_PAREN shift to state 927
## Reductions:

State 927:
## Known stack suffix:
## annotations ACTION name L_PAREN parameterList R_PAREN
## LR(1) items:
actionDeclaration -> annotations ACTION name L_PAREN parameterList R_PAREN . blockStatement [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
-- On PRAGMA shift to state 207
-- On L_BRACE shift to state 532
-- On AT shift to state 302
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On blockStatement shift to state 928
-- On annotations shift to state 551
-- On annotation shift to state 331
## Reductions:

State 928:
## Known stack suffix:
## annotations ACTION name L_PAREN parameterList R_PAREN blockStatement
## LR(1) items:
actionDeclaration -> annotations ACTION name L_PAREN parameterList R_PAREN blockStatement . [ VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production actionDeclaration -> annotations ACTION name L_PAREN parameterList R_PAREN blockStatement

State 929:
## Known stack suffix:
## actionDeclaration
## LR(1) items:
controlLocalDeclaration -> actionDeclaration . [ VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production controlLocalDeclaration -> actionDeclaration

State 930:
## Known stack suffix:
## controlDeclaration
## LR(1) items:
topDeclaration -> controlDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production topDeclaration -> controlDeclaration

State 931:
## Known stack suffix:
## constantDeclaration
## LR(1) items:
topDeclaration -> constantDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production topDeclaration -> constantDeclaration

State 932:
## Known stack suffix:
## annotations
## LR(1) items:
actionDeclaration -> annotations . ACTION name L_PAREN parameterList R_PAREN blockStatement [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
constantDeclaration -> annotations . CONST typeRef name ASSIGN initialValue SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
controlTypeDeclaration -> annotations . CONTROL push_name optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
enumDeclaration -> annotations . ENUM name L_BRACE identifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
enumDeclaration -> annotations . ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
externDeclaration -> annotations . EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
externDeclaration -> annotations . EXTERN functionPrototype pop_scope SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
headerTypeDeclaration -> annotations . HEADER name L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
headerUnionDeclaration -> annotations . HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
instantiation -> annotations . typeRef L_PAREN argumentList R_PAREN name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
instantiation -> annotations . typeRef L_PAREN argumentList R_PAREN name ASSIGN objInitializer SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
packageTypeDeclaration -> annotations . PACKAGE push_name optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON ]
parserTypeDeclaration -> annotations . PARSER push_name optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
structTypeDeclaration -> annotations . STRUCT name L_BRACE petr4_list(structField) R_BRACE [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
typedefDeclaration -> annotations . TYPEDEF typeRef name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
typedefDeclaration -> annotations . TYPEDEF derivedTypeDeclaration name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
typedefDeclaration -> annotations . TYPE typeRef name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
typedefDeclaration -> annotations . TYPE derivedTypeDeclaration name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On VARBIT shift to state 2
-- On TYPEDEF shift to state 933
-- On TYPE shift to state 940
-- On TUPLE shift to state 16
-- On STRUCT shift to state 379
-- On STRING shift to state 18
-- On PARSER shift to state 947
-- On PACKAGE shift to state 953
-- On NAME shift to state 301
-- On INT shift to state 20
-- On HEADER_UNION shift to state 384
-- On HEADER shift to state 389
-- On EXTERN shift to state 959
-- On ERROR shift to state 46
-- On ENUM shift to state 394
-- On DOT shift to state 38
-- On CONTROL shift to state 969
-- On CONST shift to state 660
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On ACTION shift to state 923
-- On typeRef shift to state 638
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 933:
## Known stack suffix:
## annotations TYPEDEF
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF . typeRef name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
typedefDeclaration -> annotations TYPEDEF . derivedTypeDeclaration name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRUCT shift to state 201
-- On STRING shift to state 18
-- On PRAGMA shift to state 207
-- On NAME shift to state 301
-- On INT shift to state 20
-- On HEADER_UNION shift to state 332
-- On HEADER shift to state 337
-- On ERROR shift to state 46
-- On ENUM shift to state 342
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On typeRef shift to state 934
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On structTypeDeclaration shift to state 371
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On headerUnionDeclaration shift to state 372
-- On headerTypeDeclaration shift to state 373
-- On headerStackType shift to state 142
-- On enumDeclaration shift to state 374
-- On dotPrefix shift to state 143
-- On derivedTypeDeclaration shift to state 937
-- On baseType shift to state 146
-- On annotations shift to state 378
-- On annotation shift to state 331
## Reductions:

State 934:
## Known stack suffix:
## annotations TYPEDEF typeRef
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF typeRef . name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 935
## Reductions:

State 935:
## Known stack suffix:
## annotations TYPEDEF typeRef name
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF typeRef name . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 936
## Reductions:

State 936:
## Known stack suffix:
## annotations TYPEDEF typeRef name SEMICOLON
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF typeRef name SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typedefDeclaration -> annotations TYPEDEF typeRef name SEMICOLON

State 937:
## Known stack suffix:
## annotations TYPEDEF derivedTypeDeclaration
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF derivedTypeDeclaration . name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 938
## Reductions:

State 938:
## Known stack suffix:
## annotations TYPEDEF derivedTypeDeclaration name
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF derivedTypeDeclaration name . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 939
## Reductions:

State 939:
## Known stack suffix:
## annotations TYPEDEF derivedTypeDeclaration name SEMICOLON
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF derivedTypeDeclaration name SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typedefDeclaration -> annotations TYPEDEF derivedTypeDeclaration name SEMICOLON

State 940:
## Known stack suffix:
## annotations TYPE
## LR(1) items:
typedefDeclaration -> annotations TYPE . typeRef name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
typedefDeclaration -> annotations TYPE . derivedTypeDeclaration name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRUCT shift to state 201
-- On STRING shift to state 18
-- On PRAGMA shift to state 207
-- On NAME shift to state 301
-- On INT shift to state 20
-- On HEADER_UNION shift to state 332
-- On HEADER shift to state 337
-- On ERROR shift to state 46
-- On ENUM shift to state 342
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On typeRef shift to state 941
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On structTypeDeclaration shift to state 371
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On headerUnionDeclaration shift to state 372
-- On headerTypeDeclaration shift to state 373
-- On headerStackType shift to state 142
-- On enumDeclaration shift to state 374
-- On dotPrefix shift to state 143
-- On derivedTypeDeclaration shift to state 944
-- On baseType shift to state 146
-- On annotations shift to state 378
-- On annotation shift to state 331
## Reductions:

State 941:
## Known stack suffix:
## annotations TYPE typeRef
## LR(1) items:
typedefDeclaration -> annotations TYPE typeRef . name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 942
## Reductions:

State 942:
## Known stack suffix:
## annotations TYPE typeRef name
## LR(1) items:
typedefDeclaration -> annotations TYPE typeRef name . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 943
## Reductions:

State 943:
## Known stack suffix:
## annotations TYPE typeRef name SEMICOLON
## LR(1) items:
typedefDeclaration -> annotations TYPE typeRef name SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typedefDeclaration -> annotations TYPE typeRef name SEMICOLON

State 944:
## Known stack suffix:
## annotations TYPE derivedTypeDeclaration
## LR(1) items:
typedefDeclaration -> annotations TYPE derivedTypeDeclaration . name SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 945
## Reductions:

State 945:
## Known stack suffix:
## annotations TYPE derivedTypeDeclaration name
## LR(1) items:
typedefDeclaration -> annotations TYPE derivedTypeDeclaration name . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 946
## Reductions:

State 946:
## Known stack suffix:
## annotations TYPE derivedTypeDeclaration name SEMICOLON
## LR(1) items:
typedefDeclaration -> annotations TYPE derivedTypeDeclaration name SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production typedefDeclaration -> annotations TYPE derivedTypeDeclaration name SEMICOLON

State 947:
## Known stack suffix:
## annotations PARSER
## LR(1) items:
parserTypeDeclaration -> annotations PARSER . push_name optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On push_name shift to state 948
-- On nonTypeName shift to state 35
-- On name shift to state 448
## Reductions:

State 948:
## Known stack suffix:
## annotations PARSER push_name
## LR(1) items:
parserTypeDeclaration -> annotations PARSER push_name . optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On L_ANGLE shift to state 417
-- On optTypeParameters shift to state 949
## Reductions:
-- On L_PAREN
--   reduce production optTypeParameters ->

State 949:
## Known stack suffix:
## annotations PARSER push_name optTypeParameters
## LR(1) items:
parserTypeDeclaration -> annotations PARSER push_name optTypeParameters . L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On L_PAREN shift to state 950
## Reductions:

State 950:
## Known stack suffix:
## annotations PARSER push_name optTypeParameters L_PAREN
## LR(1) items:
parserTypeDeclaration -> annotations PARSER push_name optTypeParameters L_PAREN . parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On separated_list_aux(COMMA,parameter) shift to state 430
-- On petr4_separated_list(COMMA,parameter) shift to state 444
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameterList shift to state 951
-- On parameter shift to state 447
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,parameter) ->

State 951:
## Known stack suffix:
## annotations PARSER push_name optTypeParameters L_PAREN parameterList
## LR(1) items:
parserTypeDeclaration -> annotations PARSER push_name optTypeParameters L_PAREN parameterList . R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On R_PAREN shift to state 952
## Reductions:

State 952:
## Known stack suffix:
## annotations PARSER push_name optTypeParameters L_PAREN parameterList R_PAREN
## LR(1) items:
parserTypeDeclaration -> annotations PARSER push_name optTypeParameters L_PAREN parameterList R_PAREN . [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parserTypeDeclaration -> annotations PARSER push_name optTypeParameters L_PAREN parameterList R_PAREN

State 953:
## Known stack suffix:
## annotations PACKAGE
## LR(1) items:
packageTypeDeclaration -> annotations PACKAGE . push_name optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On push_name shift to state 954
-- On nonTypeName shift to state 35
-- On name shift to state 448
## Reductions:

State 954:
## Known stack suffix:
## annotations PACKAGE push_name
## LR(1) items:
packageTypeDeclaration -> annotations PACKAGE push_name . optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON ]
## Transitions:
-- On L_ANGLE shift to state 417
-- On optTypeParameters shift to state 955
## Reductions:
-- On L_PAREN
--   reduce production optTypeParameters ->

State 955:
## Known stack suffix:
## annotations PACKAGE push_name optTypeParameters
## LR(1) items:
packageTypeDeclaration -> annotations PACKAGE push_name optTypeParameters . L_PAREN parameterList R_PAREN [ SEMICOLON ]
## Transitions:
-- On L_PAREN shift to state 956
## Reductions:

State 956:
## Known stack suffix:
## annotations PACKAGE push_name optTypeParameters L_PAREN
## LR(1) items:
packageTypeDeclaration -> annotations PACKAGE push_name optTypeParameters L_PAREN . parameterList R_PAREN [ SEMICOLON ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On separated_list_aux(COMMA,parameter) shift to state 430
-- On petr4_separated_list(COMMA,parameter) shift to state 444
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameterList shift to state 957
-- On parameter shift to state 447
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,parameter) ->

State 957:
## Known stack suffix:
## annotations PACKAGE push_name optTypeParameters L_PAREN parameterList
## LR(1) items:
packageTypeDeclaration -> annotations PACKAGE push_name optTypeParameters L_PAREN parameterList . R_PAREN [ SEMICOLON ]
## Transitions:
-- On R_PAREN shift to state 958
## Reductions:

State 958:
## Known stack suffix:
## annotations PACKAGE push_name optTypeParameters L_PAREN parameterList R_PAREN
## LR(1) items:
packageTypeDeclaration -> annotations PACKAGE push_name optTypeParameters L_PAREN parameterList R_PAREN . [ SEMICOLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production packageTypeDeclaration -> annotations PACKAGE push_name optTypeParameters L_PAREN parameterList R_PAREN

State 959:
## Known stack suffix:
## annotations EXTERN
## LR(1) items:
externDeclaration -> annotations EXTERN . push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
externDeclaration -> annotations EXTERN . functionPrototype pop_scope SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On VOID shift to state 1
-- On VARBIT shift to state 2
-- On TYPE shift to state 5
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On STATE shift to state 8
-- On NAME shift to state 11
-- On KEY shift to state 19
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On ENTRIES shift to state 30
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 460
-- On typeRef shift to state 461
-- On typeOrVoid shift to state 462
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On tableKwName shift to state 34
-- On specializedType shift to state 140
-- On push_externName shift to state 960
-- On prefixedType shift to state 44
-- On nonTypeName shift to state 505
-- On headerStackType shift to state 142
-- On functionPrototype shift to state 966
-- On externName shift to state 509
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 960:
## Known stack suffix:
## annotations EXTERN push_externName
## LR(1) items:
externDeclaration -> annotations EXTERN push_externName . optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On L_ANGLE shift to state 417
-- On optTypeParameters shift to state 961
## Reductions:
-- On L_BRACE
--   reduce production optTypeParameters ->

State 961:
## Known stack suffix:
## annotations EXTERN push_externName optTypeParameters
## LR(1) items:
externDeclaration -> annotations EXTERN push_externName optTypeParameters . L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On L_BRACE shift to state 962
## Reductions:

State 962:
## Known stack suffix:
## annotations EXTERN push_externName optTypeParameters L_BRACE
## LR(1) items:
externDeclaration -> annotations EXTERN push_externName optTypeParameters L_BRACE . petr4_list(methodPrototype) R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On petr4_list(methodPrototype) shift to state 963
-- On list_aux(methodPrototype) shift to state 475
## Default reduction:
-- After reading the next token, reduce production list_aux(methodPrototype) ->

State 963:
## Known stack suffix:
## annotations EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype)
## LR(1) items:
externDeclaration -> annotations EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) . R_BRACE pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On R_BRACE shift to state 964
## Reductions:

State 964:
## Known stack suffix:
## annotations EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE
## LR(1) items:
externDeclaration -> annotations EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE . pop_scope [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On pop_scope shift to state 965
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 965:
## Known stack suffix:
## annotations EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope
## LR(1) items:
externDeclaration -> annotations EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production externDeclaration -> annotations EXTERN push_externName optTypeParameters L_BRACE petr4_list(methodPrototype) R_BRACE pop_scope

State 966:
## Known stack suffix:
## annotations EXTERN functionPrototype
## LR(1) items:
externDeclaration -> annotations EXTERN functionPrototype . pop_scope SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On pop_scope shift to state 967
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 967:
## Known stack suffix:
## annotations EXTERN functionPrototype pop_scope
## LR(1) items:
externDeclaration -> annotations EXTERN functionPrototype pop_scope . SEMICOLON [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
-- On SEMICOLON shift to state 968
## Reductions:

State 968:
## Known stack suffix:
## annotations EXTERN functionPrototype pop_scope SEMICOLON
## LR(1) items:
externDeclaration -> annotations EXTERN functionPrototype pop_scope SEMICOLON . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production externDeclaration -> annotations EXTERN functionPrototype pop_scope SEMICOLON

State 969:
## Known stack suffix:
## annotations CONTROL
## LR(1) items:
controlTypeDeclaration -> annotations CONTROL . push_name optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On push_name shift to state 970
-- On nonTypeName shift to state 35
-- On name shift to state 448
## Reductions:

State 970:
## Known stack suffix:
## annotations CONTROL push_name
## LR(1) items:
controlTypeDeclaration -> annotations CONTROL push_name . optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On L_ANGLE shift to state 417
-- On optTypeParameters shift to state 971
## Reductions:
-- On L_PAREN
--   reduce production optTypeParameters ->

State 971:
## Known stack suffix:
## annotations CONTROL push_name optTypeParameters
## LR(1) items:
controlTypeDeclaration -> annotations CONTROL push_name optTypeParameters . L_PAREN parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On L_PAREN shift to state 972
## Reductions:

State 972:
## Known stack suffix:
## annotations CONTROL push_name optTypeParameters L_PAREN
## LR(1) items:
controlTypeDeclaration -> annotations CONTROL push_name optTypeParameters L_PAREN . parameterList R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On PRAGMA shift to state 207
-- On OUT shift to state 427
-- On INOUT shift to state 428
-- On IN shift to state 429
-- On AT shift to state 302
-- On separated_list_aux(COMMA,parameter) shift to state 430
-- On petr4_separated_list(COMMA,parameter) shift to state 444
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parameterList shift to state 973
-- On parameter shift to state 447
-- On nonempty_list_aux(annotation) shift to state 325
-- On direction shift to state 433
-- On annotations shift to state 438
-- On annotation shift to state 331
## Reductions:
-- On VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
--   reduce production direction ->
-- On R_PAREN COMMA
--   reduce production separated_list_aux(COMMA,parameter) ->

State 973:
## Known stack suffix:
## annotations CONTROL push_name optTypeParameters L_PAREN parameterList
## LR(1) items:
controlTypeDeclaration -> annotations CONTROL push_name optTypeParameters L_PAREN parameterList . R_PAREN [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
-- On R_PAREN shift to state 974
## Reductions:

State 974:
## Known stack suffix:
## annotations CONTROL push_name optTypeParameters L_PAREN parameterList R_PAREN
## LR(1) items:
controlTypeDeclaration -> annotations CONTROL push_name optTypeParameters L_PAREN parameterList R_PAREN . [ SEMICOLON L_PAREN L_BRACE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production controlTypeDeclaration -> annotations CONTROL push_name optTypeParameters L_PAREN parameterList R_PAREN

State 975:
## Known stack suffix:
## actionDeclaration
## LR(1) items:
topDeclaration -> actionDeclaration . [ VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production topDeclaration -> actionDeclaration

State 976:
## Known stack suffix:
## topDeclarationList
## LR(1) items:
p4program -> topDeclarationList . END [ # ]
## Transitions:
-- On END shift to state 977
## Reductions:

State 977:
## Known stack suffix:
## topDeclarationList END
## LR(1) items:
p4program -> topDeclarationList END . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production p4program -> topDeclarationList END

State 978:
## Known stack suffix:
## p4program
## LR(1) items:
p4program' -> p4program . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept p4program

State 979:
## Known stack suffix:
##
## LR(1) items:
typeDeclaration' -> . typeDeclaration [ # ]
## Transitions:
-- On TYPEDEF shift to state 980
-- On TYPE shift to state 987
-- On STRUCT shift to state 994
-- On PRAGMA shift to state 207
-- On PARSER shift to state 415
-- On PACKAGE shift to state 449
-- On HEADER_UNION shift to state 999
-- On HEADER shift to state 1004
-- On ENUM shift to state 1009
-- On CONTROL shift to state 514
-- On AT shift to state 302
-- On typedefDeclaration shift to state 1022
-- On typeDeclaration shift to state 1023
-- On structTypeDeclaration shift to state 1024
-- On petr4_nonempty_list(annotation) shift to state 324
-- On parserTypeDeclaration shift to state 1025
-- On packageTypeDeclaration shift to state 1028
-- On nonempty_list_aux(annotation) shift to state 325
-- On headerUnionDeclaration shift to state 1031
-- On headerTypeDeclaration shift to state 1032
-- On enumDeclaration shift to state 1033
-- On derivedTypeDeclaration shift to state 1034
-- On controlTypeDeclaration shift to state 1035
-- On annotations shift to state 1038
-- On annotation shift to state 331
## Reductions:

State 980:
## Known stack suffix:
## TYPEDEF
## LR(1) items:
typedefDeclaration -> TYPEDEF . typeRef name SEMICOLON [ # ]
typedefDeclaration -> TYPEDEF . derivedTypeDeclaration name SEMICOLON [ # ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRUCT shift to state 201
-- On STRING shift to state 18
-- On PRAGMA shift to state 207
-- On NAME shift to state 301
-- On INT shift to state 20
-- On HEADER_UNION shift to state 332
-- On HEADER shift to state 337
-- On ERROR shift to state 46
-- On ENUM shift to state 342
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On typeRef shift to state 981
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On structTypeDeclaration shift to state 371
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On headerUnionDeclaration shift to state 372
-- On headerTypeDeclaration shift to state 373
-- On headerStackType shift to state 142
-- On enumDeclaration shift to state 374
-- On dotPrefix shift to state 143
-- On derivedTypeDeclaration shift to state 984
-- On baseType shift to state 146
-- On annotations shift to state 378
-- On annotation shift to state 331
## Reductions:

State 981:
## Known stack suffix:
## TYPEDEF typeRef
## LR(1) items:
typedefDeclaration -> TYPEDEF typeRef . name SEMICOLON [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 982
## Reductions:

State 982:
## Known stack suffix:
## TYPEDEF typeRef name
## LR(1) items:
typedefDeclaration -> TYPEDEF typeRef name . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 983
## Reductions:

State 983:
## Known stack suffix:
## TYPEDEF typeRef name SEMICOLON
## LR(1) items:
typedefDeclaration -> TYPEDEF typeRef name SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typedefDeclaration -> TYPEDEF typeRef name SEMICOLON

State 984:
## Known stack suffix:
## TYPEDEF derivedTypeDeclaration
## LR(1) items:
typedefDeclaration -> TYPEDEF derivedTypeDeclaration . name SEMICOLON [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 985
## Reductions:

State 985:
## Known stack suffix:
## TYPEDEF derivedTypeDeclaration name
## LR(1) items:
typedefDeclaration -> TYPEDEF derivedTypeDeclaration name . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 986
## Reductions:

State 986:
## Known stack suffix:
## TYPEDEF derivedTypeDeclaration name SEMICOLON
## LR(1) items:
typedefDeclaration -> TYPEDEF derivedTypeDeclaration name SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typedefDeclaration -> TYPEDEF derivedTypeDeclaration name SEMICOLON

State 987:
## Known stack suffix:
## TYPE
## LR(1) items:
typedefDeclaration -> TYPE . typeRef name SEMICOLON [ # ]
typedefDeclaration -> TYPE . derivedTypeDeclaration name SEMICOLON [ # ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRUCT shift to state 201
-- On STRING shift to state 18
-- On PRAGMA shift to state 207
-- On NAME shift to state 301
-- On INT shift to state 20
-- On HEADER_UNION shift to state 332
-- On HEADER shift to state 337
-- On ERROR shift to state 46
-- On ENUM shift to state 342
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On typeRef shift to state 988
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On structTypeDeclaration shift to state 371
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On headerUnionDeclaration shift to state 372
-- On headerTypeDeclaration shift to state 373
-- On headerStackType shift to state 142
-- On enumDeclaration shift to state 374
-- On dotPrefix shift to state 143
-- On derivedTypeDeclaration shift to state 991
-- On baseType shift to state 146
-- On annotations shift to state 378
-- On annotation shift to state 331
## Reductions:

State 988:
## Known stack suffix:
## TYPE typeRef
## LR(1) items:
typedefDeclaration -> TYPE typeRef . name SEMICOLON [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 989
## Reductions:

State 989:
## Known stack suffix:
## TYPE typeRef name
## LR(1) items:
typedefDeclaration -> TYPE typeRef name . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 990
## Reductions:

State 990:
## Known stack suffix:
## TYPE typeRef name SEMICOLON
## LR(1) items:
typedefDeclaration -> TYPE typeRef name SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typedefDeclaration -> TYPE typeRef name SEMICOLON

State 991:
## Known stack suffix:
## TYPE derivedTypeDeclaration
## LR(1) items:
typedefDeclaration -> TYPE derivedTypeDeclaration . name SEMICOLON [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 992
## Reductions:

State 992:
## Known stack suffix:
## TYPE derivedTypeDeclaration name
## LR(1) items:
typedefDeclaration -> TYPE derivedTypeDeclaration name . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 993
## Reductions:

State 993:
## Known stack suffix:
## TYPE derivedTypeDeclaration name SEMICOLON
## LR(1) items:
typedefDeclaration -> TYPE derivedTypeDeclaration name SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typedefDeclaration -> TYPE derivedTypeDeclaration name SEMICOLON

State 994:
## Known stack suffix:
## STRUCT
## LR(1) items:
structTypeDeclaration -> STRUCT . name L_BRACE petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 995
## Reductions:

State 995:
## Known stack suffix:
## STRUCT name
## LR(1) items:
structTypeDeclaration -> STRUCT name . L_BRACE petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On L_BRACE shift to state 996
## Reductions:

State 996:
## Known stack suffix:
## STRUCT name L_BRACE
## LR(1) items:
structTypeDeclaration -> STRUCT name L_BRACE . petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On petr4_list(structField) shift to state 997
-- On list_aux(structField) shift to state 206
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) ->

State 997:
## Known stack suffix:
## STRUCT name L_BRACE petr4_list(structField)
## LR(1) items:
structTypeDeclaration -> STRUCT name L_BRACE petr4_list(structField) . R_BRACE [ # ]
## Transitions:
-- On R_BRACE shift to state 998
## Reductions:

State 998:
## Known stack suffix:
## STRUCT name L_BRACE petr4_list(structField) R_BRACE
## LR(1) items:
structTypeDeclaration -> STRUCT name L_BRACE petr4_list(structField) R_BRACE . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production structTypeDeclaration -> STRUCT name L_BRACE petr4_list(structField) R_BRACE

State 999:
## Known stack suffix:
## HEADER_UNION
## LR(1) items:
headerUnionDeclaration -> HEADER_UNION . name L_BRACE petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1000
## Reductions:

State 1000:
## Known stack suffix:
## HEADER_UNION name
## LR(1) items:
headerUnionDeclaration -> HEADER_UNION name . L_BRACE petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On L_BRACE shift to state 1001
## Reductions:

State 1001:
## Known stack suffix:
## HEADER_UNION name L_BRACE
## LR(1) items:
headerUnionDeclaration -> HEADER_UNION name L_BRACE . petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On petr4_list(structField) shift to state 1002
-- On list_aux(structField) shift to state 206
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) ->

State 1002:
## Known stack suffix:
## HEADER_UNION name L_BRACE petr4_list(structField)
## LR(1) items:
headerUnionDeclaration -> HEADER_UNION name L_BRACE petr4_list(structField) . R_BRACE [ # ]
## Transitions:
-- On R_BRACE shift to state 1003
## Reductions:

State 1003:
## Known stack suffix:
## HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE
## LR(1) items:
headerUnionDeclaration -> HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production headerUnionDeclaration -> HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE

State 1004:
## Known stack suffix:
## HEADER
## LR(1) items:
headerTypeDeclaration -> HEADER . name L_BRACE petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1005
## Reductions:

State 1005:
## Known stack suffix:
## HEADER name
## LR(1) items:
headerTypeDeclaration -> HEADER name . L_BRACE petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On L_BRACE shift to state 1006
## Reductions:

State 1006:
## Known stack suffix:
## HEADER name L_BRACE
## LR(1) items:
headerTypeDeclaration -> HEADER name L_BRACE . petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On petr4_list(structField) shift to state 1007
-- On list_aux(structField) shift to state 206
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) ->

State 1007:
## Known stack suffix:
## HEADER name L_BRACE petr4_list(structField)
## LR(1) items:
headerTypeDeclaration -> HEADER name L_BRACE petr4_list(structField) . R_BRACE [ # ]
## Transitions:
-- On R_BRACE shift to state 1008
## Reductions:

State 1008:
## Known stack suffix:
## HEADER name L_BRACE petr4_list(structField) R_BRACE
## LR(1) items:
headerTypeDeclaration -> HEADER name L_BRACE petr4_list(structField) R_BRACE . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production headerTypeDeclaration -> HEADER name L_BRACE petr4_list(structField) R_BRACE

State 1009:
## Known stack suffix:
## ENUM
## LR(1) items:
enumDeclaration -> ENUM . name L_BRACE identifierList R_BRACE [ # ]
enumDeclaration -> ENUM . BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On BIT shift to state 1010
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1018
## Reductions:

State 1010:
## Known stack suffix:
## ENUM BIT
## LR(1) items:
enumDeclaration -> ENUM BIT . L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On L_ANGLE shift to state 1011
## Reductions:

State 1011:
## Known stack suffix:
## ENUM BIT L_ANGLE
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE . INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On INTEGER shift to state 1012
## Reductions:

State 1012:
## Known stack suffix:
## ENUM BIT L_ANGLE INTEGER
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE INTEGER . R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On R_ANGLE shift to state 1013
## Reductions:

State 1013:
## Known stack suffix:
## ENUM BIT L_ANGLE INTEGER R_ANGLE
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE INTEGER R_ANGLE . name L_BRACE specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1014
## Reductions:

State 1014:
## Known stack suffix:
## ENUM BIT L_ANGLE INTEGER R_ANGLE name
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE INTEGER R_ANGLE name . L_BRACE specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On L_BRACE shift to state 1015
## Reductions:

State 1015:
## Known stack suffix:
## ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE . specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On specifiedIdentifierList shift to state 1016
-- On specifiedIdentifier shift to state 351
-- On separated_nonempty_list_aux(COMMA,__anonymous_1) shift to state 352
-- On petr4_separated_nonempty_list(COMMA,__anonymous_1) shift to state 358
-- On nonTypeName shift to state 35
-- On name shift to state 355
## Reductions:

State 1016:
## Known stack suffix:
## ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList . R_BRACE [ # ]
## Transitions:
-- On R_BRACE shift to state 1017
## Reductions:

State 1017:
## Known stack suffix:
## ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE
## LR(1) items:
enumDeclaration -> ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production enumDeclaration -> ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE

State 1018:
## Known stack suffix:
## ENUM name
## LR(1) items:
enumDeclaration -> ENUM name . L_BRACE identifierList R_BRACE [ # ]
## Transitions:
-- On L_BRACE shift to state 1019
## Reductions:

State 1019:
## Known stack suffix:
## ENUM name L_BRACE
## LR(1) items:
enumDeclaration -> ENUM name L_BRACE . identifierList R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On separated_nonempty_list_aux(COMMA,__anonymous_0) shift to state 361
-- On petr4_separated_nonempty_list(COMMA,__anonymous_0) shift to state 364
-- On nonTypeName shift to state 35
-- On name shift to state 365
-- On identifierList shift to state 1020
## Reductions:

State 1020:
## Known stack suffix:
## ENUM name L_BRACE identifierList
## LR(1) items:
enumDeclaration -> ENUM name L_BRACE identifierList . R_BRACE [ # ]
## Transitions:
-- On R_BRACE shift to state 1021
## Reductions:

State 1021:
## Known stack suffix:
## ENUM name L_BRACE identifierList R_BRACE
## LR(1) items:
enumDeclaration -> ENUM name L_BRACE identifierList R_BRACE . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production enumDeclaration -> ENUM name L_BRACE identifierList R_BRACE

State 1022:
## Known stack suffix:
## typedefDeclaration
## LR(1) items:
typeDeclaration -> typedefDeclaration . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typeDeclaration -> typedefDeclaration

State 1023:
## Known stack suffix:
## typeDeclaration
## LR(1) items:
typeDeclaration' -> typeDeclaration . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept typeDeclaration

State 1024:
## Known stack suffix:
## structTypeDeclaration
## LR(1) items:
derivedTypeDeclaration -> structTypeDeclaration . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production derivedTypeDeclaration -> structTypeDeclaration

State 1025:
## Known stack suffix:
## parserTypeDeclaration
## LR(1) items:
typeDeclaration -> parserTypeDeclaration . pop_scope SEMICOLON [ # ]
## Transitions:
-- On pop_scope shift to state 1026
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 1026:
## Known stack suffix:
## parserTypeDeclaration pop_scope
## LR(1) items:
typeDeclaration -> parserTypeDeclaration pop_scope . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 1027
## Reductions:

State 1027:
## Known stack suffix:
## parserTypeDeclaration pop_scope SEMICOLON
## LR(1) items:
typeDeclaration -> parserTypeDeclaration pop_scope SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typeDeclaration -> parserTypeDeclaration pop_scope SEMICOLON

State 1028:
## Known stack suffix:
## packageTypeDeclaration
## LR(1) items:
typeDeclaration -> packageTypeDeclaration . pop_scope SEMICOLON [ # ]
## Transitions:
-- On pop_scope shift to state 1029
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 1029:
## Known stack suffix:
## packageTypeDeclaration pop_scope
## LR(1) items:
typeDeclaration -> packageTypeDeclaration pop_scope . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 1030
## Reductions:

State 1030:
## Known stack suffix:
## packageTypeDeclaration pop_scope SEMICOLON
## LR(1) items:
typeDeclaration -> packageTypeDeclaration pop_scope SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typeDeclaration -> packageTypeDeclaration pop_scope SEMICOLON

State 1031:
## Known stack suffix:
## headerUnionDeclaration
## LR(1) items:
derivedTypeDeclaration -> headerUnionDeclaration . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production derivedTypeDeclaration -> headerUnionDeclaration

State 1032:
## Known stack suffix:
## headerTypeDeclaration
## LR(1) items:
derivedTypeDeclaration -> headerTypeDeclaration . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production derivedTypeDeclaration -> headerTypeDeclaration

State 1033:
## Known stack suffix:
## enumDeclaration
## LR(1) items:
derivedTypeDeclaration -> enumDeclaration . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production derivedTypeDeclaration -> enumDeclaration

State 1034:
## Known stack suffix:
## derivedTypeDeclaration
## LR(1) items:
typeDeclaration -> derivedTypeDeclaration . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typeDeclaration -> derivedTypeDeclaration

State 1035:
## Known stack suffix:
## controlTypeDeclaration
## LR(1) items:
typeDeclaration -> controlTypeDeclaration . pop_scope SEMICOLON [ # ]
## Transitions:
-- On pop_scope shift to state 1036
## Default reduction:
-- After reading the next token, reduce production pop_scope ->

State 1036:
## Known stack suffix:
## controlTypeDeclaration pop_scope
## LR(1) items:
typeDeclaration -> controlTypeDeclaration pop_scope . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 1037
## Reductions:

State 1037:
## Known stack suffix:
## controlTypeDeclaration pop_scope SEMICOLON
## LR(1) items:
typeDeclaration -> controlTypeDeclaration pop_scope SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typeDeclaration -> controlTypeDeclaration pop_scope SEMICOLON

State 1038:
## Known stack suffix:
## annotations
## LR(1) items:
controlTypeDeclaration -> annotations . CONTROL push_name optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON ]
enumDeclaration -> annotations . ENUM name L_BRACE identifierList R_BRACE [ # ]
enumDeclaration -> annotations . ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ # ]
headerTypeDeclaration -> annotations . HEADER name L_BRACE petr4_list(structField) R_BRACE [ # ]
headerUnionDeclaration -> annotations . HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE [ # ]
packageTypeDeclaration -> annotations . PACKAGE push_name optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON ]
parserTypeDeclaration -> annotations . PARSER push_name optTypeParameters L_PAREN parameterList R_PAREN [ SEMICOLON ]
structTypeDeclaration -> annotations . STRUCT name L_BRACE petr4_list(structField) R_BRACE [ # ]
typedefDeclaration -> annotations . TYPEDEF typeRef name SEMICOLON [ # ]
typedefDeclaration -> annotations . TYPEDEF derivedTypeDeclaration name SEMICOLON [ # ]
typedefDeclaration -> annotations . TYPE typeRef name SEMICOLON [ # ]
typedefDeclaration -> annotations . TYPE derivedTypeDeclaration name SEMICOLON [ # ]
## Transitions:
-- On TYPEDEF shift to state 1039
-- On TYPE shift to state 1046
-- On STRUCT shift to state 1053
-- On PARSER shift to state 947
-- On PACKAGE shift to state 953
-- On HEADER_UNION shift to state 1058
-- On HEADER shift to state 1063
-- On ENUM shift to state 1068
-- On CONTROL shift to state 969
## Reductions:

State 1039:
## Known stack suffix:
## annotations TYPEDEF
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF . typeRef name SEMICOLON [ # ]
typedefDeclaration -> annotations TYPEDEF . derivedTypeDeclaration name SEMICOLON [ # ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRUCT shift to state 201
-- On STRING shift to state 18
-- On PRAGMA shift to state 207
-- On NAME shift to state 301
-- On INT shift to state 20
-- On HEADER_UNION shift to state 332
-- On HEADER shift to state 337
-- On ERROR shift to state 46
-- On ENUM shift to state 342
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On typeRef shift to state 1040
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On structTypeDeclaration shift to state 371
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On headerUnionDeclaration shift to state 372
-- On headerTypeDeclaration shift to state 373
-- On headerStackType shift to state 142
-- On enumDeclaration shift to state 374
-- On dotPrefix shift to state 143
-- On derivedTypeDeclaration shift to state 1043
-- On baseType shift to state 146
-- On annotations shift to state 378
-- On annotation shift to state 331
## Reductions:

State 1040:
## Known stack suffix:
## annotations TYPEDEF typeRef
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF typeRef . name SEMICOLON [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1041
## Reductions:

State 1041:
## Known stack suffix:
## annotations TYPEDEF typeRef name
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF typeRef name . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 1042
## Reductions:

State 1042:
## Known stack suffix:
## annotations TYPEDEF typeRef name SEMICOLON
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF typeRef name SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typedefDeclaration -> annotations TYPEDEF typeRef name SEMICOLON

State 1043:
## Known stack suffix:
## annotations TYPEDEF derivedTypeDeclaration
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF derivedTypeDeclaration . name SEMICOLON [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1044
## Reductions:

State 1044:
## Known stack suffix:
## annotations TYPEDEF derivedTypeDeclaration name
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF derivedTypeDeclaration name . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 1045
## Reductions:

State 1045:
## Known stack suffix:
## annotations TYPEDEF derivedTypeDeclaration name SEMICOLON
## LR(1) items:
typedefDeclaration -> annotations TYPEDEF derivedTypeDeclaration name SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typedefDeclaration -> annotations TYPEDEF derivedTypeDeclaration name SEMICOLON

State 1046:
## Known stack suffix:
## annotations TYPE
## LR(1) items:
typedefDeclaration -> annotations TYPE . typeRef name SEMICOLON [ # ]
typedefDeclaration -> annotations TYPE . derivedTypeDeclaration name SEMICOLON [ # ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRUCT shift to state 201
-- On STRING shift to state 18
-- On PRAGMA shift to state 207
-- On NAME shift to state 301
-- On INT shift to state 20
-- On HEADER_UNION shift to state 332
-- On HEADER shift to state 337
-- On ERROR shift to state 46
-- On ENUM shift to state 342
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On typeRef shift to state 1047
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On structTypeDeclaration shift to state 371
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On headerUnionDeclaration shift to state 372
-- On headerTypeDeclaration shift to state 373
-- On headerStackType shift to state 142
-- On enumDeclaration shift to state 374
-- On dotPrefix shift to state 143
-- On derivedTypeDeclaration shift to state 1050
-- On baseType shift to state 146
-- On annotations shift to state 378
-- On annotation shift to state 331
## Reductions:

State 1047:
## Known stack suffix:
## annotations TYPE typeRef
## LR(1) items:
typedefDeclaration -> annotations TYPE typeRef . name SEMICOLON [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1048
## Reductions:

State 1048:
## Known stack suffix:
## annotations TYPE typeRef name
## LR(1) items:
typedefDeclaration -> annotations TYPE typeRef name . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 1049
## Reductions:

State 1049:
## Known stack suffix:
## annotations TYPE typeRef name SEMICOLON
## LR(1) items:
typedefDeclaration -> annotations TYPE typeRef name SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typedefDeclaration -> annotations TYPE typeRef name SEMICOLON

State 1050:
## Known stack suffix:
## annotations TYPE derivedTypeDeclaration
## LR(1) items:
typedefDeclaration -> annotations TYPE derivedTypeDeclaration . name SEMICOLON [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1051
## Reductions:

State 1051:
## Known stack suffix:
## annotations TYPE derivedTypeDeclaration name
## LR(1) items:
typedefDeclaration -> annotations TYPE derivedTypeDeclaration name . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 1052
## Reductions:

State 1052:
## Known stack suffix:
## annotations TYPE derivedTypeDeclaration name SEMICOLON
## LR(1) items:
typedefDeclaration -> annotations TYPE derivedTypeDeclaration name SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production typedefDeclaration -> annotations TYPE derivedTypeDeclaration name SEMICOLON

State 1053:
## Known stack suffix:
## annotations STRUCT
## LR(1) items:
structTypeDeclaration -> annotations STRUCT . name L_BRACE petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1054
## Reductions:

State 1054:
## Known stack suffix:
## annotations STRUCT name
## LR(1) items:
structTypeDeclaration -> annotations STRUCT name . L_BRACE petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On L_BRACE shift to state 1055
## Reductions:

State 1055:
## Known stack suffix:
## annotations STRUCT name L_BRACE
## LR(1) items:
structTypeDeclaration -> annotations STRUCT name L_BRACE . petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On petr4_list(structField) shift to state 1056
-- On list_aux(structField) shift to state 206
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) ->

State 1056:
## Known stack suffix:
## annotations STRUCT name L_BRACE petr4_list(structField)
## LR(1) items:
structTypeDeclaration -> annotations STRUCT name L_BRACE petr4_list(structField) . R_BRACE [ # ]
## Transitions:
-- On R_BRACE shift to state 1057
## Reductions:

State 1057:
## Known stack suffix:
## annotations STRUCT name L_BRACE petr4_list(structField) R_BRACE
## LR(1) items:
structTypeDeclaration -> annotations STRUCT name L_BRACE petr4_list(structField) R_BRACE . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production structTypeDeclaration -> annotations STRUCT name L_BRACE petr4_list(structField) R_BRACE

State 1058:
## Known stack suffix:
## annotations HEADER_UNION
## LR(1) items:
headerUnionDeclaration -> annotations HEADER_UNION . name L_BRACE petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1059
## Reductions:

State 1059:
## Known stack suffix:
## annotations HEADER_UNION name
## LR(1) items:
headerUnionDeclaration -> annotations HEADER_UNION name . L_BRACE petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On L_BRACE shift to state 1060
## Reductions:

State 1060:
## Known stack suffix:
## annotations HEADER_UNION name L_BRACE
## LR(1) items:
headerUnionDeclaration -> annotations HEADER_UNION name L_BRACE . petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On petr4_list(structField) shift to state 1061
-- On list_aux(structField) shift to state 206
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) ->

State 1061:
## Known stack suffix:
## annotations HEADER_UNION name L_BRACE petr4_list(structField)
## LR(1) items:
headerUnionDeclaration -> annotations HEADER_UNION name L_BRACE petr4_list(structField) . R_BRACE [ # ]
## Transitions:
-- On R_BRACE shift to state 1062
## Reductions:

State 1062:
## Known stack suffix:
## annotations HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE
## LR(1) items:
headerUnionDeclaration -> annotations HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production headerUnionDeclaration -> annotations HEADER_UNION name L_BRACE petr4_list(structField) R_BRACE

State 1063:
## Known stack suffix:
## annotations HEADER
## LR(1) items:
headerTypeDeclaration -> annotations HEADER . name L_BRACE petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1064
## Reductions:

State 1064:
## Known stack suffix:
## annotations HEADER name
## LR(1) items:
headerTypeDeclaration -> annotations HEADER name . L_BRACE petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On L_BRACE shift to state 1065
## Reductions:

State 1065:
## Known stack suffix:
## annotations HEADER name L_BRACE
## LR(1) items:
headerTypeDeclaration -> annotations HEADER name L_BRACE . petr4_list(structField) R_BRACE [ # ]
## Transitions:
-- On petr4_list(structField) shift to state 1066
-- On list_aux(structField) shift to state 206
## Default reduction:
-- After reading the next token, reduce production list_aux(structField) ->

State 1066:
## Known stack suffix:
## annotations HEADER name L_BRACE petr4_list(structField)
## LR(1) items:
headerTypeDeclaration -> annotations HEADER name L_BRACE petr4_list(structField) . R_BRACE [ # ]
## Transitions:
-- On R_BRACE shift to state 1067
## Reductions:

State 1067:
## Known stack suffix:
## annotations HEADER name L_BRACE petr4_list(structField) R_BRACE
## LR(1) items:
headerTypeDeclaration -> annotations HEADER name L_BRACE petr4_list(structField) R_BRACE . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production headerTypeDeclaration -> annotations HEADER name L_BRACE petr4_list(structField) R_BRACE

State 1068:
## Known stack suffix:
## annotations ENUM
## LR(1) items:
enumDeclaration -> annotations ENUM . name L_BRACE identifierList R_BRACE [ # ]
enumDeclaration -> annotations ENUM . BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On BIT shift to state 1069
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1077
## Reductions:

State 1069:
## Known stack suffix:
## annotations ENUM BIT
## LR(1) items:
enumDeclaration -> annotations ENUM BIT . L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On L_ANGLE shift to state 1070
## Reductions:

State 1070:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE . INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On INTEGER shift to state 1071
## Reductions:

State 1071:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE INTEGER
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER . R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On R_ANGLE shift to state 1072
## Reductions:

State 1072:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE INTEGER R_ANGLE
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER R_ANGLE . name L_BRACE specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1073
## Reductions:

State 1073:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name . L_BRACE specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On L_BRACE shift to state 1074
## Reductions:

State 1074:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE . specifiedIdentifierList R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On specifiedIdentifierList shift to state 1075
-- On specifiedIdentifier shift to state 351
-- On separated_nonempty_list_aux(COMMA,__anonymous_1) shift to state 352
-- On petr4_separated_nonempty_list(COMMA,__anonymous_1) shift to state 358
-- On nonTypeName shift to state 35
-- On name shift to state 355
## Reductions:

State 1075:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList . R_BRACE [ # ]
## Transitions:
-- On R_BRACE shift to state 1076
## Reductions:

State 1076:
## Known stack suffix:
## annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE
## LR(1) items:
enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production enumDeclaration -> annotations ENUM BIT L_ANGLE INTEGER R_ANGLE name L_BRACE specifiedIdentifierList R_BRACE

State 1077:
## Known stack suffix:
## annotations ENUM name
## LR(1) items:
enumDeclaration -> annotations ENUM name . L_BRACE identifierList R_BRACE [ # ]
## Transitions:
-- On L_BRACE shift to state 1078
## Reductions:

State 1078:
## Known stack suffix:
## annotations ENUM name L_BRACE
## LR(1) items:
enumDeclaration -> annotations ENUM name L_BRACE . identifierList R_BRACE [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On separated_nonempty_list_aux(COMMA,__anonymous_0) shift to state 361
-- On petr4_separated_nonempty_list(COMMA,__anonymous_0) shift to state 364
-- On nonTypeName shift to state 35
-- On name shift to state 365
-- On identifierList shift to state 1079
## Reductions:

State 1079:
## Known stack suffix:
## annotations ENUM name L_BRACE identifierList
## LR(1) items:
enumDeclaration -> annotations ENUM name L_BRACE identifierList . R_BRACE [ # ]
## Transitions:
-- On R_BRACE shift to state 1080
## Reductions:

State 1080:
## Known stack suffix:
## annotations ENUM name L_BRACE identifierList R_BRACE
## LR(1) items:
enumDeclaration -> annotations ENUM name L_BRACE identifierList R_BRACE . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production enumDeclaration -> annotations ENUM name L_BRACE identifierList R_BRACE

State 1081:
## Known stack suffix:
##
## LR(1) items:
variableDeclaration' -> . variableDeclaration [ # ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On PRAGMA shift to state 207
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On AT shift to state 302
-- On variableDeclaration shift to state 1082
-- On typeRef shift to state 1083
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On petr4_nonempty_list(annotation) shift to state 324
-- On nonempty_list_aux(annotation) shift to state 325
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
-- On annotations shift to state 1087
-- On annotation shift to state 331
## Reductions:

State 1082:
## Known stack suffix:
## variableDeclaration
## LR(1) items:
variableDeclaration' -> variableDeclaration . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept variableDeclaration

State 1083:
## Known stack suffix:
## typeRef
## LR(1) items:
variableDeclaration -> typeRef . name optInitialValue SEMICOLON [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1084
## Reductions:

State 1084:
## Known stack suffix:
## typeRef name
## LR(1) items:
variableDeclaration -> typeRef name . optInitialValue SEMICOLON [ # ]
## Transitions:
-- On ASSIGN shift to state 650
-- On optInitialValue shift to state 1085
## Reductions:
-- On SEMICOLON
--   reduce production optInitialValue ->

State 1085:
## Known stack suffix:
## typeRef name optInitialValue
## LR(1) items:
variableDeclaration -> typeRef name optInitialValue . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 1086
## Reductions:

State 1086:
## Known stack suffix:
## typeRef name optInitialValue SEMICOLON
## LR(1) items:
variableDeclaration -> typeRef name optInitialValue SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production variableDeclaration -> typeRef name optInitialValue SEMICOLON

State 1087:
## Known stack suffix:
## annotations
## LR(1) items:
variableDeclaration -> annotations . typeRef name optInitialValue SEMICOLON [ # ]
## Transitions:
-- On VARBIT shift to state 2
-- On TUPLE shift to state 16
-- On STRING shift to state 18
-- On NAME shift to state 301
-- On INT shift to state 20
-- On ERROR shift to state 46
-- On DOT shift to state 38
-- On BOOL shift to state 48
-- On BIT shift to state 49
-- On typeRef shift to state 1088
-- On typeName shift to state 138
-- On tupleType shift to state 128
-- On specializedType shift to state 140
-- On prefixedType shift to state 44
-- On headerStackType shift to state 142
-- On dotPrefix shift to state 143
-- On baseType shift to state 146
## Reductions:

State 1088:
## Known stack suffix:
## annotations typeRef
## LR(1) items:
variableDeclaration -> annotations typeRef . name optInitialValue SEMICOLON [ # ]
## Transitions:
-- On TYPE shift to state 5
-- On STATE shift to state 8
-- On NAME shift to state 28
-- On KEY shift to state 19
-- On ENTRIES shift to state 30
-- On APPLY shift to state 31
-- On ACTIONS shift to state 32
-- On varName shift to state 33
-- On tableKwName shift to state 34
-- On nonTypeName shift to state 35
-- On name shift to state 1089
## Reductions:

State 1089:
## Known stack suffix:
## annotations typeRef name
## LR(1) items:
variableDeclaration -> annotations typeRef name . optInitialValue SEMICOLON [ # ]
## Transitions:
-- On ASSIGN shift to state 650
-- On optInitialValue shift to state 1090
## Reductions:
-- On SEMICOLON
--   reduce production optInitialValue ->

State 1090:
## Known stack suffix:
## annotations typeRef name optInitialValue
## LR(1) items:
variableDeclaration -> annotations typeRef name optInitialValue . SEMICOLON [ # ]
## Transitions:
-- On SEMICOLON shift to state 1091
## Reductions:

State 1091:
## Known stack suffix:
## annotations typeRef name optInitialValue SEMICOLON
## LR(1) items:
variableDeclaration -> annotations typeRef name optInitialValue SEMICOLON . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production variableDeclaration -> annotations typeRef name optInitialValue SEMICOLON

