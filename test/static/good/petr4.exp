Note: the nonterminal symbol list (from petr4.mly) is renamed petr4_list.
Note: the nonterminal symbol nonempty_list (from petr4.mly) is renamed petr4_nonempty_list.
Note: the nonterminal symbol option (from petr4.mly) is renamed petr4_option.
Note: the nonterminal symbol separated_list (from petr4.mly) is renamed petr4_separated_list.
Note: the nonterminal symbol separated_nonempty_list (from petr4.mly) is renamed petr4_separated_nonempty_list.
Grammar has 163 nonterminal symbols, among which 3 start symbols.
Grammar has 89 terminal symbols.
Grammar has 475 productions.
nullable(variableDeclaration) = false
nullable(varName) = false
nullable(valueSetDeclaration) = false
nullable(typedefDeclaration) = false
nullable(typeRef) = false
nullable(typeParameter) = false
nullable(typeOrVoid) = false
nullable(typeName) = false
nullable(typeDeclaration) = false
nullable(typeArgumentList) = true
nullable(typeArg) = false
nullable(tupleType) = false
nullable(tupleKeysetExpression) = false
nullable(transitionStatement) = true
nullable(topDeclarationList) = true
nullable(topDeclaration) = false
nullable(tablePropertyList) = false
nullable(tableProperty) = false
nullable(tableKwName) = false
nullable(tableDeclaration) = false
nullable(switchStatement) = false
nullable(switchLabel) = false
nullable(switchCases) = true
nullable(switchCase) = false
nullable(structTypeDeclaration) = false
nullable(structField) = false
nullable(statementOrDeclaration) = false
nullable(statement) = false
nullable(stateExpression) = false
nullable(specifiedIdentifierList) = false
nullable(specifiedIdentifier) = false
nullable(specializedType) = false
nullable(simpleKeysetExpression) = false
nullable(separated_nonempty_list_aux(SEMICOLON,actionRef)) = false
nullable(separated_nonempty_list_aux(COMMA,simpleKeysetExpression)) = false
nullable(separated_nonempty_list_aux(COMMA,kvPair)) = false
nullable(separated_nonempty_list_aux(COMMA,__anonymous_1)) = false
nullable(separated_nonempty_list_aux(COMMA,__anonymous_0)) = false
nullable(separated_list_aux(COMMA,typeParameter)) = true
nullable(separated_list_aux(COMMA,typeArg)) = true
nullable(separated_list_aux(COMMA,parameter)) = true
nullable(separated_list_aux(COMMA,expression)) = true
nullable(separated_list_aux(COMMA,argument)) = true
nullable(separated_atLeastTwo_list_aux(COMMA,simpleKeysetExpression)) = false
nullable(separated_atLeastTwo_list(COMMA,simpleKeysetExpression)) = false
nullable(selectExpression) = false
nullable(selectCase) = false
nullable(returnStatement) = false
nullable(realTypeArgumentList) = false
nullable(realTypeArg) = false
nullable(push_scope) = true
nullable(push_name) = false
nullable(push_externName) = false
nullable(prefixedType) = false
nullable(prefixedNonTypeName) = false
nullable(pop_scope) = true
nullable(petr4_separated_nonempty_list(COMMA,kvPair)) = false
nullable(petr4_separated_nonempty_list(COMMA,__anonymous_1)) = false
nullable(petr4_separated_nonempty_list(COMMA,__anonymous_0)) = false
nullable(petr4_separated_list(COMMA,typeParameter)) = true
nullable(petr4_separated_list(COMMA,typeArg)) = true
nullable(petr4_separated_list(COMMA,parameter)) = true
nullable(petr4_separated_list(COMMA,expression)) = true
nullable(petr4_separated_list(COMMA,argument)) = true
nullable(petr4_nonempty_list(tableProperty)) = false
nullable(petr4_nonempty_list(parserState)) = false
nullable(petr4_nonempty_list(annotation)) = false
nullable(petr4_list(switchCase)) = true
nullable(petr4_list(structField)) = true
nullable(petr4_list(statementOrDeclaration)) = true
nullable(petr4_list(selectCase)) = true
nullable(petr4_list(parserStatement)) = true
nullable(petr4_list(objDeclaration)) = true
nullable(petr4_list(methodPrototype)) = true
nullable(petr4_list(keyElement)) = true
nullable(petr4_list(entry)) = true
nullable(petr4_list(controlLocalDeclaration)) = true
nullable(petr4_list(annotationToken)) = true
nullable(parserTypeDeclaration) = false
nullable(parserStatement) = false
nullable(parserState) = false
nullable(parserLocalElement) = false
nullable(parserDeclaration) = false
nullable(parserBlockStatement) = false
nullable(parameterList) = true
nullable(parameter) = false
nullable(packageTypeDeclaration) = false
nullable(p4program) = false
nullable(optTypeParameters) = true
nullable(optInitialValue) = true
nullable(optConstructorParameters) = true
nullable(objInitializer) = false
nullable(objDeclaration) = false
nullable(nonempty_list_aux(tableProperty)) = false
nullable(nonempty_list_aux(parserState)) = false
nullable(nonempty_list_aux(annotation)) = false
nullable(nonTypeName) = false
nullable(nonTableKwName) = false
nullable(namedType) = false
nullable(name) = false
nullable(methodPrototype) = false
nullable(member) = false
nullable(matchKindDeclaration) = false
nullable(lvalue) = false
nullable(list_aux(switchCase)) = true
nullable(list_aux(structField)) = true
nullable(list_aux(statementOrDeclaration)) = true
nullable(list_aux(selectCase)) = true
nullable(list_aux(parserStatement)) = true
nullable(list_aux(parserLocalElement)) = true
nullable(list_aux(objDeclaration)) = true
nullable(list_aux(methodPrototype)) = true
nullable(list_aux(keyElement)) = true
nullable(list_aux(entry)) = true
nullable(list_aux(controlLocalDeclaration)) = true
nullable(list_aux(annotationToken)) = true
nullable(kvPair) = false
nullable(kvList) = false
nullable(keysetExpression) = false
nullable(keyElementList) = true
nullable(keyElement) = false
nullable(instantiation) = false
nullable(initialValue) = false
nullable(identifierList) = false
nullable(headerUnionDeclaration) = false
nullable(headerTypeDeclaration) = false
nullable(headerStackType) = false
nullable(go_toplevel) = true
nullable(go_local) = true
nullable(functionPrototype) = false
nullable(functionDeclaration) = false
nullable(externName) = false
nullable(externDeclaration) = false
nullable(expressionList) = true
nullable(expression) = false
nullable(exitStatement) = false
nullable(errorDeclaration) = false
nullable(enumDeclaration) = false
nullable(entry) = false
nullable(entriesList) = true
nullable(emptyStatement) = false
nullable(dotPrefix) = false
nullable(direction) = true
nullable(directApplication) = false
nullable(derivedTypeDeclaration) = false
nullable(controlTypeDeclaration) = false
nullable(controlLocalDeclaration) = false
nullable(controlDeclaration) = false
nullable(controlBody) = false
nullable(constantDeclaration) = false
nullable(conditionalStatement) = false
nullable(blockStatement) = false
nullable(baseType) = false
nullable(assignmentOrMethodCallStatement) = false
nullable(argumentList) = true
nullable(argument) = false
nullable(annotations) = false
nullable(annotationToken) = false
nullable(annotationBody) = true
nullable(annotation) = false
nullable(actionRef) = false
nullable(actionList) = true
nullable(actionDeclaration) = false
first(variableDeclaration) = VARBIT TUPLE STRING PRAGMA NAME INT ERROR DOT BOOL BIT AT
first(varName) = NAME
first(valueSetDeclaration) = VALUESET PRAGMA AT
first(typedefDeclaration) = TYPEDEF TYPE PRAGMA AT
first(typeRef) = VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
first(typeParameter) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(typeOrVoid) = VOID VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
first(typeName) = NAME DOT
first(typeDeclaration) = TYPEDEF TYPE STRUCT PRAGMA PARSER PACKAGE HEADER_UNION HEADER ENUM CONTROL AT
first(typeArgumentList) = VARBIT TYPE TUPLE STRING STATE NAME KEY INT ERROR ENTRIES DOT DONTCARE COMMA BOOL BIT APPLY ACTIONS
first(typeArg) = VARBIT TYPE TUPLE STRING STATE NAME KEY INT ERROR ENTRIES DOT DONTCARE BOOL BIT APPLY ACTIONS
first(tupleType) = TUPLE
first(tupleKeysetExpression) = L_PAREN
first(transitionStatement) = TRANSITION
first(topDeclarationList) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM DOT CONTROL CONST BOOL BIT AT ACTION
first(topDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM DOT CONTROL CONST BOOL BIT AT ACTION
first(tablePropertyList) = TYPE STATE PRAGMA NAME KEY CONST AT APPLY ACTIONS
first(tableProperty) = TYPE STATE PRAGMA NAME KEY CONST AT APPLY ACTIONS
first(tableKwName) = KEY ENTRIES ACTIONS
first(tableDeclaration) = TABLE PRAGMA AT
first(switchStatement) = SWITCH
first(switchLabel) = TYPE STATE NAME KEY ENTRIES DEFAULT APPLY ACTIONS
first(switchCases) = TYPE STATE NAME KEY ENTRIES DEFAULT APPLY ACTIONS
first(switchCase) = TYPE STATE NAME KEY ENTRIES DEFAULT APPLY ACTIONS
first(structTypeDeclaration) = STRUCT PRAGMA AT
first(structField) = VARBIT TUPLE STRING PRAGMA NAME INT ERROR DOT BOOL BIT AT
first(statementOrDeclaration) = VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
first(statement) = TYPE SWITCH STATE SEMICOLON RETURN PRAGMA NAME L_BRACE KEY IF EXIT ENTRIES DOT AT APPLY ACTIONS
first(stateExpression) = TYPE STATE SELECT NAME KEY ENTRIES APPLY ACTIONS
first(specifiedIdentifierList) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(specifiedIdentifier) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(specializedType) = NAME DOT
first(simpleKeysetExpression) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
first(separated_nonempty_list_aux(SEMICOLON,actionRef)) = TYPE STATE PRAGMA NAME KEY ENTRIES AT APPLY ACTIONS
first(separated_nonempty_list_aux(COMMA,simpleKeysetExpression)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
first(separated_nonempty_list_aux(COMMA,kvPair)) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(separated_nonempty_list_aux(COMMA,__anonymous_1)) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(separated_nonempty_list_aux(COMMA,__anonymous_0)) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(separated_list_aux(COMMA,typeParameter)) = TYPE STATE NAME KEY ENTRIES COMMA APPLY ACTIONS
first(separated_list_aux(COMMA,typeArg)) = VARBIT TYPE TUPLE STRING STATE NAME KEY INT ERROR ENTRIES DOT DONTCARE COMMA BOOL BIT APPLY ACTIONS
first(separated_list_aux(COMMA,parameter)) = VARBIT TUPLE STRING PRAGMA OUT NAME INT INOUT IN ERROR DOT COMMA BOOL BIT AT
first(separated_list_aux(COMMA,expression)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT COMMA APPLY ACTIONS
first(separated_list_aux(COMMA,argument)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE COMPLEMENT COMMA APPLY ACTIONS
first(separated_atLeastTwo_list_aux(COMMA,simpleKeysetExpression)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
first(separated_atLeastTwo_list(COMMA,simpleKeysetExpression)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
first(selectExpression) = SELECT
first(selectCase) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
first(returnStatement) = RETURN
first(realTypeArgumentList) = VARBIT TUPLE STRING NAME INT ERROR DOT DONTCARE BOOL BIT
first(realTypeArg) = VARBIT TUPLE STRING NAME INT ERROR DOT DONTCARE BOOL BIT
first(push_scope) = 
first(push_name) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(push_externName) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(prefixedType) = NAME DOT
first(prefixedNonTypeName) = TYPE STATE NAME KEY ENTRIES DOT APPLY ACTIONS
first(pop_scope) = 
first(petr4_separated_nonempty_list(COMMA,kvPair)) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(petr4_separated_nonempty_list(COMMA,__anonymous_1)) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(petr4_separated_nonempty_list(COMMA,__anonymous_0)) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(petr4_separated_list(COMMA,typeParameter)) = TYPE STATE NAME KEY ENTRIES COMMA APPLY ACTIONS
first(petr4_separated_list(COMMA,typeArg)) = VARBIT TYPE TUPLE STRING STATE NAME KEY INT ERROR ENTRIES DOT DONTCARE COMMA BOOL BIT APPLY ACTIONS
first(petr4_separated_list(COMMA,parameter)) = VARBIT TUPLE STRING PRAGMA OUT NAME INT INOUT IN ERROR DOT COMMA BOOL BIT AT
first(petr4_separated_list(COMMA,expression)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT COMMA APPLY ACTIONS
first(petr4_separated_list(COMMA,argument)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE COMPLEMENT COMMA APPLY ACTIONS
first(petr4_nonempty_list(tableProperty)) = TYPE STATE PRAGMA NAME KEY CONST AT APPLY ACTIONS
first(petr4_nonempty_list(parserState)) = STATE PRAGMA AT
first(petr4_nonempty_list(annotation)) = PRAGMA AT
first(petr4_list(switchCase)) = TYPE STATE NAME KEY ENTRIES DEFAULT APPLY ACTIONS
first(petr4_list(structField)) = VARBIT TUPLE STRING PRAGMA NAME INT ERROR DOT BOOL BIT AT
first(petr4_list(statementOrDeclaration)) = VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
first(petr4_list(selectCase)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
first(petr4_list(parserStatement)) = VARBIT TYPE TUPLE STRING STATE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
first(petr4_list(objDeclaration)) = VOID VARBIT TUPLE STRING PRAGMA NAME INT ERROR DOT BOOL BIT AT
first(petr4_list(methodPrototype)) = VOID VARBIT TYPE TUPLE STRING STATE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT
first(petr4_list(keyElement)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS
first(petr4_list(entry)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
first(petr4_list(controlLocalDeclaration)) = VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ACTION
first(petr4_list(annotationToken)) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT
first(parserTypeDeclaration) = PRAGMA PARSER AT
first(parserStatement) = VARBIT TYPE TUPLE STRING STATE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
first(parserState) = STATE PRAGMA AT
first(parserLocalElement) = VARBIT VALUESET TUPLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT
first(parserDeclaration) = PRAGMA PARSER AT
first(parserBlockStatement) = PRAGMA L_BRACE AT
first(parameterList) = VARBIT TUPLE STRING PRAGMA OUT NAME INT INOUT IN ERROR DOT COMMA BOOL BIT AT
first(parameter) = VARBIT TUPLE STRING PRAGMA OUT NAME INT INOUT IN ERROR DOT BOOL BIT AT
first(packageTypeDeclaration) = PRAGMA PACKAGE AT
first(p4program) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION
first(optTypeParameters) = L_ANGLE
first(optInitialValue) = ASSIGN
first(optConstructorParameters) = L_PAREN
first(objInitializer) = L_BRACE
first(objDeclaration) = VOID VARBIT TUPLE STRING PRAGMA NAME INT ERROR DOT BOOL BIT AT
first(nonempty_list_aux(tableProperty)) = TYPE STATE PRAGMA NAME KEY CONST AT APPLY ACTIONS
first(nonempty_list_aux(parserState)) = STATE PRAGMA AT
first(nonempty_list_aux(annotation)) = PRAGMA AT
first(nonTypeName) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(nonTableKwName) = TYPE STATE NAME APPLY
first(namedType) = NAME DOT
first(name) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(methodPrototype) = VOID VARBIT TYPE TUPLE STRING STATE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT
first(member) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(matchKindDeclaration) = MATCH_KIND
first(lvalue) = TYPE STATE NAME KEY ENTRIES DOT APPLY ACTIONS
first(list_aux(switchCase)) = TYPE STATE NAME KEY ENTRIES DEFAULT APPLY ACTIONS
first(list_aux(structField)) = VARBIT TUPLE STRING PRAGMA NAME INT ERROR DOT BOOL BIT AT
first(list_aux(statementOrDeclaration)) = VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
first(list_aux(selectCase)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
first(list_aux(parserStatement)) = VARBIT TYPE TUPLE STRING STATE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
first(list_aux(parserLocalElement)) = VARBIT VALUESET TUPLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT
first(list_aux(objDeclaration)) = VOID VARBIT TUPLE STRING PRAGMA NAME INT ERROR DOT BOOL BIT AT
first(list_aux(methodPrototype)) = VOID VARBIT TYPE TUPLE STRING STATE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT
first(list_aux(keyElement)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS
first(list_aux(entry)) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
first(list_aux(controlLocalDeclaration)) = VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ACTION
first(list_aux(annotationToken)) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT
first(kvPair) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(kvList) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(keysetExpression) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
first(keyElementList) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS
first(keyElement) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS
first(instantiation) = VARBIT TUPLE STRING PRAGMA NAME INT ERROR DOT BOOL BIT AT
first(initialValue) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS
first(identifierList) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(headerUnionDeclaration) = PRAGMA HEADER_UNION AT
first(headerTypeDeclaration) = PRAGMA HEADER AT
first(headerStackType) = NAME DOT
first(go_toplevel) = 
first(go_local) = 
first(functionPrototype) = VOID VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
first(functionDeclaration) = VOID VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
first(externName) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
first(externDeclaration) = PRAGMA EXTERN AT
first(expressionList) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT COMMA APPLY ACTIONS
first(expression) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS
first(exitStatement) = EXIT
first(errorDeclaration) = ERROR
first(enumDeclaration) = PRAGMA ENUM AT
first(entry) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
first(entriesList) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
first(emptyStatement) = SEMICOLON
first(dotPrefix) = DOT
first(direction) = OUT INOUT IN
first(directApplication) = NAME DOT
first(derivedTypeDeclaration) = STRUCT PRAGMA HEADER_UNION HEADER ENUM AT
first(controlTypeDeclaration) = PRAGMA CONTROL AT
first(controlLocalDeclaration) = VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT ACTION
first(controlDeclaration) = PRAGMA CONTROL AT
first(controlBody) = PRAGMA L_BRACE AT
first(constantDeclaration) = PRAGMA CONST AT
first(conditionalStatement) = IF
first(blockStatement) = PRAGMA L_BRACE AT
first(baseType) = VARBIT STRING INT ERROR BOOL BIT
first(assignmentOrMethodCallStatement) = TYPE STATE NAME KEY ENTRIES DOT APPLY ACTIONS
first(argumentList) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE COMPLEMENT COMMA APPLY ACTIONS
first(argument) = TYPE TRUE STRING_LITERAL STATE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE COMPLEMENT APPLY ACTIONS
first(annotations) = PRAGMA AT
first(annotationToken) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT
first(annotationBody) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT
first(annotation) = PRAGMA AT
first(actionRef) = TYPE STATE PRAGMA NAME KEY ENTRIES AT APPLY ACTIONS
first(actionList) = TYPE STATE PRAGMA NAME KEY ENTRIES AT APPLY ACTIONS
first(actionDeclaration) = PRAGMA AT ACTION
minimal(variableDeclaration) = (* 3 *) BOOL KEY SEMICOLON
minimal(varName) = (* 2 *) NAME IDENTIFIER
minimal(valueSetDeclaration) = (* 9 *) VALUESET L_ANGLE BOOL R_ANGLE L_PAREN INTEGER R_PAREN KEY SEMICOLON
minimal(typedefDeclaration) = (* 4 *) TYPEDEF BOOL KEY SEMICOLON
minimal(typeRef) = (* 1 *) BOOL
minimal(typeParameter) = (* 1 *) KEY
minimal(typeOrVoid) = (* 1 *) BOOL
minimal(typeName) = (* 2 *) NAME TYPENAME
minimal(typeDeclaration) = (* 4 *) HEADER KEY L_BRACE R_BRACE
minimal(typeArgumentList) = (* 0 *)
minimal(typeArg) = (* 1 *) DONTCARE
minimal(tupleType) = (* 3 *) TUPLE L_ANGLE R_ANGLE
minimal(tupleKeysetExpression) = (* 5 *) L_PAREN INTEGER COMMA INTEGER R_PAREN
minimal(transitionStatement) = (* 0 *)
minimal(topDeclarationList) = (* 0 *)
minimal(topDeclaration) = (* 4 *) EXTERN KEY L_BRACE R_BRACE
minimal(tablePropertyList) = (* 4 *) KEY ASSIGN L_BRACE R_BRACE
minimal(tableProperty) = (* 4 *) KEY ASSIGN L_BRACE R_BRACE
minimal(tableKwName) = (* 1 *) KEY
minimal(tableDeclaration) = (* 8 *) TABLE KEY L_BRACE KEY ASSIGN L_BRACE R_BRACE R_BRACE
minimal(switchStatement) = (* 6 *) SWITCH L_PAREN INTEGER R_PAREN L_BRACE R_BRACE
minimal(switchLabel) = (* 1 *) KEY
minimal(switchCases) = (* 0 *)
minimal(switchCase) = (* 2 *) KEY COLON
minimal(structTypeDeclaration) = (* 4 *) STRUCT KEY L_BRACE R_BRACE
minimal(structField) = (* 3 *) BOOL KEY SEMICOLON
minimal(statementOrDeclaration) = (* 1 *) SEMICOLON
minimal(statement) = (* 1 *) SEMICOLON
minimal(stateExpression) = (* 2 *) KEY SEMICOLON
minimal(specifiedIdentifierList) = (* 3 *) KEY ASSIGN INTEGER
minimal(specifiedIdentifier) = (* 3 *) KEY ASSIGN INTEGER
minimal(specializedType) = (* 4 *) NAME TYPENAME L_ANGLE R_ANGLE
minimal(simpleKeysetExpression) = (* 1 *) INTEGER
minimal(separated_nonempty_list_aux(SEMICOLON,actionRef)) = (* 1 *) KEY
minimal(separated_nonempty_list_aux(COMMA,simpleKeysetExpression)) = (* 1 *) INTEGER
minimal(separated_nonempty_list_aux(COMMA,kvPair)) = (* 3 *) KEY EQ INTEGER
minimal(separated_nonempty_list_aux(COMMA,__anonymous_1)) = (* 3 *) KEY ASSIGN INTEGER
minimal(separated_nonempty_list_aux(COMMA,__anonymous_0)) = (* 1 *) KEY
minimal(separated_list_aux(COMMA,typeParameter)) = (* 0 *)
minimal(separated_list_aux(COMMA,typeArg)) = (* 0 *)
minimal(separated_list_aux(COMMA,parameter)) = (* 0 *)
minimal(separated_list_aux(COMMA,expression)) = (* 0 *)
minimal(separated_list_aux(COMMA,argument)) = (* 0 *)
minimal(separated_atLeastTwo_list_aux(COMMA,simpleKeysetExpression)) = (* 3 *) INTEGER COMMA INTEGER
minimal(separated_atLeastTwo_list(COMMA,simpleKeysetExpression)) = (* 3 *) INTEGER COMMA INTEGER
minimal(selectExpression) = (* 5 *) SELECT L_PAREN R_PAREN L_BRACE R_BRACE
minimal(selectCase) = (* 4 *) INTEGER COLON KEY SEMICOLON
minimal(returnStatement) = (* 2 *) RETURN SEMICOLON
minimal(realTypeArgumentList) = (* 1 *) DONTCARE
minimal(realTypeArg) = (* 1 *) DONTCARE
minimal(push_scope) = (* 0 *)
minimal(push_name) = (* 1 *) KEY
minimal(push_externName) = (* 1 *) KEY
minimal(prefixedType) = (* 2 *) NAME TYPENAME
minimal(prefixedNonTypeName) = (* 1 *) KEY
minimal(pop_scope) = (* 0 *)
minimal(petr4_separated_nonempty_list(COMMA,kvPair)) = (* 3 *) KEY EQ INTEGER
minimal(petr4_separated_nonempty_list(COMMA,__anonymous_1)) = (* 3 *) KEY ASSIGN INTEGER
minimal(petr4_separated_nonempty_list(COMMA,__anonymous_0)) = (* 1 *) KEY
minimal(petr4_separated_list(COMMA,typeParameter)) = (* 0 *)
minimal(petr4_separated_list(COMMA,typeArg)) = (* 0 *)
minimal(petr4_separated_list(COMMA,parameter)) = (* 0 *)
minimal(petr4_separated_list(COMMA,expression)) = (* 0 *)
minimal(petr4_separated_list(COMMA,argument)) = (* 0 *)
minimal(petr4_nonempty_list(tableProperty)) = (* 4 *) KEY ASSIGN L_BRACE R_BRACE
minimal(petr4_nonempty_list(parserState)) = (* 4 *) STATE KEY L_BRACE R_BRACE
minimal(petr4_nonempty_list(annotation)) = (* 2 *) AT KEY
minimal(petr4_list(switchCase)) = (* 0 *)
minimal(petr4_list(structField)) = (* 0 *)
minimal(petr4_list(statementOrDeclaration)) = (* 0 *)
minimal(petr4_list(selectCase)) = (* 0 *)
minimal(petr4_list(parserStatement)) = (* 0 *)
minimal(petr4_list(objDeclaration)) = (* 0 *)
minimal(petr4_list(methodPrototype)) = (* 0 *)
minimal(petr4_list(keyElement)) = (* 0 *)
minimal(petr4_list(entry)) = (* 0 *)
minimal(petr4_list(controlLocalDeclaration)) = (* 0 *)
minimal(petr4_list(annotationToken)) = (* 0 *)
minimal(parserTypeDeclaration) = (* 4 *) PARSER KEY L_PAREN R_PAREN
minimal(parserStatement) = (* 2 *) L_BRACE R_BRACE
minimal(parserState) = (* 4 *) STATE KEY L_BRACE R_BRACE
minimal(parserLocalElement) = (* 3 *) BOOL KEY SEMICOLON
minimal(parserDeclaration) = (* 10 *) PARSER KEY L_PAREN R_PAREN L_BRACE STATE KEY L_BRACE R_BRACE R_BRACE
minimal(parserBlockStatement) = (* 2 *) L_BRACE R_BRACE
minimal(parameterList) = (* 0 *)
minimal(parameter) = (* 2 *) BOOL KEY
minimal(packageTypeDeclaration) = (* 4 *) PACKAGE KEY L_PAREN R_PAREN
minimal(p4program) = (* 1 *) END
minimal(optTypeParameters) = (* 0 *)
minimal(optInitialValue) = (* 0 *)
minimal(optConstructorParameters) = (* 0 *)
minimal(objInitializer) = (* 2 *) L_BRACE R_BRACE
minimal(objDeclaration) = (* 5 *) BOOL L_PAREN R_PAREN KEY SEMICOLON
minimal(nonempty_list_aux(tableProperty)) = (* 4 *) KEY ASSIGN L_BRACE R_BRACE
minimal(nonempty_list_aux(parserState)) = (* 4 *) STATE KEY L_BRACE R_BRACE
minimal(nonempty_list_aux(annotation)) = (* 2 *) AT KEY
minimal(nonTypeName) = (* 1 *) KEY
minimal(nonTableKwName) = (* 1 *) APPLY
minimal(namedType) = (* 2 *) NAME TYPENAME
minimal(name) = (* 1 *) KEY
minimal(methodPrototype) = (* 4 *) KEY L_PAREN R_PAREN SEMICOLON
minimal(member) = (* 1 *) KEY
minimal(matchKindDeclaration) = (* 4 *) MATCH_KIND L_BRACE KEY R_BRACE
minimal(lvalue) = (* 1 *) KEY
minimal(list_aux(switchCase)) = (* 0 *)
minimal(list_aux(structField)) = (* 0 *)
minimal(list_aux(statementOrDeclaration)) = (* 0 *)
minimal(list_aux(selectCase)) = (* 0 *)
minimal(list_aux(parserStatement)) = (* 0 *)
minimal(list_aux(parserLocalElement)) = (* 0 *)
minimal(list_aux(objDeclaration)) = (* 0 *)
minimal(list_aux(methodPrototype)) = (* 0 *)
minimal(list_aux(keyElement)) = (* 0 *)
minimal(list_aux(entry)) = (* 0 *)
minimal(list_aux(controlLocalDeclaration)) = (* 0 *)
minimal(list_aux(annotationToken)) = (* 0 *)
minimal(kvPair) = (* 3 *) KEY EQ INTEGER
minimal(kvList) = (* 3 *) KEY EQ INTEGER
minimal(keysetExpression) = (* 1 *) INTEGER
minimal(keyElementList) = (* 0 *)
minimal(keyElement) = (* 4 *) INTEGER COLON KEY SEMICOLON
minimal(instantiation) = (* 5 *) BOOL L_PAREN R_PAREN KEY SEMICOLON
minimal(initialValue) = (* 1 *) INTEGER
minimal(identifierList) = (* 1 *) KEY
minimal(headerUnionDeclaration) = (* 4 *) HEADER_UNION KEY L_BRACE R_BRACE
minimal(headerTypeDeclaration) = (* 4 *) HEADER KEY L_BRACE R_BRACE
minimal(headerStackType) = (* 5 *) NAME TYPENAME L_BRACKET INTEGER R_BRACKET
minimal(go_toplevel) = (* 0 *)
minimal(go_local) = (* 0 *)
minimal(functionPrototype) = (* 4 *) BOOL KEY L_PAREN R_PAREN
minimal(functionDeclaration) = (* 6 *) BOOL KEY L_PAREN R_PAREN L_BRACE R_BRACE
minimal(externName) = (* 1 *) KEY
minimal(externDeclaration) = (* 4 *) EXTERN KEY L_BRACE R_BRACE
minimal(expressionList) = (* 0 *)
minimal(expression) = (* 1 *) INTEGER
minimal(exitStatement) = (* 2 *) EXIT SEMICOLON
minimal(errorDeclaration) = (* 4 *) ERROR L_BRACE KEY R_BRACE
minimal(enumDeclaration) = (* 5 *) ENUM KEY L_BRACE KEY R_BRACE
minimal(entry) = (* 4 *) INTEGER COLON KEY SEMICOLON
minimal(entriesList) = (* 0 *)
minimal(emptyStatement) = (* 1 *) SEMICOLON
minimal(dotPrefix) = (* 1 *) DOT
minimal(direction) = (* 0 *)
minimal(directApplication) = (* 7 *) NAME TYPENAME DOT APPLY L_PAREN R_PAREN SEMICOLON
minimal(derivedTypeDeclaration) = (* 4 *) HEADER KEY L_BRACE R_BRACE
minimal(controlTypeDeclaration) = (* 4 *) CONTROL KEY L_PAREN R_PAREN
minimal(controlLocalDeclaration) = (* 3 *) BOOL KEY SEMICOLON
minimal(controlDeclaration) = (* 9 *) CONTROL KEY L_PAREN R_PAREN L_BRACE APPLY L_BRACE R_BRACE R_BRACE
minimal(controlBody) = (* 2 *) L_BRACE R_BRACE
minimal(constantDeclaration) = (* 6 *) CONST BOOL KEY ASSIGN INTEGER SEMICOLON
minimal(conditionalStatement) = (* 5 *) IF L_PAREN INTEGER R_PAREN SEMICOLON
minimal(blockStatement) = (* 2 *) L_BRACE R_BRACE
minimal(baseType) = (* 1 *) BOOL
minimal(assignmentOrMethodCallStatement) = (* 4 *) KEY L_PAREN R_PAREN SEMICOLON
minimal(argumentList) = (* 0 *)
minimal(argument) = (* 1 *) INTEGER
minimal(annotations) = (* 2 *) AT KEY
minimal(annotationToken) = (* 1 *) ABSTRACT
minimal(annotationBody) = (* 0 *)
minimal(annotation) = (* 2 *) AT KEY
minimal(actionRef) = (* 1 *) KEY
minimal(actionList) = (* 0 *)
minimal(actionDeclaration) = (* 6 *) ACTION KEY L_PAREN R_PAREN L_BRACE R_BRACE
follow(variableDeclaration) = VARBIT VALUESET TYPE TUPLE TRANSITION TABLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS ACTION #
follow(varName) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT
follow(valueSetDeclaration) = VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT
follow(typedefDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION #
follow(typeRef) = TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS
follow(typeParameter) = R_ANGLE COMMA
follow(typeOrVoid) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
follow(typeName) = TYPE STATE R_PAREN R_ANGLE NAME L_PAREN L_BRACKET KEY ENTRIES DOT COMMA APPLY ACTIONS
follow(typeDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION #
follow(typeArgumentList) = R_ANGLE
follow(typeArg) = R_ANGLE COMMA
follow(tupleType) = TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS
follow(tupleKeysetExpression) = COLON
follow(transitionStatement) = R_BRACE
follow(topDeclarationList) = END
follow(topDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION
follow(tablePropertyList) = R_BRACE
follow(tableProperty) = TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS
follow(tableKwName) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT
follow(tableDeclaration) = VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION
follow(switchStatement) = VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS
follow(switchLabel) = COLON
follow(switchCases) = R_BRACE
follow(switchCase) = TYPE STATE R_BRACE NAME KEY ENTRIES DEFAULT APPLY ACTIONS
follow(structTypeDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION #
follow(structField) = VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT
follow(statementOrDeclaration) = VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
follow(statement) = VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS
follow(stateExpression) = R_BRACE
follow(specifiedIdentifierList) = R_BRACE
follow(specifiedIdentifier) = R_BRACE COMMA
follow(specializedType) = TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS
follow(simpleKeysetExpression) = R_PAREN COMMA COLON
follow(separated_nonempty_list_aux(SEMICOLON,actionRef)) = SEMICOLON
follow(separated_nonempty_list_aux(COMMA,simpleKeysetExpression)) = COMMA
follow(separated_nonempty_list_aux(COMMA,kvPair)) = R_BRACKET COMMA
follow(separated_nonempty_list_aux(COMMA,__anonymous_1)) = R_BRACE COMMA
follow(separated_nonempty_list_aux(COMMA,__anonymous_0)) = R_BRACE COMMA
follow(separated_list_aux(COMMA,typeParameter)) = R_ANGLE COMMA
follow(separated_list_aux(COMMA,typeArg)) = R_ANGLE COMMA
follow(separated_list_aux(COMMA,parameter)) = R_PAREN COMMA
follow(separated_list_aux(COMMA,expression)) = R_PAREN R_BRACKET R_BRACE COMMA
follow(separated_list_aux(COMMA,argument)) = R_PAREN COMMA
follow(separated_atLeastTwo_list_aux(COMMA,simpleKeysetExpression)) = R_PAREN
follow(separated_atLeastTwo_list(COMMA,simpleKeysetExpression)) = R_PAREN
follow(selectExpression) = R_BRACE
follow(selectCase) = TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
follow(returnStatement) = VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS
follow(realTypeArgumentList) = R_ANGLE COMMA
follow(realTypeArg) = R_ANGLE COMMA
follow(push_scope) = VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_PAREN L_BRACE L_ANGLE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
follow(push_name) = L_PAREN L_BRACE L_ANGLE
follow(push_externName) = L_BRACE L_ANGLE
follow(prefixedType) = TYPE STATE R_PAREN R_ANGLE NAME L_PAREN L_BRACKET L_ANGLE KEY ENTRIES DOT COMMA APPLY ACTIONS
follow(prefixedNonTypeName) = L_PAREN L_BRACKET L_ANGLE DOT ASSIGN
follow(pop_scope) = VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION
follow(petr4_separated_nonempty_list(COMMA,kvPair)) = R_BRACKET
follow(petr4_separated_nonempty_list(COMMA,__anonymous_1)) = R_BRACE
follow(petr4_separated_nonempty_list(COMMA,__anonymous_0)) = R_BRACE
follow(petr4_separated_list(COMMA,typeParameter)) = R_ANGLE
follow(petr4_separated_list(COMMA,typeArg)) = R_ANGLE
follow(petr4_separated_list(COMMA,parameter)) = R_PAREN
follow(petr4_separated_list(COMMA,expression)) = R_PAREN R_BRACKET R_BRACE
follow(petr4_separated_list(COMMA,argument)) = R_PAREN
follow(petr4_nonempty_list(tableProperty)) = R_BRACE
follow(petr4_nonempty_list(parserState)) = R_BRACE
follow(petr4_nonempty_list(annotation)) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT APPLY ACTIONS ACTION ABSTRACT
follow(petr4_list(switchCase)) = R_BRACE
follow(petr4_list(structField)) = R_BRACE
follow(petr4_list(statementOrDeclaration)) = R_BRACE
follow(petr4_list(selectCase)) = R_BRACE
follow(petr4_list(parserStatement)) = TRANSITION R_BRACE
follow(petr4_list(objDeclaration)) = R_BRACE
follow(petr4_list(methodPrototype)) = R_BRACE
follow(petr4_list(keyElement)) = R_BRACE
follow(petr4_list(entry)) = R_BRACE
follow(petr4_list(controlLocalDeclaration)) = APPLY
follow(petr4_list(annotationToken)) = R_PAREN PRAGMA_END L_PAREN
follow(parserTypeDeclaration) = SEMICOLON L_PAREN L_BRACE
follow(parserStatement) = VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
follow(parserState) = STATE R_BRACE PRAGMA AT
follow(parserLocalElement) = VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT
follow(parserDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION
follow(parserBlockStatement) = VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
follow(parameterList) = R_PAREN
follow(parameter) = R_PAREN COMMA
follow(packageTypeDeclaration) = SEMICOLON
follow(p4program) = #
follow(optTypeParameters) = L_PAREN L_BRACE
follow(optInitialValue) = SEMICOLON
follow(optConstructorParameters) = L_BRACE
follow(objInitializer) = SEMICOLON
follow(objDeclaration) = VOID VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT
follow(nonempty_list_aux(tableProperty)) = TYPE STATE R_BRACE PRAGMA NAME KEY CONST AT APPLY ACTIONS
follow(nonempty_list_aux(parserState)) = STATE R_BRACE PRAGMA AT
follow(nonempty_list_aux(annotation)) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT
follow(nonTypeName) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT
follow(nonTableKwName) = ASSIGN
follow(namedType) = L_PAREN
follow(name) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT
follow(methodPrototype) = VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT
follow(member) = SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND ASSIGN AND
follow(matchKindDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION
follow(lvalue) = L_PAREN L_BRACKET L_ANGLE DOT ASSIGN
follow(list_aux(switchCase)) = TYPE STATE R_BRACE NAME KEY ENTRIES DEFAULT APPLY ACTIONS
follow(list_aux(structField)) = VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT
follow(list_aux(statementOrDeclaration)) = VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
follow(list_aux(selectCase)) = TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
follow(list_aux(parserStatement)) = VARBIT TYPE TUPLE TRANSITION STRING STATE R_BRACE PRAGMA NAME L_BRACE KEY INT ERROR ENTRIES DOT CONST BOOL BIT AT APPLY ACTIONS
follow(list_aux(parserLocalElement)) = VARBIT VALUESET TUPLE STRING STATE PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT
follow(list_aux(objDeclaration)) = VOID VARBIT TUPLE STRING R_BRACE PRAGMA NAME INT ERROR DOT BOOL BIT AT
follow(list_aux(methodPrototype)) = VOID VARBIT TYPE TUPLE STRING STATE R_BRACE PRAGMA NAME KEY INT ERROR ENTRIES DOT BOOL BIT AT APPLY ACTIONS ABSTRACT
follow(list_aux(keyElement)) = TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS
follow(list_aux(entry)) = TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
follow(list_aux(controlLocalDeclaration)) = VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION
follow(list_aux(annotationToken)) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT
follow(kvPair) = R_BRACKET COMMA
follow(kvList) = R_BRACKET
follow(keysetExpression) = COLON
follow(keyElementList) = R_BRACE
follow(keyElement) = TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT COMPLEMENT APPLY ACTIONS
follow(instantiation) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION
follow(initialValue) = SEMICOLON
follow(identifierList) = R_BRACE
follow(headerUnionDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION #
follow(headerTypeDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION #
follow(headerStackType) = TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS
follow(go_toplevel) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
follow(go_local) = TYPE STATE SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE NAME MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE KEY GE EQ ENTRIES DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND ASSIGN APPLY AND ACTIONS
follow(functionPrototype) = SEMICOLON PRAGMA L_BRACE AT
follow(functionDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON R_BRACE PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION
follow(externName) = L_BRACE L_ANGLE
follow(externDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION
follow(expressionList) = R_PAREN R_BRACKET R_BRACE
follow(expression) = SHL SEMICOLON R_PAREN R_BRACKET R_BRACE R_ANGLE RANGE QUESTION PLUS_SAT PLUSPLUS PLUS OR NE MUL MOD MINUS_SAT MINUS MASK L_PAREN L_BRACKET L_ANGLE LE GE EQ DOT DIV COMMA COLON BIT_XOR BIT_OR BIT_AND AND
follow(exitStatement) = VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS
follow(errorDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION
follow(enumDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION #
follow(entry) = TYPE TRUE STRING_LITERAL STATE R_BRACE PLUS NOT NAME MINUS L_PAREN L_BRACE KEY INTEGER FALSE ERROR ENTRIES DOT DONTCARE DEFAULT COMPLEMENT APPLY ACTIONS
follow(entriesList) = R_BRACE
follow(emptyStatement) = VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS
follow(dotPrefix) = TYPE STATE NAME KEY ENTRIES APPLY ACTIONS
follow(direction) = VARBIT TUPLE STRING NAME INT ERROR DOT BOOL BIT
follow(directApplication) = VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS
follow(derivedTypeDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND KEY INT HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION #
follow(controlTypeDeclaration) = SEMICOLON L_PAREN L_BRACE
follow(controlLocalDeclaration) = VARBIT TUPLE TABLE STRING PRAGMA NAME INT ERROR DOT CONST BOOL BIT AT APPLY ACTION
follow(controlDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT ACTION
follow(controlBody) = R_BRACE
follow(constantDeclaration) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRANSITION TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION
follow(conditionalStatement) = VARBIT TYPE TUPLE SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS
follow(blockStatement) = VOID VARBIT TYPEDEF TYPE TUPLE TABLE SWITCH STRUCT STRING STATE SEMICOLON R_BRACE RETURN PRAGMA PARSER PACKAGE NAME MATCH_KIND L_BRACE KEY INT IF HEADER_UNION HEADER EXTERN EXIT ERROR ENUM ENTRIES END ELSE DOT DEFAULT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION
follow(baseType) = TYPE STATE R_PAREN R_ANGLE NAME L_PAREN KEY ENTRIES COMMA APPLY ACTIONS
follow(assignmentOrMethodCallStatement) = VARBIT TYPE TUPLE TRANSITION SWITCH STRING STATE SEMICOLON R_BRACE RETURN PRAGMA NAME L_BRACE KEY INT IF EXIT ERROR ENTRIES ELSE DOT CONST BOOL BIT AT APPLY ACTIONS
follow(argumentList) = R_PAREN
follow(argument) = R_PAREN COMMA
follow(annotations) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT APPLY ACTIONS ACTION ABSTRACT
follow(annotationToken) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TRUE TRANSITION TABLE SWITCH STRUCT STRING_LITERAL STRING STATE SHL SEMICOLON SELECT R_PAREN R_BRACKET R_BRACE R_ANGLE RETURN RANGE QUESTION PRAGMA_END PRAGMA PLUS_SAT PLUSPLUS PLUS PARSER PACKAGE OUT OR NOT NE NAME MUL MOD MINUS_SAT MINUS MATCH_KIND MASK L_PAREN L_BRACKET L_BRACE L_ANGLE LE KEY INTEGER INT INOUT IN IF HEADER_UNION HEADER GE FALSE EXTERN EXIT ERROR EQ ENUM ENTRIES ELSE DOT DONTCARE DIV DEFAULT CONTROL CONST COMPLEMENT COMMA COLON BOOL BIT_XOR BIT_OR BIT_AND BIT AT ASSIGN APPLY AND ACTIONS ACTION ABSTRACT
follow(annotationBody) = R_PAREN PRAGMA_END L_PAREN
follow(annotation) = VOID VARBIT VALUESET TYPEDEF TYPE TUPLE TABLE STRUCT STRING STATE SEMICOLON PRAGMA PARSER PACKAGE OUT NAME L_BRACE KEY INT INOUT IN HEADER_UNION HEADER EXTERN ERROR ENUM ENTRIES DOT CONTROL CONST BOOL BIT AT APPLY ACTIONS ACTION ABSTRACT
follow(actionRef) = SEMICOLON PRAGMA AT
follow(actionList) = R_BRACE
follow(actionDeclaration) = VOID VARBIT TYPEDEF TYPE TUPLE TABLE STRUCT STRING SEMICOLON PRAGMA PARSER PACKAGE NAME MATCH_KIND INT HEADER_UNION HEADER EXTERN ERROR ENUM END DOT CONTROL CONST BOOL BIT AT APPLY ACTION
Built an LR(0) automaton with 985 states.
The grammar is not SLR(1) -- 36 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 1092 states.
649 shift/reduce conflicts were silently solved.
Warning: one state has reduce/reduce conflicts.
Warning: one reduce/reduce conflict was arbitrarily resolved.
462 out of 1092 states have a default reduction.
333 out of 1092 states are represented.
0 out of 257 symbols keep track of their start position.
0 out of 257 symbols keep track of their end position.
326 out of 478 productions exploit shiftreduce optimization.
0 out of 1092 states can peek at an error.
2832 functions before inlining, 286 functions after inlining.
