%{
module P4Info = Info

open Core_kernel
open Context
open Types

module Info = P4Info

let declare_vars vars = List.iter vars ~f:declare_var
let declare_types types = List.iter types ~f:declare_type

%}
%start p4program
%start typeDeclaration
%start variableDeclaration
%token <Info.t> ABSTRACT
%token <Info.t> ACTION
%token <Info.t> ACTIONS
%token <Info.t> AND
%token <Info.t> APPLY
%token <Info.t> ASSIGN
%token <Info.t> AT
%token <Info.t> BIT
%token <Info.t> BIT_AND
%token <Info.t> BIT_OR
%token <Info.t> BIT_XOR
%token <Info.t> BOOL
%token <Info.t> COLON
%token <Info.t> COMMA
%token <Info.t> COMPLEMENT
%token <Info.t> CONST
%token <Info.t> CONTROL
%token <Info.t> DEFAULT
%token <Info.t> DIV
%token <Info.t> DONTCARE
%token <Info.t> DOT
%token <Info.t> ELSE
%token <Info.t> END
%token <Info.t> ENTRIES
%token <Info.t> ENUM
%token <Info.t> EQ
%token <Info.t> ERROR
%token <Info.t> EXIT
%token <Info.t> EXTERN
%token <Info.t> FALSE
%token <Info.t> GE
%token <Info.t> HEADER
%token <Info.t> HEADER_UNION
%token IDENTIFIER
%token <Info.t> IF
%token <Info.t> IN
%token <Info.t> INOUT
%token <Info.t> INT
%token <Types.P4Int.t * string> INTEGER
%token <Info.t> KEY
%token <Info.t> LE
%token <Info.t> L_ANGLE
%token <Info.t> L_BRACE
%token <Info.t> L_BRACKET
%token <Info.t> L_PAREN
%token <Info.t> MASK
%token <Info.t> MATCH_KIND
%token <Info.t> MINUS
%token <Info.t> MINUS_SAT
%token <Info.t> MOD
%token <Info.t> MUL
%token <Types.P4String.t> NAME
%token <Info.t> NE
%token <Info.t> NOT
%token <Info.t> OR
%token <Info.t> OUT
%token <Info.t> PACKAGE
%token <Info.t> PARSER
%token <Info.t> PLUS
%token <Info.t> PLUSPLUS
%token <Info.t> PLUS_SAT
%token <Info.t> PRAGMA
%token <Info.t> PRAGMA_END
%token <Info.t> QUESTION
%token <Info.t> RANGE
%token <Info.t> RETURN
%token <Info.t> R_ANGLE
%token <Info.t> R_BRACE
%token <Info.t> R_BRACKET
%token <Info.t> R_PAREN
%token <Info.t> SELECT
%token <Info.t> SEMICOLON
%token <Info.t> SHL
%token <Info.t> STATE
%token <Info.t> STRING
%token <Types.P4String.t> STRING_LITERAL
%token <Info.t> STRUCT
%token <Info.t> SWITCH
%token <Info.t> TABLE
%token <Info.t> THEN
%token <Info.t> TRANSITION
%token <Info.t> TRUE
%token <Info.t> TUPLE
%token <Info.t> TYPE
%token <Info.t> TYPEDEF
%token TYPENAME
%token <Info.t> VALUESET
%token <Info.t> VARBIT
%token <Info.t> VOID
%right ELSE THEN
%nonassoc QUESTION
%nonassoc COLON
%left OR
%left AND
%left EQ NE
%left GE LE L_ANGLE R_ANGLE
%left BIT_OR
%left BIT_XOR
%left BIT_AND
%left SHL
%left MINUS MINUS_SAT PLUS PLUSPLUS PLUS_SAT
%left DIV MOD MUL
%right PREFIX
%nonassoc L_BRACKET L_PAREN
%left DOT
%type <Types.program> p4program
%type <Types.Declaration.t> typeDeclaration
%type <Types.Declaration.t> variableDeclaration
%%

push_scope:
  
    {    ( push_scope() )}

push_name:
  n = name
    {     ( push_scope();
       declare_type n;
       n)}

push_externName:
  n = externName
    {    ( push_scope();
      declare_type n;
      n)}

pop_scope:
  
    {    ( pop_scope() )}

go_toplevel:
  
    {    ( go_toplevel () )}

go_local:
  
    {    ( go_local () )}

separated_nonempty_list_aux_COMMA___anonymous_0_:
  id = name
    {let x =                                                  (id) in
    ( [x] )}
| xs = separated_nonempty_list_aux_COMMA___anonymous_0_ _2 = COMMA id = name
    {let x =                                                  (id) in
    ( x::xs )}

separated_nonempty_list_aux_COMMA___anonymous_1_:
  specId = specifiedIdentifier
    {let x =                                                                         ( specId ) in
    ( [x] )}
| xs = separated_nonempty_list_aux_COMMA___anonymous_1_ _2 = COMMA specId = specifiedIdentifier
    {let x =                                                                         ( specId ) in
    ( x::xs )}

separated_nonempty_list_aux_COMMA_kvPair_:
  x = kvPair
    {    ( [x] )}
| xs = separated_nonempty_list_aux_COMMA_kvPair_ _2 = COMMA x = kvPair
    {    ( x::xs )}

separated_nonempty_list_aux_COMMA_simpleKeysetExpression_:
  x = simpleKeysetExpression
    {    ( [x] )}
| xs = separated_nonempty_list_aux_COMMA_simpleKeysetExpression_ _2 = COMMA x = simpleKeysetExpression
    {    ( x::xs )}

separated_nonempty_list_aux_SEMICOLON_actionRef_:
  x = actionRef
    {    ( [x] )}
| xs = separated_nonempty_list_aux_SEMICOLON_actionRef_ _2 = SEMICOLON x = actionRef
    {    ( x::xs )}

petr4_separated_nonempty_list_COMMA___anonymous_0_:
  rev_list = separated_nonempty_list_aux_COMMA___anonymous_0_
    {    ( List.rev rev_list )}

petr4_separated_nonempty_list_COMMA___anonymous_1_:
  rev_list = separated_nonempty_list_aux_COMMA___anonymous_1_
    {    ( List.rev rev_list )}

petr4_separated_nonempty_list_COMMA_kvPair_:
  rev_list = separated_nonempty_list_aux_COMMA_kvPair_
    {    ( List.rev rev_list )}

separated_atLeastTwo_list_aux_COMMA_simpleKeysetExpression_:
  xs = separated_nonempty_list_aux_COMMA_simpleKeysetExpression_ _2 = COMMA x = simpleKeysetExpression
    {    ( x::xs )}

separated_atLeastTwo_list_COMMA_simpleKeysetExpression_:
  rev_list = separated_atLeastTwo_list_aux_COMMA_simpleKeysetExpression_
    {      (List.rev rev_list)}

separated_list_aux_COMMA_argument_:
  
    {    ( [] )}
| x = argument
    {    ( [x] )}
| xs = separated_list_aux_COMMA_argument_ _2 = COMMA x = argument
    {    ( x::xs )}

separated_list_aux_COMMA_expression_:
  
    {    ( [] )}
| x = expression
    {    ( [x] )}
| xs = separated_list_aux_COMMA_expression_ _2 = COMMA x = expression
    {    ( x::xs )}

separated_list_aux_COMMA_parameter_:
  
    {    ( [] )}
| x = parameter
    {    ( [x] )}
| xs = separated_list_aux_COMMA_parameter_ _2 = COMMA x = parameter
    {    ( x::xs )}

separated_list_aux_COMMA_typeArg_:
  
    {    ( [] )}
| x = typeArg
    {    ( [x] )}
| xs = separated_list_aux_COMMA_typeArg_ _2 = COMMA x = typeArg
    {    ( x::xs )}

separated_list_aux_COMMA_typeParameter_:
  
    {    ( [] )}
| x = typeParameter
    {    ( [x] )}
| xs = separated_list_aux_COMMA_typeParameter_ _2 = COMMA x = typeParameter
    {    ( x::xs )}

petr4_separated_list_COMMA_argument_:
  rev_list = separated_list_aux_COMMA_argument_
    {    ( List.rev rev_list )}

petr4_separated_list_COMMA_expression_:
  rev_list = separated_list_aux_COMMA_expression_
    {    ( List.rev rev_list )}

petr4_separated_list_COMMA_parameter_:
  rev_list = separated_list_aux_COMMA_parameter_
    {    ( List.rev rev_list )}

petr4_separated_list_COMMA_typeArg_:
  rev_list = separated_list_aux_COMMA_typeArg_
    {    ( List.rev rev_list )}

petr4_separated_list_COMMA_typeParameter_:
  rev_list = separated_list_aux_COMMA_typeParameter_
    {    ( List.rev rev_list )}

nonempty_list_aux_annotation_:
  x = annotation
    {    ( [x] )}
| xs = nonempty_list_aux_annotation_ x = annotation
    {    (x::xs)}

nonempty_list_aux_parserState_:
  x = parserState
    {    ( [x] )}
| xs = nonempty_list_aux_parserState_ x = parserState
    {    (x::xs)}

nonempty_list_aux_tableProperty_:
  x = tableProperty
    {    ( [x] )}
| xs = nonempty_list_aux_tableProperty_ x = tableProperty
    {    (x::xs)}

petr4_nonempty_list_annotation_:
  rev_list = nonempty_list_aux_annotation_
    {    ( List.rev rev_list )}

petr4_nonempty_list_parserState_:
  rev_list = nonempty_list_aux_parserState_
    {    ( List.rev rev_list )}

petr4_nonempty_list_tableProperty_:
  rev_list = nonempty_list_aux_tableProperty_
    {    ( List.rev rev_list )}

list_aux_annotationToken_:
  
    {    ( [] )}
| xs = list_aux_annotationToken_ x = annotationToken
    {    ( x::xs )}

list_aux_controlLocalDeclaration_:
  
    {    ( [] )}
| xs = list_aux_controlLocalDeclaration_ x = controlLocalDeclaration
    {    ( x::xs )}

list_aux_entry_:
  
    {    ( [] )}
| xs = list_aux_entry_ x = entry
    {    ( x::xs )}

list_aux_keyElement_:
  
    {    ( [] )}
| xs = list_aux_keyElement_ x = keyElement
    {    ( x::xs )}

list_aux_methodPrototype_:
  
    {    ( [] )}
| xs = list_aux_methodPrototype_ x = methodPrototype
    {    ( x::xs )}

list_aux_objDeclaration_:
  
    {    ( [] )}
| xs = list_aux_objDeclaration_ x = objDeclaration
    {    ( x::xs )}

list_aux_parserLocalElement_:
  
    {    ( [] )}
| xs = list_aux_parserLocalElement_ x = parserLocalElement
    {    ( x::xs )}

list_aux_parserStatement_:
  
    {    ( [] )}
| xs = list_aux_parserStatement_ x = parserStatement
    {    ( x::xs )}

list_aux_selectCase_:
  
    {    ( [] )}
| xs = list_aux_selectCase_ x = selectCase
    {    ( x::xs )}

list_aux_statementOrDeclaration_:
  
    {    ( [] )}
| xs = list_aux_statementOrDeclaration_ x = statementOrDeclaration
    {    ( x::xs )}

list_aux_structField_:
  
    {    ( [] )}
| xs = list_aux_structField_ x = structField
    {    ( x::xs )}

list_aux_switchCase_:
  
    {    ( [] )}
| xs = list_aux_switchCase_ x = switchCase
    {    ( x::xs )}

petr4_list_annotationToken_:
  rev_list = list_aux_annotationToken_
    {    (List.rev rev_list)}

petr4_list_controlLocalDeclaration_:
  rev_list = list_aux_controlLocalDeclaration_
    {    (List.rev rev_list)}

petr4_list_entry_:
  rev_list = list_aux_entry_
    {    (List.rev rev_list)}

petr4_list_keyElement_:
  rev_list = list_aux_keyElement_
    {    (List.rev rev_list)}

petr4_list_methodPrototype_:
  rev_list = list_aux_methodPrototype_
    {    (List.rev rev_list)}

petr4_list_objDeclaration_:
  rev_list = list_aux_objDeclaration_
    {    (List.rev rev_list)}

petr4_list_parserStatement_:
  rev_list = list_aux_parserStatement_
    {    (List.rev rev_list)}

petr4_list_selectCase_:
  rev_list = list_aux_selectCase_
    {    (List.rev rev_list)}

petr4_list_statementOrDeclaration_:
  rev_list = list_aux_statementOrDeclaration_
    {    (List.rev rev_list)}

petr4_list_structField_:
  rev_list = list_aux_structField_
    {    (List.rev rev_list)}

petr4_list_switchCase_:
  rev_list = list_aux_switchCase_
    {    (List.rev rev_list)}

p4program:
  ds = topDeclarationList _2 = END
    {                                        ( Program(ds) )}

topDeclarationList:
  
    {              ( [] )}
| _1 = SEMICOLON ds = topDeclarationList
    {                                    ( ds )}
| d = topDeclaration ds = topDeclarationList
    {                                             ( d :: ds )}

topDeclaration:
  c = constantDeclaration
    {    ( declare_var (Declaration.name c);
      c )}
| e = externDeclaration
    {    ( e )}
| a = actionDeclaration
    {    ( declare_var (Declaration.name a);
      a )}
| p = parserDeclaration
    {    ( declare_type (Declaration.name p);
      p )}
| c = controlDeclaration
    {    ( declare_type (Declaration.name c);
      c )}
| i = instantiation
    {    ( declare_var (Declaration.name i);
      i )}
| t = typeDeclaration
    {    ( declare_type (Declaration.name t);
      t )}
| e = errorDeclaration
    {    ( (* declare_type (Declaration.name e); *)
      e )}
| m = matchKindDeclaration
    {    ( m )}
| f = functionDeclaration
    {    ( declare_var (Declaration.name f);
      f )}

varName:
  id = NAME _2 = IDENTIFIER
    {                       ( id )}

tableKwName:
  info = KEY
    {             ( (info, "key") )}
| info = ACTIONS
    {                 ( (info, "actions") )}
| info = ENTRIES
    {                 ( (info, "entries") )}

nonTableKwName:
  n = varName
    {              ( n )}
| n = NAME _2 = TYPENAME
    {                    ( n )}
| info = APPLY
    {               ( (info, "apply") )}
| info = STATE
    {               ( (info, "state") )}
| info = TYPE
    {              ( (info, "type") )}

nonTypeName:
  n = varName
    {              ( n )}
| n = tableKwName
    {                  ( n )}
| info = APPLY
    {               ( (info, "apply") )}
| info = STATE
    {               ( (info, "state") )}
| info = TYPE
    {              ( (info, "type") )}

name:
  n = nonTypeName
    {                      ( n )}
| n = NAME _2 = TYPENAME
    {                      ( n )}

annotations:
  annotations = petr4_nonempty_list_annotation_
    {                                          ( annotations )}

annotation:
  info1 = AT name = name
    {    ( let info2 = info name in
      let body = (info2, Annotation.Empty) in
      (Info.merge info1 info2,
       Annotation.{ name; body } ) )}
| info1 = AT name = name info2 = L_PAREN body = annotationBody info3 = R_PAREN
    {    ( let body = (Info.merge info2 info3, Annotation.Unparsed(body)) in
      (Info.merge info1 info3,
       Annotation.{ name; body }) )}
| info1 = AT name = name info2 = L_BRACKET body = expressionList info3 = R_BRACKET
    {    ( let body = (Info.merge info2 info3, Annotation.Expression(body)) in
      (Info.merge info1 info3,
       Annotation.{ name; body }) )}
| info1 = AT name = name info2 = L_BRACKET body = kvList info3 = R_BRACKET
    {    ( let body = (Info.merge info2 info3, Annotation.KeyValue(body)) in
      (Info.merge info1 info3,
       Annotation.{ name; body }) )}
| info1 = PRAGMA name = name body = annotationBody info2 = PRAGMA_END
    {    ( let body = (Info.merge info2 info2, Annotation.Unparsed(body)) in
       (Info.merge info1 info2,
       Annotation.{ name; body }) )}

annotationBody:
  body = petr4_list_annotationToken_
    {  ( body )}
| body1 = annotationBody _2 = L_PAREN body2 = annotationBody _4 = R_PAREN
    {  ( body1 @ body2 )}

annotationToken:
  _1 = ABSTRACT
    {                   ( (_1, "abstract") )}
| _1 = ACTION
    {                   ( (_1, "action") )}
| _1 = ACTIONS
    {                   ( (_1, "actions") )}
| _1 = APPLY
    {                   ( (_1, "apply") )}
| _1 = BOOL
    {                   ( (_1, "bool") )}
| _1 = BIT
    {                   ( (_1, "bit") )}
| _1 = CONST
    {                   ( (_1, "const") )}
| _1 = CONTROL
    {                   ( (_1, "control") )}
| _1 = DEFAULT
    {                   ( (_1, "default") )}
| _1 = ELSE
    {                   ( (_1, "else") )}
| _1 = ENTRIES
    {                   ( (_1, "entries") )}
| _1 = ENUM
    {                   ( (_1, "enum") )}
| _1 = ERROR
    {                   ( (_1, "error") )}
| _1 = EXIT
    {                   ( (_1, "exit") )}
| _1 = EXTERN
    {                   ( (_1, "extern") )}
| _1 = FALSE
    {                   ( (_1, "false") )}
| _1 = HEADER
    {                   ( (_1, "header") )}
| _1 = HEADER_UNION
    {                   ( (_1, "header_union") )}
| _1 = IF
    {                   ( (_1, "if") )}
| _1 = IN
    {                   ( (_1, "in") )}
| _1 = INOUT
    {                   ( (_1, "inout") )}
| _1 = INT
    {                   ( (_1, "int") )}
| _1 = KEY
    {                   ( (_1, "key") )}
| _1 = MATCH_KIND
    {                   ( (_1, "match_kind") )}
| _1 = TYPE
    {                   ( (_1, "type") )}
| _1 = OUT
    {                   ( (_1, "out") )}
| _1 = PARSER
    {                   ( (_1, "parser") )}
| _1 = PACKAGE
    {                   ( (_1, "package") )}
| _1 = PRAGMA
    {                   ( (_1, "pragma") )}
| _1 = RETURN
    {                   ( (_1, "return") )}
| _1 = SELECT
    {                   ( (_1, "select") )}
| _1 = STATE
    {                   ( (_1, "state") )}
| _1 = STRING
    {                   ( (_1, "string") )}
| _1 = STRUCT
    {                   ( (_1, "struct") )}
| _1 = SWITCH
    {                   ( (_1, "switch") )}
| _1 = TABLE
    {                   ( (_1, "table") )}
| _1 = TRANSITION
    {                   ( (_1, "transition") )}
| _1 = TRUE
    {                   ( (_1, "true") )}
| _1 = TUPLE
    {                   ( (_1, "tuple") )}
| _1 = TYPEDEF
    {                   ( (_1, "typedef") )}
| _1 = VARBIT
    {                   ( (_1, "varbit") )}
| _1 = VALUESET
    {                   ( (_1, "valueset") )}
| _1 = VOID
    {                   ( (_1, "void") )}
| _1 = DONTCARE
    {                   ( (_1, "_") )}
| _1 = NAME _2 = IDENTIFIER
    {                   ( _1 )}
| _1 = NAME _2 = TYPENAME
    {                   ( _1 )}
| _1 = STRING_LITERAL
    {                   ( _1 )}
| _1 = INTEGER
    {                   ( let n_int, n_str = _1 in
                     let info = fst n_int in
                     (info, n_str) )}
| _1 = MASK
    {                   ( (_1, "&&&") )}
| _1 = RANGE
    {                   ( (_1, "..") )}
| _1 = SHL
    {                   ( (_1, "<<") )}
| _1 = AND
    {                   ( (_1, "&&") )}
| _1 = OR
    {                   ( (_1, "||") )}
| _1 = EQ
    {                   ( (_1, "==") )}
| _1 = NE
    {                   ( (_1, "!=") )}
| _1 = GE
    {                   ( (_1, ">=") )}
| _1 = LE
    {                   ( (_1, "<=") )}
| _1 = PLUSPLUS
    {                   ( (_1, "++") )}
| _1 = PLUS
    {                   ( (_1, "+") )}
| _1 = PLUS_SAT
    {                   ( (_1, "|+|") )}
| _1 = MINUS
    {                   ( (_1, "-") )}
| _1 = MINUS_SAT
    {                   ( (_1, "|-|") )}
| _1 = MUL
    {                   ( (_1, "*") )}
| _1 = DIV
    {                   ( (_1, "/") )}
| _1 = MOD
    {                   ( (_1, "%") )}
| _1 = BIT_OR
    {                   ( (_1, "|") )}
| _1 = BIT_AND
    {                   ( (_1, "&") )}
| _1 = BIT_XOR
    {                   ( (_1, "^") )}
| _1 = COMPLEMENT
    {                   ( (_1, "~") )}
| _1 = L_BRACKET
    {                   ( (_1, "[") )}
| _1 = R_BRACKET
    {                   ( (_1, "]") )}
| _1 = L_BRACE
    {                   ( (_1, "{") )}
| _1 = R_BRACE
    {                   ( (_1, "}") )}
| _1 = L_ANGLE
    {                   ( (_1, "<") )}
| _1 = R_ANGLE
    {                   ( (_1, ">") )}
| _1 = NOT
    {                   ( (_1, "!") )}
| _1 = COLON
    {                   ( (_1, ":") )}
| _1 = COMMA
    {                   ( (_1, ",") )}
| _1 = QUESTION
    {                   ( (_1, "?") )}
| _1 = DOT
    {                   ( (_1, ".") )}
| _1 = ASSIGN
    {                   ( (_1, "=") )}
| _1 = SEMICOLON
    {                   ( (_1, ";") )}
| _1 = AT
    {                   ( (_1, "@") )}

parameterList:
  params = petr4_separated_list_COMMA_parameter_
    {    ( let names = List.map ~f:(fun (_,p) -> p.Parameter.variable) params in
      declare_vars names; params )}

parameter:
  direction = direction typ = typeRef variable = name
    {let annotations =                ( [] ) in
    ( let info1 =
        match direction with
        | None -> info typ
        | Some dir -> info dir in
      (Info.merge info1 (info variable),
       Parameter.{ annotations; direction; typ; variable; opt_value = None }) )}
| annotations = annotations direction = direction typ = typeRef variable = name
    {let annotations =                              ( annotations ) in
    ( let info1 =
        match direction with
        | None -> info typ
        | Some dir -> info dir in
      (Info.merge info1 (info variable),
       Parameter.{ annotations; direction; typ; variable; opt_value = None }) )}
| direction = direction typ = typeRef variable = name _5 = ASSIGN value = expression
    {let annotations =                ( [] ) in
    ( let info1 =
        match direction with
        | None -> info typ
        | Some dir -> info dir in
      (Info.merge info1 (info variable),
       Parameter.{ annotations; direction; typ; variable; opt_value = Some value }) )}
| annotations = annotations direction = direction typ = typeRef variable = name _5 = ASSIGN value = expression
    {let annotations =                              ( annotations ) in
    ( let info1 =
        match direction with
        | None -> info typ
        | Some dir -> info dir in
      (Info.merge info1 (info variable),
       Parameter.{ annotations; direction; typ; variable; opt_value = Some value }) )}

direction:
  info = IN
    {                 ( Some (info, Direction.In) )}
| info = OUT
    {                 ( Some (info, Direction.Out) )}
| info = INOUT
    {                 ( Some (info, Direction.InOut) )}
| 
    {                 ( None )}

packageTypeDeclaration:
  info1 = PACKAGE name = push_name type_params = optTypeParameters _5 = L_PAREN params = parameterList info2 = R_PAREN
    {let annotations =                ( [] ) in
     (  (Info.merge info1 info2,
        Declaration.PackageType { annotations; name; type_params; params }) )}
| annotations = annotations info1 = PACKAGE name = push_name type_params = optTypeParameters _5 = L_PAREN params = parameterList info2 = R_PAREN
    {let annotations =                              ( annotations ) in
     (  (Info.merge info1 info2,
        Declaration.PackageType { annotations; name; type_params; params }) )}

instantiation:
  typ = typeRef _3 = L_PAREN args = argumentList _5 = R_PAREN name = name info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( (Info.merge (info typ) info2,
       Declaration.Instantiation { annotations; typ; args; name; init=None }) )}
| annotations = annotations typ = typeRef _3 = L_PAREN args = argumentList _5 = R_PAREN name = name info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( (Info.merge (info typ) info2,
       Declaration.Instantiation { annotations; typ; args; name; init=None }) )}
| typ = typeRef _3 = L_PAREN args = argumentList _5 = R_PAREN name = name _7 = ASSIGN init = objInitializer info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( (Info.merge (info typ) info2,
       Declaration.Instantiation { annotations; typ; args; name; init=Some init }) )}
| annotations = annotations typ = typeRef _3 = L_PAREN args = argumentList _5 = R_PAREN name = name _7 = ASSIGN init = objInitializer info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( (Info.merge (info typ) info2,
       Declaration.Instantiation { annotations; typ; args; name; init=Some init }) )}

objInitializer:
  _1 = L_BRACE statements = petr4_list_objDeclaration_ _3 = R_BRACE
    {  ( (Info.merge _1 _3, Block.{ annotations = []; statements }) )}

objDeclaration:
  decl = functionDeclaration
    {  ( (info decl, Statement.DeclarationStatement { decl }) )}
| decl = instantiation
    {  ( (info decl, Statement.DeclarationStatement { decl }) )}

optConstructorParameters:
  
    {              ( [] )}
| _1 = L_PAREN params = parameterList _3 = R_PAREN
    {                                         ( params )}

dotPrefix:
  info = DOT
    {             ( info )}

parserDeclaration:
  p_type = parserTypeDeclaration constructor_params = optConstructorParameters _3 = L_BRACE locals = list_aux_parserLocalElement_ states = petr4_nonempty_list_parserState_ info2 = R_BRACE _7 = pop_scope
    {    ( let open Declaration in
      let (info1, annotations, name, type_params, params) = p_type in
      let info = Info.merge info1 info2 in
      (info, Parser { annotations; name; type_params; params; constructor_params; locals; states }) )}

parserLocalElement:
  c = constantDeclaration
    {                          ( c )}
| v = variableDeclaration
    {                          ( v )}
| i = instantiation
    {                          ( i )}
| vs = valueSetDeclaration
    {                           ( vs )}

parserTypeDeclaration:
  info1 = PARSER name = push_name type_params = optTypeParameters _5 = L_PAREN params = parameterList info2 = R_PAREN
    {let annotations =                ( [] ) in
    ( let info = Info.merge info1 info2 in
      (info, annotations, name, type_params, params) )}
| annotations = annotations info1 = PARSER name = push_name type_params = optTypeParameters _5 = L_PAREN params = parameterList info2 = R_PAREN
    {let annotations =                              ( annotations ) in
    ( let info = Info.merge info1 info2 in
      (info, annotations, name, type_params, params) )}

parserState:
  info1 = STATE name = push_name _4 = L_BRACE statements = petr4_list_parserStatement_ transition = transitionStatement info2 = R_BRACE _8 = pop_scope
    {let annotations =                ( [] ) in
     ( (Info.merge info1 info2, Parser.{ annotations; name; statements; transition }) )}
| annotations = annotations info1 = STATE name = push_name _4 = L_BRACE statements = petr4_list_parserStatement_ transition = transitionStatement info2 = R_BRACE _8 = pop_scope
    {let annotations =                              ( annotations ) in
     ( (Info.merge info1 info2, Parser.{ annotations; name; statements; transition }) )}

parserStatement:
  s = assignmentOrMethodCallStatement
    {   ( s )}
| s = directApplication
    {   ( s )}
| s = parserBlockStatement
    {   ( s )}
| decl = constantDeclaration
    {  ( (info decl, Statement.DeclarationStatement { decl }) )}
| decl = variableDeclaration
    {  ( (info decl, Statement.DeclarationStatement { decl }) )}

parserBlockStatement:
  info1 = L_BRACE statements = petr4_list_parserStatement_ info2 = R_BRACE
    {let annotations =                ( [] ) in
     ( let info = Info.merge info1 info2 in
       let block = (info, Block.{ annotations; statements }) in
       (info, Statement.BlockStatement { block = block }) )}
| annotations = annotations info1 = L_BRACE statements = petr4_list_parserStatement_ info2 = R_BRACE
    {let annotations =                              ( annotations ) in
     ( let info = Info.merge info1 info2 in
       let block = (info, Block.{ annotations; statements }) in
       (info, Statement.BlockStatement { block = block }) )}

transitionStatement:
  
    {  ( let info = Info.M "Compiler-generated reject transition" in
    (info, Parser.Direct { next = (info, "reject") }) )}
| info1 = TRANSITION transition = stateExpression
    {    ( (Info.merge info1 (info transition),
       snd transition) )}

stateExpression:
  next = name info2 = SEMICOLON
    {    ( (Info.merge (info next) info2,
       Parser.Direct { next = next }) )}
| select = selectExpression
    {    ( select )}

selectExpression:
  info1 = SELECT _2 = L_PAREN exprs = expressionList _4 = R_PAREN _5 = L_BRACE cases = petr4_list_selectCase_ info2 = R_BRACE
    {    ( (Info.merge info1 info2,
       Parser.Select { exprs; cases }) )}

selectCase:
  matches = keysetExpression _2 = COLON next = name info2 = SEMICOLON
    {  ( let info1 = match matches with
      | expr::_ -> info expr
      | _ -> assert false in
    (Info.merge info1 info2,
     Parser.{ matches; next }) )}

keysetExpression:
  exprs = tupleKeysetExpression
    {                                ( exprs )}
| expr = simpleKeysetExpression
    {                                 ( [expr] )}

tupleKeysetExpression:
  _1 = L_PAREN exprs = separated_atLeastTwo_list_COMMA_simpleKeysetExpression_ _3 = R_PAREN
    {    ( exprs )}

simpleKeysetExpression:
  expr = expression
    {                    ( (info expr, Match.Expression { expr }) )}
| info = DONTCARE
    {                  ( (info, Match.DontCare) )}
| info = DEFAULT
    {                 ( (info, Match.Default) )}
| expr = expression _2 = MASK mask = expression
    {    ( let info = Info.merge (info expr) (info mask) in
      (info, Match.Expression { expr = (info, Expression.Mask { expr; mask }) }) )}
| lo = expression _2 = RANGE hi = expression
    {    ( let info = Info.merge (info lo) (info hi) in
      (info, Match.Expression {expr = (info, Expression.Range { lo; hi })}))}

valueSetDeclaration:
  info1 = VALUESET _3 = L_ANGLE typ = baseType _5 = R_ANGLE _6 = L_PAREN size = expression _8 = R_PAREN name = name info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( (Info.merge info1 info2,
      Declaration.ValueSet { annotations; typ; size; name } ) )}
| annotations = annotations info1 = VALUESET _3 = L_ANGLE typ = baseType _5 = R_ANGLE _6 = L_PAREN size = expression _8 = R_PAREN name = name info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( (Info.merge info1 info2,
      Declaration.ValueSet { annotations; typ; size; name } ) )}
| info1 = VALUESET _3 = L_ANGLE typ = tupleType _5 = R_ANGLE _6 = L_PAREN size = expression _8 = R_PAREN name = name info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( (Info.merge info1 info2,
      Declaration.ValueSet { annotations; typ; size; name } ) )}
| annotations = annotations info1 = VALUESET _3 = L_ANGLE typ = tupleType _5 = R_ANGLE _6 = L_PAREN size = expression _8 = R_PAREN name = name info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( (Info.merge info1 info2,
      Declaration.ValueSet { annotations; typ; size; name } ) )}
| info1 = VALUESET _3 = L_ANGLE typ = typeName _5 = R_ANGLE _6 = L_PAREN size = expression _8 = R_PAREN name = name info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( (Info.merge info1 info2,
      Declaration.ValueSet { annotations; typ; size; name } ) )}
| annotations = annotations info1 = VALUESET _3 = L_ANGLE typ = typeName _5 = R_ANGLE _6 = L_PAREN size = expression _8 = R_PAREN name = name info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( (Info.merge info1 info2,
      Declaration.ValueSet { annotations; typ; size; name } ) )}

controlDeclaration:
  ct_decl = controlTypeDeclaration constructor_params = optConstructorParameters _3 = L_BRACE locals = petr4_list_controlLocalDeclaration_ _5 = APPLY apply = controlBody info2 = R_BRACE _8 = pop_scope
    {    (
      let info1, annotations, name, type_params, params = ct_decl in
      (Info.merge info1 info2,
       Declaration.Control { annotations; name; type_params; params; constructor_params;
                             locals; apply } ) )}

controlTypeDeclaration:
  info1 = CONTROL name = push_name type_params = optTypeParameters _5 = L_PAREN params = parameterList info2 = R_PAREN
    {let annotations =                ( [] ) in
     ( (Info.merge info1 info2, annotations, name, type_params, params) )}
| annotations = annotations info1 = CONTROL name = push_name type_params = optTypeParameters _5 = L_PAREN params = parameterList info2 = R_PAREN
    {let annotations =                              ( annotations ) in
     ( (Info.merge info1 info2, annotations, name, type_params, params) )}

controlLocalDeclaration:
  c = constantDeclaration
    {    ( c )}
| a = actionDeclaration
    {    ( declare_var (Declaration.name a); a )}
| t = tableDeclaration
    {    ( declare_var (Declaration.name t); t )}
| i = instantiation
    {    ( i )}
| v = variableDeclaration
    {    ( v )}

controlBody:
  b = blockStatement
    {                     ( b )}

externDeclaration:
  info1 = EXTERN name = push_externName type_params = optTypeParameters _5 = L_BRACE methods = petr4_list_methodPrototype_ info2 = R_BRACE _8 = pop_scope
    {let annotations =                ( [] ) in
     ( let type_decl =
         (Info.merge info1 info2,
          (Declaration.ExternObject { annotations; name; type_params; methods })) in
       declare_type (Declaration.name type_decl);
       type_decl )}
| annotations = annotations info1 = EXTERN name = push_externName type_params = optTypeParameters _5 = L_BRACE methods = petr4_list_methodPrototype_ info2 = R_BRACE _8 = pop_scope
    {let annotations =                              ( annotations ) in
     ( let type_decl =
         (Info.merge info1 info2,
          (Declaration.ExternObject { annotations; name; type_params; methods })) in
       declare_type (Declaration.name type_decl);
       type_decl )}
| info1 = EXTERN func = functionPrototype _4 = pop_scope info2 = SEMICOLON
    {let annotations =                ( [] ) in
     ( let (_, return, name, type_params, params) = func in
       let decl =
         (Info.merge info1 info2,
          Declaration.ExternFunction { annotations; return; name; type_params; params }) in
       declare_var (Declaration.name decl);
       decl )}
| annotations = annotations info1 = EXTERN func = functionPrototype _4 = pop_scope info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
     ( let (_, return, name, type_params, params) = func in
       let decl =
         (Info.merge info1 info2,
          Declaration.ExternFunction { annotations; return; name; type_params; params }) in
       declare_var (Declaration.name decl);
       decl )}

externName:
  n = nonTypeName
    {                  ( declare_type n; n )}

functionPrototype:
  typ = typeOrVoid name = name _3 = push_scope type_params = optTypeParameters _5 = L_PAREN params = parameterList info2 = R_PAREN
    {    ( (Info.merge (info typ) info2, typ, name, type_params, params) )}

methodPrototype:
  func = functionPrototype _3 = pop_scope info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( let (info1, return, name, type_params, params) = func in
      (Info.merge info1 info2,
       MethodPrototype.Method { annotations; return; name; type_params; params }) )}
| annotations = annotations func = functionPrototype _3 = pop_scope info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( let (info1, return, name, type_params, params) = func in
      (Info.merge info1 info2,
       MethodPrototype.Method { annotations; return; name; type_params; params }) )}
| _2 = ABSTRACT func = functionPrototype _4 = pop_scope info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( let (info1, return, name, type_params, params) = func in
      (Info.merge info1 info2,
       MethodPrototype.AbstractMethod { annotations; return; name; type_params; params }) )}
| annotations = annotations _2 = ABSTRACT func = functionPrototype _4 = pop_scope info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( let (info1, return, name, type_params, params) = func in
      (Info.merge info1 info2,
       MethodPrototype.AbstractMethod { annotations; return; name; type_params; params }) )}
| name = name _3 = L_PAREN params = parameterList _5 = R_PAREN info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( (Info.merge (info name) info2,
      MethodPrototype.Constructor { annotations; name; params }) )}
| annotations = annotations name = name _3 = L_PAREN params = parameterList _5 = R_PAREN info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( (Info.merge (info name) info2,
      MethodPrototype.Constructor { annotations; name; params }) )}

typeRef:
  t = baseType
    {    ( t )}
| t = typeName
    {    ( t )}
| t = specializedType
    {    ( t )}
| t = headerStackType
    {    ( t )}
| t = tupleType
    {    ( t )}

namedType:
  t = typeName
    {    ( t )}
| t = specializedType
    {    ( t )}

prefixedType:
  name = NAME _2 = TYPENAME
    {    ( (info name, Type.TypeName name) )}
| _1 = dotPrefix _2 = go_toplevel name = NAME _4 = TYPENAME _5 = go_local
    {    ( (info name, Type.TopLevelType name) )}

typeName:
  typ = prefixedType
    {    ( typ )}

tupleType:
  info1 = TUPLE _2 = L_ANGLE elements = typeArgumentList info2 = R_ANGLE
    {    ( (Info.merge info1 info2,
       Type.Tuple elements) )}

headerStackType:
  header = typeName _2 = L_BRACKET size = expression info2 = R_BRACKET
    {    ( (Info.merge (info header) info2,
       Type.HeaderStack { header; size }) )}

specializedType:
  base = prefixedType _2 = L_ANGLE args = typeArgumentList info2 = R_ANGLE
    {    ( (Info.merge (info base) info2,
      Type.SpecializedType { base; args }) )}

baseType:
  info = BOOL
    {    ( (info, Type.Bool) )}
| info = ERROR
    {    ( (info, Type.Error) )}
| info = BIT
    {    ( let width = (info, Expression.Int (info, { value = Bigint.of_int 1;
                                                 width_signed = None })) in
      (info, Type.BitType width) )}
| info1 = BIT _2 = L_ANGLE value = INTEGER info2 = R_ANGLE
    {    ( let value_int = fst value in
      let value_info = fst value_int in
      let width = (value_info, Expression.Int value_int) in
      let info = Info.merge info1 info2 in
      (info, Type.BitType width) )}
| info1 = INT _2 = L_ANGLE value = INTEGER info2 = R_ANGLE
    {     ( let value_int = fst value in
       let value_info = fst value_int in
       let width = (value_info, Expression.Int value_int) in
       let info = Info.merge info1 info2 in
      (info, Type.IntType width) )}
| info1 = VARBIT _2 = L_ANGLE value = INTEGER info2 = R_ANGLE
    {     ( let value_int = fst value in
       let value_info = fst value_int in
       let max_width = (value_info, Expression.Int value_int) in
       let info = Info.merge info1 info2 in
      (info, Type.VarBit max_width) )}
| info1 = BIT _2 = L_ANGLE _3 = L_PAREN width = expression _5 = R_PAREN info2 = R_ANGLE
    {    ( (Info.merge info1 info2,
       Type.BitType width) )}
| info1 = INT _2 = L_ANGLE _3 = L_PAREN width = expression _5 = R_PAREN info2 = R_ANGLE
    {    ( (Info.merge info1 info2,
       Type.IntType width) )}
| info1 = VARBIT _2 = L_ANGLE _3 = L_PAREN max_width = expression _5 = R_PAREN info2 = R_ANGLE
    {    ( (Info.merge info1 info2,
       Type.VarBit max_width) )}
| info = INT
    {    ( (info, Type.Integer) )}
| info = STRING
    {    ( (info, Type.String) )}

typeOrVoid:
  t = typeRef
    {  ( t )}
| info = VOID
    {  ( (info, Type.Void) )}
| name = varName
    {  ( (info name, Type.TypeName name) )}

optTypeParameters:
  
    {              ( [] )}
| _1 = L_ANGLE types = petr4_separated_list_COMMA_typeParameter_ _3 = R_ANGLE
    {    ( declare_types types;
      types )}

typeParameter:
  name = name
    {              ( name )}

realTypeArg:
  info = DONTCARE
    {  ( (info, Type.DontCare) )}
| t = typeRef
    {  ( t )}

typeArg:
  info = DONTCARE
    {                  ( (info, Type.DontCare) )}
| typ = typeRef
    {                ( typ )}
| name = nonTypeName
    {                     ( (info name, Type.TypeName name) )}

typeArgumentList:
  ts = petr4_separated_list_COMMA_typeArg_
    {                                      (ts)}

realTypeArgumentList:
  t = realTypeArg
    {                  ( [t] )}
| ts = realTypeArgumentList _2 = COMMA t = typeArg
    {                                              ( t::ts )}

typeDeclaration:
  d = derivedTypeDeclaration
    {  ( declare_type (Declaration.name d);
    d )}
| d = typedefDeclaration
    {  ( declare_type (Declaration.name d);
    d )}
| d = packageTypeDeclaration _2 = pop_scope _3 = SEMICOLON
    {  ( declare_type (Declaration.name d);
    d )}
| ctd = controlTypeDeclaration _2 = pop_scope _3 = SEMICOLON
    {  ( let info, annotations, name, type_params, params = ctd in
    (info,
     Declaration.ControlType { annotations; name; type_params; params } ) )}
| ptd = parserTypeDeclaration _2 = pop_scope _3 = SEMICOLON
    {  ( let info, annotations, name, type_params, params = ptd in
    (info,
     Declaration.ParserType { annotations; name; type_params; params } ) )}

derivedTypeDeclaration:
  d = headerTypeDeclaration
    {  ( d )}
| d = headerUnionDeclaration
    {  ( d )}
| d = structTypeDeclaration
    {  ( d )}
| d = enumDeclaration
    {  ( d )}

headerTypeDeclaration:
  info1 = HEADER name = name _4 = L_BRACE fields = petr4_list_structField_ info2 = R_BRACE
    {let annotations =                ( [] ) in
     ( (Info.merge info1 info2,
        Declaration.Header { annotations; name; fields }) )}
| annotations = annotations info1 = HEADER name = name _4 = L_BRACE fields = petr4_list_structField_ info2 = R_BRACE
    {let annotations =                              ( annotations ) in
     ( (Info.merge info1 info2,
        Declaration.Header { annotations; name; fields }) )}

headerUnionDeclaration:
  info1 = HEADER_UNION name = name _4 = L_BRACE fields = petr4_list_structField_ info2 = R_BRACE
    {let annotations =                ( [] ) in
     ( (Info.merge info1 info2,
        Declaration.HeaderUnion { annotations; name; fields }) )}
| annotations = annotations info1 = HEADER_UNION name = name _4 = L_BRACE fields = petr4_list_structField_ info2 = R_BRACE
    {let annotations =                              ( annotations ) in
     ( (Info.merge info1 info2,
        Declaration.HeaderUnion { annotations; name; fields }) )}

structTypeDeclaration:
  info1 = STRUCT name = name _4 = L_BRACE fields = petr4_list_structField_ info2 = R_BRACE
    {let annotations =                ( [] ) in
     ( (Info.merge info1 info2,
        Declaration.Struct { annotations; name; fields }) )}
| annotations = annotations info1 = STRUCT name = name _4 = L_BRACE fields = petr4_list_structField_ info2 = R_BRACE
    {let annotations =                              ( annotations ) in
     ( (Info.merge info1 info2,
        Declaration.Struct { annotations; name; fields }) )}

structField:
  typ = typeRef name = name info2 = SEMICOLON
    {let annotations =                ( [] ) in
     ( (Info.merge (info typ) info2,
        { annotations; typ; name }) )}
| annotations = annotations typ = typeRef name = name info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
     ( (Info.merge (info typ) info2,
        { annotations; typ; name }) )}

enumDeclaration:
  info1 = ENUM name = name _4 = L_BRACE members = identifierList info2 = R_BRACE
    {let annotations =                ( [] ) in
    ( (Info.merge info1 info2,
      Declaration.Enum { annotations; name; members }) )}
| annotations = annotations info1 = ENUM name = name _4 = L_BRACE members = identifierList info2 = R_BRACE
    {let annotations =                              ( annotations ) in
    ( (Info.merge info1 info2,
      Declaration.Enum { annotations; name; members }) )}
| info1 = ENUM info2 = BIT _4 = L_ANGLE value = INTEGER info3 = R_ANGLE name = name _8 = L_BRACE members = specifiedIdentifierList info4 = R_BRACE
    {let annotations =                ( [] ) in
   ( let value_int = fst value in
     let value_info = fst value_int in
     let width = (value_info, Expression.Int value_int) in
     let typ = (Info.merge info2 info4, Type.BitType width) in
     (Info.merge info1 info4,
      Declaration.SerializableEnum { annotations; typ; name; members }) )}
| annotations = annotations info1 = ENUM info2 = BIT _4 = L_ANGLE value = INTEGER info3 = R_ANGLE name = name _8 = L_BRACE members = specifiedIdentifierList info4 = R_BRACE
    {let annotations =                              ( annotations ) in
   ( let value_int = fst value in
     let value_info = fst value_int in
     let width = (value_info, Expression.Int value_int) in
     let typ = (Info.merge info2 info4, Type.BitType width) in
     (Info.merge info1 info4,
      Declaration.SerializableEnum { annotations; typ; name; members }) )}

errorDeclaration:
  info1 = ERROR _2 = L_BRACE members = identifierList info2 = R_BRACE
    {    ( declare_vars members;
      (Info.merge info1 info2,
       Declaration.Error { members }) )}

matchKindDeclaration:
  info1 = MATCH_KIND _2 = L_BRACE members = identifierList info2 = R_BRACE
    {    ( declare_vars members;
      (Info.merge info1 info2,
       Declaration.MatchKind { members }) )}

identifierList:
  ids = petr4_separated_nonempty_list_COMMA___anonymous_0_
    {    ( ids )}

specifiedIdentifier:
  name = name _2 = ASSIGN init = expression
    {    ( (name, init) )}

specifiedIdentifierList:
  specIds = petr4_separated_nonempty_list_COMMA___anonymous_1_
    {    ( specIds )}

typedefDeclaration:
  info1 = TYPEDEF typ = typeRef name = name info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( (Info.merge info1 info2,
       Declaration.TypeDef { annotations; name; typ_or_decl = Left typ } ) )}
| annotations = annotations info1 = TYPEDEF typ = typeRef name = name info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( (Info.merge info1 info2,
       Declaration.TypeDef { annotations; name; typ_or_decl = Left typ } ) )}
| info1 = TYPEDEF decl = derivedTypeDeclaration name = name info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( (Info.merge info1 info2,
       Declaration.TypeDef { annotations; name; typ_or_decl = Right decl } ) )}
| annotations = annotations info1 = TYPEDEF decl = derivedTypeDeclaration name = name info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( (Info.merge info1 info2,
       Declaration.TypeDef { annotations; name; typ_or_decl = Right decl } ) )}
| info1 = TYPE typ = typeRef name = name info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( (Info.merge info1 info2,
       Declaration.NewType { annotations; name; typ_or_decl = Left typ } ) )}
| annotations = annotations info1 = TYPE typ = typeRef name = name info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( (Info.merge info1 info2,
       Declaration.NewType { annotations; name; typ_or_decl = Left typ } ) )}
| info1 = TYPE decl = derivedTypeDeclaration name = name info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( (Info.merge info1 info2,
       Declaration.NewType { annotations; name; typ_or_decl = Right decl } ) )}
| annotations = annotations info1 = TYPE decl = derivedTypeDeclaration name = name info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( (Info.merge info1 info2,
       Declaration.NewType { annotations; name; typ_or_decl = Right decl } ) )}

assignmentOrMethodCallStatement:
  func = lvalue _2 = L_PAREN args = argumentList _4 = R_PAREN info2 = SEMICOLON
    {    ( let type_args = [] in
      (Info.merge (info func) info2,
       Statement.MethodCall { func; type_args; args }) )}
| func = lvalue _2 = L_ANGLE type_args = typeArgumentList _4 = R_ANGLE _5 = L_PAREN args = argumentList _7 = R_PAREN info2 = SEMICOLON
    {    ( (Info.merge (info func) info2,
       Statement.MethodCall { func; type_args; args }) )}
| lhs = lvalue _2 = ASSIGN rhs = expression info2 = SEMICOLON
    {    ( (Info.merge (info lhs) info2,
      Statement.Assignment { lhs; rhs }) )}

emptyStatement:
  info = SEMICOLON
    {                   ( (info, Statement.EmptyStatement) )}

returnStatement:
  info1 = RETURN info2 = SEMICOLON
    {    ( (Info.merge info1 info2,
       Statement.Return { expr = None }) )}
| info1 = RETURN expr = expression info2 = SEMICOLON
    {    ( (Info.merge info1 info2,
       Statement.Return { expr = Some expr }) )}

exitStatement:
  info1 = EXIT info2 = SEMICOLON
    {    ( (Info.merge info1 info2,
       Statement.Exit) )}

conditionalStatement:
  info1 = IF _2 = L_PAREN cond = expression _4 = R_PAREN tru = statement _6 = ELSE fls = statement
    {    ( let info2 = info fls in
      let fls = Some fls in
      (Info.merge info1 info2,
       Statement.Conditional { cond; tru; fls }) )}
| info1 = IF _2 = L_PAREN cond = expression _4 = R_PAREN tru = statement %prec THEN
    {    ( let fls = None in
      (Info.merge info1 (info tru),
       Statement.Conditional { cond; tru; fls }) )}

directApplication:
  typ = typeName _2 = DOT _3 = APPLY _4 = L_PAREN args = argumentList _6 = R_PAREN info2 = SEMICOLON
    {    ( (Info.merge (info typ) info2,
      Statement.DirectApplication { typ; args }) )}

statement:
  s = assignmentOrMethodCallStatement
    {    ( s )}
| s = directApplication
    {    ( s )}
| s = conditionalStatement
    {    ( s )}
| s = emptyStatement
    {    ( s )}
| s = exitStatement
    {    ( s )}
| s = returnStatement
    {    ( s )}
| s = switchStatement
    {    ( s )}
| block = blockStatement
    {    ( (info block, Statement.BlockStatement { block }) )}

blockStatement:
  info1 = L_BRACE _3 = push_scope statements = petr4_list_statementOrDeclaration_ info2 = R_BRACE _6 = pop_scope
    {let annotations =                ( [] ) in
     ( (Info.merge info1 info2,
       Block.{ annotations; statements }) )}
| annotations = annotations info1 = L_BRACE _3 = push_scope statements = petr4_list_statementOrDeclaration_ info2 = R_BRACE _6 = pop_scope
    {let annotations =                              ( annotations ) in
     ( (Info.merge info1 info2,
       Block.{ annotations; statements }) )}

switchStatement:
  info1 = SWITCH _2 = L_PAREN expr = expression _4 = R_PAREN _5 = L_BRACE cases = switchCases info2 = R_BRACE
    {    ( (Info.merge info1 info2,
       Statement.Switch { expr; cases }) )}

switchCases:
  cases = petr4_list_switchCase_
    {                                       ( cases )}

switchCase:
  label = switchLabel _2 = COLON code = blockStatement
    {    ( (Info.merge (info label) (info code), Statement.Action { label; code } ) )}
| label = switchLabel info2 = COLON
    {    ( (Info.merge (info label) info2, Statement.FallThrough { label }) )}

switchLabel:
  name = name
    {  ( (info name, Statement.Name name) )}
| info = DEFAULT
    {  ( (info, Statement.Default) )}

statementOrDeclaration:
  decl = variableDeclaration
    {  ( (info decl, Statement.DeclarationStatement { decl = decl }) )}
| decl = constantDeclaration
    {  ( (info decl, Statement.DeclarationStatement { decl = decl }) )}
| decl = instantiation
    {  ( (info decl, Statement.DeclarationStatement { decl = decl }) )}
| s = statement
    {  ( s )}

tableDeclaration:
  info1 = TABLE name = name _4 = L_BRACE properties = tablePropertyList info2 = R_BRACE
    {let annotations =                ( [] ) in
     ( (Info.merge info1 info2,
        Declaration.Table { annotations; name; properties }) )}
| annotations = annotations info1 = TABLE name = name _4 = L_BRACE properties = tablePropertyList info2 = R_BRACE
    {let annotations =                              ( annotations ) in
     ( (Info.merge info1 info2,
        Declaration.Table { annotations; name; properties }) )}

tablePropertyList:
  props = petr4_nonempty_list_tableProperty_
    {                                       ( props )}

tableProperty:
  info1 = KEY _2 = ASSIGN _3 = L_BRACE elts = keyElementList info2 = R_BRACE
    {    ( (Info.merge info1 info2,
       Table.Key { keys = elts }) )}
| info1 = ACTIONS _2 = ASSIGN _3 = L_BRACE acts = actionList info2 = R_BRACE
    {    ( (Info.merge info1 info2,
       Table.Actions { actions = acts }) )}
| info1 = CONST _2 = ENTRIES _3 = ASSIGN _4 = L_BRACE entries = entriesList info2 = R_BRACE
    {    ( (Info.merge info1 info2,
       Table.Entries { entries = entries }) )}
| info1 = CONST n = nonTableKwName _4 = ASSIGN v = initialValue info2 = SEMICOLON
    {let annos =                ( [] ) in
    ( (Info.merge info1 info2,
       Table.Custom { annotations = annos; const = true; name = n; value = v }) )}
| annotations = annotations info1 = CONST n = nonTableKwName _4 = ASSIGN v = initialValue info2 = SEMICOLON
    {let annos =                              ( annotations ) in
    ( (Info.merge info1 info2,
       Table.Custom { annotations = annos; const = true; name = n; value = v }) )}
| n = nonTableKwName _3 = ASSIGN v = initialValue info2 = SEMICOLON
    {let annos =                ( [] ) in
    ( (Info.merge (info n) info2,
       Table.Custom { annotations = annos; const = false; name = n; value = v }) )}
| annotations = annotations n = nonTableKwName _3 = ASSIGN v = initialValue info2 = SEMICOLON
    {let annos =                              ( annotations ) in
    ( (Info.merge (info n) info2,
       Table.Custom { annotations = annos; const = false; name = n; value = v }) )}

keyElementList:
  elts = petr4_list_keyElement_
    {                                        ( elts )}

keyElement:
  key = expression _2 = COLON match_kind = name info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( (Info.merge (info key) info2,
       Table.{ annotations; key; match_kind }) )}
| key = expression _2 = COLON match_kind = name annotations = annotations info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( (Info.merge (info key) info2,
       Table.{ annotations; key; match_kind }) )}

actionList:
  
    {  ( [] )}
| acts = separated_nonempty_list_aux_SEMICOLON_actionRef_ _2 = SEMICOLON
    {    ( List.rev acts )}

entriesList:
  entries = petr4_list_entry_
    {                        ( entries )}

entry:
  matches = keysetExpression info1 = COLON act = actionRef info2 = SEMICOLON
    {let annos =                ( [] ) in
    ( let info = Info.merge info1 info2 in
      (info, { annotations = annos; matches = matches; action = act }) )}
| matches = keysetExpression info1 = COLON act = actionRef annotations = annotations info2 = SEMICOLON
    {let annos =                              ( annotations ) in
    ( let info = Info.merge info1 info2 in
      (info, { annotations = annos; matches = matches; action = act }) )}

actionRef:
  name = name
    {let annotations =                ( [] ) in
     ( (info name, { annotations; name; args = [] }) )}
| annotations = annotations name = name
    {let annotations =                              ( annotations ) in
     ( (info name, { annotations; name; args = [] }) )}
| name = name _3 = L_PAREN args = argumentList info2 = R_PAREN
    {let annotations =                ( [] ) in
     ( (Info.merge (info name) info2,
        { annotations; name; args }) )}
| annotations = annotations name = name _3 = L_PAREN args = argumentList info2 = R_PAREN
    {let annotations =                              ( annotations ) in
     ( (Info.merge (info name) info2,
        { annotations; name; args }) )}

actionDeclaration:
  info1 = ACTION name = name _4 = L_PAREN params = parameterList _6 = R_PAREN body = blockStatement
    {let annotations =                ( [] ) in
     ( (Info.merge info1 (info body),
        Declaration.Action { annotations; name; params; body }) )}
| annotations = annotations info1 = ACTION name = name _4 = L_PAREN params = parameterList _6 = R_PAREN body = blockStatement
    {let annotations =                              ( annotations ) in
     ( (Info.merge info1 (info body),
        Declaration.Action { annotations; name; params; body }) )}

variableDeclaration:
  typ = typeRef name = name init = optInitialValue info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( declare_var name;
      (Info.merge (info typ) info2,
       Declaration.Variable { annotations; typ; name; init }) )}
| annotations = annotations typ = typeRef name = name init = optInitialValue info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( declare_var name;
      (Info.merge (info typ) info2,
       Declaration.Variable { annotations; typ; name; init }) )}

constantDeclaration:
  info1 = CONST typ = typeRef name = name _5 = ASSIGN value = initialValue info2 = SEMICOLON
    {let annotations =                ( [] ) in
    ( (Info.merge info1 info2,
       Declaration.Constant { annotations; typ; name; value }) )}
| annotations = annotations info1 = CONST typ = typeRef name = name _5 = ASSIGN value = initialValue info2 = SEMICOLON
    {let annotations =                              ( annotations ) in
    ( (Info.merge info1 info2,
       Declaration.Constant { annotations; typ; name; value }) )}

optInitialValue:
  
    {              ( None )}
| _1 = ASSIGN v = initialValue
    {                          ( Some v )}

initialValue:
  v = expression
    {                 ( v )}

functionDeclaration:
  func = functionPrototype body = blockStatement _3 = pop_scope
    {    ( let (info1, return, name, type_params, params) = func in
      (Info.merge info1 (info body),
       Declaration.Function { return; name; type_params; params; body }) )}

argumentList:
  args = petr4_separated_list_COMMA_argument_
    {                                                     ( args )}

argument:
  value = expression
    {    ( (info value, Argument.Expression { value }) )}
| key = name _2 = ASSIGN value = expression
    {    ( (Info.merge (info key) (info value),
       Argument.KeyValue { key; value }) )}
| info = DONTCARE
    {    ( (info, Argument.Missing) )}

kvPair:
  key = name _2 = EQ value = expression
    {  ( (Info.merge (info key) (info value),
     KeyValue.{ key; value }) )}

kvList:
  kvs = petr4_separated_nonempty_list_COMMA_kvPair_
    {  ( kvs )}

expressionList:
  exprs = petr4_separated_list_COMMA_expression_
    {  ( exprs )}

member:
  n = name
    {           ( n )}

prefixedNonTypeName:
  name = nonTypeName
    {  ( (info name, Expression.Name name) )}
| info1 = dotPrefix _2 = go_toplevel name = nonTypeName _4 = go_local
    {  ( (Info.merge info1 (info name),
     Expression.TopLevel name) )}

lvalue:
  expr = prefixedNonTypeName
    {                             ( expr )}
| expr = lvalue _2 = DOT name = member
    {  ( (Info.merge (info expr) (info name),
     Expression.ExpressionMember { expr; name }) )}
| array = lvalue _2 = L_BRACKET index = expression info2 = R_BRACKET
    {    ( (Info.merge (info array) info2,
       Expression.ArrayAccess { array; index }) )}
| bits = lvalue _2 = L_BRACKET hi = expression _4 = COLON lo = expression info2 = R_BRACKET
    {    ( (Info.merge (info bits) info2,
       Expression.BitStringAccess { bits; lo; hi }) )}

expression:
  value = INTEGER
    {  ( let value_int = fst value in
    let info = fst value_int in
    (info, Expression.Int value_int) )}
| info1 = TRUE
    {  ( (info1, Expression.True) )}
| info1 = FALSE
    {  ( (info1, Expression.False) )}
| value = STRING_LITERAL
    {  ( (fst value, Expression.String value) )}
| name = nonTypeName
    {  ( (info name, Expression.Name name) )}
| info1 = dotPrefix _2 = go_toplevel name = nonTypeName _4 = go_local
    {  ( (Info.merge info1 (fst name), Expression.TopLevel name) )}
| array = expression _2 = L_BRACKET index = expression info2 = R_BRACKET
    {  ( (Info.merge (info array) info2,
     Expression.ArrayAccess { array; index }) )}
| bits = expression _2 = L_BRACKET hi = expression _4 = COLON lo = expression info2 = R_BRACKET
    {  ( (Info.merge (info bits) info2,
     Expression.BitStringAccess { bits; lo; hi }) )}
| info1 = L_BRACE values = expressionList info2 = R_BRACE
    {  ( (Info.merge info1 info2,
     Expression.List { values }) )}
| _1 = L_PAREN exp = expression _3 = R_PAREN
    {  ( exp )}
| info1 = NOT arg = expression %prec PREFIX
    {  ( (Info.merge info1 (info arg),
     Expression.UnaryOp { op = (info1, Op.Not); arg }) )}
| info1 = COMPLEMENT arg = expression %prec PREFIX
    {  ( (Info.merge info1 (info arg),
     Expression.UnaryOp{op = (info1, Op.BitNot); arg }) )}
| info1 = MINUS arg = expression %prec PREFIX
    {  ( (Info.merge info1 (info arg),
     Expression.UnaryOp{op = (info1, UMinus); arg }) )}
| info1 = PLUS exp = expression %prec PREFIX
    {  ( let info2,exp = exp in
    (Info.merge info1 info2, exp) )}
| info1 = L_PAREN typ = typeRef _3 = R_PAREN expr = expression %prec PREFIX
    {  ( (Info.merge info1 (info expr),
     Expression.Cast { typ; expr }) )}
| typ = typeName _2 = DOT name = member
    {  ( (Info.merge (info typ) (info name),
     Expression.TypeMember { typ; name }) )}
| info1 = ERROR _2 = DOT name = member
    {  ( (Info.merge info1 (info name),
     Expression.ErrorMember name) )}
| expr = expression _2 = DOT name = member
    {  ( (Info.merge (info expr) (info name),
     Expression.ExpressionMember { expr; name }) )}
| arg1 = expression info = MUL arg2 = expression
    {let op =     ( (info, Op.Mul) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = DIV arg2 = expression
    {let op =     ( (info, Op.Div) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = MOD arg2 = expression
    {let op =     ( (info, Op.Mod) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = PLUS arg2 = expression
    {let op =     ( (info, Op.Plus) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = PLUS_SAT arg2 = expression
    {let op =     ( (info, Op.PlusSat)) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = MINUS arg2 = expression
    {let op =     ( (info, Op.Minus) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = MINUS_SAT arg2 = expression
    {let op =     ( (info, Op.MinusSat) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = SHL arg2 = expression
    {let op =     ( (info, Op.Shl) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = R_ANGLE _2 = R_ANGLE arg2 = expression
    {let op =     ( (info, Op.Shr) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = LE arg2 = expression
    {let op =     ( (info, Op.Le) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = GE arg2 = expression
    {let op =     ( (info, Op.Ge) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = L_ANGLE arg2 = expression
    {let op =     ( (info, Op.Lt) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = R_ANGLE arg2 = expression
    {let op =     ( (info, Op.Gt) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = NE arg2 = expression
    {let op =     ( (info, Op.NotEq) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = EQ arg2 = expression
    {let op =     ( (info, Op.Eq) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = BIT_AND arg2 = expression
    {let op =     ( (info, Op.BitAnd) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = BIT_XOR arg2 = expression
    {let op =     ( (info, Op.BitXor) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = BIT_OR arg2 = expression
    {let op =     ( (info, Op.BitOr) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = PLUSPLUS arg2 = expression
    {let op =     ( (info, Op.PlusPlus) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = AND arg2 = expression
    {let op =     ( (info, Op.And) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| arg1 = expression info = OR arg2 = expression
    {let op =     ( (info, Op.Or) ) in
  ( (Info.merge (Types.info arg1) (Types.info arg2),
     Expression.BinaryOp { op; args = (arg1, arg2) }) )}
| cond = expression _2 = QUESTION tru = expression _4 = COLON fls = expression
    {   ( (Info.merge (info cond) (info fls),
      Expression.Ternary { cond; tru; fls }) )}
| func = expression _2 = L_ANGLE type_args = realTypeArgumentList _4 = R_ANGLE _5 = L_PAREN args = argumentList info2 = R_PAREN
    {   ( (Info.merge (info func) info2,
      Expression.FunctionCall { func; type_args; args }) )}
| func = expression _2 = L_PAREN args = argumentList info2 = R_PAREN
    {   ( let type_args = [] in
     (Info.merge (info func) info2,
      Expression.FunctionCall { func; type_args; args }) )}
| typ = namedType _2 = L_PAREN args = argumentList info2 = R_PAREN
    {   ( (Info.merge (info typ) info2,
      Expression.NamelessInstantiation { typ; args }) )}

%%
Note: the nonterminal symbol list (from petr4.mly) is renamed petr4_list.
Note: the nonterminal symbol nonempty_list (from petr4.mly) is renamed petr4_nonempty_list.
Note: the nonterminal symbol option (from petr4.mly) is renamed petr4_option.
Note: the nonterminal symbol separated_list (from petr4.mly) is renamed petr4_separated_list.
Note: the nonterminal symbol separated_nonempty_list (from petr4.mly) is renamed petr4_separated_nonempty_list.
