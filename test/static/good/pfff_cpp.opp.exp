File "pfff_cpp.mly", line 62, characters 52-60:
Warning: the token TComment is unused.
File "pfff_cpp.mly", line 62, characters 36-51:
Warning: the token TCommentNewline is unused.
File "pfff_cpp.mly", line 62, characters 22-35:
Warning: the token TCommentSpace is unused.
File "pfff_cpp.mly", line 67, characters 57-69:
Warning: the token TComment_Cpp is unused.
File "pfff_cpp.mly", line 65, characters 51-62:
Warning: the token TComment_Pp is unused.
File "pfff_cpp.mly", line 134, characters 22-40:
Warning: the token TCppEscapedNewline is unused.
File "pfff_cpp.mly", line 195, characters 22-38:
Warning: the token TInt_ZeroVirtual is unused.
File "pfff_cpp.mly", line 53, characters 22-30:
Warning: the token TUnknown is unused.
File "pfff_cpp.mly", line 122, characters 22-32:
Warning: the token Tattribute is unused.
File "pfff_cpp.mly", line 214, characters 2-16:
Warning: the token Tsigned_Constr is unused.
File "pfff_cpp.mly", line 214, characters 17-33:
Warning: the token Tunsigned_Constr is unused.
%{
(* Yoann Padioleau
 *
 * Copyright (C) 2002-2005 Yoann Padioleau
 * Copyright (C) 2006-2007 Ecole des Mines de Nantes
 * Copyright (C) 2008-2009 University of Urbana Champaign
 * Copyright (C) 2010-2014 Facebook
 * Copyright (C) 2019-2020 r2c
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License (GPL)
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * file license.txt for more details.
 *)
open Common

open Cst_cpp
open Parser_cpp_mly_helper

module PI = Parse_info

(*************************************************************************)
(* Prelude *)
(*************************************************************************)
(* This file contains a grammar for C/C++/Cpp.
 * See cst_cpp.ml for more information.
 *
 * reference:
 *  - orig_c.mly and orig_cpp.mly in this directory
 *  - http://www.nongnu.org/hcb/ for an up-to-date hyperlinked C++ grammar
 *
 * TODO:
 *  - http://www.externsoft.ch/download/cpp-iso.html
 *  - tree-sitter-cpp grammar
 *)
%}
%start main
%start sgrep_spatch_pattern
%start toplevel
%token <Parse_info.t> EOF
%token <Parse_info.t> LDots
%token <Parse_info.t> RDots
%token <Parse_info.t> TAnd
%token <Parse_info.t> TAndLog
%token <Parse_info.t> TAny_Action
%token <Cst_cpp.assignOp> TAssign
%token <Parse_info.t> TBang
%token <Parse_info.t> TCBrace
%token <Parse_info.t> TCCro
%token <Parse_info.t> TCCro_new
%token <Parse_info.t> TCPar
%token <Parse_info.t> TCPar_EOL
%token <(string * Parse_info.t) * Cst_cpp.isWchar> TChar
%token <Parse_info.t> TCol
%token <Parse_info.t> TColCol
%token <Parse_info.t> TColCol_BeforeTypedef
%token <Parse_info.t> TComma
%token <Parse_info.t> TComment
%token <Parse_info.t> TCommentNewline
%token <Parse_info.t> TCommentNewline_DefineEndOfMacro
%token <Parse_info.t> TCommentSpace
%token <(Token_cpp.cpluspluscommentkind * Parse_info.t)> TComment_Cpp
%token <(Token_cpp.cppcommentkind * Parse_info.t)> TComment_Pp
%token <Parse_info.t> TCppDirectiveOther
%token <Parse_info.t> TCppEscapedNewline
%token <Parse_info.t> TDec
%token <(string * Parse_info.t)> TDefParamVariadic
%token <Parse_info.t> TDefine
%token <Parse_info.t> TDiv
%token <Parse_info.t> TDot
%token <Parse_info.t> TDotStar
%token <Parse_info.t> TEllipsis
%token <Parse_info.t> TEndif
%token <Parse_info.t> TEq
%token <Parse_info.t> TEqEq
%token <(float option * Parse_info.t) * Cst_cpp.floatType> TFloat
%token <string * Parse_info.t> TIdent
%token <string * Parse_info.t> TIdent_ClassnameInQualifier
%token <string * Parse_info.t> TIdent_ClassnameInQualifier_BeforeTypedef
%token <string * Parse_info.t> TIdent_Constructor
%token <(string * Parse_info.t)> TIdent_Define
%token <(string * Parse_info.t)> TIdent_MacroDecl
%token <(string * Parse_info.t)> TIdent_MacroIterator
%token <Parse_info.t> TIdent_MacroStmt
%token <Parse_info.t> TIdent_MacroString
%token <string * Parse_info.t> TIdent_Templatename
%token <string * Parse_info.t> TIdent_TemplatenameInQualifier
%token <string * Parse_info.t> TIdent_TemplatenameInQualifier_BeforeTypedef
%token <string * Parse_info.t> TIdent_Typedef
%token <string * Parse_info.t> TIdent_TypedefConstr
%token <Parse_info.t> TIfdef
%token <(bool * Parse_info.t)> TIfdefBool
%token <(bool * Parse_info.t)> TIfdefMisc
%token <(bool * Parse_info.t)> TIfdefVersion
%token <Parse_info.t> TIfdefelif
%token <Parse_info.t> TIfdefelse
%token <Parse_info.t> TInc
%token <(string * string * Parse_info.t)> TInclude
%token <Parse_info.t> TInf
%token <Parse_info.t> TInfEq
%token <Parse_info.t> TInf_Template
%token <int option * Parse_info.t> TInt
%token <Parse_info.t> TInt_ZeroVirtual
%token <Parse_info.t> TMinus
%token <Parse_info.t> TMod
%token <Parse_info.t> TMul
%token <Parse_info.t> TNotEq
%token <Parse_info.t> TOBrace
%token <Parse_info.t> TOBrace_DefineInit
%token <Parse_info.t> TOCro
%token <Parse_info.t> TOCro_Lambda
%token <Parse_info.t> TOCro_new
%token <Parse_info.t> TOPar
%token <Parse_info.t> TOPar_CplusplusInit
%token <Parse_info.t> TOPar_Define
%token <Parse_info.t> TOr
%token <Parse_info.t> TOrLog
%token <Parse_info.t> TPlus
%token <Parse_info.t> TPtVirg
%token <Parse_info.t> TPtrOp
%token <Parse_info.t> TPtrOpStar
%token <Parse_info.t> TShl
%token <Parse_info.t> TShr
%token <(string * Parse_info.t) * Cst_cpp.isWchar> TString
%token <Parse_info.t> TSup
%token <Parse_info.t> TSupEq
%token <Parse_info.t> TSup_Template
%token <Parse_info.t> TTilde
%token <string * Parse_info.t> TUndef
%token <Parse_info.t> TUnknown
%token <Parse_info.t> TWhy
%token <Parse_info.t> TXor
%token <Parse_info.t> Tasm
%token <Parse_info.t> Tattribute
%token <Parse_info.t> Tauto
%token <Parse_info.t> Tbool
%token <Parse_info.t> Tbool_Constr
%token <Parse_info.t> Tbreak
%token <Parse_info.t> Tcase
%token <Parse_info.t> Tcatch
%token <Parse_info.t> Tchar
%token <Parse_info.t> Tchar_Constr
%token <Parse_info.t> Tclass
%token <Parse_info.t> Tconst
%token <Parse_info.t> Tconst_MacroDeclConst
%token <Parse_info.t> Tconst_cast
%token <Parse_info.t> Tconstexpr
%token <Parse_info.t> Tcontinue
%token <Parse_info.t> Tdecltype
%token <Parse_info.t> Tdefault
%token <Parse_info.t> Tdelete
%token <Parse_info.t> Tdo
%token <Parse_info.t> Tdouble
%token <Parse_info.t> Tdouble_Constr
%token <Parse_info.t> Tdynamic_cast
%token <Parse_info.t> Telse
%token <Parse_info.t> Tenum
%token <Parse_info.t> Texplicit
%token <Parse_info.t> Textern
%token <Parse_info.t> Tfalse
%token <Parse_info.t> Tfloat
%token <Parse_info.t> Tfloat_Constr
%token <Parse_info.t> Tfor
%token <Parse_info.t> Tfriend
%token <Parse_info.t> Tgoto
%token <Parse_info.t> Tif
%token <Parse_info.t> Tinline
%token <Parse_info.t> Tint
%token <Parse_info.t> Tint_Constr
%token <Parse_info.t> Tlong
%token <Parse_info.t> Tlong_Constr
%token <Parse_info.t> Tmutable
%token <Parse_info.t> Tnamespace
%token <Parse_info.t> Tnew
%token <Parse_info.t> Tnull
%token <Parse_info.t> Tnullptr
%token <Parse_info.t> Toperator
%token <Parse_info.t> Tprivate
%token <Parse_info.t> Tprotected
%token <Parse_info.t> Tpublic
%token <Parse_info.t> Tregister
%token <Parse_info.t> Treinterpret_cast
%token <Parse_info.t> Trestrict
%token <Parse_info.t> Treturn
%token <Parse_info.t> Tshort
%token <Parse_info.t> Tshort_Constr
%token <Parse_info.t> Tsigned
%token <Parse_info.t> Tsigned_Constr
%token <Parse_info.t> Tsizeof
%token <Parse_info.t> Tstatic
%token <Parse_info.t> Tstatic_cast
%token <Parse_info.t> Tstruct
%token <Parse_info.t> Tswitch
%token <Parse_info.t> Ttemplate
%token <Parse_info.t> Tthis
%token <Parse_info.t> Tthread_local
%token <Parse_info.t> Tthrow
%token <Parse_info.t> Ttrue
%token <Parse_info.t> Ttry
%token <Parse_info.t> Ttypedef
%token <Parse_info.t> Ttypeid
%token <Parse_info.t> Ttypename
%token <Parse_info.t> Ttypeof
%token <Parse_info.t> Tunion
%token <Parse_info.t> Tunsigned
%token <Parse_info.t> Tunsigned_Constr
%token <Parse_info.t> Tusing
%token <Parse_info.t> Tvirtual
%token <Parse_info.t> Tvoid
%token <Parse_info.t> Tvolatile
%token <Parse_info.t> Twchar_t
%token <Parse_info.t> Twchar_t_Constr
%token <Parse_info.t> Twhile
%nonassoc LOW_PRIORITY_RULE
%nonassoc Telse
%left TAnd
%left TMul
%left TAndLog
%type <Cst_cpp.program> main
%type <Cst_cpp.any> sgrep_spatch_pattern
%type <Cst_cpp.toplevel option> toplevel
%%

option_TColCol_:
  
    {    ( None )}
| x = TColCol
    {    ( Some x )}

option_TComma_:
  
    {    ( None )}
| x = TComma
    {    ( Some x )}

option_Tinline_:
  
    {    ( None )}
| x = Tinline
    {    ( Some x )}

option_Ttemplate_:
  
    {    ( None )}
| x = Ttemplate
    {    ( Some x )}

option_Ttypename_:
  
    {    ( None )}
| x = Ttypename
    {    ( Some x )}

option_Tvoid_:
  
    {    ( None )}
| x = Tvoid
    {    ( Some x )}

option_Tvolatile_:
  
    {    ( None )}
| x = Tvolatile
    {    ( Some x )}

option_assign_expr_:
  
    {    ( None )}
| x = assign_expr
    {    ( Some x )}

option_base_clause_:
  
    {    ( None )}
| x = base_clause
    {    ( Some x )}

option_exn_spec_:
  
    {    ( None )}
| x = exn_spec
    {    ( Some x )}

option_expr_:
  
    {    ( None )}
| x = expr
    {    ( Some x )}

option_ident_:
  
    {    ( None )}
| x = ident
    {    ( Some x )}

option_new_initializer_:
  
    {    ( None )}
| x = new_initializer
    {    ( Some x )}

option_new_placement_:
  
    {    ( None )}
| x = new_placement
    {    ( Some x )}

option_parameter_type_list_:
  
    {    ( None )}
| x = parameter_type_list
    {    ( Some x )}

list_statement_cpp_:
  
    {    ( [] )}
| x = statement_cpp xs = list_statement_cpp_
    {    ( x :: xs )}

nonempty_list_TAny_Action_:
  x = TAny_Action
    {    ( [ x ] )}
| x = TAny_Action xs = nonempty_list_TAny_Action_
    {    ( x :: xs )}

nonempty_list_colon_asm_:
  x = colon_asm
    {    ( [ x ] )}
| x = colon_asm xs = nonempty_list_colon_asm_
    {    ( x :: xs )}

nonempty_list_declaration_cpp_:
  x = declaration_cpp
    {    ( [ x ] )}
| x = declaration_cpp xs = nonempty_list_declaration_cpp_
    {    ( x :: xs )}

nonempty_list_designator_:
  x = designator
    {    ( [ x ] )}
| x = designator xs = nonempty_list_designator_
    {    ( x :: xs )}

nonempty_list_external_declaration_:
  x = external_declaration
    {    ( [ x ] )}
| x = external_declaration xs = nonempty_list_external_declaration_
    {    ( x :: xs )}

nonempty_list_handler_:
  x = handler
    {    ( [ x ] )}
| x = handler xs = nonempty_list_handler_
    {    ( x :: xs )}

nonempty_list_statement_:
  x = statement
    {    ( [ x ] )}
| x = statement xs = nonempty_list_statement_
    {    ( x :: xs )}

nonempty_list_string_elem_:
  x = string_elem
    {    ( [ x ] )}
| x = string_elem xs = nonempty_list_string_elem_
    {    ( x :: xs )}

listc_argument_:
  _1 = argument
    {     ( [_1, []] )}
| _1 = listc_argument_ _2 = TComma _3 = argument
    {                  ( _1 @ [_3, [_2]] )}

listc_base_specifier_:
  _1 = base_specifier
    {     ( [_1, []] )}
| _1 = listc_base_specifier_ _2 = TComma _3 = base_specifier
    {                  ( _1 @ [_3, [_2]] )}

listc_colon_option_:
  _1 = colon_option
    {     ( [_1, []] )}
| _1 = listc_colon_option_ _2 = TComma _3 = colon_option
    {                  ( _1 @ [_3, [_2]] )}

listc_enumerator_:
  _1 = enumerator
    {     ( [_1, []] )}
| _1 = listc_enumerator_ _2 = TComma _3 = enumerator
    {                  ( _1 @ [_3, [_2]] )}

listc_init_declarator_:
  _1 = init_declarator
    {     ( [_1, []] )}
| _1 = listc_init_declarator_ _2 = TComma _3 = init_declarator
    {                  ( _1 @ [_3, [_2]] )}

listc_mem_initializer_:
  _1 = mem_initializer
    {     ( [_1, []] )}
| _1 = listc_mem_initializer_ _2 = TComma _3 = mem_initializer
    {                  ( _1 @ [_3, [_2]] )}

listc_member_declarator_:
  _1 = member_declarator
    {     ( [_1, []] )}
| _1 = listc_member_declarator_ _2 = TComma _3 = member_declarator
    {                  ( _1 @ [_3, [_2]] )}

listc_param_define_:
  _1 = param_define
    {     ( [_1, []] )}
| _1 = listc_param_define_ _2 = TComma _3 = param_define
    {                  ( _1 @ [_3, [_2]] )}

listc_template_argument_:
  _1 = template_argument
    {     ( [_1, []] )}
| _1 = listc_template_argument_ _2 = TComma _3 = template_argument
    {                  ( _1 @ [_3, [_2]] )}

listc_template_parameter_:
  _1 = template_parameter
    {     ( [_1, []] )}
| _1 = listc_template_parameter_ _2 = TComma _3 = template_parameter
    {                  ( _1 @ [_3, [_2]] )}

optl_listc_argument__:
  
    {               ( [] )}
| _1 = listc_argument_
    {               ( _1 )}

optl_listc_param_define__:
  
    {               ( [] )}
| _1 = listc_param_define_
    {               ( _1 )}

optl_member_specification_:
  
    {               ( [] )}
| _1 = member_specification
    {               ( _1 )}

optl_nested_name_specifier_:
  
    {               ( [] )}
| _1 = nested_name_specifier
    {               ( _1 )}

optl_nested_name_specifier2_:
  
    {               ( [] )}
| _1 = nested_name_specifier2
    {               ( _1 )}

optl_nonempty_list_declaration_cpp__:
  
    {               ( [] )}
| _1 = nonempty_list_declaration_cpp_
    {               ( _1 )}

main:
  _1 = translation_unit _2 = EOF
    {                               ( _1 )}

translation_unit:
  _1 = nonempty_list_external_declaration_
    {                                        ( _1 )}

external_declaration:
  _1 = function_definition
    {                                  ( DeclElem (Func (FunctionOrMethod _1)) )}
| _1 = block_declaration
    {                                  ( DeclElem (BlockDecl _1) )}

toplevel:
  _1 = toplevel_aux
    {                ( Some _1 )}
| _1 = EOF
    {                ( None )}

toplevel_aux:
  _1 = declaration
    {                       ( DeclElem _1 )}
| _1 = cpp_directive
    {                       ( CppDirectiveDecl _1 )}
| _1 = cpp_ifdef_directive
    {                                                         ( IfdefDecl _1 )}
| _1 = cpp_other
    {                       ( _1 )}
| _1 = TCBrace
    {       ( DeclElem (EmptyDef _1) )}

sgrep_spatch_pattern:
  _1 = expr _2 = EOF
    {                             ( Expr _1 )}
| _1 = statement _2 = EOF
    {                             ( Stmt _1 )}
| _1 = statement _2 = nonempty_list_statement_ _3 = EOF
    {                             ( Stmts (_1::_2) )}
| _1 = cpp_directive _2 = EOF
    {                             ( Toplevel (CppDirectiveDecl _1) )}

id_expression:
  _1 = unqualified_id
    {                  ( noQscope, _1 )}
| _1 = qualified_id
    {                ( _1 )}

unqualified_id:
  _1 = TIdent
    {                          ( IdIdent _1 )}
| _1 = operator_function_id
    {                          ( _1 )}
| _1 = conversion_function_id
    {                          ( _1 )}

operator_function_id:
  _1 = Toperator _2 = operator_kind
    {                                              ( IdOperator (_1, _2) )}

conversion_function_id:
  _1 = Toperator _2 = conversion_type_id
    {                                                     ( IdConverter (_1, _2) )}

operator_kind:
  _1 = TEqEq
    {          ( BinaryOp (Logical Eq),    [_1] )}
| _1 = TNotEq
    {          ( BinaryOp (Logical NotEq), [_1] )}
| _1 = TEq
    {           ( AssignOp (SimpleAssign _1), noii )}
| _1 = TAssign
    {           ( AssignOp (_1), noii )}
| _1 = TTilde
    {          ( UnaryTildeOp, [_1] )}
| _1 = TBang
    {                                         ( UnaryNotOp,   [_1] )}
| _1 = TComma
    {       ( CommaOp,  [_1] )}
| _1 = TPlus
    {         ( BinaryOp (Arith Plus),  [_1] )}
| _1 = TMinus
    {          ( BinaryOp (Arith Minus), [_1] )}
| _1 = TMul
    {         ( BinaryOp (Arith Mul),   [_1] )}
| _1 = TDiv
    {        ( BinaryOp (Arith Div), [_1] )}
| _1 = TMod
    {                                              ( BinaryOp (Arith Mod),[_1] )}
| _1 = TOr
    {       ( BinaryOp (Arith Or),  [_1] )}
| _1 = TXor
    {                                             ( BinaryOp (Arith Xor), [_1] )}
| _1 = TAnd
    {        ( BinaryOp (Arith And), [_1]  )}
| _1 = TShl
    {        ( BinaryOp (Arith DecLeft), [_1] )}
| _1 = TShr
    {        ( BinaryOp (Arith DecRight), [_1] )}
| _1 = TOrLog
    {           ( BinaryOp (Logical OrLog), [_1] )}
| _1 = TAndLog
    {        ( BinaryOp (Logical AndLog), [_1] )}
| _1 = TInf
    {        ( BinaryOp (Logical Inf), [_1] )}
| _1 = TSup
    {                                                ( BinaryOp (Logical Sup), [_1])}
| _1 = TInfEq
    {          ( BinaryOp (Logical InfEq), [_1] )}
| _1 = TSupEq
    {          ( BinaryOp (Logical SupEq), [_1] )}
| _1 = TInc
    {        ( FixOp Inc, [_1] )}
| _1 = TDec
    {                                   ( FixOp Dec, [_1] )}
| _1 = TPtrOpStar
    {              ( PtrOpOp PtrStarOp, [_1] )}
| _1 = TPtrOp
    {                                                   ( PtrOpOp PtrOp,     [_1] )}
| _1 = TOPar _2 = TCPar
    {           ( AccessOp ParenOp, [_1;_2] )}
| _1 = TOCro _2 = TCCro
    {                                                   ( AccessOp ArrayOp, [_1;_2])}
| _1 = Tnew
    {           ( AllocOp NewOp,    [_1] )}
| _1 = Tdelete
    {                                                ( AllocOp DeleteOp, [_1] )}
| _1 = Tnew _2 = TOCro_new _3 = TCCro_new
    {                               ( AllocOp NewArrayOp,    [_1;_2;_3] )}
| _1 = Tdelete _2 = TOCro_new _3 = TCCro_new
    {                               ( AllocOp DeleteArrayOp, [_1;_2;_3] )}

qualified_id:
  _1 = nested_name_specifier _2 = unqualified_id
    {   ( _1, _2 )}

nested_name_specifier:
  _1 = class_or_namespace_name_for_qualifier _2 = TColCol _3 = optl_nested_name_specifier_
    {   ( (_1, _2)::_3 )}

class_or_namespace_name_for_qualifier:
  _1 = TIdent_ClassnameInQualifier
    {     ( QClassname _1 )}
| _1 = TIdent_TemplatenameInQualifier _2 = TInf_Template _3 = listc_template_argument_ _4 = TSup_Template
    {     ( QTemplateId (_1, (_2, _3, _4)) )}

enum_name_or_typedef_name_or_simple_class_name:
  _1 = TIdent_Typedef
    {                                                               ( _1 )}

nested_name_specifier2:
  _1 = class_or_namespace_name_for_qualifier2 _2 = TColCol_BeforeTypedef _3 = optl_nested_name_specifier2_
    {     ( (_1, _2)::_3 )}

class_or_namespace_name_for_qualifier2:
  _1 = TIdent_ClassnameInQualifier_BeforeTypedef
    {     ( QClassname _1  )}
| _1 = TIdent_TemplatenameInQualifier_BeforeTypedef _2 = TInf_Template _3 = listc_template_argument_ _4 = TSup_Template
    {     ( QTemplateId (_1, (_2, _3, _4)) )}

ident:
  _1 = TIdent
    {                  ( _1 )}
| _1 = TIdent_Typedef
    {                  ( _1 )}

expr:
  _1 = assign_expr
    {                           ( _1 )}
| _1 = expr _2 = TComma _3 = assign_expr
    {                        ( Sequence (_1, _2, _3) )}

assign_expr:
  _1 = cond_expr
    {                                 ( _1 )}
| _1 = cast_expr _2 = TAssign _3 = assign_expr
    {                                 ( Assign (_1, _2,_3))}
| _1 = cast_expr _2 = TEq _3 = assign_expr
    {                                 ( Assign (_1,SimpleAssign _2,_3))}
| _1 = Tthrow _2 = option_assign_expr_
    {                              ( Throw (_1, _2) )}

cond_expr:
  _1 = logical_or_expr
    {                     ( _1 )}
| _1 = logical_or_expr _2 = TWhy _3 = option_expr_ _4 = TCol _5 = assign_expr
    {                                             ( CondExpr (_1,_2, _3, _4, _5))}

multiplicative_expr:
  _1 = pm_expr
    {           ( _1 )}
| _1 = multiplicative_expr _2 = TMul _3 = pm_expr
    {                                    ( Binary(_1,(Arith Mul,_2),_3) )}
| _1 = multiplicative_expr _2 = TDiv _3 = pm_expr
    {                                    ( Binary(_1,(Arith Div,_2),_3) )}
| _1 = multiplicative_expr _2 = TMod _3 = pm_expr
    {                                    ( Binary(_1,(Arith Mod,_2),_3) )}

additive_expr:
  _1 = multiplicative_expr
    {                       ( _1 )}
| _1 = additive_expr _2 = TPlus _3 = multiplicative_expr
    {                                            ( Binary(_1,(Arith Plus,_2),_3) )}
| _1 = additive_expr _2 = TMinus _3 = multiplicative_expr
    {                                            ( Binary(_1,(Arith Minus,_2),_3) )}

shift_expr:
  _1 = additive_expr
    {                 ( _1 )}
| _1 = shift_expr _2 = TShl _3 = additive_expr
    {                                 ( Binary(_1,(Arith DecLeft,_2),_3) )}
| _1 = shift_expr _2 = TShr _3 = additive_expr
    {                                 ( Binary(_1,(Arith DecRight,_2),_3) )}

relational_expr:
  _1 = shift_expr
    {              ( _1 )}
| _1 = relational_expr _2 = TInf _3 = shift_expr
    {                                   ( Binary(_1,(Logical Inf,_2),_3) )}
| _1 = relational_expr _2 = TSup _3 = shift_expr
    {                                   ( Binary(_1,(Logical Sup,_2),_3) )}
| _1 = relational_expr _2 = TInfEq _3 = shift_expr
    {                                     ( Binary(_1,(Logical InfEq,_2),_3) )}
| _1 = relational_expr _2 = TSupEq _3 = shift_expr
    {                                     ( Binary(_1,(Logical SupEq,_2),_3) )}

equality_expr:
  _1 = relational_expr
    {                   ( _1 )}
| _1 = equality_expr _2 = TEqEq _3 = relational_expr
    {                                        ( Binary(_1,(Logical Eq,_2),_3) )}
| _1 = equality_expr _2 = TNotEq _3 = relational_expr
    {                                        ( Binary(_1,(Logical NotEq,_2),_3) )}

and_expr:
  _1 = equality_expr
    {                 ( _1 )}
| _1 = and_expr _2 = TAnd _3 = equality_expr
    {                              ( Binary(_1,(Arith And,_2),_3) )}

exclusive_or_expr:
  _1 = and_expr
    {            ( _1 )}
| _1 = exclusive_or_expr _2 = TXor _3 = and_expr
    {                                   ( Binary(_1,(Arith Xor,_2),_3) )}

inclusive_or_expr:
  _1 = exclusive_or_expr
    {                     ( _1 )}
| _1 = inclusive_or_expr _2 = TOr _3 = exclusive_or_expr
    {                                           ( Binary(_1,(Arith Or,_2),_3) )}

logical_and_expr:
  _1 = inclusive_or_expr
    {                     ( _1 )}
| _1 = logical_and_expr _2 = TAndLog _3 = inclusive_or_expr
    {                                           ( Binary(_1,(Logical AndLog,_2),_3) )}

logical_or_expr:
  _1 = logical_and_expr
    {                    ( _1 )}
| _1 = logical_or_expr _2 = TOrLog _3 = logical_and_expr
    {                                           ( Binary(_1,(Logical OrLog,_2),_3) )}

pm_expr:
  _1 = cast_expr
    {             ( _1 )}
| _1 = pm_expr _2 = TDotStar _3 = cast_expr
    {                                  ( RecordStarAccess   (_1, _2,_3) )}
| _1 = pm_expr _2 = TPtrOpStar _3 = cast_expr
    {                                  ( RecordPtStarAccess (_1, _2, _3) )}

cast_expr:
  _1 = unary_expr
    {                             ( _1 )}
| _1 = TOPar _2 = type_id _3 = TCPar _4 = cast_expr
    {                             ( Cast ((_1, _2, _3), _4) )}
| _1 = TOPar _2 = type_id _3 = TIdent _4 = TCPar
    {                          ( Flag_parsing.sgrep_guard (TypedMetavar (_3, _2)) )}

unary_expr:
  _1 = postfix_expr
    {                           ( _1 )}
| _1 = TInc _2 = unary_expr
    {                           ( Infix (_2, (Inc, _1)) )}
| _1 = TDec _2 = unary_expr
    {                           ( Infix (_2, (Dec, _1)) )}
| _1 = unary_op _2 = cast_expr
    {                           ( Unary (_2, _1) )}
| _1 = Tsizeof _2 = unary_expr
    {                           ( SizeOfExpr (_1, _2) )}
| _1 = Tsizeof _2 = TOPar _3 = type_id _4 = TCPar
    {                           ( SizeOfType (_1, (_2, _3, _4)) )}
| _1 = new_expr
    {                 ( _1 )}
| _1 = delete_expr
    {                 ( _1 )}

unary_op:
  _1 = TAnd
    {          ( GetRef,     _1 )}
| _1 = TMul
    {          ( DeRef,      _1 )}
| _1 = TPlus
    {          ( UnPlus,     _1 )}
| _1 = TMinus
    {          ( UnMinus,    _1 )}
| _1 = TTilde
    {          ( Tilde,      _1 )}
| _1 = TBang
    {          ( Not,        _1 )}
| _1 = TAndLog
    {        ( GetRefLabel, _1 )}

postfix_expr:
  _1 = primary_expr
    {                              ( _1 )}
| _1 = postfix_expr _2 = TOCro _3 = expr _4 = TCCro
    {                                          ( ArrayAccess (_1, (_2, _3,_4)) )}
| _1 = postfix_expr _2 = TOPar _3 = optl_listc_argument__ _4 = TCPar
    {                                              ( mk_funcall _1 (_2, _3, _4) )}
| _1 = postfix_expr _2 = TDot _3 = option_Ttemplate_ _4 = option_TColCol_ _5 = id_expression
    {     ( let name = (_4, fst _5, snd _5) in RecordAccess (_1,_2,name) )}
| _1 = postfix_expr _2 = TPtrOp _3 = option_Ttemplate_ _4 = option_TColCol_ _5 = id_expression
    {     ( let name = (_4, fst _5, snd _5) in RecordPtAccess(_1,_2,name)  )}
| _1 = postfix_expr _2 = TInc
    {                              ( Postfix (_1, (Inc, _2)) )}
| _1 = postfix_expr _2 = TDec
    {                              ( Postfix (_1, (Dec, _2)) )}
| _1 = TOPar _2 = type_id _3 = TCPar _4 = braced_init_list
    {                                    ( GccConstructor ((_1, _2, _3), _4) )}
| _1 = cast_operator_expr
    {                      ( _1 )}
| _1 = Ttypeid _2 = TOPar _3 = unary_expr _4 = TCPar
    {                              ( TypeId (_1, (_2, Right _3, _4)) )}
| _1 = Ttypeid _2 = TOPar _3 = type_id _4 = TCPar
    {                              ( TypeId (_1, (_2, Left _3, _4)) )}
| _1 = cast_constructor_expr
    {                         ( _1 )}
| _1 = simple_type_specifier _2 = braced_init_list
    {                                           ( ExprTodo (Common2.fst3 _2) )}
| _1 = TIdent _2 = braced_init_list
    {                           ( ExprTodo (Common2.fst3 _2) )}

primary_expr:
  _1 = literal
    {           ( _1 )}
| _1 = Tthis
    {         ( This _1 )}
| _1 = TOPar _2 = expr _3 = TCPar
    {                ( ParenExpr (_1, _2, _3) )}
| _1 = TOPar _2 = compound _3 = TCPar
    {                       ( StatementExpr (_1, _2, _3) )}
| _1 = primary_cplusplus_id
    {                        ( _1 )}
| _1 = lambda_introducer _2 = compound
    {                              ( ExprTodo _1 )}
| _1 = LDots _2 = expr _3 = RDots
    {                    ( DeepEllipsis (_1, _2, _3) )}

literal:
  _1 = TInt
    {           ( C (Int    (_1)) )}
| _1 = TFloat
    {           ( C (Float  (_1)) )}
| _1 = TChar
    {           ( C (Char   (_1)) )}
| _1 = TString
    {           ( C (String (_1)) )}
| _1 = string_elem _2 = nonempty_list_string_elem_
    {                            ( C (MultiString (_1 :: _2)) )}
| _1 = Ttrue
    {           ( C (Bool (true, _1)) )}
| _1 = Tfalse
    {           ( C (Bool (false, _1)) )}
| _1 = Tnullptr
    {            ( C (Nullptr _1) )}
| _1 = Tnull
    {            ( C (Nullptr _1) )}

primary_cplusplus_id:
  _1 = id_expression
    {     ( let name = (None, fst _1, snd _1) in
       Id (name, noIdInfo()) )}
| _1 = TColCol _2 = TIdent
    {     ( let name = Some _1, noQscope, IdIdent _2 in
       Id (name, noIdInfo()) )}
| _1 = TColCol _2 = operator_function_id
    {     ( let qop = _2 in
       let name = (Some _1, noQscope, qop) in
       Id (name, noIdInfo()) )}
| _1 = TColCol _2 = qualified_id
    {     ( let name = (Some _1, fst _2, snd _2) in
       Id (name, noIdInfo()) )}

cast_operator_expr:
  _1 = cpp_cast_operator _2 = TInf_Template _3 = type_id _4 = TSup_Template _5 = TOPar _6 = expr _7 = TCPar
    {     ( CplusplusCast (_1, (_2, _3, _4), (_5, _6, _7)) )}
| _1 = cpp_cast_operator _2 = TOPar _3 = expr _4 = TCPar
    {     ( ExprTodo _2 )}

cpp_cast_operator:
  _1 = Tstatic_cast
    {                     ( Static_cast, _1 )}
| _1 = Tdynamic_cast
    {                     ( Dynamic_cast, _1 )}
| _1 = Tconst_cast
    {                     ( Const_cast, _1 )}
| _1 = Treinterpret_cast
    {                     ( Reinterpret_cast, _1 )}

cast_constructor_expr:
  _1 = TIdent_TypedefConstr _2 = TOPar _3 = optl_listc_argument__ _4 = TCPar
    {     ( let name = None, noQscope, IdIdent _1 in
       let ft = nQ, (TypeName name) in
       ConstructedObject (ft, (_2, _3, _4))
     )}
| _1 = basic_type_2 _2 = TOPar _3 = optl_listc_argument__ _4 = TCPar
    {     ( let ft = nQ, _1 in
       ConstructedObject (ft, (_2, _3, _4))
     )}

new_expr:
  _1 = option_TColCol_ _2 = Tnew _3 = option_new_placement_ _4 = new_type_id _5 = option_new_initializer_
    {     ( New (_1, _2, _3, _4, _5)  )}

delete_expr:
  _1 = option_TColCol_ _2 = Tdelete _3 = cast_expr
    {    ( Delete (_1, _2, _3) )}
| _1 = option_TColCol_ _2 = Tdelete _3 = TOCro_new _4 = TCCro_new _5 = cast_expr
    {     ( DeleteArray (_1,_2,(_3,(),_4), _5) )}

new_placement:
  _1 = TOPar _2 = listc_argument_ _3 = TCPar
    {                                       ( (_1, _2, _3) )}

new_initializer:
  _1 = TOPar _2 = optl_listc_argument__ _3 = TCPar
    {                                               ( (_1, _2, _3) )}

lambda_introducer:
  _1 = TOCro_Lambda _2 = TCCro
    {                                   ( _1 )}
| _1 = TOCro_Lambda _2 = lambda_capture _3 = TCCro
    {                                   ( _1 )}

lambda_capture:
  _1 = capture_list
    {                ( )}
| _1 = capture_default
    {                   ( )}
| _1 = capture_default _2 = TComma _3 = capture_list
    {                                    ( )}

capture_default:
  _1 = TAnd
    {       ( )}
| _1 = TEq
    {        ( )}

capture_list:
  _1 = capture
    {           ( )}
| _1 = capture_list _2 = TComma _3 = capture
    {                            ( )}
| _1 = capture_list _2 = TComma _3 = capture _4 = TEllipsis
    {                                  ( )}
| _1 = capture _2 = TEllipsis
    {                 ( )}

capture:
  _1 = ident
    {         ( )}
| _1 = TAnd _2 = ident
    {             ( )}
| _1 = Tthis
    {         ( )}
| _1 = ident _2 = TEq _3 = assign_expr
    {                         ( )}

string_elem:
  _1 = TString
    {                      ( fst _1 )}
| _1 = TIdent_MacroString
    {                      ( "<MACRO>", _1 )}

argument:
  _1 = assign_expr
    {               ( Arg _1 )}
| _1 = type_id
    {               ( ArgType _1  )}
| _1 = TEllipsis
    {         ( Flag_parsing.sgrep_guard (Arg (Ellipses _1)) )}
| _1 = nonempty_list_TAny_Action_
    {                ( ArgAction (ActMisc _1) )}

const_expr:
  _1 = cond_expr
    {                      ( _1  )}

basic_type_2:
  _1 = Tchar_Constr
    {                   ( (BaseType (IntType (CChar, _1))) )}
| _1 = Tint_Constr
    {                   ( (BaseType (IntType (Si (Signed,CInt), _1))))}
| _1 = Tfloat_Constr
    {                   ( (BaseType (FloatType (CFloat, _1))) )}
| _1 = Tdouble_Constr
    {                   ( (BaseType (FloatType (CDouble, _1))) )}
| _1 = Twchar_t_Constr
    {                   ( (BaseType (IntType (WChar_t, _1))) )}
| _1 = Tshort_Constr
    {                   ( (BaseType (IntType (Si (Signed, CShort), _1))) )}
| _1 = Tlong_Constr
    {                   ( (BaseType (IntType (Si (Signed, CLong), _1))) )}
| _1 = Tbool_Constr
    {                   ( (BaseType (IntType (CBool, _1))) )}

statement:
  _1 = compound
    {                   ( Compound _1 )}
| _1 = expr_statement
    {                   ( ExprStatement (fst _1, snd _1) )}
| _1 = labeled
    {                   ( _1 )}
| _1 = selection
    {                   ( _1 )}
| _1 = iteration
    {                   ( _1 )}
| _1 = jump _2 = TPtVirg
    {                   ( Jump         (_1, _2) )}
| _1 = TIdent_MacroStmt
    {                    ( MacroStmt _1 )}
| _1 = declaration_statement
    {                         ( _1 )}
| _1 = function_definition
    {                       ( NestedFunc _1 )}
| _1 = try_block
    {             ( _1 )}
| _1 = TEllipsis
    {         ( Flag_parsing.sgrep_guard (ExprStatement (Some (Ellipses _1), _1)) )}

compound:
  _1 = TOBrace _2 = list_statement_cpp_ _3 = TCBrace
    {                                 ( (_1, _2, _3) )}

expr_statement:
  _1 = option_expr_ _2 = TPtVirg
    {                          ( _1, _2 )}

labeled:
  _1 = ident _2 = TCol _3 = statement
    {                                    ( Label (_1, _2, _3) )}
| _1 = Tcase _2 = const_expr _3 = TCol _4 = statement
    {                                    ( Case (_1, _2, _3, _4) )}
| _1 = Tcase _2 = const_expr _3 = TEllipsis _4 = const_expr _5 = TCol _6 = statement
    {     ( CaseRange (_1, _2, _3, _4, _5, _6) )}
| _1 = Tdefault _2 = TCol _3 = statement
    {                                    ( Default (_1, _2, _3) )}

selection:
  _1 = Tif _2 = TOPar _3 = condition _4 = TCPar _5 = statement %prec LOW_PRIORITY_RULE
    {     ( If (_1, (_2, _3, _4), _5, None) )}
| _1 = Tif _2 = TOPar _3 = condition _4 = TCPar _5 = statement _6 = Telse _7 = statement
    {     ( If (_1, (_2, _3, _4), _5, Some (_6, _7)) )}
| _1 = Tswitch _2 = TOPar _3 = condition _4 = TCPar _5 = statement
    {     ( Switch (_1, (_2, _3, _4), _5) )}

iteration:
  _1 = Twhile _2 = TOPar _3 = condition _4 = TCPar _5 = statement
    {     ( While (_1, (_2, _3, _4), _5) )}
| _1 = Tdo _2 = statement _3 = Twhile _4 = TOPar _5 = expr _6 = TCPar _7 = TPtVirg
    {     ( DoWhile (_1, _2, _3, (_4, _5, _6), _7) )}
| _1 = Tfor _2 = TOPar _3 = for_init_stmt _4 = expr_statement _5 = option_expr_ _6 = TCPar _7 = statement
    {     ( For (_1, (_2, (fst _3, snd _3, fst _4, snd _4, _5), _6), _7) )}
| _1 = Tfor _2 = TOPar _3 = for_range_decl _4 = TCol _5 = for_range_init _6 = TCPar _7 = statement
    {     ( StmtTodo _1 )}
| _1 = TIdent_MacroIterator _2 = TOPar _3 = optl_listc_argument__ _4 = TCPar _5 = statement
    {     ( MacroIteration (_1, (_2, _3, _4), _5) )}

jump:
  _1 = Tgoto _2 = ident
    {                ( Goto (_1, _2) )}
| _1 = Tcontinue
    {                ( Continue _1 )}
| _1 = Tbreak
    {                ( Break _1 )}
| _1 = Treturn
    {                ( Return (_1, None) )}
| _1 = Treturn _2 = expr
    {                ( Return (_1, Some _2) )}
| _1 = Tgoto _2 = TMul _3 = expr
    {                  ( GotoComputed (_1, _2, _3) )}

statement_cpp:
  _1 = statement
    {             ( StmtElem _1 )}
| _1 = cpp_directive
    {                                                  ( CppDirectiveStmt _1 )}
| _1 = cpp_ifdef_directive
    {                                                  ( IfdefStmt _1 )}

declaration_statement:
  _1 = block_declaration
    {                                         ( DeclStmt _1 )}

condition:
  _1 = expr
    {        ( _1 )}
| _1 = decl_spec_seq _2 = declaratori _3 = TEq _4 = initializer_clause
    {     ( ExprTodo (PI.fake_info "TODO") )}

for_init_stmt:
  _1 = expr_statement
    {                  ( _1 )}
| _1 = simple_declaration
    {                      ( None, PI.fake_info ";" )}

for_range_decl:
  _1 = decl_spec_seq _2 = declarator
    {let _1 =                               ( _1 ) in
                                          ( )}

for_range_init:
  _1 = expr
    {                     ( )}

try_block:
  _1 = Ttry _2 = compound _3 = nonempty_list_handler_
    {                                  ( Try (_1, _2, _3) )}

handler:
  _1 = Tcatch _2 = TOPar _3 = exception_decl _4 = TCPar _5 = compound
    {                                                ( (_1, (_2, _3, _4), _5) )}

exception_decl:
  _1 = parameter_decl
    {                  ( ExnDecl _1 )}
| _1 = TEllipsis
    {                  ( ExnDeclEllipsis _1 )}

type_spec:
  _1 = simple_type_specifier
    {                         ( _1 )}
| _1 = elaborated_type_specifier
    {                             ( _1 )}
| _1 = enum_specifier
    {                   ( Right3 _1, noii )}
| _1 = class_specifier
    {                   ( Right3 (StructDef _1), noii )}

simple_type_specifier:
  _1 = Tvoid
    {                        ( Right3 (BaseType (Void _1)),            noii )}
| _1 = Tchar
    {                        ( Right3 (BaseType (IntType (CChar, _1))), noii)}
| _1 = Tint
    {                        ( Right3 (BaseType (IntType (Si (Signed,CInt), _1))), noii)}
| _1 = Tfloat
    {                        ( Right3 (BaseType (FloatType (CFloat, _1))),  noii)}
| _1 = Tdouble
    {                        ( Right3 (BaseType (FloatType (CDouble, _1))), noii )}
| _1 = Tshort
    {                        ( Middle3 Short,  [_1])}
| _1 = Tlong
    {                        ( Middle3 Long,   [_1])}
| _1 = Tsigned
    {                        ( Left3 Signed,   [_1])}
| _1 = Tunsigned
    {                        ( Left3 UnSigned, [_1])}
| _1 = Tbool
    {                        ( Right3 (BaseType (IntType (CBool, _1))), noii )}
| _1 = Twchar_t
    {                        ( Right3 (BaseType (IntType (WChar_t, _1))), noii )}
| _1 = Ttypeof _2 = TOPar _3 = assign_expr _4 = TCPar
    {                               ( Right3(TypeOf (_1,(_2,Right _3,_4))), noii)}
| _1 = Ttypeof _2 = TOPar _3 = type_id _4 = TCPar
    {                               ( Right3(TypeOf (_1,(_2,Left _3,_4))), noii)}
| _1 = type_cplusplus_id
    {                     ( Right3 (TypeName _1), noii )}
| _1 = decltype_specifier
    {                      ( Middle3 Long, [_1] )}

decltype_specifier:
  _1 = Tdecltype _2 = TOPar _3 = expr _4 = TCPar
    {                                    ( _1  )}
| _1 = Tdecltype _2 = TOPar _3 = TIdent_Typedef _4 = TCPar
    {                                    ( _1 )}

elaborated_type_specifier:
  _1 = Tenum _2 = ident
    {                                ( Right3 (EnumName (_1, _2)), noii )}
| _1 = class_key _2 = ident
    {                                ( Right3 (StructUnionName (_1, _2)), noii )}
| _1 = Ttypename _2 = type_cplusplus_id
    {                                ( Right3 (TypenameKwd (_1, _2)), noii )}

type_cplusplus_id:
  _1 = type_name
    {                                    ( None, noQscope, _1 )}
| _1 = nested_name_specifier2 _2 = type_name
    {                                    ( None, _1, _2 )}
| _1 = TColCol_BeforeTypedef _2 = type_name
    {                                    ( Some _1, noQscope, _2 )}
| _1 = TColCol_BeforeTypedef _2 = nested_name_specifier2 _3 = type_name
    {                                                          ( Some _1, _2, _3 )}

type_name:
  _1 = enum_name_or_typedef_name_or_simple_class_name
    {                                                  ( IdIdent _1 )}
| _1 = template_id
    {               ( _1 )}

template_id:
  _1 = TIdent_Templatename _2 = TInf_Template _3 = listc_template_argument_ _4 = TSup_Template
    {    ( IdTemplateId (_1, (_2, _3, _4)) )}

template_argument:
  _1 = type_id
    {               ( Left _1 )}
| _1 = assign_expr
    {               ( Right _1 )}

cv_qualif:
  _1 = Tconst
    {             ( {const=Some _1; volatile=None} )}
| _1 = Tvolatile
    {             ( {const=None ; volatile=Some _1} )}
| _1 = Trestrict
    {             ( (* TODO *) {const=None ; volatile=None} )}

declarator:
  _1 = pointer _2 = direct_d
    {                    ( (fst _2, fun x -> x |> _1 |> (snd _2)  ) )}
| _1 = direct_d
    {                    ( _1  )}

pointer:
  _1 = TMul
    {                              ( fun x ->(nQ,         (Pointer (_1, x))))}
| _1 = TMul _2 = cv_qualif_list
    {                              ( fun x ->(_2.qualifD, (Pointer (_1, x))))}
| _1 = TMul _2 = pointer
    {                              ( fun x ->(nQ,         (Pointer (_1, _2 x))))}
| _1 = TMul _2 = cv_qualif_list _3 = pointer
    {                              ( fun x ->(_2.qualifD, (Pointer (_1, _3 x))))}
| _1 = TAnd
    {                              ( fun x ->(nQ,    (Reference (_1, x))))}
| _1 = TAnd _2 = pointer
    {                              ( fun x ->(nQ,    (Reference (_1, _2 x))))}
| _1 = TAndLog
    {                               ( fun x ->(nQ,    (Reference (_1, x))))}
| _1 = TAndLog _2 = pointer
    {                               ( fun x ->(nQ,    (Reference (_1, _2 x))))}

direct_d:
  _1 = declarator_id
    {     ( (_1, fun x -> x) )}
| _1 = TOPar _2 = declarator _3 = TCPar
    {     ( (fst _2, fun x -> (nQ, (ParenType (_1, (snd _2) x, _3)))) )}
| _1 = direct_d _2 = TOCro _3 = TCCro
    {     ( (fst _1, fun x->(snd _1) (nQ,(Array ((_2,None,_3),x)))) )}
| _1 = direct_d _2 = TOCro _3 = const_expr _4 = TCCro
    {     ( (fst _1, fun x->(snd _1) (nQ,(Array ((_2, Some _3, _4),x)))) )}
| _1 = direct_d _2 = TOPar _3 = TCPar _4 = const_opt _5 = option_exn_spec_
    {     ( (fst _1, fun x-> (snd _1)
         (nQ, (FunctionType {
           ft_ret= x; ft_params = (_2, [], _3);
           ft_dots = None; ft_const = _4; ft_throw = _5; })))
     )}
| _1 = direct_d _2 = TOPar _3 = parameter_type_list _4 = TCPar _5 = const_opt _6 = option_exn_spec_
    {     ( (fst _1, fun x-> (snd _1)
          (nQ,(FunctionType {
            ft_ret = x; ft_params = (_2,fst _3,_4);
            ft_dots = snd _3; ft_const = _5; ft_throw = _6; })))
     )}

declarator_id:
  _1 = option_TColCol_ _2 = id_expression
    {                        ( (_1, fst _2, snd _2) )}

abstract_declarator:
  _1 = pointer
    {                                      ( _1 )}
| _1 = direct_abstract_declarator
    {                                      ( _1 )}
| _1 = pointer _2 = direct_abstract_declarator
    {                                      ( fun x -> x |> _2 |> _1 )}

direct_abstract_declarator:
  _1 = TOPar _2 = abstract_declarator _3 = TCPar
    {     ( (fun x -> (nQ, (ParenType (_1, _2 x, _3)))) )}
| _1 = TOCro _2 = TCCro
    {     ( fun x ->   (nQ, (Array ((_1,None, _2), x))))}
| _1 = TOCro _2 = const_expr _3 = TCCro
    {     ( fun x ->   (nQ, (Array ((_1, Some _2, _3), x))))}
| _1 = direct_abstract_declarator _2 = TOCro _3 = TCCro
    {     ( fun x ->_1 (nQ, (Array ((_2, None, _3), x))) )}
| _1 = direct_abstract_declarator _2 = TOCro _3 = const_expr _4 = TCCro
    {     ( fun x ->_1 (nQ, (Array ((_2, Some _3, _4), x))) )}
| _1 = TOPar _2 = TCPar
    {     ( fun x -> (nQ, (FunctionType {
       ft_ret = x; ft_params = (_1,[],_2);
       ft_dots = None; ft_const = None; ft_throw = None;})) )}
| _1 = TOPar _2 = parameter_type_list _3 = TCPar
    {     ( fun x -> (nQ, (FunctionType {
         ft_ret = x; ft_params = (_1,fst _2,_3);
         ft_dots = snd _2; ft_const = None; ft_throw = None; })) )}
| _1 = direct_abstract_declarator _2 = TOPar _3 = TCPar _4 = const_opt _5 = option_exn_spec_
    {     ( fun x -> _1 (nQ, (FunctionType {
         ft_ret = x; ft_params = (_2,[],_3);
         ft_dots = None; ft_const = _4; ft_throw = _5; })) )}
| _1 = direct_abstract_declarator _2 = TOPar _3 = parameter_type_list _4 = TCPar _5 = const_opt _6 = option_exn_spec_
    {     ( fun x -> _1 (nQ, (FunctionType {
         ft_ret = x; ft_params = (_2,fst _3,_4);
         ft_dots = snd _3; ft_const = _5; ft_throw = _6; })) )}

parameter_type_list:
  _1 = parameter_list
    {                            ( _1, None )}
| _1 = parameter_list _2 = TComma _3 = TEllipsis
    {                            ( _1, Some (_2,_3) )}

parameter_decl:
  _1 = decl_spec_seq _2 = declarator
    {     ( let (t_ret,reg) = type_and_register_from_decl _1 in
       let (name, ftyp) = fixNameForParam _2 in
       { p_name = Some name; p_type = ftyp t_ret;
         p_register = reg; p_val = None } )}
| _1 = decl_spec_seq _2 = abstract_declarator
    {     ( let (t_ret, reg) = type_and_register_from_decl _1 in
       { p_name = None; p_type = _2 t_ret;
         p_register = reg; p_val = None } )}
| _1 = decl_spec_seq
    {     ( let (t_ret, reg) = type_and_register_from_decl _1 in
       { p_name = None; p_type = t_ret; p_register = reg; p_val = None } )}
| _1 = decl_spec_seq _2 = declarator _3 = TEq _4 = assign_expr
    {     ( let (t_ret, reg) = type_and_register_from_decl _1 in
       let (name, ftyp) = fixNameForParam _2 in
       { p_name = Some name; p_type = ftyp t_ret;
         p_register = reg; p_val = Some (_3, _4) } )}
| _1 = decl_spec_seq _2 = abstract_declarator _3 = TEq _4 = assign_expr
    {     ( let (t_ret, reg) = type_and_register_from_decl _1 in
       { p_name = None; p_type = _2 t_ret;
         p_register = reg; p_val = Some (_3, _4) } )}
| _1 = decl_spec_seq _2 = TEq _3 = assign_expr
    {     ( let (t_ret, reg) = type_and_register_from_decl _1 in
       { p_name = None; p_type = t_ret;
         p_register = reg; p_val = Some(_2,_3) } )}

parameter_list:
  _1 = parameter_decl2
    {                                      ( [_1, []] )}
| _1 = parameter_list _2 = TComma _3 = parameter_decl2
    {                                      ( _1 @ [_3,  [_2]] )}

parameter_decl2:
  _1 = parameter_decl
    {                  ( _1 )}
| _1 = TIdent
    {     ( let t = nQ, (TypeName (None, [], IdIdent _1)) in
       { p_name = None; p_type = t; p_val = None; p_register = None; } )}

exn_spec:
  _1 = Tthrow _2 = TOPar _3 = TCPar
    {                                         ( (_1, (_2, [], _3)) )}
| _1 = Tthrow _2 = TOPar _3 = exn_name _4 = TCPar
    {                                         ( (_1, (_2, [Left _3], _4)) )}
| _1 = Tthrow _2 = TOPar _3 = exn_name _4 = TComma _5 = exn_name _6 = TCPar
    {     ( (_1, (_2, [Left _3; Right _4; Left _5], _6))  )}

exn_name:
  _1 = ident
    {                ( None, [], IdIdent _1 )}

const_opt:
  _1 = Tconst
    {                 ( Some _1 )}
| 
    {             ( None )}

spec_qualif_list:
  _1 = type_spec
    {                                ( addTypeD _1 nullDecl )}
| _1 = cv_qualif
    {                                ( {nullDecl with qualifD = _1} )}
| _1 = type_spec _2 = spec_qualif_list
    {                                ( addTypeD _1 _2   )}
| _1 = cv_qualif _2 = spec_qualif_list
    {                                ( addQualifD _1 _2 )}

cv_qualif_list:
  _1 = cv_qualif
    {                              ( {nullDecl with qualifD = _1 } )}
| _1 = cv_qualif_list _2 = cv_qualif
    {                              ( addQualifD _2 _1 )}

type_id:
  _1 = spec_qualif_list
    {     ( let (t_ret, _, _) = type_and_storage_from_decl _1 in  t_ret )}
| _1 = spec_qualif_list _2 = abstract_declarator
    {     ( let (t_ret, _, _) = type_and_storage_from_decl _1 in _2 t_ret )}

new_type_id:
  _1 = spec_qualif_list %prec LOW_PRIORITY_RULE
    {     ( let (t_ret, _, _) = type_and_storage_from_decl _1 in  t_ret )}
| _1 = spec_qualif_list _2 = new_declarator
    {     ( let (t_ret, _, _) = type_and_storage_from_decl _1 in (* TODOAST *) t_ret )}

new_declarator:
  _1 = ptr_operator _2 = new_declarator
    {     ( () )}
| _1 = ptr_operator %prec LOW_PRIORITY_RULE
    {     ( () )}
| _1 = direct_new_declarator
    {     ( () )}

ptr_operator:
  _1 = TMul
    {       ( () )}
| _1 = TAnd
    {       ( () )}
| _1 = TAndLog
    {        ( () )}

direct_new_declarator:
  _1 = TOCro _2 = expr _3 = TCCro
    {                                      ( () )}
| _1 = direct_new_declarator _2 = TOCro _3 = expr _4 = TCCro
    {                                      ( () )}

conversion_type_id:
  _1 = simple_type_specifier _2 = conversion_declarator
    {     ( let tx = addTypeD _1 nullDecl in
       let (t_ret, _, _) = type_and_storage_from_decl tx in t_ret
     )}
| _1 = simple_type_specifier %prec LOW_PRIORITY_RULE
    {     ( let tx = addTypeD _1 nullDecl in
       let (t_ret, _, _) = type_and_storage_from_decl tx in t_ret
     )}

conversion_declarator:
  _1 = ptr_operator _2 = conversion_declarator
    {     ( () )}
| _1 = ptr_operator %prec LOW_PRIORITY_RULE
    {     ( () )}

class_specifier:
  _1 = class_head _2 = TOBrace _3 = optl_member_specification_ _4 = TCBrace
    {     ( let (kind, nameopt, baseopt) = _1 in
       { c_kind = kind; c_name = nameopt;
         c_inherit = baseopt; c_members = (_2, _3, _4) } )}

class_head:
  _1 = class_key
    {     ( _1, None, None )}
| _1 = class_key _2 = ident _3 = option_base_clause_
    {     ( let name = None, noQscope, IdIdent _2 in
       _1, Some name, _3 )}
| _1 = class_key _2 = nested_name_specifier _3 = ident _4 = option_base_clause_
    {     ( let name = None, _2, IdIdent _3 in
       _1, Some name, _4 )}

class_key:
  _1 = Tstruct
    {             ( Struct, _1 )}
| _1 = Tunion
    {             ( Union, _1 )}
| _1 = Tclass
    {             ( Class, _1 )}

base_clause:
  _1 = TCol _2 = listc_base_specifier_
    {                                       ( _1, _2 )}

base_specifier:
  _1 = class_name
    {     ( { i_name = _1; i_virtual = None; i_access = None } )}
| _1 = access_specifier _2 = class_name
    {     ( { i_name = _2; i_virtual = None; i_access = Some _1 } )}
| _1 = Tvirtual _2 = access_specifier _3 = class_name
    {     ( { i_name = _3; i_virtual = Some _1; i_access = Some _2 } )}

class_name:
  _1 = type_cplusplus_id
    {                      ( _1 )}
| _1 = TIdent
    {                      ( None, noQscope, IdIdent _1 )}

member_specification:
  _1 = member_declaration _2 = optl_member_specification_
    {     ( ClassElem _1::_2 )}
| _1 = access_specifier _2 = TCol _3 = optl_member_specification_
    {     ( ClassElem (Access (_1, _2))::_3 )}

access_specifier:
  _1 = Tpublic
    {              ( Public, _1 )}
| _1 = Tprivate
    {              ( Private, _1 )}
| _1 = Tprotected
    {              ( Protected, _1 )}

member_declaration:
  _1 = field_declaration
    {                          ( fixFieldOrMethodDecl _1 )}
| _1 = function_definition
    {                          ( MemberFunc (FunctionOrMethod _1) )}
| _1 = qualified_id _2 = TPtVirg
    {     ( let name = (None, fst _1, snd _1) in
       QualifiedIdInClass (name, _2)
     )}
| _1 = using_declaration
    {                          ( UsingDeclInClass _1 )}
| _1 = template_declaration
    {                          ( TemplateDeclInClass _1 )}
| _1 = ctor_dtor_member
    {                          ( _1 )}
| _1 = TPtVirg
    {          ( EmptyField _1 )}

field_declaration:
  _1 = decl_spec_seq _2 = TPtVirg
    {     ( (* gccext: allow empty elements if it is a structdef or enumdef *)
       let (t_ret, sto, _inline) = type_and_storage_from_decl _1 in
       let onedecl = { v_namei = None; v_type = t_ret; v_storage = sto } in
       ([(FieldDecl onedecl),noii], _2)
     )}
| _1 = decl_spec_seq _2 = listc_member_declarator_ _3 = TPtVirg
    {     ( let (t_ret, sto, _inline) = type_and_storage_from_decl _1 in
       (_2 |> (List.map (fun (f, iivirg) -> f t_ret sto, iivirg)), _3)
     )}

member_declarator:
  _1 = declarator
    {     ( let (name, partialt) = _1 in (fun t_ret sto ->
       FieldDecl {
         v_namei = Some (name, None);
         v_type = partialt t_ret; v_storage = sto; })
     )}
| _1 = declarator _2 = TEq _3 = const_expr
    {     ( let (name, partialt) = _1 in (fun t_ret sto ->
       FieldDecl {
         v_namei = Some (name, Some (EqInit (_2, InitExpr _3)));
         v_type = partialt t_ret; v_storage = sto;
       })
     )}
| _1 = declarator _2 = TCol _3 = const_expr
    {     ( let (name, _partialt) = fixNameForParam _1 in (fun t_ret _stoTODO ->
       BitField (Some name, _2, t_ret, _3))
     )}
| _1 = TCol _2 = const_expr
    {     ( (fun t_ret _stoTODO -> BitField (None, _1, t_ret, _2)) )}

enum_specifier:
  _1 = enum_head _2 = TOBrace _3 = listc_enumerator_ _4 = option_TComma_ _5 = TCBrace
    {     ( EnumDef (_1, None(* TODO *), (_2, _3, _5)) (*$4*) )}
| _1 = enum_head _2 = TOBrace _3 = TCBrace
    {     ( EnumDef (_1, None(* TODO *), (_2, [], _3)) )}

enum_head:
  _1 = Tenum _2 = option_ident_
    {let _1 =          ( _1 ) in
                                          ( _1 )}
| _1 = Tenum _2_inlined1 = Tclass _2 = option_ident_
    {let _1 =                 ( _1 ) in
                                          ( _1 )}
| _1 = Tenum _2_inlined1 = Tstruct _2 = option_ident_
    {let _1 =                  ( _1 ) in
                                          ( _1 )}

enumerator:
  _1 = ident
    {                        ( { e_name = _1; e_val = None; } )}
| _1 = ident _2 = TEq _3 = const_expr
    {                        ( { e_name = _1; e_val = Some (_2, _3); } )}

simple_declaration:
  _1 = decl_spec_seq _2 = TPtVirg
    {     ( let (t_ret, sto, _inline) = type_and_storage_from_decl _1 in
       DeclList ([{v_namei = None; v_type = t_ret; v_storage = sto},noii],_2)
     )}
| _1 = decl_spec_seq _2 = listc_init_declarator_ _3 = TPtVirg
    {     ( let (t_ret, sto, _inline) = type_and_storage_from_decl _1 in
       DeclList (
         (_2 |> List.map (fun (((name, f), iniopt), iivirg) ->
           (* old: if fst (unwrap storage)=StoTypedef then LP.add_typedef s; *)
           { v_namei = Some (name, iniopt);
             v_type = f t_ret; v_storage = sto
           },
           iivirg
         )), _3)
     )}
| _1 = TIdent_MacroDecl _2 = TOPar _3 = listc_argument_ _4 = TCPar _5 = TPtVirg
    {     ( MacroDecl ([], _1, (_2, _3, _4), _5) )}
| _1 = Tstatic _2 = TIdent_MacroDecl _3 = TOPar _4 = listc_argument_ _5 = TCPar _6 = TPtVirg
    {     ( MacroDecl ([_1], _2, (_3, _4, _5), _6) )}
| _1 = Tstatic _2 = Tconst_MacroDeclConst _3 = TIdent_MacroDecl _4 = TOPar _5 = listc_argument_ _6 = TCPar _7 = TPtVirg
    {     ( MacroDecl ([_1;_2], _3, (_4, _5, _6), _7) )}

decl_spec_seq:
  _1 = decl_spec
    {                           ( _1 nullDecl )}
| _1 = decl_spec _2 = decl_spec_seq
    {                           ( _1 _2 )}

decl_spec:
  _1 = storage_class_spec
    {                      ( addStorageD _1 )}
| _1 = type_spec
    {                      ( addTypeD  _1 )}
| _1 = function_spec
    {                      ( addInlineD (snd _1)(*TODO*) )}
| _1 = cv_qualif
    {                      ( addQualifD _1 )}
| _1 = Ttypedef
    {                      ( addStorageD (StoTypedef _1) )}
| _1 = Tfriend
    {                      ( addInlineD _1 (*TODO*) )}
| _1 = Tconstexpr
    {                      ( addInlineD _1 (*TODO*) )}

function_spec:
  _1 = Tinline
    {           ( Inline, _1 )}
| _1 = Tvirtual
    {            ( Virtual, _1 )}

storage_class_spec:
  _1 = Tstatic
    {                ( Sto (Static,  _1) )}
| _1 = Textern
    {                ( Sto (Extern,  _1) )}
| _1 = Tauto
    {                ( Sto (Auto,    _1) )}
| _1 = Tregister
    {                ( Sto (Register,_1) )}
| _1 = Tmutable
    {                ( Sto (Register,_1) (*TODO*) )}
| _1 = Tthread_local
    {                 ( Sto (Register,_1) (*TODO*) )}

init_declarator:
  _1 = declaratori
    {                                ( (_1, None) )}
| _1 = declaratori _2 = TEq _3 = initializer_clause
    {                                        ( (_1, Some (EqInit (_2, _3))) )}
| _1 = declaratori _2 = TOPar_CplusplusInit _3 = optl_listc_argument__ _4 = TCPar
    {     ( (_1, Some (ObjInit (_2, _3, _4))) )}

declaratori:
  _1 = declarator
    {                             ( _1 )}
| _1 = declarator _2 = gcc_asm_decl
    {                             ( _1 )}

gcc_asm_decl:
  _1 = Tasm _2 = option_Tvolatile_ _3 = TOPar _4 = asmbody _5 = TCPar
    {                                          (  )}

initializer_clause:
  _1 = assign_expr
    {                    ( InitExpr _1 )}
| _1 = braced_init_list
    {                    ( InitList _1 )}

braced_init_list:
  _1 = TOBrace _2 = TCBrace
    {                                 ( (_1, [], _2) )}
| _1 = TOBrace _2 = initialize_list _3 = option_TComma_ _4 = TCBrace
    {                                 ( (_1, List.rev _2, _4) (*$3*) )}

initialize_list:
  _1 = initialize2
    {                                      ( [_1,   []] )}
| _1 = initialize_list _2 = TComma _3 = initialize2
    {                                   ( (_3,  [_2])::_1 )}

initialize2:
  _1 = cond_expr
    {                    ( InitExpr _1 )}
| _1 = braced_init_list
    {                    ( InitList _1 )}
| _1 = nonempty_list_designator_ _2 = TEq _3 = initialize2
    {                                ( InitDesignators (_1, _2, _3) )}
| _1 = ident _2 = TCol _3 = initialize2
    {                               ( InitFieldOld (_1, _2, _3) )}
| _1 = TOCro _2 = const_expr _3 = TCCro _4 = TEq _5 = initialize2
    {     ( InitDesignators ([DesignatorIndex(_1, _2, _3)], _4, _5) )}
| _1 = TOCro _2 = const_expr _3 = TCCro _4 = initialize2
    {                                   ( InitIndexOld ((_1, _2, _3), _4) )}

designator:
  _1 = TDot _2 = ident
    {                ( DesignatorField (_1, _2) )}

block_declaration:
  _1 = simple_declaration
    {                      ( _1 )}
| _1 = asm_definition
    {                      ( _1 )}
| _1 = namespace_alias_definition
    {                              ( _1 )}
| _1 = using_declaration
    {                     ( UsingDecl _1 )}
| _1 = using_directive
    {                     ( _1 )}

namespace_alias_definition:
  _1 = Tnamespace _2 = TIdent _3 = TEq _4 = qualified_namespace_spec _5 = TPtVirg
    {  ( NameSpaceAlias (_1, _2, _3, _4, _5) )}

using_directive:
  _1 = Tusing _2 = Tnamespace _3 = qualified_namespace_spec _4 = TPtVirg
    {  ( UsingDirective (_1, _2, _3, _4) )}

qualified_namespace_spec:
  _1 = option_TColCol_ _2 = optl_nested_name_specifier_ _1_inlined1 = TIdent
    {let _3 =
  let _1 = _1_inlined1 in
                         ( _1 )
in
  ( _1, _2, IdIdent _3 )}

using_declaration:
  _1 = Tusing _2 = option_Ttypename_ _3 = option_TColCol_ _4 = nested_name_specifier _5 = unqualified_id _6 = TPtVirg
    {     ( let name = (_3, _4, _5) in _1, name, _6 (*$2*) )}
| _1 = Tusing _2 = option_Ttypename_ _3 = option_TColCol_ _4 = unqualified_id _5 = TPtVirg
    {     ( let name = (_3, [], _4) in _1, name, _5 (*$2*) )}

asm_definition:
  _1 = Tasm _2 = option_Tvolatile_ _3 = TOPar _4 = asmbody _5 = TCPar _6 = TPtVirg
    {                                                    (Asm(_1,_2,(_3,_4,_5),_6))}

asmbody:
  _1 = nonempty_list_string_elem_ _2 = nonempty_list_colon_asm_
    {                            ( _1, _2 )}
| _1 = nonempty_list_string_elem_
    {                ( _1, [] )}

colon_asm:
  _1 = TCol _2 = listc_colon_option_
    {                                   ( Colon (_1, _2) )}

colon_option:
  _1 = TString
    {                            ( ColonMisc [snd (fst _1)] )}
| _1 = TString _2 = TOPar _3 = asm_expr _4 = TCPar
    {                            ( ColonExpr ([snd (fst _1)], (_2, _3, _4)) )}
| _1 = TOCro _2 = TIdent _3 = TCCro _4 = TString _5 = TOPar _6 = asm_expr _7 = TCPar
    {     ( ColonExpr ([_1;snd _2;_3;snd (fst _4)], (_5, _6, _7))  )}
| _1 = TIdent
    {                            ( ColonMisc [snd _1] )}
| 
    {                            ( ColonMisc [] )}

asm_expr:
  _1 = assign_expr
    {                      ( _1 )}

declaration:
  _1 = block_declaration
    {                                     ( BlockDecl _1 )}
| _1 = function_definition
    {                                     ( Func (FunctionOrMethod _1) )}
| _1 = ctor_dtor
    {             ( _1 )}
| _1 = template_declaration
    {                                     ( let (a,b,c) = _1 in TemplateDecl (a,b,c))}
| _1 = explicit_specialization
    {                                     ( _1 )}
| _1 = linkage_specification
    {                                     ( _1 )}
| _1 = namespace_definition
    {                                     ( _1 )}
| _1 = TPtVirg
    {          ( EmptyDef _1 )}

declaration_cpp:
  _1 = declaration
    {               ( DeclElem _1 )}
| _1 = cpp_directive
    {                                                 ( CppDirectiveDecl _1 )}
| _1 = cpp_ifdef_directive
    {                                                 ( IfdefDecl _1 )}

template_declaration:
  _1 = Ttemplate _2 = TInf_Template _3 = listc_template_parameter_ _4 = TSup_Template _5 = declaration
    {   ( (_1, (_2, _3, _4), _5) )}

explicit_specialization:
  _1 = Ttemplate _2 = TInf_Template _3 = TSup_Template _4 = declaration
    {   ( TemplateSpecialization (_1, (_2, (), _3), _4) )}

template_parameter:
  _1 = parameter_decl
    {                  ( _1 )}

linkage_specification:
  _1 = Textern _2 = TString _3 = declaration
    {     ( ExternC (_1, (snd (fst _2)), _3) )}
| _1 = Textern _2 = TString _3 = TOBrace _4 = optl_nonempty_list_declaration_cpp__ _5 = TCBrace
    {     ( ExternCList (_1, (snd (fst _2)), (_3, _4, _5)) )}

namespace_definition:
  _1 = named_namespace_definition
    {                                ( _1 )}
| _1 = unnamed_namespace_definition
    {                                ( _1 )}

named_namespace_definition:
  _1 = Tnamespace _2 = TIdent _3 = TOBrace _4 = optl_nonempty_list_declaration_cpp__ _5 = TCBrace
    {     ( NameSpace (_1, _2, (_3, _4, _5)) )}

unnamed_namespace_definition:
  _1 = Tnamespace _2 = TOBrace _3 = optl_nonempty_list_declaration_cpp__ _4 = TCBrace
    {     ( NameSpaceAnon (_1, (_2, _3, _4)) )}

function_definition:
  _1 = decl_spec_seq _2 = declarator _3 = function_body
    {     ( let (t_ret, sto) = type_and_storage_for_funcdef_from_decl _1 in
       let x = (fst _2, fixOldCDecl ((snd _2) t_ret), sto) in
       fixFunc (x, _3)
     )}

function_body:
  _1 = compound
    {            ( _1 )}

ctor_dtor:
  _1 = nested_name_specifier _2 = TIdent_Constructor _3 = TOPar _4 = option_parameter_type_list_ _5 = TCPar _6 = ctor_mem_initializer_list_opt _7 = compound
    {     ( DeclTodo )}
| _1 = nested_name_specifier _2 = TTilde _3 = ident _4 = TOPar _5 = option_Tvoid_ _6 = TCPar _7 = compound
    {     ( DeclTodo )}
| _1 = option_Tinline_ _2 = TIdent_Constructor _3 = TOPar _4 = option_parameter_type_list_ _5 = TCPar _6 = ctor_mem_initializer_list_opt _7 = compound
    {     ( DeclTodo )}
| _1 = TTilde _2 = ident _3 = TOPar _4 = option_Tvoid_ _5 = TCPar _6 = option_exn_spec_ _7 = compound
    {     ( DeclTodo )}

ctor_dtor_member:
  _1 = ctor_spec _2 = TIdent_Constructor _3 = TOPar _4 = option_parameter_type_list_ _5 = TCPar _6 = ctor_mem_initializer_list_opt _7 = compound
    {     ( MemberFunc (Constructor (mk_constructor _2 (_3, _4, _5) _7)) )}
| _1 = ctor_spec _2 = TIdent_Constructor _3 = TOPar _4 = option_parameter_type_list_ _5 = TCPar _6 = TPtVirg
    {     ( MemberDecl (ConstructorDecl (_2, (_3, opt_to_list_params _4, _5), _6)) )}
| _1 = ctor_spec _2 = TIdent_Constructor _3 = TOPar _4 = option_parameter_type_list_ _5 = TCPar _6 = TEq _7 = Tdelete _8 = TPtVirg
    {     ( MemberDecl (ConstructorDecl (_2, (_3, opt_to_list_params _4, _5), _6)) )}
| _1 = ctor_spec _2 = TIdent_Constructor _3 = TOPar _4 = option_parameter_type_list_ _5 = TCPar _6 = TEq _7 = Tdefault _8 = TPtVirg
    {     ( MemberDecl (ConstructorDecl (_2, (_3, opt_to_list_params _4, _5), _6)) )}
| _1 = dtor_spec _2 = TTilde _3 = ident _4 = TOPar _5 = option_Tvoid_ _6 = TCPar _7 = option_exn_spec_ _8 = compound
    {     ( MemberFunc (Destructor (mk_destructor _2 _3 (_4, _5, _6) _7 _8)) )}
| _1 = dtor_spec _2 = TTilde _3 = ident _4 = TOPar _5 = option_Tvoid_ _6 = TCPar _7 = option_exn_spec_ _8 = TPtVirg
    {     ( MemberDecl (DestructorDecl (_2, _3, (_4, _5, _6), _7, _8)) )}
| _1 = dtor_spec _2 = TTilde _3 = ident _4 = TOPar _5 = option_Tvoid_ _6 = TCPar _7 = option_exn_spec_ _8 = TEq _9 = Tdelete _10 = TPtVirg
    {     ( MemberDecl (DestructorDecl (_2, _3, (_4, _5, _6), _7, _8)) )}
| _1 = dtor_spec _2 = TTilde _3 = ident _4 = TOPar _5 = option_Tvoid_ _6 = TCPar _7 = option_exn_spec_ _8 = TEq _9 = Tdefault _10 = TPtVirg
    {     ( MemberDecl (DestructorDecl (_2, _3, (_4, _5, _6), _7, _8)) )}

ctor_spec:
  _1 = Texplicit
    {             ( )}
| _1 = Tinline
    {           ( )}
| 
    {             ( )}

dtor_spec:
  _1 = Tvirtual
    {            ( )}
| _1 = Tinline
    {           ( )}
| 
    {             ( )}

ctor_mem_initializer_list_opt:
  _1 = TCol _2 = listc_mem_initializer_
    {                              ( () )}
| 
    {               ( () )}

mem_initializer:
  _1 = mem_initializer_id _2 = TOPar _3 = optl_listc_argument__ _4 = TCPar
    {                                                    ( () )}

mem_initializer_id:
  _1 = primary_cplusplus_id
    {                        ( () )}

cpp_directive:
  _1 = TInclude
    {     ( let (_include_str, filename, tok) = _1 in
       (* redo some lexing work :( *)
       let inc_kind, path =
         match () with
         | _ when filename =~ "^\"\\(.*\\)\"$" ->  Local, matched1 filename
         | _ when filename =~ "^\\<\\(.*\\)\\>$" -> Standard, matched1 filename
         | _ -> Weird, filename
       in
       Include (tok, inc_kind, path)
     )}
| _1 = TDefine _2 = TIdent_Define _3 = define_val _4 = TCommentNewline_DefineEndOfMacro
    {     ( Define (_1, _2, DefineVar, _3) (*$4??*) )}
| _1 = TDefine _2 = TIdent_Define _3 = TOPar_Define _4 = optl_listc_param_define__ _5 = TCPar _6 = define_val _7 = TCommentNewline_DefineEndOfMacro
    {     ( Define (_1, _2, (DefineFunc (_3, _4, _5)), _6) (*$7*) )}
| _1 = TUndef
    {                      ( Undef _1 )}
| _1 = TCppDirectiveOther
    {                      ( PragmaAndCo _1 )}

define_val:
  _1 = expr
    {             ( DefineExpr _1 )}
| _1 = statement
    {             ( DefineStmt _1 )}
| _1 = Tdo _2 = statement _3 = Twhile _4 = TOPar _5 = expr _6 = TCPar
    {     ( match _5 with
       | (C (Int (Some 0, tok))) ->
         DefineDoWhileZero (_1, _2, _3, (_4, tok, _6))
       | _ -> raise Parsing.Parse_error
     )}
| _1 = Tif _2 = TOPar _3 = condition _4 = TCPar _5 = id_expression
    {     ( let name = (None, fst _5, snd _5) in
       DefinePrintWrapper (_1, (_2, _3, _4), name)
     )}
| _1 = TOBrace_DefineInit _2 = initialize_list _3 = TCBrace _4 = option_TComma_
    {    ( DefineInit (InitList (_1, List.rev _2, _3) (*$4*))  )}
| 
    {               ( DefineEmpty )}

param_define:
  _1 = ident
    {                        ( _1 )}
| _1 = TDefParamVariadic
    {                        ( _1 )}
| _1 = TEllipsis
    {                        ( "...", _1 )}
| _1 = Tregister
    {                        ( "register", _1 )}
| _1 = Tnew
    {                        ( "new", _1 )}

cpp_ifdef_directive:
  _1 = TIfdef
    {              ( Ifdef, _1 )}
| _1 = TIfdefelse
    {              ( IfdefElse, _1 )}
| _1 = TIfdefelif
    {              ( IfdefElseif, _1 )}
| _1 = TEndif
    {              ( IfdefEndif, _1 )}
| _1 = TIfdefBool
    {               ( Ifdef, snd _1 )}
| _1 = TIfdefMisc
    {               ( Ifdef, snd _1 )}
| _1 = TIfdefVersion
    {                 ( Ifdef, snd _1 )}

cpp_other:
  _1 = TIdent _2 = TOPar _3 = listc_argument_ _4 = TCPar _5 = TPtVirg
    {                                        ( MacroTop (_1, (_2, _3, _4),Some _5))}
| _1 = TIdent _2 = TOPar _3 = listc_argument_ _4 = TCPar_EOL
    {                                        ( MacroTop (_1, (_2, _3, _4),None) )}
| _1 = TIdent _2 = TPtVirg
    {                                        ( MacroVarTop (_1, _2) )}

%%
