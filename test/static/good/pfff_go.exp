File "pfff_go.mly", line 156, characters 34-42:
Warning: the token TComment is unused.
File "pfff_go.mly", line 156, characters 43-58:
Warning: the token TCommentNewline is unused.
File "pfff_go.mly", line 156, characters 20-33:
Warning: the token TCommentSpace is unused.
File "pfff_go.mly", line 149, characters 20-28:
Warning: the token TUnknown is unused.
Grammar has 107 nonterminal symbols, among which 2 start symbols.
Grammar has 78 terminal symbols.
Grammar has 313 productions.
nullable(xfndcl) = false
nullable(xdcl_list) = true
nullable(xdcl) = false
nullable(vardcl) = false
nullable(uexpr) = false
nullable(typedcl) = false
nullable(sym) = false
nullable(switch_stmt) = false
nullable(structtype) = false
nullable(structdcl) = false
nullable(stmt) = true
nullable(simple_stmt) = false
nullable(sgrep_spatch_pattern) = false
nullable(select_stmt) = false
nullable(recvchantype) = false
nullable(ptrtype) = false
nullable(pseudocall) = false
nullable(pexpr_no_paren) = false
nullable(pexpr) = false
nullable(partial) = false
nullable(packname) = false
nullable(package) = false
nullable(othertype) = false
nullable(option(simple_stmt)) = true
nullable(option(new_name)) = true
nullable(option(expr)) = true
nullable(option(LSTR)) = true
nullable(option(LSEMICOLON)) = true
nullable(option(LCOMMA)) = true
nullable(oexpr_no_dots) = true
nullable(oexpr_list) = true
nullable(oarg_type_list_ocomma) = true
nullable(ntype) = false
nullable(non_recvchantype) = false
nullable(non_expr_type) = false
nullable(non_dcl_stmt) = false
nullable(name_or_type) = false
nullable(name) = false
nullable(loop_body) = false
nullable(listsc_t(vardcl)) = false
nullable(listsc_t(typedcl)) = false
nullable(listsc_t(structdcl)) = false
nullable(listsc_t(interfacedcl)) = false
nullable(listsc_t(import_stmt)) = false
nullable(listsc(stmt)) = true
nullable(listc(new_name)) = false
nullable(listc(expr_or_type)) = false
nullable(listc(expr)) = false
nullable(listc(dcl_name)) = false
nullable(list_sep_term(vardcl,LSEMICOLON)) = false
nullable(list_sep_term(typedcl,LSEMICOLON)) = false
nullable(list_sep_term(structdcl,LSEMICOLON)) = false
nullable(list_sep_term(interfacedcl,LSEMICOLON)) = false
nullable(list_sep_term(import_stmt,LSEMICOLON)) = false
nullable(list_sep(stmt,LSEMICOLON)) = true
nullable(list_sep(new_name,LCOMMA)) = false
nullable(list_sep(expr_or_type,LCOMMA)) = false
nullable(list_sep(expr,LCOMMA)) = false
nullable(list_sep(dcl_name,LCOMMA)) = false
nullable(lbrace) = false
nullable(keyval_list) = false
nullable(keyval) = false
nullable(item_list) = true
nullable(item) = true
nullable(interfacetype) = false
nullable(interfacedcl) = false
nullable(indcl) = false
nullable(imports) = true
nullable(import_stmt) = false
nullable(import) = false
nullable(if_stmt) = false
nullable(if_header) = true
nullable(for_stmt) = false
nullable(fntype) = false
nullable(fnret_type) = false
nullable(fnres) = true
nullable(fnliteral) = false
nullable(fnlitdcl) = false
nullable(fndcl) = false
nullable(fnbody) = true
nullable(file) = false
nullable(expr_or_type) = false
nullable(expr_no_dots) = false
nullable(expr) = false
nullable(elseif_list) = true
nullable(elseif) = false
nullable(else_) = true
nullable(dotname) = false
nullable(dotdotdot) = false
nullable(convtype) = false
nullable(constdcl1_list) = false
nullable(constdcl1) = false
nullable(constdcl) = false
nullable(comptype) = false
nullable(compound_stmt) = false
nullable(complitexpr) = false
nullable(common_dcl) = false
nullable(caseblock_list) = true
nullable(caseblock) = false
nullable(case) = false
nullable(braced_keyval_list) = true
nullable(basic_literal) = false
nullable(bare_complitexpr) = false
nullable(arguments) = false
nullable(argument) = false
nullable(arg_type_list) = false
nullable(arg_type) = false
first(xfndcl) = LFUNC
first(xdcl_list) = LVAR LTYPE LFUNC LCONST
first(xdcl) = LVAR LTYPE LFUNC LCONST
first(vardcl) = LNAME
first(uexpr) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LCOMM LCHAN LBRACKET LBANG LAND
first(typedcl) = LNAME
first(sym) = LNAME
first(switch_stmt) = LSWITCH
first(structtype) = LSTRUCT
first(structdcl) = LNAME LMULT LDDD
first(stmt) = LVAR LTYPE LSWITCH LSTRUCT LSTR LSELECT LRUNE LRETURN LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LIF LHAT LGOTO LGO LFUNC LFOR LFLOAT LFALL LDots LDEFER LDDD LCONTINUE LCONST LCOMM LCHAN LBREAK LBRACKET LBRACE LBANG LAND
first(simple_stmt) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(sgrep_spatch_pattern) = LVAR LTYPE LSWITCH LSTRUCT LSTR LSEMICOLON LSELECT LRUNE LRETURN LPLUS LPAREN LPACKAGE LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMPORT LIMAG LIF LHAT LGOTO LGO LFUNC LFOR LFLOAT LFALL LDots LDEFER LDDD LCONTINUE LCONST LCOMM LCHAN LBREAK LBRACKET LBRACE_SEMGREP LBRACE LBANG LAND EOF
first(select_stmt) = LSELECT
first(recvchantype) = LCOMM
first(ptrtype) = LMULT
first(pseudocall) = LSTRUCT LSTR LRUNE LPAREN LNAME LMAP LINTERFACE LINT LIMAG LFUNC LFLOAT LCHAN LBRACKET
first(pexpr_no_paren) = LSTRUCT LSTR LRUNE LPAREN LNAME LMAP LINTERFACE LINT LIMAG LFUNC LFLOAT LCHAN LBRACKET
first(pexpr) = LSTRUCT LSTR LRUNE LPAREN LNAME LMAP LINTERFACE LINT LIMAG LFUNC LFLOAT LCHAN LBRACKET
first(partial) = LNAME LBRACE_SEMGREP
first(packname) = LNAME
first(package) = LPACKAGE
first(othertype) = LSTRUCT LMAP LINTERFACE LCHAN LBRACKET
first(option(simple_stmt)) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(option(new_name)) = LNAME
first(option(expr)) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(option(LSTR)) = LSTR
first(option(LSEMICOLON)) = LSEMICOLON
first(option(LCOMMA)) = LCOMMA
first(oexpr_no_dots) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(oexpr_list) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(oarg_type_list_ocomma) = LSTRUCT LPAREN LNAME LMULT LMAP LINTERFACE LFUNC LDDD LCOMM LCHAN LBRACKET
first(ntype) = LSTRUCT LPAREN LNAME LMULT LMAP LINTERFACE LFUNC LCOMM LCHAN LBRACKET
first(non_recvchantype) = LSTRUCT LPAREN LNAME LMULT LMAP LINTERFACE LFUNC LCHAN LBRACKET
first(non_expr_type) = LSTRUCT LMULT LMAP LINTERFACE LFUNC LCOMM LCHAN LBRACKET
first(non_dcl_stmt) = LSWITCH LSTRUCT LSTR LSELECT LRUNE LRETURN LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LIF LHAT LGOTO LGO LFUNC LFOR LFLOAT LFALL LDots LDEFER LDDD LCONTINUE LCOMM LCHAN LBREAK LBRACKET LBANG LAND
first(name_or_type) = LSTRUCT LPAREN LNAME LMULT LMAP LINTERFACE LFUNC LCOMM LCHAN LBRACKET
first(name) = LNAME
first(loop_body) = LBODY
first(listsc_t(vardcl)) = LNAME
first(listsc_t(typedcl)) = LNAME
first(listsc_t(structdcl)) = LNAME LMULT LDDD
first(listsc_t(interfacedcl)) = LNAME LDDD
first(listsc_t(import_stmt)) = LSTR LNAME LDOT
first(listsc(stmt)) = LVAR LTYPE LSWITCH LSTRUCT LSTR LSEMICOLON LSELECT LRUNE LRETURN LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LIF LHAT LGOTO LGO LFUNC LFOR LFLOAT LFALL LDots LDEFER LDDD LCONTINUE LCONST LCOMM LCHAN LBREAK LBRACKET LBRACE LBANG LAND
first(listc(new_name)) = LNAME
first(listc(expr_or_type)) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(listc(expr)) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(listc(dcl_name)) = LNAME
first(list_sep_term(vardcl,LSEMICOLON)) = LNAME
first(list_sep_term(typedcl,LSEMICOLON)) = LNAME
first(list_sep_term(structdcl,LSEMICOLON)) = LNAME LMULT LDDD
first(list_sep_term(interfacedcl,LSEMICOLON)) = LNAME LDDD
first(list_sep_term(import_stmt,LSEMICOLON)) = LSTR LNAME LDOT
first(list_sep(stmt,LSEMICOLON)) = LVAR LTYPE LSWITCH LSTRUCT LSTR LSEMICOLON LSELECT LRUNE LRETURN LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LIF LHAT LGOTO LGO LFUNC LFOR LFLOAT LFALL LDots LDEFER LDDD LCONTINUE LCONST LCOMM LCHAN LBREAK LBRACKET LBRACE LBANG LAND
first(list_sep(new_name,LCOMMA)) = LNAME
first(list_sep(expr_or_type,LCOMMA)) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(list_sep(expr,LCOMMA)) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(list_sep(dcl_name,LCOMMA)) = LNAME
first(lbrace) = LBRACE LBODY
first(keyval_list) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBRACE LBANG LAND
first(keyval) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBRACE LBANG LAND
first(item_list) = LVAR LTYPE LSWITCH LSTRUCT LSTR LSEMICOLON LSELECT LRUNE LRETURN LPLUS LPAREN LPACKAGE LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMPORT LIMAG LIF LHAT LGOTO LGO LFUNC LFOR LFLOAT LFALL LDots LDEFER LDDD LCONTINUE LCONST LCOMM LCHAN LBREAK LBRACKET LBRACE LBANG LAND
first(item) = LVAR LTYPE LSWITCH LSTRUCT LSTR LSELECT LRUNE LRETURN LPLUS LPAREN LPACKAGE LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMPORT LIMAG LIF LHAT LGOTO LGO LFUNC LFOR LFLOAT LFALL LDots LDEFER LDDD LCONTINUE LCONST LCOMM LCHAN LBREAK LBRACKET LBRACE LBANG LAND
first(interfacetype) = LINTERFACE
first(interfacedcl) = LNAME LDDD
first(indcl) = LPAREN
first(imports) = LIMPORT
first(import_stmt) = LSTR LNAME LDOT
first(import) = LIMPORT
first(if_stmt) = LIF
first(if_header) = LSTRUCT LSTR LSEMICOLON LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(for_stmt) = LFOR
first(fntype) = LFUNC
first(fnret_type) = LSTRUCT LNAME LMULT LMAP LINTERFACE LFUNC LCOMM LCHAN LBRACKET
first(fnres) = LSTRUCT LPAREN LNAME LMULT LMAP LINTERFACE LFUNC LCOMM LCHAN LBRACKET
first(fnliteral) = LFUNC
first(fnlitdcl) = LFUNC
first(fndcl) = LPAREN LNAME
first(fnbody) = LBRACE
first(file) = LPACKAGE
first(expr_or_type) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(expr_no_dots) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(expr) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(elseif_list) = LELSE
first(elseif) = LELSE
first(else_) = LELSE
first(dotname) = LNAME
first(dotdotdot) = LDDD
first(convtype) = LSTRUCT LMAP LINTERFACE LFUNC LCHAN LBRACKET
first(constdcl1_list) = LNAME
first(constdcl1) = LNAME
first(constdcl) = LNAME
first(comptype) = LSTRUCT LMAP LINTERFACE LCHAN LBRACKET
first(compound_stmt) = LBRACE
first(complitexpr) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBRACE LBANG LAND
first(common_dcl) = LVAR LTYPE LCONST
first(caseblock_list) = LDEFAULT LCASE
first(caseblock) = LDEFAULT LCASE
first(case) = LDEFAULT LCASE
first(braced_keyval_list) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBRACE LBANG LAND
first(basic_literal) = LSTR LRUNE LINT LIMAG LFLOAT
first(bare_complitexpr) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBRACE LBANG LAND
first(arguments) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(argument) = LSTRUCT LSTR LRUNE LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LHAT LFUNC LFLOAT LDots LDDD LCOMM LCHAN LBRACKET LBANG LAND
first(arg_type_list) = LSTRUCT LPAREN LNAME LMULT LMAP LINTERFACE LFUNC LDDD LCOMM LCHAN LBRACKET
first(arg_type) = LSTRUCT LPAREN LNAME LMULT LMAP LINTERFACE LFUNC LDDD LCOMM LCHAN LBRACKET
minimal(xfndcl) = (* 4 *) LFUNC LNAME LPAREN RPAREN
minimal(xdcl_list) = (* 0 *)
minimal(xdcl) = (* 3 *) LVAR LNAME LNAME
minimal(vardcl) = (* 2 *) LNAME LNAME
minimal(uexpr) = (* 1 *) LINT
minimal(typedcl) = (* 2 *) LNAME LNAME
minimal(sym) = (* 1 *) LNAME
minimal(switch_stmt) = (* 3 *) LSWITCH LBODY RBRACE
minimal(structtype) = (* 3 *) LSTRUCT LBODY RBRACE
minimal(structdcl) = (* 1 *) LNAME
minimal(stmt) = (* 0 *)
minimal(simple_stmt) = (* 1 *) LINT
minimal(sgrep_spatch_pattern) = (* 1 *) EOF
minimal(select_stmt) = (* 3 *) LSELECT LBODY RBRACE
minimal(recvchantype) = (* 3 *) LCOMM LCHAN LNAME
minimal(ptrtype) = (* 2 *) LMULT LNAME
minimal(pseudocall) = (* 3 *) LINT LPAREN RPAREN
minimal(pexpr_no_paren) = (* 1 *) LINT
minimal(pexpr) = (* 1 *) LINT
minimal(partial) = (* 2 *) LBRACE_SEMGREP RBRACE
minimal(packname) = (* 1 *) LNAME
minimal(package) = (* 2 *) LPACKAGE LNAME
minimal(othertype) = (* 2 *) LCHAN LNAME
minimal(option(simple_stmt)) = (* 0 *)
minimal(option(new_name)) = (* 0 *)
minimal(option(expr)) = (* 0 *)
minimal(option(LSTR)) = (* 0 *)
minimal(option(LSEMICOLON)) = (* 0 *)
minimal(option(LCOMMA)) = (* 0 *)
minimal(oexpr_no_dots) = (* 0 *)
minimal(oexpr_list) = (* 0 *)
minimal(oarg_type_list_ocomma) = (* 0 *)
minimal(ntype) = (* 1 *) LNAME
minimal(non_recvchantype) = (* 1 *) LNAME
minimal(non_expr_type) = (* 2 *) LCHAN LNAME
minimal(non_dcl_stmt) = (* 1 *) LINT
minimal(name_or_type) = (* 1 *) LNAME
minimal(name) = (* 1 *) LNAME
minimal(loop_body) = (* 2 *) LBODY RBRACE
minimal(listsc_t(vardcl)) = (* 2 *) LNAME LNAME
minimal(listsc_t(typedcl)) = (* 2 *) LNAME LNAME
minimal(listsc_t(structdcl)) = (* 1 *) LNAME
minimal(listsc_t(interfacedcl)) = (* 1 *) LNAME
minimal(listsc_t(import_stmt)) = (* 1 *) LSTR
minimal(listsc(stmt)) = (* 0 *)
minimal(listc(new_name)) = (* 1 *) LNAME
minimal(listc(expr_or_type)) = (* 1 *) LINT
minimal(listc(expr)) = (* 1 *) LINT
minimal(listc(dcl_name)) = (* 1 *) LNAME
minimal(list_sep_term(vardcl,LSEMICOLON)) = (* 2 *) LNAME LNAME
minimal(list_sep_term(typedcl,LSEMICOLON)) = (* 2 *) LNAME LNAME
minimal(list_sep_term(structdcl,LSEMICOLON)) = (* 1 *) LNAME
minimal(list_sep_term(interfacedcl,LSEMICOLON)) = (* 1 *) LNAME
minimal(list_sep_term(import_stmt,LSEMICOLON)) = (* 1 *) LSTR
minimal(list_sep(stmt,LSEMICOLON)) = (* 0 *)
minimal(list_sep(new_name,LCOMMA)) = (* 1 *) LNAME
minimal(list_sep(expr_or_type,LCOMMA)) = (* 1 *) LINT
minimal(list_sep(expr,LCOMMA)) = (* 1 *) LINT
minimal(list_sep(dcl_name,LCOMMA)) = (* 1 *) LNAME
minimal(lbrace) = (* 1 *) LBODY
minimal(keyval_list) = (* 1 *) LINT
minimal(keyval) = (* 3 *) LINT LCOLON LINT
minimal(item_list) = (* 0 *)
minimal(item) = (* 0 *)
minimal(interfacetype) = (* 3 *) LINTERFACE LBODY RBRACE
minimal(interfacedcl) = (* 1 *) LNAME
minimal(indcl) = (* 2 *) LPAREN RPAREN
minimal(imports) = (* 0 *)
minimal(import_stmt) = (* 1 *) LSTR
minimal(import) = (* 2 *) LIMPORT LSTR
minimal(if_stmt) = (* 3 *) LIF LBODY RBRACE
minimal(if_header) = (* 0 *)
minimal(for_stmt) = (* 3 *) LFOR LBODY RBRACE
minimal(fntype) = (* 3 *) LFUNC LPAREN RPAREN
minimal(fnret_type) = (* 1 *) LNAME
minimal(fnres) = (* 0 *)
minimal(fnliteral) = (* 5 *) LFUNC LPAREN RPAREN LBODY RBRACE
minimal(fnlitdcl) = (* 3 *) LFUNC LPAREN RPAREN
minimal(fndcl) = (* 3 *) LNAME LPAREN RPAREN
minimal(fnbody) = (* 0 *)
minimal(file) = (* 4 *) LPACKAGE LNAME LSEMICOLON EOF
minimal(expr_or_type) = (* 1 *) LINT
minimal(expr_no_dots) = (* 1 *) LINT
minimal(expr) = (* 1 *) LINT
minimal(elseif_list) = (* 0 *)
minimal(elseif) = (* 4 *) LELSE LIF LBODY RBRACE
minimal(else_) = (* 0 *)
minimal(dotname) = (* 1 *) LNAME
minimal(dotdotdot) = (* 2 *) LDDD LNAME
minimal(convtype) = (* 2 *) LCHAN LNAME
minimal(constdcl1_list) = (* 1 *) LNAME
minimal(constdcl1) = (* 1 *) LNAME
minimal(constdcl) = (* 3 *) LNAME LEQ LINT
minimal(comptype) = (* 2 *) LCHAN LNAME
minimal(compound_stmt) = (* 2 *) LBRACE RBRACE
minimal(complitexpr) = (* 1 *) LINT
minimal(common_dcl) = (* 3 *) LVAR LNAME LNAME
minimal(caseblock_list) = (* 0 *)
minimal(caseblock) = (* 2 *) LDEFAULT LCOLON
minimal(case) = (* 2 *) LDEFAULT LCOLON
minimal(braced_keyval_list) = (* 0 *)
minimal(basic_literal) = (* 1 *) LINT
minimal(bare_complitexpr) = (* 1 *) LINT
minimal(arguments) = (* 1 *) LINT
minimal(argument) = (* 1 *) LINT
minimal(arg_type_list) = (* 1 *) LNAME
minimal(arg_type) = (* 1 *) LNAME
maximal(xfndcl) = infinity
maximal(xdcl_list) = infinity
maximal(xdcl) = infinity
maximal(vardcl) = infinity
maximal(uexpr) = infinity
maximal(typedcl) = infinity
maximal(sym) = 1
maximal(switch_stmt) = infinity
maximal(structtype) = infinity
maximal(structdcl) = infinity
maximal(stmt) = infinity
maximal(simple_stmt) = infinity
maximal(sgrep_spatch_pattern) = infinity
maximal(select_stmt) = infinity
maximal(recvchantype) = infinity
maximal(ptrtype) = infinity
maximal(pseudocall) = infinity
maximal(pexpr_no_paren) = infinity
maximal(pexpr) = infinity
maximal(partial) = infinity
maximal(packname) = 3
maximal(package) = 2
maximal(othertype) = infinity
maximal(option(simple_stmt)) = infinity
maximal(option(new_name)) = 1
maximal(option(expr)) = infinity
maximal(option(LSTR)) = 1
maximal(option(LSEMICOLON)) = 1
maximal(option(LCOMMA)) = 1
maximal(oexpr_no_dots) = infinity
maximal(oexpr_list) = infinity
maximal(oarg_type_list_ocomma) = infinity
maximal(ntype) = infinity
maximal(non_recvchantype) = infinity
maximal(non_expr_type) = infinity
maximal(non_dcl_stmt) = infinity
maximal(name_or_type) = infinity
maximal(name) = 1
maximal(loop_body) = infinity
maximal(listsc_t(vardcl)) = infinity
maximal(listsc_t(typedcl)) = infinity
maximal(listsc_t(structdcl)) = infinity
maximal(listsc_t(interfacedcl)) = infinity
maximal(listsc_t(import_stmt)) = infinity
maximal(listsc(stmt)) = infinity
maximal(listc(new_name)) = infinity
maximal(listc(expr_or_type)) = infinity
maximal(listc(expr)) = infinity
maximal(listc(dcl_name)) = infinity
maximal(list_sep_term(vardcl,LSEMICOLON)) = infinity
maximal(list_sep_term(typedcl,LSEMICOLON)) = infinity
maximal(list_sep_term(structdcl,LSEMICOLON)) = infinity
maximal(list_sep_term(interfacedcl,LSEMICOLON)) = infinity
maximal(list_sep_term(import_stmt,LSEMICOLON)) = infinity
maximal(list_sep(stmt,LSEMICOLON)) = infinity
maximal(list_sep(new_name,LCOMMA)) = infinity
maximal(list_sep(expr_or_type,LCOMMA)) = infinity
maximal(list_sep(expr,LCOMMA)) = infinity
maximal(list_sep(dcl_name,LCOMMA)) = infinity
maximal(lbrace) = 1
maximal(keyval_list) = infinity
maximal(keyval) = infinity
maximal(item_list) = infinity
maximal(item) = infinity
maximal(interfacetype) = infinity
maximal(interfacedcl) = infinity
maximal(indcl) = infinity
maximal(imports) = infinity
maximal(import_stmt) = 2
maximal(import) = infinity
maximal(if_stmt) = infinity
maximal(if_header) = infinity
maximal(for_stmt) = infinity
maximal(fntype) = infinity
maximal(fnret_type) = infinity
maximal(fnres) = infinity
maximal(fnliteral) = infinity
maximal(fnlitdcl) = infinity
maximal(fndcl) = infinity
maximal(fnbody) = infinity
maximal(file) = infinity
maximal(expr_or_type) = infinity
maximal(expr_no_dots) = infinity
maximal(expr) = infinity
maximal(elseif_list) = infinity
maximal(elseif) = infinity
maximal(else_) = infinity
maximal(dotname) = 3
maximal(dotdotdot) = infinity
maximal(convtype) = infinity
maximal(constdcl1_list) = infinity
maximal(constdcl1) = infinity
maximal(constdcl) = infinity
maximal(comptype) = infinity
maximal(compound_stmt) = infinity
maximal(complitexpr) = infinity
maximal(common_dcl) = infinity
maximal(caseblock_list) = infinity
maximal(caseblock) = infinity
maximal(case) = infinity
maximal(braced_keyval_list) = infinity
maximal(basic_literal) = 1
maximal(bare_complitexpr) = infinity
maximal(arguments) = infinity
maximal(argument) = infinity
maximal(arg_type_list) = infinity
maximal(arg_type) = infinity
follow(xfndcl) = LSEMICOLON EOF
follow(xdcl_list) = LVAR LTYPE LFUNC LCONST EOF
follow(xdcl) = LSEMICOLON
follow(vardcl) = RPAREN RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(uexpr) = RPAREN RDots RBRACKET RBRACE LSEMICOLON LRSH LPLUS LPIPE LPERCENT LOROR LNE LMULT LMINUS LLT LLSH LLE LINC LHAT LGT LGE LEQEQ LEQ LDIV LDEFAULT LDEC LDDD LCOMMA LCOMM LCOLON LCOLAS LCASE LBODY LASOP LANDNOT LANDAND LAND EOF
follow(typedcl) = RPAREN RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(sym) = RPAREN RDots RBRACKET RBRACE LSTRUCT LSTR LSEMICOLON LRSH LPLUS LPIPE LPERCENT LPAREN LOROR LNE LNAME LMULT LMINUS LMAP LLT LLSH LLE LINTERFACE LINC LHAT LGT LGE LFUNC LEQEQ LEQ LDOT LDIV LDEFAULT LDEC LDDD LCOMMA LCOMM LCOLON LCOLAS LCHAN LCASE LBRACKET LBRACE LBODY LASOP LANDNOT LANDAND LAND EOF
follow(switch_stmt) = RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(structtype) = RPAREN RBRACKET RBRACE LSTR LSEMICOLON LPAREN LEQ LDEFAULT LDDD LCOMMA LCOLON LCOLAS LCASE LBRACE LBODY EOF
follow(structdcl) = RBRACE LSEMICOLON
follow(stmt) = RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(simple_stmt) = RBRACE LSEMICOLON LDEFAULT LCASE LBODY EOF
follow(sgrep_spatch_pattern) = #
follow(select_stmt) = RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(recvchantype) = RPAREN RBRACKET RBRACE LSTR LSEMICOLON LPAREN LEQ LDEFAULT LDDD LCOMMA LCOLON LCOLAS LCASE LBRACE LBODY EOF
follow(ptrtype) = RPAREN RBRACKET RBRACE LSTR LSEMICOLON LPAREN LEQ LDEFAULT LDDD LCOMMA LCOLON LCOLAS LCASE LBRACE LBODY EOF
follow(pseudocall) = RPAREN RDots RBRACKET RBRACE LSEMICOLON LRSH LPLUS LPIPE LPERCENT LPAREN LOROR LNE LMULT LMINUS LLT LLSH LLE LINC LHAT LGT LGE LEQEQ LEQ LDOT LDIV LDEFAULT LDEC LDDD LCOMMA LCOMM LCOLON LCOLAS LCASE LBRACKET LBRACE LBODY LASOP LANDNOT LANDAND LAND EOF
follow(pexpr_no_paren) = RPAREN RDots RBRACKET RBRACE LSEMICOLON LRSH LPLUS LPIPE LPERCENT LPAREN LOROR LNE LMULT LMINUS LLT LLSH LLE LINC LHAT LGT LGE LEQEQ LEQ LDOT LDIV LDEFAULT LDEC LDDD LCOMMA LCOMM LCOLON LCOLAS LCASE LBRACKET LBRACE LBODY LASOP LANDNOT LANDAND LAND EOF
follow(pexpr) = RPAREN RDots RBRACKET RBRACE LSEMICOLON LRSH LPLUS LPIPE LPERCENT LPAREN LOROR LNE LMULT LMINUS LLT LLSH LLE LINC LHAT LGT LGE LEQEQ LEQ LDOT LDIV LDEFAULT LDEC LDDD LCOMMA LCOMM LCOLON LCOLAS LCASE LBRACKET LBODY LASOP LANDNOT LANDAND LAND EOF
follow(partial) = EOF
follow(packname) = RBRACE LSTR LSEMICOLON
follow(package) = LSEMICOLON EOF
follow(othertype) = RPAREN RBRACKET RBRACE LSTR LSEMICOLON LPAREN LEQ LDEFAULT LDDD LCOMMA LCOLON LCOLAS LCASE LBRACE LBODY EOF
follow(option(simple_stmt)) = LSEMICOLON LBODY
follow(option(new_name)) = RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(option(expr)) = RBRACKET LCOLON
follow(option(LSTR)) = RBRACE LSEMICOLON
follow(option(LSEMICOLON)) = RPAREN RBRACE LDEFAULT LCASE EOF
follow(option(LCOMMA)) = RPAREN RBRACE
follow(oexpr_no_dots) = RBRACKET
follow(oexpr_list) = RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(oarg_type_list_ocomma) = RPAREN
follow(ntype) = RPAREN RBRACKET RBRACE LSTR LSEMICOLON LPAREN LEQ LDEFAULT LDDD LCOMMA LCOLON LCOLAS LCASE LBRACE LBODY EOF
follow(non_recvchantype) = RPAREN RBRACKET RBRACE LSTR LSEMICOLON LPAREN LEQ LDEFAULT LDDD LCOMMA LCOLON LCOLAS LCASE LBRACE LBODY EOF
follow(non_expr_type) = RPAREN LEQ LDDD LCOMMA LCOLON LCOLAS
follow(non_dcl_stmt) = RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(name_or_type) = RPAREN LCOMMA
follow(name) = RPAREN RDots RBRACKET RBRACE LSTR LSEMICOLON LRSH LPLUS LPIPE LPERCENT LPAREN LOROR LNE LMULT LMINUS LLT LLSH LLE LINC LHAT LGT LGE LEQEQ LEQ LDOT LDIV LDEFAULT LDEC LDDD LCOMMA LCOMM LCOLON LCOLAS LCASE LBRACKET LBRACE LBODY LASOP LANDNOT LANDAND LAND EOF
follow(loop_body) = RBRACE LSEMICOLON LELSE LDEFAULT LCASE EOF
follow(listsc_t(vardcl)) = RPAREN
follow(listsc_t(typedcl)) = RPAREN
follow(listsc_t(structdcl)) = RBRACE
follow(listsc_t(interfacedcl)) = RBRACE
follow(listsc_t(import_stmt)) = RPAREN
follow(listsc(stmt)) = RBRACE LDEFAULT LCASE
follow(listc(new_name)) = LSTRUCT LPAREN LNAME LMULT LMAP LINTERFACE LFUNC LCOMM LCHAN LBRACKET
follow(listc(expr_or_type)) = LEQ LCOLON LCOLAS
follow(listc(expr)) = RPAREN RBRACE LSEMICOLON LEQ LDEFAULT LCOLAS LCASE LBODY EOF
follow(listc(dcl_name)) = RPAREN LSTRUCT LSEMICOLON LPAREN LNAME LMULT LMAP LINTERFACE LFUNC LEQ LCOMM LCHAN LBRACKET
follow(list_sep_term(vardcl,LSEMICOLON)) = RPAREN
follow(list_sep_term(typedcl,LSEMICOLON)) = RPAREN
follow(list_sep_term(structdcl,LSEMICOLON)) = RBRACE
follow(list_sep_term(interfacedcl,LSEMICOLON)) = RBRACE
follow(list_sep_term(import_stmt,LSEMICOLON)) = RPAREN
follow(list_sep(stmt,LSEMICOLON)) = RBRACE LSEMICOLON LDEFAULT LCASE
follow(list_sep(new_name,LCOMMA)) = LSTRUCT LPAREN LNAME LMULT LMAP LINTERFACE LFUNC LCOMMA LCOMM LCHAN LBRACKET
follow(list_sep(expr_or_type,LCOMMA)) = LEQ LCOMMA LCOLON LCOLAS
follow(list_sep(expr,LCOMMA)) = RPAREN RBRACE LSEMICOLON LEQ LDEFAULT LCOMMA LCOLAS LCASE LBODY EOF
follow(list_sep(dcl_name,LCOMMA)) = RPAREN LSTRUCT LSEMICOLON LPAREN LNAME LMULT LMAP LINTERFACE LFUNC LEQ LCOMMA LCOMM LCHAN LBRACKET
follow(lbrace) = RBRACE LVAR LTYPE LSWITCH LSTRUCT LSTR LSEMICOLON LSELECT LRUNE LRETURN LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LIF LHAT LGOTO LGO LFUNC LFOR LFLOAT LFALL LDots LDEFER LDDD LCONTINUE LCONST LCOMM LCHAN LBREAK LBRACKET LBRACE LBANG LAND
follow(keyval_list) = RBRACE LCOMMA
follow(keyval) = RBRACE LCOMMA
follow(item_list) = LSEMICOLON EOF
follow(item) = LSEMICOLON EOF
follow(interfacetype) = RPAREN RBRACKET RBRACE LSTR LSEMICOLON LPAREN LEQ LDEFAULT LDDD LCOMMA LCOLON LCOLAS LCASE LBRACE LBODY EOF
follow(interfacedcl) = RBRACE LSEMICOLON
follow(indcl) = RBRACE LSEMICOLON
follow(imports) = LVAR LTYPE LIMPORT LFUNC LCONST EOF
follow(import_stmt) = RPAREN LSEMICOLON EOF
follow(import) = LSEMICOLON EOF
follow(if_stmt) = RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(if_header) = LBODY
follow(for_stmt) = RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(fntype) = RPAREN RBRACKET RBRACE LSTR LSEMICOLON LPAREN LEQ LDEFAULT LDDD LCOMMA LCOLON LCOLAS LCASE LBRACE LBODY EOF
follow(fnret_type) = RPAREN RBRACKET RBRACE LSTR LSEMICOLON LPAREN LEQ LDEFAULT LDDD LCOMMA LCOLON LCOLAS LCASE LBRACE LBODY EOF
follow(fnres) = RPAREN RBRACKET RBRACE LSTR LSEMICOLON LPAREN LEQ LDEFAULT LDDD LCOMMA LCOLON LCOLAS LCASE LBRACE LBODY EOF
follow(fnliteral) = RPAREN RDots RBRACKET RBRACE LSEMICOLON LRSH LPLUS LPIPE LPERCENT LPAREN LOROR LNE LMULT LMINUS LLT LLSH LLE LINC LHAT LGT LGE LEQEQ LEQ LDOT LDIV LDEFAULT LDEC LDDD LCOMMA LCOMM LCOLON LCOLAS LCASE LBRACKET LBRACE LBODY LASOP LANDNOT LANDAND LAND EOF
follow(fnlitdcl) = LBRACE LBODY
follow(fndcl) = LSEMICOLON LBRACE EOF
follow(fnbody) = LSEMICOLON EOF
follow(file) = #
follow(expr_or_type) = RPAREN LEQ LDDD LCOMMA LCOLON LCOLAS
follow(expr_no_dots) = RBRACKET
follow(expr) = RPAREN RDots RBRACKET RBRACE LSEMICOLON LRSH LPLUS LPIPE LPERCENT LOROR LNE LMULT LMINUS LLT LLSH LLE LINC LHAT LGT LGE LEQEQ LEQ LDIV LDEFAULT LDEC LDDD LCOMMA LCOMM LCOLON LCOLAS LCASE LBODY LASOP LANDNOT LANDAND LAND EOF
follow(elseif_list) = RBRACE LSEMICOLON LELSE LDEFAULT LCASE EOF
follow(elseif) = RBRACE LSEMICOLON LELSE LDEFAULT LCASE EOF
follow(else_) = RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(dotname) = RPAREN RBRACKET RBRACE LSTR LSEMICOLON LPAREN LEQ LDEFAULT LDDD LCOMMA LCOLON LCOLAS LCASE LBRACE LBODY EOF
follow(dotdotdot) = RPAREN LCOMMA
follow(convtype) = LPAREN
follow(constdcl1_list) = RPAREN LSEMICOLON
follow(constdcl1) = RPAREN LSEMICOLON
follow(constdcl) = RPAREN RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(comptype) = LBRACE LBODY
follow(compound_stmt) = RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(complitexpr) = RBRACE LSEMICOLON LCOMMA LCOLON EOF
follow(common_dcl) = RBRACE LSEMICOLON LDEFAULT LCASE EOF
follow(caseblock_list) = RBRACE LDEFAULT LCASE
follow(caseblock) = RBRACE LDEFAULT LCASE
follow(case) = RBRACE LVAR LTYPE LSWITCH LSTRUCT LSTR LSEMICOLON LSELECT LRUNE LRETURN LPLUS LPAREN LNAME LMULT LMINUS LMAP LINTERFACE LINT LIMAG LIF LHAT LGOTO LGO LFUNC LFOR LFLOAT LFALL LDots LDEFER LDEFAULT LDDD LCONTINUE LCONST LCOMM LCHAN LCASE LBREAK LBRACKET LBRACE LBANG LAND
follow(braced_keyval_list) = RBRACE
follow(basic_literal) = RPAREN RDots RBRACKET RBRACE LSEMICOLON LRSH LPLUS LPIPE LPERCENT LPAREN LOROR LNE LMULT LMINUS LLT LLSH LLE LINC LHAT LGT LGE LEQEQ LEQ LDOT LDIV LDEFAULT LDEC LDDD LCOMMA LCOMM LCOLON LCOLAS LCASE LBRACKET LBRACE LBODY LASOP LANDNOT LANDAND LAND EOF
follow(bare_complitexpr) = RBRACE LCOMMA
follow(arguments) = RPAREN LDDD LCOMMA
follow(argument) = RPAREN LDDD LCOMMA
follow(arg_type_list) = RPAREN LCOMMA
follow(arg_type) = RPAREN LCOMMA
Built an LR(0) automaton with 577 states.
The grammar is not SLR(1) -- 67 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 577 states.
803 shift/reduce conflicts were silently solved.
226 out of 577 states have a default reduction.
The action table is 45583 entries; 4890 non-zero; 4481 compressed.
The action table occupies roughly 9056 bytes.
The goto table is 62893 entries; 2469 non-zero; 5446 compressed.
The goto table occupies roughly 10992 bytes.
The error table occupies roughly 5736 bytes.
The default_reduction table occupies roughly 1192 bytes.
The lhs table occupies roughly 352 bytes.
The trace table occupies roughly 8 bytes.
