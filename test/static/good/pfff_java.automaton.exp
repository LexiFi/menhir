State 0:
## Known stack suffix:
##
## LR(1) items:
goal' -> . goal [ # ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 6
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PACKAGE shift to state 10
-- On NATIVE shift to state 16
-- On INTERFACE shift to state 17
-- On IMPORT shift to state 903
-- On FINAL shift to state 316
-- On ENUM shift to state 317
-- On DEFAULT shift to state 328
-- On CLASS shift to state 329
-- On AT shift to state 338
-- On ABSTRACT shift to state 342
-- On type_declaration shift to state 911
-- On package_declaration shift to state 918
-- On nonempty_list(import_declaration) shift to state 924
-- On modifiers shift to state 926
-- On modifier shift to state 391
-- On list(type_declaration) shift to state 930
-- On interface_declaration shift to state 914
-- On import_declaration shift to state 922
-- On goal shift to state 931
-- On enum_declaration shift to state 915
-- On compilation_unit shift to state 932
-- On class_header shift to state 396
-- On class_declaration shift to state 916
-- On annotation_type_declaration shift to state 917
-- On annotation shift to state 390
## Reductions:
-- On EOF
--   reduce production list(type_declaration) ->

State 1:
## Known stack suffix:
## VOLATILE
## LR(1) items:
modifier -> VOLATILE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> VOLATILE

State 2:
## Known stack suffix:
## TRANSIENT
## LR(1) items:
modifier -> TRANSIENT . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> TRANSIENT

State 3:
## Known stack suffix:
## SYNCHRONIZED
## LR(1) items:
modifier -> SYNCHRONIZED . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> SYNCHRONIZED

State 4:
## Known stack suffix:
## STRICTFP
## LR(1) items:
modifier -> STRICTFP . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> STRICTFP

State 5:
## Known stack suffix:
## STATIC
## LR(1) items:
modifier -> STATIC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> STATIC

State 6:
## Known stack suffix:
## SM
## LR(1) items:
type_declaration -> SM . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production type_declaration -> SM

State 7:
## Known stack suffix:
## PUBLIC
## LR(1) items:
modifier -> PUBLIC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> PUBLIC

State 8:
## Known stack suffix:
## PROTECTED
## LR(1) items:
modifier -> PROTECTED . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> PROTECTED

State 9:
## Known stack suffix:
## PRIVATE
## LR(1) items:
modifier -> PRIVATE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> PRIVATE

State 10:
## Known stack suffix:
## PACKAGE
## LR(1) items:
package_declaration -> PACKAGE . qualified_ident SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On qualified_ident shift to state 12
## Reductions:

State 11:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
qualified_ident -> IDENTIFIER . [ VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT LP INTERFACE IDENTIFIER FINAL EOF ENUM DOT DEFAULT CM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT LP INTERFACE IDENTIFIER FINAL EOF ENUM DOT DEFAULT CM CLASS AT ABSTRACT
--   reduce production qualified_ident -> IDENTIFIER

State 12:
## Known stack suffix:
## PACKAGE qualified_ident
## LR(1) items:
package_declaration -> PACKAGE qualified_ident . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
qualified_ident -> qualified_ident . DOT IDENTIFIER [ SM DOT ]
## Transitions:
-- On SM shift to state 13
-- On DOT shift to state 14
## Reductions:

State 13:
## Known stack suffix:
## PACKAGE qualified_ident SM
## LR(1) items:
package_declaration -> PACKAGE qualified_ident SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production package_declaration -> PACKAGE qualified_ident SM

State 14:
## Known stack suffix:
## qualified_ident DOT
## LR(1) items:
qualified_ident -> qualified_ident DOT . IDENTIFIER [ VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT LP INTERFACE IDENTIFIER FINAL EOF ENUM DOT DEFAULT CM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 15
## Reductions:

State 15:
## Known stack suffix:
## qualified_ident DOT IDENTIFIER
## LR(1) items:
qualified_ident -> qualified_ident DOT IDENTIFIER . [ VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT LP INTERFACE IDENTIFIER FINAL EOF ENUM DOT DEFAULT CM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT LP INTERFACE IDENTIFIER FINAL EOF ENUM DOT DEFAULT CM CLASS AT ABSTRACT
--   reduce production qualified_ident -> qualified_ident DOT IDENTIFIER

State 16:
## Known stack suffix:
## NATIVE
## LR(1) items:
modifier -> NATIVE . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> NATIVE

State 17:
## Known stack suffix:
## INTERFACE
## LR(1) items:
interface_declaration -> INTERFACE . identifier optl(type_parameters) optl(extends_interfaces) interface_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 19
## Reductions:

State 18:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
identifier -> IDENTIFIER . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT_GENERIC LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EXTENDS EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT_GENERIC LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EXTENDS EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production identifier -> IDENTIFIER

State 19:
## Known stack suffix:
## INTERFACE identifier
## LR(1) items:
interface_declaration -> INTERFACE identifier . optl(type_parameters) optl(extends_interfaces) interface_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LT shift to state 20
-- On type_parameters shift to state 63
-- On optl(type_parameters) shift to state 64
## Reductions:
-- On LC EXTENDS
--   reduce production optl(type_parameters) ->

State 20:
## Known stack suffix:
## LT
## LR(1) items:
type_parameters -> LT . listc(type_parameter) GT [ VOID PRIMITIVE_TYPE LC IMPLEMENTS IDENTIFIER EXTENDS EOF ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On type_parameter shift to state 21
-- On listc(type_parameter) shift to state 22
-- On identifier shift to state 26
## Reductions:

State 21:
## Known stack suffix:
## type_parameter
## LR(1) items:
listc(type_parameter) -> type_parameter . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production listc(type_parameter) -> type_parameter

State 22:
## Known stack suffix:
## LT listc(type_parameter)
## LR(1) items:
listc(type_parameter) -> listc(type_parameter) . CM type_parameter [ GT CM ]
type_parameters -> LT listc(type_parameter) . GT [ VOID PRIMITIVE_TYPE LC IMPLEMENTS IDENTIFIER EXTENDS EOF ]
## Transitions:
-- On GT shift to state 23
-- On CM shift to state 24
## Reductions:

State 23:
## Known stack suffix:
## LT listc(type_parameter) GT
## LR(1) items:
type_parameters -> LT listc(type_parameter) GT . [ VOID PRIMITIVE_TYPE LC IMPLEMENTS IDENTIFIER EXTENDS EOF ]
## Transitions:
## Reductions:
-- On VOID PRIMITIVE_TYPE LC IMPLEMENTS IDENTIFIER EXTENDS EOF
--   reduce production type_parameters -> LT listc(type_parameter) GT

State 24:
## Known stack suffix:
## listc(type_parameter) CM
## LR(1) items:
listc(type_parameter) -> listc(type_parameter) CM . type_parameter [ GT CM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On type_parameter shift to state 25
-- On identifier shift to state 26
## Reductions:

State 25:
## Known stack suffix:
## listc(type_parameter) CM type_parameter
## LR(1) items:
listc(type_parameter) -> listc(type_parameter) CM type_parameter . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production listc(type_parameter) -> listc(type_parameter) CM type_parameter

State 26:
## Known stack suffix:
## identifier
## LR(1) items:
type_parameter -> identifier . [ GT CM ]
type_parameter -> identifier . EXTENDS bound [ GT CM ]
## Transitions:
-- On EXTENDS shift to state 27
## Reductions:
-- On GT CM
--   reduce production type_parameter -> identifier

State 27:
## Known stack suffix:
## identifier EXTENDS
## LR(1) items:
type_parameter -> identifier EXTENDS . bound [ GT CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On reference_type shift to state 29
-- On primitive_type shift to state 30
-- On name shift to state 32
-- On list_sep(reference_type,AND) shift to state 59
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On bound shift to state 62
-- On array_type shift to state 51
## Reductions:

State 28:
## Known stack suffix:
## PRIMITIVE_TYPE
## LR(1) items:
primitive_type -> PRIMITIVE_TYPE . [ RP OR LC LB_RB LB IMPLEMENTS IDENTIFIER EOF DOTS DOT ]
## Transitions:
## Reductions:
-- On RP OR LC LB_RB LB IMPLEMENTS IDENTIFIER EOF DOTS DOT
--   reduce production primitive_type -> PRIMITIVE_TYPE

State 29:
## Known stack suffix:
## reference_type
## LR(1) items:
list_sep(reference_type,AND) -> reference_type . [ GT CM AND ]
## Transitions:
## Reductions:
-- On GT CM AND
--   reduce production list_sep(reference_type,AND) -> reference_type

State 30:
## Known stack suffix:
## primitive_type
## LR(1) items:
array_type -> primitive_type . LB_RB [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 31
## Reductions:

State 31:
## Known stack suffix:
## primitive_type LB_RB
## LR(1) items:
array_type -> primitive_type LB_RB . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS DOT COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS DOT COND COLONCOLON COLON CM AND_AND AND
--   reduce production array_type -> primitive_type LB_RB

State 32:
## Known stack suffix:
## name
## LR(1) items:
class_or_interface_type -> name . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS COND COLON CM AND_AND AND ]
name -> name . DOT identifier_ [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS DOT COND COLON CM AND_AND AND ]
name -> name . DOT LT_GENERIC listc(type_argument) GT identifier_ [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS DOT COND COLON CM AND_AND AND ]
## Transitions:
-- On DOT shift to state 33
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS COND COLON CM AND_AND AND
--   reduce production class_or_interface_type -> name

State 33:
## Known stack suffix:
## name DOT
## LR(1) items:
name -> name DOT . identifier_ [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LP LE LC LB_RB LB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS DOT COND COLON CM AND_AND AND ]
name -> name DOT . LT_GENERIC listc(type_argument) GT identifier_ [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LP LE LC LB_RB LB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS DOT COND COLON CM AND_AND AND ]
## Transitions:
-- On LT_GENERIC shift to state 34
-- On IDENTIFIER shift to state 18
-- On identifier_ shift to state 58
-- On identifier shift to state 39
## Reductions:

State 34:
## Known stack suffix:
## name DOT LT_GENERIC
## LR(1) items:
name -> name DOT LT_GENERIC . listc(type_argument) GT identifier_ [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On COND shift to state 35
-- On type_argument shift to state 41
-- On reference_type shift to state 42
-- On primitive_type shift to state 30
-- On name shift to state 32
-- On listc(type_argument) shift to state 55
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 35:
## Known stack suffix:
## COND
## LR(1) items:
type_argument -> COND . [ GT CM ]
type_argument -> COND . EXTENDS reference_type [ GT CM ]
type_argument -> COND . SUPER reference_type [ GT CM ]
## Transitions:
-- On SUPER shift to state 36
-- On EXTENDS shift to state 53
## Reductions:
-- On GT CM
--   reduce production type_argument -> COND

State 36:
## Known stack suffix:
## COND SUPER
## LR(1) items:
type_argument -> COND SUPER . reference_type [ GT CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On reference_type shift to state 37
-- On primitive_type shift to state 30
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 37:
## Known stack suffix:
## COND SUPER reference_type
## LR(1) items:
type_argument -> COND SUPER reference_type . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production type_argument -> COND SUPER reference_type

State 38:
## Known stack suffix:
## identifier_
## LR(1) items:
name -> identifier_ . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production name -> identifier_

State 39:
## Known stack suffix:
## identifier
## LR(1) items:
identifier_ -> identifier . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
identifier_ -> identifier . LT_GENERIC listc0(type_argument) GT [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LT_GENERIC shift to state 40
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production identifier_ -> identifier

State 40:
## Known stack suffix:
## identifier LT_GENERIC
## LR(1) items:
identifier_ -> identifier LT_GENERIC . listc0(type_argument) GT [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On COND shift to state 35
-- On type_argument shift to state 41
-- On reference_type shift to state 42
-- On primitive_type shift to state 30
-- On optl(listc(type_argument)) shift to state 43
-- On name shift to state 32
-- On listc0(type_argument) shift to state 44
-- On listc(type_argument) shift to state 46
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:
-- On GT
--   reduce production optl(listc(type_argument)) ->

State 41:
## Known stack suffix:
## type_argument
## LR(1) items:
listc(type_argument) -> type_argument . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production listc(type_argument) -> type_argument

State 42:
## Known stack suffix:
## reference_type
## LR(1) items:
type_argument -> reference_type . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production type_argument -> reference_type

State 43:
## Known stack suffix:
## optl(listc(type_argument))
## LR(1) items:
listc0(type_argument) -> optl(listc(type_argument)) . [ GT ]
## Transitions:
## Reductions:
-- On GT
--   reduce production listc0(type_argument) -> optl(listc(type_argument))

State 44:
## Known stack suffix:
## identifier LT_GENERIC listc0(type_argument)
## LR(1) items:
identifier_ -> identifier LT_GENERIC listc0(type_argument) . GT [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On GT shift to state 45
## Reductions:

State 45:
## Known stack suffix:
## identifier LT_GENERIC listc0(type_argument) GT
## LR(1) items:
identifier_ -> identifier LT_GENERIC listc0(type_argument) GT . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production identifier_ -> identifier LT_GENERIC listc0(type_argument) GT

State 46:
## Known stack suffix:
## listc(type_argument)
## LR(1) items:
listc(type_argument) -> listc(type_argument) . CM type_argument [ GT CM ]
optl(listc(type_argument)) -> listc(type_argument) . [ GT ]
## Transitions:
-- On CM shift to state 47
## Reductions:
-- On GT
--   reduce production optl(listc(type_argument)) -> listc(type_argument)

State 47:
## Known stack suffix:
## listc(type_argument) CM
## LR(1) items:
listc(type_argument) -> listc(type_argument) CM . type_argument [ GT CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On COND shift to state 35
-- On type_argument shift to state 48
-- On reference_type shift to state 42
-- On primitive_type shift to state 30
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 48:
## Known stack suffix:
## listc(type_argument) CM type_argument
## LR(1) items:
listc(type_argument) -> listc(type_argument) CM type_argument . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production listc(type_argument) -> listc(type_argument) CM type_argument

State 49:
## Known stack suffix:
## class_or_interface_type
## LR(1) items:
array_type -> class_or_interface_type . LB_RB [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS DOT COND COLONCOLON COLON CM AND_AND AND ]
reference_type -> class_or_interface_type . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS COND COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 50
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS COND COLON CM AND_AND AND
--   reduce production reference_type -> class_or_interface_type

State 50:
## Known stack suffix:
## class_or_interface_type LB_RB
## LR(1) items:
array_type -> class_or_interface_type LB_RB . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS DOT COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS DOT COND COLONCOLON COLON CM AND_AND AND
--   reduce production array_type -> class_or_interface_type LB_RB

State 51:
## Known stack suffix:
## array_type
## LR(1) items:
array_type -> array_type . LB_RB [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS COND COLON CM AND_AND AND ]
reference_type -> array_type . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS COND COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 52
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS COND COLON CM AND_AND AND
--   reduce production reference_type -> array_type

State 52:
## Known stack suffix:
## array_type LB_RB
## LR(1) items:
array_type -> array_type LB_RB . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS DOT COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS DOT COND COLONCOLON COLON CM AND_AND AND
--   reduce production array_type -> array_type LB_RB

State 53:
## Known stack suffix:
## COND EXTENDS
## LR(1) items:
type_argument -> COND EXTENDS . reference_type [ GT CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On reference_type shift to state 54
-- On primitive_type shift to state 30
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 54:
## Known stack suffix:
## COND EXTENDS reference_type
## LR(1) items:
type_argument -> COND EXTENDS reference_type . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production type_argument -> COND EXTENDS reference_type

State 55:
## Known stack suffix:
## name DOT LT_GENERIC listc(type_argument)
## LR(1) items:
listc(type_argument) -> listc(type_argument) . CM type_argument [ GT CM ]
name -> name DOT LT_GENERIC listc(type_argument) . GT identifier_ [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On GT shift to state 56
-- On CM shift to state 47
## Reductions:

State 56:
## Known stack suffix:
## name DOT LT_GENERIC listc(type_argument) GT
## LR(1) items:
name -> name DOT LT_GENERIC listc(type_argument) GT . identifier_ [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier_ shift to state 57
-- On identifier shift to state 39
## Reductions:

State 57:
## Known stack suffix:
## name DOT LT_GENERIC listc(type_argument) GT identifier_
## LR(1) items:
name -> name DOT LT_GENERIC listc(type_argument) GT identifier_ . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production name -> name DOT LT_GENERIC listc(type_argument) GT identifier_

State 58:
## Known stack suffix:
## name DOT identifier_
## LR(1) items:
name -> name DOT identifier_ . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production name -> name DOT identifier_

State 59:
## Known stack suffix:
## list_sep(reference_type,AND)
## LR(1) items:
bound -> list_sep(reference_type,AND) . [ GT CM ]
list_sep(reference_type,AND) -> list_sep(reference_type,AND) . AND reference_type [ GT CM AND ]
## Transitions:
-- On AND shift to state 60
## Reductions:
-- On GT CM
--   reduce production bound -> list_sep(reference_type,AND)

State 60:
## Known stack suffix:
## list_sep(reference_type,AND) AND
## LR(1) items:
list_sep(reference_type,AND) -> list_sep(reference_type,AND) AND . reference_type [ GT CM AND ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On reference_type shift to state 61
-- On primitive_type shift to state 30
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 61:
## Known stack suffix:
## list_sep(reference_type,AND) AND reference_type
## LR(1) items:
list_sep(reference_type,AND) -> list_sep(reference_type,AND) AND reference_type . [ GT CM AND ]
## Transitions:
## Reductions:
-- On GT CM AND
--   reduce production list_sep(reference_type,AND) -> list_sep(reference_type,AND) AND reference_type

State 62:
## Known stack suffix:
## identifier EXTENDS bound
## LR(1) items:
type_parameter -> identifier EXTENDS bound . [ GT CM ]
## Transitions:
## Reductions:
-- On GT CM
--   reduce production type_parameter -> identifier EXTENDS bound

State 63:
## Known stack suffix:
## type_parameters
## LR(1) items:
optl(type_parameters) -> type_parameters . [ LC IMPLEMENTS EXTENDS EOF ]
## Transitions:
## Reductions:
-- On LC IMPLEMENTS EXTENDS EOF
--   reduce production optl(type_parameters) -> type_parameters

State 64:
## Known stack suffix:
## INTERFACE identifier optl(type_parameters)
## LR(1) items:
interface_declaration -> INTERFACE identifier optl(type_parameters) . optl(extends_interfaces) interface_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On EXTENDS shift to state 65
-- On optl(extends_interfaces) shift to state 67
-- On extends_interfaces shift to state 369
## Reductions:
-- On LC
--   reduce production optl(extends_interfaces) ->

State 65:
## Known stack suffix:
## EXTENDS
## LR(1) items:
extends_interfaces -> EXTENDS . reference_type [ LC CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On reference_type shift to state 66
-- On primitive_type shift to state 30
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 66:
## Known stack suffix:
## EXTENDS reference_type
## LR(1) items:
extends_interfaces -> EXTENDS reference_type . [ LC CM ]
## Transitions:
## Reductions:
-- On LC CM
--   reduce production extends_interfaces -> EXTENDS reference_type

State 67:
## Known stack suffix:
## INTERFACE identifier optl(type_parameters) optl(extends_interfaces)
## LR(1) items:
interface_declaration -> INTERFACE identifier optl(type_parameters) optl(extends_interfaces) . interface_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 68
-- On interface_body shift to state 902
## Reductions:

State 68:
## Known stack suffix:
## LC
## LR(1) items:
interface_body -> LC . list(interface_member_declaration) RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 69
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 859
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On LT shift to state 20
-- On INTERFACE shift to state 17
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On ENUM shift to state 317
-- On DOTS shift to state 860
-- On DEFAULT shift to state 328
-- On CLASS shift to state 329
-- On AT shift to state 338
-- On ABSTRACT shift to state 342
-- On type_parameters shift to state 861
-- On type_ shift to state 872
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifiers shift to state 875
-- On modifier shift to state 391
-- On method_header shift to state 695
-- On method_declaration shift to state 890
-- On list(interface_member_declaration) shift to state 891
-- On interface_method_declaration shift to state 893
-- On interface_member_declaration shift to state 894
-- On interface_generic_method_decl shift to state 896
-- On interface_declaration shift to state 897
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On enum_declaration shift to state 898
-- On constant_declaration shift to state 899
-- On class_or_interface_type shift to state 49
-- On class_header shift to state 396
-- On class_declaration shift to state 900
-- On array_type shift to state 51
-- On annotation_type_declaration shift to state 901
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(interface_member_declaration) ->

State 69:
## Known stack suffix:
## VOID
## LR(1) items:
method_header -> VOID . method_declarator optl(throws) [ SM LC ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On method_declarator shift to state 70
-- On identifier shift to state 79
## Reductions:

State 70:
## Known stack suffix:
## VOID method_declarator
## LR(1) items:
method_declarator -> method_declarator . LB_RB [ THROWS SM LC LB_RB EOF ]
method_header -> VOID method_declarator . optl(throws) [ SM LC EOF ]
## Transitions:
-- On THROWS shift to state 71
-- On LB_RB shift to state 76
-- On throws shift to state 77
-- On optl(throws) shift to state 78
## Reductions:
-- On SM LC EOF
--   reduce production optl(throws) ->

State 71:
## Known stack suffix:
## THROWS
## LR(1) items:
throws -> THROWS . listc(name) [ SM LC EOF ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On name shift to state 72
-- On listc(name) shift to state 73
-- On identifier_ shift to state 38
-- On identifier shift to state 39
## Reductions:

State 72:
## Known stack suffix:
## name
## LR(1) items:
listc(name) -> name . [ SM LC EOF CM ]
name -> name . DOT identifier_ [ SM LC EOF DOT CM ]
name -> name . DOT LT_GENERIC listc(type_argument) GT identifier_ [ SM LC EOF DOT CM ]
## Transitions:
-- On DOT shift to state 33
## Reductions:
-- On SM LC EOF CM
--   reduce production listc(name) -> name

State 73:
## Known stack suffix:
## THROWS listc(name)
## LR(1) items:
listc(name) -> listc(name) . CM name [ SM LC EOF CM ]
throws -> THROWS listc(name) . [ SM LC EOF ]
## Transitions:
-- On CM shift to state 74
## Reductions:
-- On SM LC EOF
--   reduce production throws -> THROWS listc(name)

State 74:
## Known stack suffix:
## listc(name) CM
## LR(1) items:
listc(name) -> listc(name) CM . name [ SM LC EOF CM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On name shift to state 75
-- On identifier_ shift to state 38
-- On identifier shift to state 39
## Reductions:

State 75:
## Known stack suffix:
## listc(name) CM name
## LR(1) items:
listc(name) -> listc(name) CM name . [ SM LC EOF CM ]
name -> name . DOT identifier_ [ SM LC EOF DOT CM ]
name -> name . DOT LT_GENERIC listc(type_argument) GT identifier_ [ SM LC EOF DOT CM ]
## Transitions:
-- On DOT shift to state 33
## Reductions:
-- On SM LC EOF CM
--   reduce production listc(name) -> listc(name) CM name

State 76:
## Known stack suffix:
## method_declarator LB_RB
## LR(1) items:
method_declarator -> method_declarator LB_RB . [ THROWS SM LC LB_RB EOF ]
## Transitions:
## Reductions:
-- On THROWS SM LC LB_RB EOF
--   reduce production method_declarator -> method_declarator LB_RB

State 77:
## Known stack suffix:
## throws
## LR(1) items:
optl(throws) -> throws . [ SM LC EOF ]
## Transitions:
## Reductions:
-- On SM LC EOF
--   reduce production optl(throws) -> throws

State 78:
## Known stack suffix:
## VOID method_declarator optl(throws)
## LR(1) items:
method_header -> VOID method_declarator optl(throws) . [ SM LC EOF ]
## Transitions:
## Reductions:
-- On SM LC EOF
--   reduce production method_header -> VOID method_declarator optl(throws)

State 79:
## Known stack suffix:
## identifier
## LR(1) items:
method_declarator -> identifier . LP listc0(formal_parameter) RP [ THROWS SM LC LB_RB EOF ]
## Transitions:
-- On LP shift to state 80
## Reductions:

State 80:
## Known stack suffix:
## identifier LP
## LR(1) items:
method_declarator -> identifier LP . listc0(formal_parameter) RP [ THROWS SM LC LB_RB EOF ]
## Transitions:
-- On FINAL shift to state 81
-- On DOTS shift to state 82
-- On AT shift to state 83
-- On variable_modifier shift to state 408
-- On optl(listc(formal_parameter)) shift to state 410
-- On listc0(formal_parameter) shift to state 857
-- On listc(formal_parameter) shift to state 413
-- On list(variable_modifier) shift to state 415
-- On formal_parameter shift to state 422
-- On annotation shift to state 113
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER
--   reduce production list(variable_modifier) ->
-- On RP
--   reduce production optl(listc(formal_parameter)) ->

State 81:
## Known stack suffix:
## FINAL
## LR(1) items:
variable_modifier -> FINAL . [ VAR PRIMITIVE_TYPE IDENTIFIER FINAL AT ]
## Transitions:
## Reductions:
-- On VAR PRIMITIVE_TYPE IDENTIFIER FINAL AT
--   reduce production variable_modifier -> FINAL

State 82:
## Known stack suffix:
## DOTS
## LR(1) items:
formal_parameter -> DOTS . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production formal_parameter -> DOTS

State 83:
## Known stack suffix:
## AT
## LR(1) items:
annotation -> AT . qualified_ident [ VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE INTERFACE IDENTIFIER FINAL EOF ENUM DEFAULT CM CLASS AT ABSTRACT ]
annotation -> AT . qualified_ident LP annotation_element RP [ VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE INTERFACE IDENTIFIER FINAL EOF ENUM DEFAULT CM CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On qualified_ident shift to state 84
## Reductions:

State 84:
## Known stack suffix:
## AT qualified_ident
## LR(1) items:
annotation -> AT qualified_ident . [ VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL EOF ENUM DEFAULT CM CLASS AT ABSTRACT ]
annotation -> AT qualified_ident . LP annotation_element RP [ VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL EOF ENUM DEFAULT CM CLASS AT ABSTRACT ]
qualified_ident -> qualified_ident . DOT IDENTIFIER [ VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT LP INTERFACE IDENTIFIER FINAL EOF ENUM DOT DEFAULT CM CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 85
-- On DOT shift to state 14
## Reductions:
-- On VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL EOF ENUM DEFAULT CM CLASS AT ABSTRACT
--   reduce production annotation -> AT qualified_ident

State 85:
## Known stack suffix:
## AT qualified_ident LP
## LR(1) items:
annotation -> AT qualified_ident LP . annotation_element RP [ VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL EOF ENUM DEFAULT CM CLASS AT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On LC shift to state 348
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 844
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On AT shift to state 83
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc(element_value_pair) shift to state 845
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 852
-- On field_access shift to state 188
-- On expr1 shift to state 352
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On element_value_pair shift to state 853
-- On element_value_array_initializer shift to state 353
-- On element_value shift to state 854
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 355
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On annotation_element shift to state 855
-- On annotation shift to state 356
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production annotation_element ->

State 86:
## Known stack suffix:
## VOID
## LR(1) items:
class_literal -> VOID . DOT CLASS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On DOT shift to state 87
## Reductions:

State 87:
## Known stack suffix:
## VOID DOT
## LR(1) items:
class_literal -> VOID DOT . CLASS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On CLASS shift to state 88
## Reductions:

State 88:
## Known stack suffix:
## VOID DOT CLASS
## LR(1) items:
class_literal -> VOID DOT CLASS . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production class_literal -> VOID DOT CLASS

State 89:
## Known stack suffix:
## TString
## LR(1) items:
literal -> TString . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production literal -> TString

State 90:
## Known stack suffix:
## TRUE
## LR(1) items:
literal -> TRUE . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production literal -> TRUE

State 91:
## Known stack suffix:
## TInt
## LR(1) items:
literal -> TInt . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production literal -> TInt

State 92:
## Known stack suffix:
## THIS
## LR(1) items:
primary_no_new_array -> THIS . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> THIS

State 93:
## Known stack suffix:
## TFloat
## LR(1) items:
literal -> TFloat . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production literal -> TFloat

State 94:
## Known stack suffix:
## TChar
## LR(1) items:
literal -> TChar . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production literal -> TChar

State 95:
## Known stack suffix:
## SUPER
## LR(1) items:
field_access -> SUPER . DOT identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> SUPER . DOT identifier LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> SUPER . COLONCOLON identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On DOT shift to state 96
-- On COLONCOLON shift to state 661
## Reductions:

State 96:
## Known stack suffix:
## SUPER DOT
## LR(1) items:
field_access -> SUPER DOT . identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> SUPER DOT . identifier LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 97
## Reductions:

State 97:
## Known stack suffix:
## SUPER DOT identifier
## LR(1) items:
field_access -> SUPER DOT identifier . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> SUPER DOT identifier . LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 98
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production field_access -> SUPER DOT identifier

State 98:
## Known stack suffix:
## SUPER DOT identifier LP
## LR(1) items:
method_invocation -> SUPER DOT identifier LP . listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On optl(listc(argument)) shift to state 224
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc0(argument) shift to state 842
-- On listc(argument) shift to state 300
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 304
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) ->

State 99:
## Known stack suffix:
## PLUS
## LR(1) items:
unary_expression -> PLUS . unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 841
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 100:
## Known stack suffix:
## NULL
## LR(1) items:
literal -> NULL . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production literal -> NULL

State 101:
## Known stack suffix:
## NOT
## LR(1) items:
unary_expression_not_plus_minus -> NOT . unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 840
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 102:
## Known stack suffix:
## NEW
## LR(1) items:
array_creation_expression -> NEW . primitive_type nonempty_list(dim_expr) dims_opt [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
array_creation_expression -> NEW . name nonempty_list(dim_expr) dims_opt [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
array_creation_expression_with_initializer -> NEW . primitive_type dims array_initializer [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
array_creation_expression_with_initializer -> NEW . name dims array_initializer [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
class_instance_creation_expression -> NEW . name LP listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On primitive_type shift to state 103
-- On name shift to state 831
-- On identifier_ shift to state 38
-- On identifier shift to state 39
## Reductions:

State 103:
## Known stack suffix:
## NEW primitive_type
## LR(1) items:
array_creation_expression -> NEW primitive_type . nonempty_list(dim_expr) dims_opt [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
array_creation_expression_with_initializer -> NEW primitive_type . dims array_initializer [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 104
-- On LB shift to state 105
-- On nonempty_list(dim_expr) shift to state 823
-- On dims shift to state 827
-- On dim_expr shift to state 829
## Reductions:

State 104:
## Known stack suffix:
## LB_RB
## LR(1) items:
dims -> LB_RB . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LC LB_RB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LC LB_RB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production dims -> LB_RB

State 105:
## Known stack suffix:
## LB
## LR(1) items:
dim_expr -> LB . expression RB [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 821
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 106:
## Known stack suffix:
## MINUS
## LR(1) items:
unary_expression -> MINUS . unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 820
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 107:
## Known stack suffix:
## LP
## LR(1) items:
cast_expression -> LP . primitive_type RP unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
cast_expression -> LP . array_type RP unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
cast_expression -> LP . expression RP unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
primary_no_new_array -> LP . expression RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
typed_metavar -> LP . type_ IDENTIFIER RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On type_ shift to state 256
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On reference_type shift to state 119
-- On primitive_type shift to state 808
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 818
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 815
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 108:
## Known stack suffix:
## LP_LAMBDA
## LR(1) items:
lambda_parameters -> LP_LAMBDA . lambda_parameter_list RP [ ARROW ]
lambda_parameters -> LP_LAMBDA . RP [ ARROW ]
## Transitions:
-- On VAR shift to state 109
-- On RP shift to state 110
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 81
-- On AT shift to state 83
-- On variable_modifier shift to state 111
-- On variable_arity_parameter shift to state 114
-- On unann_type shift to state 115
-- On type_ shift to state 118
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On nonempty_list(variable_modifier) shift to state 121
-- On name shift to state 32
-- On listc(lambda_param) shift to state 129
-- On listc(identifier) shift to state 134
-- On lambda_parameter_type shift to state 131
-- On lambda_parameter_list shift to state 137
-- On lambda_param shift to state 139
-- On identifier_ shift to state 38
-- On identifier shift to state 140
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
-- On annotation shift to state 113
## Reductions:

State 109:
## Known stack suffix:
## VAR
## LR(1) items:
lambda_parameter_type -> VAR . [ IDENTIFIER ]
## Transitions:
## Reductions:
-- On IDENTIFIER
--   reduce production lambda_parameter_type -> VAR

State 110:
## Known stack suffix:
## LP_LAMBDA RP
## LR(1) items:
lambda_parameters -> LP_LAMBDA RP . [ ARROW ]
## Transitions:
## Reductions:
-- On ARROW
--   reduce production lambda_parameters -> LP_LAMBDA RP

State 111:
## Known stack suffix:
## variable_modifier
## LR(1) items:
nonempty_list(variable_modifier) -> variable_modifier . [ VAR PRIMITIVE_TYPE IDENTIFIER ]
nonempty_list(variable_modifier) -> variable_modifier . nonempty_list(variable_modifier) [ VAR PRIMITIVE_TYPE IDENTIFIER ]
## Transitions:
-- On FINAL shift to state 81
-- On AT shift to state 83
-- On variable_modifier shift to state 111
-- On nonempty_list(variable_modifier) shift to state 112
-- On annotation shift to state 113
## Reductions:
-- On VAR PRIMITIVE_TYPE IDENTIFIER
--   reduce production nonempty_list(variable_modifier) -> variable_modifier

State 112:
## Known stack suffix:
## variable_modifier nonempty_list(variable_modifier)
## LR(1) items:
nonempty_list(variable_modifier) -> variable_modifier nonempty_list(variable_modifier) . [ VAR PRIMITIVE_TYPE IDENTIFIER ]
## Transitions:
## Reductions:
-- On VAR PRIMITIVE_TYPE IDENTIFIER
--   reduce production nonempty_list(variable_modifier) -> variable_modifier nonempty_list(variable_modifier)

State 113:
## Known stack suffix:
## annotation
## LR(1) items:
variable_modifier -> annotation . [ VAR PRIMITIVE_TYPE IDENTIFIER FINAL AT ]
## Transitions:
## Reductions:
-- On VAR PRIMITIVE_TYPE IDENTIFIER FINAL AT
--   reduce production variable_modifier -> annotation

State 114:
## Known stack suffix:
## variable_arity_parameter
## LR(1) items:
lambda_param -> variable_arity_parameter . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production lambda_param -> variable_arity_parameter

State 115:
## Known stack suffix:
## unann_type
## LR(1) items:
lambda_parameter_type -> unann_type . [ IDENTIFIER ]
variable_arity_parameter -> unann_type . DOTS identifier [ RP CM ]
## Transitions:
-- On DOTS shift to state 116
## Reductions:
-- On IDENTIFIER
--   reduce production lambda_parameter_type -> unann_type

State 116:
## Known stack suffix:
## unann_type DOTS
## LR(1) items:
variable_arity_parameter -> unann_type DOTS . identifier [ RP CM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 117
## Reductions:

State 117:
## Known stack suffix:
## unann_type DOTS identifier
## LR(1) items:
variable_arity_parameter -> unann_type DOTS identifier . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production variable_arity_parameter -> unann_type DOTS identifier

State 118:
## Known stack suffix:
## type_
## LR(1) items:
unann_type -> type_ . [ IDENTIFIER DOTS ]
## Transitions:
## Reductions:
-- On IDENTIFIER DOTS
--   reduce production unann_type -> type_

State 119:
## Known stack suffix:
## reference_type
## LR(1) items:
type_ -> reference_type . [ OR LC IMPLEMENTS IDENTIFIER EOF DOTS ]
## Transitions:
## Reductions:
-- On OR LC IMPLEMENTS IDENTIFIER EOF DOTS
--   reduce production type_ -> reference_type

State 120:
## Known stack suffix:
## primitive_type
## LR(1) items:
array_type -> primitive_type . LB_RB [ OR LC LB_RB IMPLEMENTS IDENTIFIER EOF DOTS ]
type_ -> primitive_type . [ OR LC IMPLEMENTS IDENTIFIER EOF DOTS ]
## Transitions:
-- On LB_RB shift to state 31
## Reductions:
-- On OR LC IMPLEMENTS IDENTIFIER EOF DOTS
--   reduce production type_ -> primitive_type

State 121:
## Known stack suffix:
## nonempty_list(variable_modifier)
## LR(1) items:
lambda_param -> nonempty_list(variable_modifier) . lambda_parameter_type variable_declarator_id [ RP CM ]
variable_arity_parameter -> nonempty_list(variable_modifier) . unann_type DOTS identifier [ RP CM ]
## Transitions:
-- On VAR shift to state 109
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On unann_type shift to state 122
-- On type_ shift to state 118
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On lambda_parameter_type shift to state 125
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 122:
## Known stack suffix:
## nonempty_list(variable_modifier) unann_type
## LR(1) items:
lambda_parameter_type -> unann_type . [ IDENTIFIER ]
variable_arity_parameter -> nonempty_list(variable_modifier) unann_type . DOTS identifier [ RP CM ]
## Transitions:
-- On DOTS shift to state 123
## Reductions:
-- On IDENTIFIER
--   reduce production lambda_parameter_type -> unann_type

State 123:
## Known stack suffix:
## nonempty_list(variable_modifier) unann_type DOTS
## LR(1) items:
variable_arity_parameter -> nonempty_list(variable_modifier) unann_type DOTS . identifier [ RP CM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 124
## Reductions:

State 124:
## Known stack suffix:
## nonempty_list(variable_modifier) unann_type DOTS identifier
## LR(1) items:
variable_arity_parameter -> nonempty_list(variable_modifier) unann_type DOTS identifier . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production variable_arity_parameter -> nonempty_list(variable_modifier) unann_type DOTS identifier

State 125:
## Known stack suffix:
## nonempty_list(variable_modifier) lambda_parameter_type
## LR(1) items:
lambda_param -> nonempty_list(variable_modifier) lambda_parameter_type . variable_declarator_id [ RP CM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 126
-- On identifier shift to state 128
## Reductions:

State 126:
## Known stack suffix:
## nonempty_list(variable_modifier) lambda_parameter_type variable_declarator_id
## LR(1) items:
lambda_param -> nonempty_list(variable_modifier) lambda_parameter_type variable_declarator_id . [ RP CM ]
variable_declarator_id -> variable_declarator_id . LB_RB [ RP LB_RB CM ]
## Transitions:
-- On LB_RB shift to state 127
## Reductions:
-- On RP CM
--   reduce production lambda_param -> nonempty_list(variable_modifier) lambda_parameter_type variable_declarator_id

State 127:
## Known stack suffix:
## variable_declarator_id LB_RB
## LR(1) items:
variable_declarator_id -> variable_declarator_id LB_RB . [ SM RP LB_RB EQ COLON CM ]
## Transitions:
## Reductions:
-- On SM RP LB_RB EQ COLON CM
--   reduce production variable_declarator_id -> variable_declarator_id LB_RB

State 128:
## Known stack suffix:
## identifier
## LR(1) items:
variable_declarator_id -> identifier . [ SM RP LB_RB EQ COLON CM ]
## Transitions:
## Reductions:
-- On SM RP LB_RB EQ COLON CM
--   reduce production variable_declarator_id -> identifier

State 129:
## Known stack suffix:
## listc(lambda_param)
## LR(1) items:
lambda_parameter_list -> listc(lambda_param) . [ RP ]
listc(lambda_param) -> listc(lambda_param) . CM lambda_param [ RP CM ]
## Transitions:
-- On CM shift to state 130
## Reductions:
-- On RP
--   reduce production lambda_parameter_list -> listc(lambda_param)

State 130:
## Known stack suffix:
## listc(lambda_param) CM
## LR(1) items:
listc(lambda_param) -> listc(lambda_param) CM . lambda_param [ RP CM ]
## Transitions:
-- On VAR shift to state 109
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 81
-- On AT shift to state 83
-- On variable_modifier shift to state 111
-- On variable_arity_parameter shift to state 114
-- On unann_type shift to state 115
-- On type_ shift to state 118
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On nonempty_list(variable_modifier) shift to state 121
-- On name shift to state 32
-- On lambda_parameter_type shift to state 131
-- On lambda_param shift to state 133
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
-- On annotation shift to state 113
## Reductions:

State 131:
## Known stack suffix:
## lambda_parameter_type
## LR(1) items:
lambda_param -> lambda_parameter_type . variable_declarator_id [ RP CM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 132
-- On identifier shift to state 128
## Reductions:

State 132:
## Known stack suffix:
## lambda_parameter_type variable_declarator_id
## LR(1) items:
lambda_param -> lambda_parameter_type variable_declarator_id . [ RP CM ]
variable_declarator_id -> variable_declarator_id . LB_RB [ RP LB_RB CM ]
## Transitions:
-- On LB_RB shift to state 127
## Reductions:
-- On RP CM
--   reduce production lambda_param -> lambda_parameter_type variable_declarator_id

State 133:
## Known stack suffix:
## listc(lambda_param) CM lambda_param
## LR(1) items:
listc(lambda_param) -> listc(lambda_param) CM lambda_param . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production listc(lambda_param) -> listc(lambda_param) CM lambda_param

State 134:
## Known stack suffix:
## listc(identifier)
## LR(1) items:
lambda_parameter_list -> listc(identifier) . [ RP ]
listc(identifier) -> listc(identifier) . CM identifier [ RP CM ]
## Transitions:
-- On CM shift to state 135
## Reductions:
-- On RP
--   reduce production lambda_parameter_list -> listc(identifier)

State 135:
## Known stack suffix:
## listc(identifier) CM
## LR(1) items:
listc(identifier) -> listc(identifier) CM . identifier [ RP CM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 136
## Reductions:

State 136:
## Known stack suffix:
## listc(identifier) CM identifier
## LR(1) items:
listc(identifier) -> listc(identifier) CM identifier . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production listc(identifier) -> listc(identifier) CM identifier

State 137:
## Known stack suffix:
## LP_LAMBDA lambda_parameter_list
## LR(1) items:
lambda_parameters -> LP_LAMBDA lambda_parameter_list . RP [ ARROW ]
## Transitions:
-- On RP shift to state 138
## Reductions:

State 138:
## Known stack suffix:
## LP_LAMBDA lambda_parameter_list RP
## LR(1) items:
lambda_parameters -> LP_LAMBDA lambda_parameter_list RP . [ ARROW ]
## Transitions:
## Reductions:
-- On ARROW
--   reduce production lambda_parameters -> LP_LAMBDA lambda_parameter_list RP

State 139:
## Known stack suffix:
## lambda_param
## LR(1) items:
listc(lambda_param) -> lambda_param . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production listc(lambda_param) -> lambda_param

State 140:
## Known stack suffix:
## identifier
## LR(1) items:
identifier_ -> identifier . [ LB_RB IDENTIFIER DOTS DOT ]
identifier_ -> identifier . LT_GENERIC listc0(type_argument) GT [ LB_RB IDENTIFIER DOTS DOT ]
listc(identifier) -> identifier . [ RP CM ]
## Transitions:
-- On LT_GENERIC shift to state 40
## Reductions:
-- On LB_RB IDENTIFIER DOTS DOT
--   reduce production identifier_ -> identifier
-- On RP CM
--   reduce production listc(identifier) -> identifier

State 141:
## Known stack suffix:
## LP
## LR(1) items:
cast_expression -> LP . primitive_type RP unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
cast_expression -> LP . array_type RP unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
cast_expression -> LP . expression RP unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
cast_lambda_expression -> LP . expression RP lambda_expression [ SM RP RDots RC RB EOF COLON CM ]
primary_no_new_array -> LP . expression RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
typed_metavar -> LP . type_ IDENTIFIER RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On type_ shift to state 256
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On reference_type shift to state 119
-- On primitive_type shift to state 808
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 811
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 815
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 142:
## Known stack suffix:
## LDots
## LR(1) items:
assignment_expression -> LDots . expression RDots [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 806
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 143:
## Known stack suffix:
## INCR
## LR(1) items:
pre_increment_expression -> INCR . unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 805
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 144:
## Known stack suffix:
## FALSE
## LR(1) items:
literal -> FALSE . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production literal -> FALSE

State 145:
## Known stack suffix:
## DECR
## LR(1) items:
pre_decrement_expression -> DECR . unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 804
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 146:
## Known stack suffix:
## COMPL
## LR(1) items:
unary_expression_not_plus_minus -> COMPL . unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 148
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 147:
## Known stack suffix:
## unary_expression_not_plus_minus
## LR(1) items:
unary_expression -> unary_expression_not_plus_minus . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production unary_expression -> unary_expression_not_plus_minus

State 148:
## Known stack suffix:
## COMPL unary_expression
## LR(1) items:
unary_expression_not_plus_minus -> COMPL unary_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production unary_expression_not_plus_minus -> COMPL unary_expression

State 149:
## Known stack suffix:
## typed_metavar
## LR(1) items:
primary_no_new_array -> typed_metavar . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> typed_metavar

State 150:
## Known stack suffix:
## primitive_type
## LR(1) items:
array_type -> primitive_type . LB_RB [ LB_RB DOT COLONCOLON ]
class_literal -> primitive_type . DOT CLASS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 31
-- On DOT shift to state 151
## Reductions:

State 151:
## Known stack suffix:
## primitive_type DOT
## LR(1) items:
class_literal -> primitive_type DOT . CLASS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On CLASS shift to state 152
## Reductions:

State 152:
## Known stack suffix:
## primitive_type DOT CLASS
## LR(1) items:
class_literal -> primitive_type DOT CLASS . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production class_literal -> primitive_type DOT CLASS

State 153:
## Known stack suffix:
## primary_no_new_array
## LR(1) items:
array_access -> primary_no_new_array . LB expression RB [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
primary -> primary_no_new_array . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LB shift to state 154
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary -> primary_no_new_array

State 154:
## Known stack suffix:
## primary_no_new_array LB
## LR(1) items:
array_access -> primary_no_new_array LB . expression RB [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 802
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 155:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
identifier -> IDENTIFIER . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT_GENERIC LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
lambda_parameters -> IDENTIFIER . [ ARROW ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT_GENERIC LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production identifier -> IDENTIFIER
-- On ARROW
--   reduce production lambda_parameters -> IDENTIFIER

State 156:
## Known stack suffix:
## DOTS
## LR(1) items:
additive_expression -> DOTS . PLUS multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> DOTS . MINUS multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
assignment_expression -> DOTS . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
-- On PLUS shift to state 157
-- On MINUS shift to state 168
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production assignment_expression -> DOTS

State 157:
## Known stack suffix:
## DOTS PLUS
## LR(1) items:
additive_expression -> DOTS PLUS . multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 801
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 158:
## Known stack suffix:
## unary_expression
## LR(1) items:
multiplicative_expression -> unary_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production multiplicative_expression -> unary_expression

State 159:
## Known stack suffix:
## primary
## LR(1) items:
class_instance_creation_expression -> primary . DOT NEW identifier LP listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
field_access -> primary . DOT identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> primary . DOT identifier LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> primary . DOT DOTS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> primary . COLONCOLON identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
postfix_expression -> primary . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
-- On DOT shift to state 160
-- On COLONCOLON shift to state 284
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND
--   reduce production postfix_expression -> primary

State 160:
## Known stack suffix:
## primary DOT
## LR(1) items:
class_instance_creation_expression -> primary DOT . NEW identifier LP listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
field_access -> primary DOT . identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> primary DOT . identifier LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> primary DOT . DOTS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On NEW shift to state 161
-- On IDENTIFIER shift to state 18
-- On DOTS shift to state 670
-- On identifier shift to state 671
## Reductions:

State 161:
## Known stack suffix:
## primary DOT NEW
## LR(1) items:
class_instance_creation_expression -> primary DOT NEW . identifier LP listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 162
## Reductions:

State 162:
## Known stack suffix:
## primary DOT NEW identifier
## LR(1) items:
class_instance_creation_expression -> primary DOT NEW identifier . LP listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 163
## Reductions:

State 163:
## Known stack suffix:
## primary DOT NEW identifier LP
## LR(1) items:
class_instance_creation_expression -> primary DOT NEW identifier LP . listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On optl(listc(argument)) shift to state 224
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc0(argument) shift to state 798
-- On listc(argument) shift to state 300
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 304
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) ->

State 164:
## Known stack suffix:
## typed_metavar
## LR(1) items:
left_hand_side -> typed_metavar . [ OPERATOR_EQ EQ ]
primary_no_new_array -> typed_metavar . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On OPERATOR_EQ EQ
--   reduce production left_hand_side -> typed_metavar
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> typed_metavar

State 165:
## Known stack suffix:
## shift_expression
## LR(1) items:
relational_expression -> shift_expression . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . LS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . SRS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . URS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On URS shift to state 166
-- On SRS shift to state 181
-- On LS shift to state 213
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production relational_expression -> shift_expression

State 166:
## Known stack suffix:
## shift_expression URS
## LR(1) items:
shift_expression -> shift_expression URS . additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On additive_expression shift to state 797
## Reductions:

State 167:
## Known stack suffix:
## DOTS
## LR(1) items:
additive_expression -> DOTS . PLUS multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> DOTS . MINUS multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On PLUS shift to state 157
-- On MINUS shift to state 168
## Reductions:

State 168:
## Known stack suffix:
## DOTS MINUS
## LR(1) items:
additive_expression -> DOTS MINUS . multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 796
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 169:
## Known stack suffix:
## pre_increment_expression
## LR(1) items:
unary_expression -> pre_increment_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production unary_expression -> pre_increment_expression

State 170:
## Known stack suffix:
## pre_decrement_expression
## LR(1) items:
unary_expression -> pre_decrement_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production unary_expression -> pre_decrement_expression

State 171:
## Known stack suffix:
## postfix_expression
## LR(1) items:
post_decrement_expression -> postfix_expression . DECR [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND ]
post_increment_expression -> postfix_expression . INCR [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND ]
unary_expression_not_plus_minus -> postfix_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On INCR shift to state 172
-- On DECR shift to state 173
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production unary_expression_not_plus_minus -> postfix_expression

State 172:
## Known stack suffix:
## postfix_expression INCR
## LR(1) items:
post_increment_expression -> postfix_expression INCR . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND
--   reduce production post_increment_expression -> postfix_expression INCR

State 173:
## Known stack suffix:
## postfix_expression DECR
## LR(1) items:
post_decrement_expression -> postfix_expression DECR . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND
--   reduce production post_decrement_expression -> postfix_expression DECR

State 174:
## Known stack suffix:
## post_increment_expression
## LR(1) items:
postfix_expression -> post_increment_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND
--   reduce production postfix_expression -> post_increment_expression

State 175:
## Known stack suffix:
## post_decrement_expression
## LR(1) items:
postfix_expression -> post_decrement_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND
--   reduce production postfix_expression -> post_decrement_expression

State 176:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LB expression RB [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
class_instance_creation_expression -> name . DOT NEW identifier LP listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
class_literal -> name . DOT CLASS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
class_or_interface_type -> name . [ LB_RB ]
field_access -> name . DOT SUPER DOT identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> name . LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> name . DOT SUPER DOT identifier LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> name . DOT DOTS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> name . COLONCOLON identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> name . COLONCOLON NEW [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> name . DOT SUPER COLONCOLON identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
name -> name . DOT identifier_ [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
name -> name . DOT LT_GENERIC listc(type_argument) GT identifier_ [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
postfix_expression -> name . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND ]
primary_no_new_array -> name . DOT THIS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 177
-- On LB shift to state 226
-- On DOT shift to state 292
-- On COLONCOLON shift to state 684
## Reductions:
-- On LB_RB
--   reduce production class_or_interface_type -> name
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND
--   reduce production postfix_expression -> name

State 177:
## Known stack suffix:
## name LP
## LR(1) items:
method_invocation -> name LP . listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On optl(listc(argument)) shift to state 224
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc0(argument) shift to state 794
-- On listc(argument) shift to state 300
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 304
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) ->

State 178:
## Known stack suffix:
## relational_expression
## LR(1) items:
equality_expression -> relational_expression . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . LT shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . GT shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . LE shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . GE shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . INSTANCEOF reference_type [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On LT shift to state 179
-- On LE shift to state 216
-- On INSTANCEOF shift to state 218
-- On GT shift to state 220
-- On GE shift to state 222
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production equality_expression -> relational_expression

State 179:
## Known stack suffix:
## relational_expression LT
## LR(1) items:
relational_expression -> relational_expression LT . shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 180
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On additive_expression shift to state 215
## Reductions:

State 180:
## Known stack suffix:
## relational_expression LT shift_expression
## LR(1) items:
relational_expression -> relational_expression LT shift_expression . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . LS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . SRS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . URS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On URS shift to state 166
-- On SRS shift to state 181
-- On LS shift to state 213
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production relational_expression -> relational_expression LT shift_expression

State 181:
## Known stack suffix:
## shift_expression SRS
## LR(1) items:
shift_expression -> shift_expression SRS . additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On additive_expression shift to state 206
## Reductions:

State 182:
## Known stack suffix:
## multiplicative_expression
## LR(1) items:
additive_expression -> multiplicative_expression . [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . TIMES unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . DIV unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . MOD unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On TIMES shift to state 183
-- On MOD shift to state 202
-- On DIV shift to state 204
## Reductions:
-- On XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production additive_expression -> multiplicative_expression

State 183:
## Known stack suffix:
## multiplicative_expression TIMES
## LR(1) items:
multiplicative_expression -> multiplicative_expression TIMES . unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 184
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 184:
## Known stack suffix:
## multiplicative_expression TIMES unary_expression
## LR(1) items:
multiplicative_expression -> multiplicative_expression TIMES unary_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production multiplicative_expression -> multiplicative_expression TIMES unary_expression

State 185:
## Known stack suffix:
## method_reference
## LR(1) items:
primary_no_new_array -> method_reference . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> method_reference

State 186:
## Known stack suffix:
## method_invocation
## LR(1) items:
primary_no_new_array -> method_invocation . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> method_invocation

State 187:
## Known stack suffix:
## literal
## LR(1) items:
primary_no_new_array -> literal . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> literal

State 188:
## Known stack suffix:
## field_access
## LR(1) items:
primary_no_new_array -> field_access . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> field_access

State 189:
## Known stack suffix:
## class_or_interface_type
## LR(1) items:
array_type -> class_or_interface_type . LB_RB [ LB_RB DOT COLONCOLON ]
## Transitions:
-- On LB_RB shift to state 50
## Reductions:

State 190:
## Known stack suffix:
## class_literal
## LR(1) items:
primary_no_new_array -> class_literal . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> class_literal

State 191:
## Known stack suffix:
## class_instance_creation_expression
## LR(1) items:
primary_no_new_array -> class_instance_creation_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> class_instance_creation_expression

State 192:
## Known stack suffix:
## cast_expression
## LR(1) items:
unary_expression_not_plus_minus -> cast_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production unary_expression_not_plus_minus -> cast_expression

State 193:
## Known stack suffix:
## array_type
## LR(1) items:
array_type -> array_type . LB_RB [ LB_RB DOT COLONCOLON ]
class_literal -> array_type . DOT CLASS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> array_type . COLONCOLON identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> array_type . COLONCOLON NEW [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 52
-- On DOT shift to state 194
-- On COLONCOLON shift to state 196
## Reductions:

State 194:
## Known stack suffix:
## array_type DOT
## LR(1) items:
class_literal -> array_type DOT . CLASS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On CLASS shift to state 195
## Reductions:

State 195:
## Known stack suffix:
## array_type DOT CLASS
## LR(1) items:
class_literal -> array_type DOT CLASS . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production class_literal -> array_type DOT CLASS

State 196:
## Known stack suffix:
## array_type COLONCOLON
## LR(1) items:
method_reference -> array_type COLONCOLON . identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> array_type COLONCOLON . NEW [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On NEW shift to state 197
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 198
## Reductions:

State 197:
## Known stack suffix:
## array_type COLONCOLON NEW
## LR(1) items:
method_reference -> array_type COLONCOLON NEW . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_reference -> array_type COLONCOLON NEW

State 198:
## Known stack suffix:
## array_type COLONCOLON identifier
## LR(1) items:
method_reference -> array_type COLONCOLON identifier . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_reference -> array_type COLONCOLON identifier

State 199:
## Known stack suffix:
## array_creation_expression_with_initializer
## LR(1) items:
primary_no_new_array -> array_creation_expression_with_initializer . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> array_creation_expression_with_initializer

State 200:
## Known stack suffix:
## array_creation_expression
## LR(1) items:
primary -> array_creation_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary -> array_creation_expression

State 201:
## Known stack suffix:
## array_access
## LR(1) items:
primary_no_new_array -> array_access . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> array_access

State 202:
## Known stack suffix:
## multiplicative_expression MOD
## LR(1) items:
multiplicative_expression -> multiplicative_expression MOD . unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 203
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 203:
## Known stack suffix:
## multiplicative_expression MOD unary_expression
## LR(1) items:
multiplicative_expression -> multiplicative_expression MOD unary_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production multiplicative_expression -> multiplicative_expression MOD unary_expression

State 204:
## Known stack suffix:
## multiplicative_expression DIV
## LR(1) items:
multiplicative_expression -> multiplicative_expression DIV . unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 205
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 205:
## Known stack suffix:
## multiplicative_expression DIV unary_expression
## LR(1) items:
multiplicative_expression -> multiplicative_expression DIV unary_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production multiplicative_expression -> multiplicative_expression DIV unary_expression

State 206:
## Known stack suffix:
## shift_expression SRS additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . PLUS DOTS [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . MINUS DOTS [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression SRS additive_expression . [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On PLUS shift to state 207
-- On MINUS shift to state 210
## Reductions:
-- On XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production shift_expression -> shift_expression SRS additive_expression

State 207:
## Known stack suffix:
## additive_expression PLUS
## LR(1) items:
additive_expression -> additive_expression PLUS . multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression PLUS . DOTS [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 208
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 209
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 208:
## Known stack suffix:
## additive_expression PLUS DOTS
## LR(1) items:
additive_expression -> additive_expression PLUS DOTS . [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production additive_expression -> additive_expression PLUS DOTS

State 209:
## Known stack suffix:
## additive_expression PLUS multiplicative_expression
## LR(1) items:
additive_expression -> additive_expression PLUS multiplicative_expression . [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . TIMES unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . DIV unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . MOD unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On TIMES shift to state 183
-- On MOD shift to state 202
-- On DIV shift to state 204
## Reductions:
-- On XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production additive_expression -> additive_expression PLUS multiplicative_expression

State 210:
## Known stack suffix:
## additive_expression MINUS
## LR(1) items:
additive_expression -> additive_expression MINUS . multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression MINUS . DOTS [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 211
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 212
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 211:
## Known stack suffix:
## additive_expression MINUS DOTS
## LR(1) items:
additive_expression -> additive_expression MINUS DOTS . [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production additive_expression -> additive_expression MINUS DOTS

State 212:
## Known stack suffix:
## additive_expression MINUS multiplicative_expression
## LR(1) items:
additive_expression -> additive_expression MINUS multiplicative_expression . [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . TIMES unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . DIV unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . MOD unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On TIMES shift to state 183
-- On MOD shift to state 202
-- On DIV shift to state 204
## Reductions:
-- On XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production additive_expression -> additive_expression MINUS multiplicative_expression

State 213:
## Known stack suffix:
## shift_expression LS
## LR(1) items:
shift_expression -> shift_expression LS . additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On additive_expression shift to state 214
## Reductions:

State 214:
## Known stack suffix:
## shift_expression LS additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . PLUS DOTS [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . MINUS DOTS [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression LS additive_expression . [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On PLUS shift to state 207
-- On MINUS shift to state 210
## Reductions:
-- On XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production shift_expression -> shift_expression LS additive_expression

State 215:
## Known stack suffix:
## additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . PLUS DOTS [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . MINUS DOTS [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> additive_expression . [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On PLUS shift to state 207
-- On MINUS shift to state 210
## Reductions:
-- On XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production shift_expression -> additive_expression

State 216:
## Known stack suffix:
## relational_expression LE
## LR(1) items:
relational_expression -> relational_expression LE . shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 217
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On additive_expression shift to state 215
## Reductions:

State 217:
## Known stack suffix:
## relational_expression LE shift_expression
## LR(1) items:
relational_expression -> relational_expression LE shift_expression . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . LS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . SRS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . URS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On URS shift to state 166
-- On SRS shift to state 181
-- On LS shift to state 213
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production relational_expression -> relational_expression LE shift_expression

State 218:
## Known stack suffix:
## relational_expression INSTANCEOF
## LR(1) items:
relational_expression -> relational_expression INSTANCEOF . reference_type [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On reference_type shift to state 219
-- On primitive_type shift to state 30
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 219:
## Known stack suffix:
## relational_expression INSTANCEOF reference_type
## LR(1) items:
relational_expression -> relational_expression INSTANCEOF reference_type . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production relational_expression -> relational_expression INSTANCEOF reference_type

State 220:
## Known stack suffix:
## relational_expression GT
## LR(1) items:
relational_expression -> relational_expression GT . shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 221
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On additive_expression shift to state 215
## Reductions:

State 221:
## Known stack suffix:
## relational_expression GT shift_expression
## LR(1) items:
relational_expression -> relational_expression GT shift_expression . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . LS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . SRS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . URS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On URS shift to state 166
-- On SRS shift to state 181
-- On LS shift to state 213
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production relational_expression -> relational_expression GT shift_expression

State 222:
## Known stack suffix:
## relational_expression GE
## LR(1) items:
relational_expression -> relational_expression GE . shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 223
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On additive_expression shift to state 215
## Reductions:

State 223:
## Known stack suffix:
## relational_expression GE shift_expression
## LR(1) items:
relational_expression -> relational_expression GE shift_expression . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . LS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . SRS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression . URS additive_expression [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On URS shift to state 166
-- On SRS shift to state 181
-- On LS shift to state 213
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production relational_expression -> relational_expression GE shift_expression

State 224:
## Known stack suffix:
## optl(listc(argument))
## LR(1) items:
listc0(argument) -> optl(listc(argument)) . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production listc0(argument) -> optl(listc(argument))

State 225:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LB expression RB [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
class_instance_creation_expression -> name . DOT NEW identifier LP listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
class_literal -> name . DOT CLASS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
class_or_interface_type -> name . [ LB_RB IDENTIFIER ]
field_access -> name . DOT SUPER DOT identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
left_hand_side -> name . [ OPERATOR_EQ EQ ]
method_invocation -> name . LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> name . DOT SUPER DOT identifier LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> name . DOT DOTS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> name . COLONCOLON identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> name . COLONCOLON NEW [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> name . DOT SUPER COLONCOLON identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
name -> name . DOT identifier_ [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
name -> name . DOT LT_GENERIC listc(type_argument) GT identifier_ [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
postfix_expression -> name . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND ]
primary_no_new_array -> name . DOT THIS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 177
-- On LB shift to state 226
-- On DOT shift to state 292
-- On COLONCOLON shift to state 684
## Reductions:
-- On LB_RB IDENTIFIER
--   reduce production class_or_interface_type -> name
-- On OPERATOR_EQ EQ
--   reduce production left_hand_side -> name
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND
--   reduce production postfix_expression -> name

State 226:
## Known stack suffix:
## name LB
## LR(1) items:
array_access -> name LB . expression RB [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 792
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 227:
## Known stack suffix:
## left_hand_side
## LR(1) items:
assignment -> left_hand_side . assignment_operator expression [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
-- On OPERATOR_EQ shift to state 228
-- On EQ shift to state 229
-- On assignment_operator shift to state 230
## Reductions:

State 228:
## Known stack suffix:
## OPERATOR_EQ
## LR(1) items:
assignment_operator -> OPERATOR_EQ . [ VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL ]
## Transitions:
## Reductions:
-- On VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL
--   reduce production assignment_operator -> OPERATOR_EQ

State 229:
## Known stack suffix:
## EQ
## LR(1) items:
assignment_operator -> EQ . [ VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL ]
## Transitions:
## Reductions:
-- On VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL
--   reduce production assignment_operator -> EQ

State 230:
## Known stack suffix:
## left_hand_side assignment_operator
## LR(1) items:
assignment -> left_hand_side assignment_operator . expression [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 791
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 231:
## Known stack suffix:
## lambda_parameters
## LR(1) items:
lambda_expression -> lambda_parameters . ARROW lambda_body [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
-- On ARROW shift to state 232
## Reductions:

State 232:
## Known stack suffix:
## lambda_parameters ARROW
## LR(1) items:
lambda_expression -> lambda_parameters ARROW . lambda_body [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On lambda_body shift to state 788
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 789
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On block shift to state 790
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 233:
## Known stack suffix:
## LC
## LR(1) items:
block -> LC . list(block_statement) RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RP RETURN RDots RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE COLON CM CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 234
-- On VOLATILE shift to state 1
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TRANSIENT shift to state 2
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 493
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On NATIVE shift to state 16
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FINAL shift to state 316
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DEFAULT shift to state 328
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On CLASS shift to state 329
-- On BREAK shift to state 585
-- On AT shift to state 83
-- On ASSERT shift to state 588
-- On ABSTRACT shift to state 342
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On type_ shift to state 641
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 642
-- On return_statement shift to state 603
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On modifiers shift to state 644
-- On modifier shift to state 391
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On local_variable_declaration_statement shift to state 646
-- On local_variable_declaration shift to state 647
-- On literal shift to state 187
-- On list(block_statement) shift to state 786
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On class_header shift to state 396
-- On class_declaration shift to state 649
-- On break_statement shift to state 615
-- On block_statement shift to state 692
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(block_statement) ->

State 234:
## Known stack suffix:
## WHILE
## LR(1) items:
while_statement -> WHILE . LP expression RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 235
## Reductions:

State 235:
## Known stack suffix:
## WHILE LP
## LR(1) items:
while_statement -> WHILE LP . expression RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 251
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 236:
## Known stack suffix:
## lambda_expression
## LR(1) items:
expression -> lambda_expression . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production expression -> lambda_expression

State 237:
## Known stack suffix:
## inclusive_or_expression
## LR(1) items:
conditional_and_expression -> inclusive_or_expression . [ SM RP RDots RC RB OR_OR EOF COND COLON CM AND_AND ]
inclusive_or_expression -> inclusive_or_expression . OR exclusive_or_expression [ SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND ]
## Transitions:
-- On OR shift to state 238
## Reductions:
-- On SM RP RDots RC RB OR_OR EOF COND COLON CM AND_AND
--   reduce production conditional_and_expression -> inclusive_or_expression

State 238:
## Known stack suffix:
## inclusive_or_expression OR
## LR(1) items:
inclusive_or_expression -> inclusive_or_expression OR . exclusive_or_expression [ SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On exclusive_or_expression shift to state 239
-- On equality_expression shift to state 241
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 239:
## Known stack suffix:
## inclusive_or_expression OR exclusive_or_expression
## LR(1) items:
exclusive_or_expression -> exclusive_or_expression . XOR and_expression [ XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND ]
inclusive_or_expression -> inclusive_or_expression OR exclusive_or_expression . [ SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND ]
## Transitions:
-- On XOR shift to state 240
## Reductions:
-- On SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND
--   reduce production inclusive_or_expression -> inclusive_or_expression OR exclusive_or_expression

State 240:
## Known stack suffix:
## exclusive_or_expression XOR
## LR(1) items:
exclusive_or_expression -> exclusive_or_expression XOR . and_expression [ XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On equality_expression shift to state 241
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On and_expression shift to state 246
-- On additive_expression shift to state 215
## Reductions:

State 241:
## Known stack suffix:
## equality_expression
## LR(1) items:
and_expression -> equality_expression . [ XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND AND ]
equality_expression -> equality_expression . EQ_EQ relational_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND ]
equality_expression -> equality_expression . NOT_EQ relational_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On NOT_EQ shift to state 242
-- On EQ_EQ shift to state 244
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND AND
--   reduce production and_expression -> equality_expression

State 242:
## Known stack suffix:
## equality_expression NOT_EQ
## LR(1) items:
equality_expression -> equality_expression NOT_EQ . relational_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 243
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On additive_expression shift to state 215
## Reductions:

State 243:
## Known stack suffix:
## equality_expression NOT_EQ relational_expression
## LR(1) items:
equality_expression -> equality_expression NOT_EQ relational_expression . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . LT shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . GT shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . LE shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . GE shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . INSTANCEOF reference_type [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On LT shift to state 179
-- On LE shift to state 216
-- On INSTANCEOF shift to state 218
-- On GT shift to state 220
-- On GE shift to state 222
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production equality_expression -> equality_expression NOT_EQ relational_expression

State 244:
## Known stack suffix:
## equality_expression EQ_EQ
## LR(1) items:
equality_expression -> equality_expression EQ_EQ . relational_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 245
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On additive_expression shift to state 215
## Reductions:

State 245:
## Known stack suffix:
## equality_expression EQ_EQ relational_expression
## LR(1) items:
equality_expression -> equality_expression EQ_EQ relational_expression . [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . LT shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . GT shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . LE shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . GE shift_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
relational_expression -> relational_expression . INSTANCEOF reference_type [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On LT shift to state 179
-- On LE shift to state 216
-- On INSTANCEOF shift to state 218
-- On GT shift to state 220
-- On GE shift to state 222
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production equality_expression -> equality_expression EQ_EQ relational_expression

State 246:
## Known stack suffix:
## exclusive_or_expression XOR and_expression
## LR(1) items:
and_expression -> and_expression . AND equality_expression [ XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND AND ]
exclusive_or_expression -> exclusive_or_expression XOR and_expression . [ XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND ]
## Transitions:
-- On AND shift to state 247
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND
--   reduce production exclusive_or_expression -> exclusive_or_expression XOR and_expression

State 247:
## Known stack suffix:
## and_expression AND
## LR(1) items:
and_expression -> and_expression AND . equality_expression [ XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On equality_expression shift to state 248
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On additive_expression shift to state 215
## Reductions:

State 248:
## Known stack suffix:
## and_expression AND equality_expression
## LR(1) items:
and_expression -> and_expression AND equality_expression . [ XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND AND ]
equality_expression -> equality_expression . EQ_EQ relational_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND ]
equality_expression -> equality_expression . NOT_EQ relational_expression [ XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On NOT_EQ shift to state 242
-- On EQ_EQ shift to state 244
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND AND
--   reduce production and_expression -> and_expression AND equality_expression

State 249:
## Known stack suffix:
## and_expression
## LR(1) items:
and_expression -> and_expression . AND equality_expression [ XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND AND ]
exclusive_or_expression -> and_expression . [ XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND ]
## Transitions:
-- On AND shift to state 247
## Reductions:
-- On XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND
--   reduce production exclusive_or_expression -> and_expression

State 250:
## Known stack suffix:
## field_access
## LR(1) items:
left_hand_side -> field_access . [ OPERATOR_EQ EQ ]
primary_no_new_array -> field_access . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On OPERATOR_EQ EQ
--   reduce production left_hand_side -> field_access
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> field_access

State 251:
## Known stack suffix:
## WHILE LP expression
## LR(1) items:
while_statement -> WHILE LP expression . RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 252
## Reductions:

State 252:
## Known stack suffix:
## WHILE LP expression RP
## LR(1) items:
while_statement -> WHILE LP expression RP . statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 234
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 530
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On BREAK shift to state 585
-- On ASSERT shift to state 588
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 638
-- On return_statement shift to state 603
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:

State 253:
## Known stack suffix:
## TRY
## LR(1) items:
try_statement -> TRY . block nonempty_list(catch_clause) [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
try_statement -> TRY . block list(catch_clause) finally [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
try_statement -> TRY . resource_specification block list(catch_clause) option(finally) [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 254
-- On LC shift to state 233
-- On resource_specification shift to state 756
-- On block shift to state 780
## Reductions:

State 254:
## Known stack suffix:
## LP
## LR(1) items:
resource_specification -> LP . list_sep(resource,SM) option(SM) RP [ LC ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 81
-- On FALSE shift to state 144
-- On AT shift to state 83
-- On variable_modifier shift to state 111
-- On variable_access shift to state 280
-- On unann_type shift to state 281
-- On typed_metavar shift to state 149
-- On type_ shift to state 118
-- On resource shift to state 282
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 283
-- On nonempty_list(variable_modifier) shift to state 286
-- On name shift to state 291
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On local_variable_type shift to state 746
-- On literal shift to state 187
-- On list_sep(resource,SM) shift to state 750
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 753
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On annotation shift to state 113
## Reductions:

State 255:
## Known stack suffix:
## LP
## LR(1) items:
primary_no_new_array -> LP . expression RP [ LB INCR DOT DECR COLONCOLON ]
typed_metavar -> LP . type_ IDENTIFIER RP [ SM RP OPERATOR_EQ LB INCR EQ DOT DECR COLONCOLON CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On type_ shift to state 256
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 260
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 256:
## Known stack suffix:
## LP type_
## LR(1) items:
typed_metavar -> LP type_ . IDENTIFIER RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 257
## Reductions:

State 257:
## Known stack suffix:
## LP type_ IDENTIFIER
## LR(1) items:
typed_metavar -> LP type_ IDENTIFIER . RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 258
## Reductions:

State 258:
## Known stack suffix:
## LP type_ IDENTIFIER RP
## LR(1) items:
typed_metavar -> LP type_ IDENTIFIER RP . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production typed_metavar -> LP type_ IDENTIFIER RP

State 259:
## Known stack suffix:
## primitive_type
## LR(1) items:
array_type -> primitive_type . LB_RB [ LB_RB IDENTIFIER DOT COLONCOLON ]
class_literal -> primitive_type . DOT CLASS [ XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND ]
type_ -> primitive_type . [ IDENTIFIER ]
## Transitions:
-- On LB_RB shift to state 31
-- On DOT shift to state 151
## Reductions:
-- On IDENTIFIER
--   reduce production type_ -> primitive_type

State 260:
## Known stack suffix:
## LP expression
## LR(1) items:
primary_no_new_array -> LP expression . RP [ LB INCR DOT DECR COLONCOLON ]
## Transitions:
-- On RP shift to state 261
## Reductions:

State 261:
## Known stack suffix:
## LP expression RP
## LR(1) items:
primary_no_new_array -> LP expression RP . [ LB INCR DOT DECR COLONCOLON ]
## Transitions:
## Reductions:
-- On LB INCR DOT DECR COLONCOLON
--   reduce production primary_no_new_array -> LP expression RP

State 262:
## Known stack suffix:
## exclusive_or_expression
## LR(1) items:
exclusive_or_expression -> exclusive_or_expression . XOR and_expression [ XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND ]
inclusive_or_expression -> exclusive_or_expression . [ SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND ]
## Transitions:
-- On XOR shift to state 240
## Reductions:
-- On SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND
--   reduce production inclusive_or_expression -> exclusive_or_expression

State 263:
## Known stack suffix:
## conditional_or_expression
## LR(1) items:
conditional_expression -> conditional_or_expression . [ SM RP RDots RC RB EOF COLON CM ]
conditional_expression -> conditional_or_expression . COND expression COLON conditional_expression [ SM RP RDots RC RB EOF COLON CM ]
conditional_expression -> conditional_or_expression . COND expression COLON lambda_expression [ SM RP RDots RC RB EOF COLON CM ]
conditional_or_expression -> conditional_or_expression . OR_OR conditional_and_expression [ SM RP RDots RC RB OR_OR EOF COND COLON CM ]
## Transitions:
-- On OR_OR shift to state 264
-- On COND shift to state 268
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production conditional_expression -> conditional_or_expression

State 264:
## Known stack suffix:
## conditional_or_expression OR_OR
## LR(1) items:
conditional_or_expression -> conditional_or_expression OR_OR . conditional_and_expression [ SM RP RDots RC RB OR_OR EOF COND COLON CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_and_expression shift to state 265
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 265:
## Known stack suffix:
## conditional_or_expression OR_OR conditional_and_expression
## LR(1) items:
conditional_and_expression -> conditional_and_expression . AND_AND inclusive_or_expression [ SM RP RDots RC RB OR_OR EOF COND COLON CM AND_AND ]
conditional_or_expression -> conditional_or_expression OR_OR conditional_and_expression . [ SM RP RDots RC RB OR_OR EOF COND COLON CM ]
## Transitions:
-- On AND_AND shift to state 266
## Reductions:
-- On SM RP RDots RC RB OR_OR EOF COND COLON CM
--   reduce production conditional_or_expression -> conditional_or_expression OR_OR conditional_and_expression

State 266:
## Known stack suffix:
## conditional_and_expression AND_AND
## LR(1) items:
conditional_and_expression -> conditional_and_expression AND_AND . inclusive_or_expression [ SM RP RDots RC RB OR_OR EOF COND COLON CM AND_AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On inclusive_or_expression shift to state 267
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 267:
## Known stack suffix:
## conditional_and_expression AND_AND inclusive_or_expression
## LR(1) items:
conditional_and_expression -> conditional_and_expression AND_AND inclusive_or_expression . [ SM RP RDots RC RB OR_OR EOF COND COLON CM AND_AND ]
inclusive_or_expression -> inclusive_or_expression . OR exclusive_or_expression [ SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND ]
## Transitions:
-- On OR shift to state 238
## Reductions:
-- On SM RP RDots RC RB OR_OR EOF COND COLON CM AND_AND
--   reduce production conditional_and_expression -> conditional_and_expression AND_AND inclusive_or_expression

State 268:
## Known stack suffix:
## conditional_or_expression COND
## LR(1) items:
conditional_expression -> conditional_or_expression COND . expression COLON conditional_expression [ SM RP RDots RC RB EOF COLON CM ]
conditional_expression -> conditional_or_expression COND . expression COLON lambda_expression [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 269
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 269:
## Known stack suffix:
## conditional_or_expression COND expression
## LR(1) items:
conditional_expression -> conditional_or_expression COND expression . COLON conditional_expression [ SM RP RDots RC RB EOF COLON CM ]
conditional_expression -> conditional_or_expression COND expression . COLON lambda_expression [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
-- On COLON shift to state 270
## Reductions:

State 270:
## Known stack suffix:
## conditional_or_expression COND expression COLON
## LR(1) items:
conditional_expression -> conditional_or_expression COND expression COLON . conditional_expression [ SM RP RDots RC RB EOF COLON CM ]
conditional_expression -> conditional_or_expression COND expression COLON . lambda_expression [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 271
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 272
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 271:
## Known stack suffix:
## conditional_or_expression COND expression COLON lambda_expression
## LR(1) items:
conditional_expression -> conditional_or_expression COND expression COLON lambda_expression . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production conditional_expression -> conditional_or_expression COND expression COLON lambda_expression

State 272:
## Known stack suffix:
## conditional_or_expression COND expression COLON conditional_expression
## LR(1) items:
conditional_expression -> conditional_or_expression COND expression COLON conditional_expression . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production conditional_expression -> conditional_or_expression COND expression COLON conditional_expression

State 273:
## Known stack suffix:
## conditional_and_expression
## LR(1) items:
conditional_and_expression -> conditional_and_expression . AND_AND inclusive_or_expression [ SM RP RDots RC RB OR_OR EOF COND COLON CM AND_AND ]
conditional_or_expression -> conditional_and_expression . [ SM RP RDots RC RB OR_OR EOF COND COLON CM ]
## Transitions:
-- On AND_AND shift to state 266
## Reductions:
-- On SM RP RDots RC RB OR_OR EOF COND COLON CM
--   reduce production conditional_or_expression -> conditional_and_expression

State 274:
## Known stack suffix:
## conditional_expression
## LR(1) items:
assignment_expression -> conditional_expression . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production assignment_expression -> conditional_expression

State 275:
## Known stack suffix:
## cast_lambda_expression
## LR(1) items:
expression -> cast_lambda_expression . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production expression -> cast_lambda_expression

State 276:
## Known stack suffix:
## assignment_expression
## LR(1) items:
expression -> assignment_expression . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production expression -> assignment_expression

State 277:
## Known stack suffix:
## assignment
## LR(1) items:
assignment_expression -> assignment . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production assignment_expression -> assignment

State 278:
## Known stack suffix:
## array_access
## LR(1) items:
left_hand_side -> array_access . [ OPERATOR_EQ EQ ]
primary_no_new_array -> array_access . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On OPERATOR_EQ EQ
--   reduce production left_hand_side -> array_access
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> array_access

State 279:
## Known stack suffix:
## array_type
## LR(1) items:
array_type -> array_type . LB_RB [ LB_RB IDENTIFIER DOT COLONCOLON ]
class_literal -> array_type . DOT CLASS [ XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND ]
method_reference -> array_type . COLONCOLON identifier [ XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND ]
method_reference -> array_type . COLONCOLON NEW [ XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND ]
reference_type -> array_type . [ IDENTIFIER ]
## Transitions:
-- On LB_RB shift to state 52
-- On DOT shift to state 194
-- On COLONCOLON shift to state 196
## Reductions:
-- On IDENTIFIER
--   reduce production reference_type -> array_type

State 280:
## Known stack suffix:
## variable_access
## LR(1) items:
resource -> variable_access . [ SM RP ]
## Transitions:
## Reductions:
-- On SM RP
--   reduce production resource -> variable_access

State 281:
## Known stack suffix:
## unann_type
## LR(1) items:
local_variable_type -> unann_type . [ IDENTIFIER ]
## Transitions:
## Reductions:
-- On IDENTIFIER
--   reduce production local_variable_type -> unann_type

State 282:
## Known stack suffix:
## resource
## LR(1) items:
list_sep(resource,SM) -> resource . [ SM RP ]
## Transitions:
## Reductions:
-- On SM RP
--   reduce production list_sep(resource,SM) -> resource

State 283:
## Known stack suffix:
## primary
## LR(1) items:
class_instance_creation_expression -> primary . DOT NEW identifier LP listc0(argument) RP option(class_body) [ LB DOT COLONCOLON ]
field_access -> primary . DOT identifier [ SM RP LB DOT COLONCOLON ]
method_invocation -> primary . DOT identifier LP listc0(argument) RP [ LB DOT COLONCOLON ]
method_invocation -> primary . DOT DOTS [ LB DOT COLONCOLON ]
method_reference -> primary . COLONCOLON identifier [ LB DOT COLONCOLON ]
## Transitions:
-- On DOT shift to state 160
-- On COLONCOLON shift to state 284
## Reductions:

State 284:
## Known stack suffix:
## primary COLONCOLON
## LR(1) items:
method_reference -> primary COLONCOLON . identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 285
## Reductions:

State 285:
## Known stack suffix:
## primary COLONCOLON identifier
## LR(1) items:
method_reference -> primary COLONCOLON identifier . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_reference -> primary COLONCOLON identifier

State 286:
## Known stack suffix:
## nonempty_list(variable_modifier)
## LR(1) items:
resource -> nonempty_list(variable_modifier) . local_variable_type identifier EQ expression [ SM RP ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On unann_type shift to state 281
-- On type_ shift to state 118
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On local_variable_type shift to state 287
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 287:
## Known stack suffix:
## nonempty_list(variable_modifier) local_variable_type
## LR(1) items:
resource -> nonempty_list(variable_modifier) local_variable_type . identifier EQ expression [ SM RP ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 288
## Reductions:

State 288:
## Known stack suffix:
## nonempty_list(variable_modifier) local_variable_type identifier
## LR(1) items:
resource -> nonempty_list(variable_modifier) local_variable_type identifier . EQ expression [ SM RP ]
## Transitions:
-- On EQ shift to state 289
## Reductions:

State 289:
## Known stack suffix:
## nonempty_list(variable_modifier) local_variable_type identifier EQ
## LR(1) items:
resource -> nonempty_list(variable_modifier) local_variable_type identifier EQ . expression [ SM RP ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 290
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 290:
## Known stack suffix:
## nonempty_list(variable_modifier) local_variable_type identifier EQ expression
## LR(1) items:
resource -> nonempty_list(variable_modifier) local_variable_type identifier EQ expression . [ SM RP ]
## Transitions:
## Reductions:
-- On SM RP
--   reduce production resource -> nonempty_list(variable_modifier) local_variable_type identifier EQ expression

State 291:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LB expression RB [ LB DOT COLONCOLON ]
class_instance_creation_expression -> name . DOT NEW identifier LP listc0(argument) RP option(class_body) [ LB DOT COLONCOLON ]
class_literal -> name . DOT CLASS [ LB DOT COLONCOLON ]
class_or_interface_type -> name . [ LB_RB IDENTIFIER ]
field_access -> name . DOT SUPER DOT identifier [ SM RP LB DOT COLONCOLON ]
method_invocation -> name . LP listc0(argument) RP [ LB DOT COLONCOLON ]
method_invocation -> name . DOT SUPER DOT identifier LP listc0(argument) RP [ LB DOT COLONCOLON ]
method_invocation -> name . DOT DOTS [ LB DOT COLONCOLON ]
method_reference -> name . COLONCOLON identifier [ LB DOT COLONCOLON ]
method_reference -> name . COLONCOLON NEW [ LB DOT COLONCOLON ]
method_reference -> name . DOT SUPER COLONCOLON identifier [ LB DOT COLONCOLON ]
name -> name . DOT identifier_ [ SM RP LP LB_RB LB IDENTIFIER DOT COLONCOLON ]
name -> name . DOT LT_GENERIC listc(type_argument) GT identifier_ [ SM RP LP LB_RB LB IDENTIFIER DOT COLONCOLON ]
primary_no_new_array -> name . DOT THIS [ LB DOT COLONCOLON ]
variable_access -> name . [ SM RP ]
## Transitions:
-- On LP shift to state 177
-- On LB shift to state 226
-- On DOT shift to state 292
-- On COLONCOLON shift to state 684
## Reductions:
-- On LB_RB IDENTIFIER
--   reduce production class_or_interface_type -> name
-- On SM RP
--   reduce production variable_access -> name

State 292:
## Known stack suffix:
## name DOT
## LR(1) items:
class_instance_creation_expression -> name DOT . NEW identifier LP listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
class_literal -> name DOT . CLASS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
field_access -> name DOT . SUPER DOT identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> name DOT . SUPER DOT identifier LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> name DOT . DOTS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> name DOT . SUPER COLONCOLON identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
name -> name DOT . identifier_ [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
name -> name DOT . LT_GENERIC listc(type_argument) GT identifier_ [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
primary_no_new_array -> name DOT . THIS [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On THIS shift to state 293
-- On SUPER shift to state 294
-- On NEW shift to state 307
-- On LT_GENERIC shift to state 34
-- On IDENTIFIER shift to state 18
-- On DOTS shift to state 682
-- On CLASS shift to state 683
-- On identifier_ shift to state 58
-- On identifier shift to state 39
## Reductions:

State 293:
## Known stack suffix:
## name DOT THIS
## LR(1) items:
primary_no_new_array -> name DOT THIS . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> name DOT THIS

State 294:
## Known stack suffix:
## name DOT SUPER
## LR(1) items:
field_access -> name DOT SUPER . DOT identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> name DOT SUPER . DOT identifier LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> name DOT SUPER . COLONCOLON identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On DOT shift to state 295
-- On COLONCOLON shift to state 305
## Reductions:

State 295:
## Known stack suffix:
## name DOT SUPER DOT
## LR(1) items:
field_access -> name DOT SUPER DOT . identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> name DOT SUPER DOT . identifier LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 296
## Reductions:

State 296:
## Known stack suffix:
## name DOT SUPER DOT identifier
## LR(1) items:
field_access -> name DOT SUPER DOT identifier . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> name DOT SUPER DOT identifier . LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 297
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production field_access -> name DOT SUPER DOT identifier

State 297:
## Known stack suffix:
## name DOT SUPER DOT identifier LP
## LR(1) items:
method_invocation -> name DOT SUPER DOT identifier LP . listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On optl(listc(argument)) shift to state 224
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc0(argument) shift to state 298
-- On listc(argument) shift to state 300
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 304
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) ->

State 298:
## Known stack suffix:
## name DOT SUPER DOT identifier LP listc0(argument)
## LR(1) items:
method_invocation -> name DOT SUPER DOT identifier LP listc0(argument) . RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 299
## Reductions:

State 299:
## Known stack suffix:
## name DOT SUPER DOT identifier LP listc0(argument) RP
## LR(1) items:
method_invocation -> name DOT SUPER DOT identifier LP listc0(argument) RP . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_invocation -> name DOT SUPER DOT identifier LP listc0(argument) RP

State 300:
## Known stack suffix:
## listc(argument)
## LR(1) items:
listc(argument) -> listc(argument) . CM argument [ RP CM ]
optl(listc(argument)) -> listc(argument) . [ RP ]
## Transitions:
-- On CM shift to state 301
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) -> listc(argument)

State 301:
## Known stack suffix:
## listc(argument) CM
## LR(1) items:
listc(argument) -> listc(argument) CM . argument [ RP CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 303
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 302:
## Known stack suffix:
## expression
## LR(1) items:
argument -> expression . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production argument -> expression

State 303:
## Known stack suffix:
## listc(argument) CM argument
## LR(1) items:
listc(argument) -> listc(argument) CM argument . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production listc(argument) -> listc(argument) CM argument

State 304:
## Known stack suffix:
## argument
## LR(1) items:
listc(argument) -> argument . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production listc(argument) -> argument

State 305:
## Known stack suffix:
## name DOT SUPER COLONCOLON
## LR(1) items:
method_reference -> name DOT SUPER COLONCOLON . identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 306
## Reductions:

State 306:
## Known stack suffix:
## name DOT SUPER COLONCOLON identifier
## LR(1) items:
method_reference -> name DOT SUPER COLONCOLON identifier . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_reference -> name DOT SUPER COLONCOLON identifier

State 307:
## Known stack suffix:
## name DOT NEW
## LR(1) items:
class_instance_creation_expression -> name DOT NEW . identifier LP listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 308
## Reductions:

State 308:
## Known stack suffix:
## name DOT NEW identifier
## LR(1) items:
class_instance_creation_expression -> name DOT NEW identifier . LP listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 309
## Reductions:

State 309:
## Known stack suffix:
## name DOT NEW identifier LP
## LR(1) items:
class_instance_creation_expression -> name DOT NEW identifier LP . listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On optl(listc(argument)) shift to state 224
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc0(argument) shift to state 310
-- On listc(argument) shift to state 300
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 304
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) ->

State 310:
## Known stack suffix:
## name DOT NEW identifier LP listc0(argument)
## LR(1) items:
class_instance_creation_expression -> name DOT NEW identifier LP listc0(argument) . RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 311
## Reductions:

State 311:
## Known stack suffix:
## name DOT NEW identifier LP listc0(argument) RP
## LR(1) items:
class_instance_creation_expression -> name DOT NEW identifier LP listc0(argument) RP . option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LC shift to state 312
-- On option(class_body) shift to state 744
-- On class_body shift to state 745
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production option(class_body) ->

State 312:
## Known stack suffix:
## LC
## LR(1) items:
class_body -> LC . list(class_body_declaration) RC [ XOR WHILE VOLATILE VOID URS TString TRY TRUE TRANSIENT TInt TIMES THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SRS SM RP RETURN RDots RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS PACKAGE OR_OR OR NULL NOT_EQ NEW NATIVE MOD MINUS LT LS LP LE LC LB INTERFACE INSTANCEOF INCR IMPORT IF IDENTIFIER GT GE FOR FINAL FALSE EQ_EQ EOF ENUM DOTS DOT DO DIV DEFAULT_COLON DEFAULT DECR CONTINUE COND COLONCOLON COLON CM CLASS CASE BREAK AT ASSERT AND_AND AND ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 69
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 313
-- On SM shift to state 315
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On LT shift to state 20
-- On LC shift to state 233
-- On INTERFACE shift to state 17
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On ENUM shift to state 317
-- On DOTS shift to state 327
-- On DEFAULT shift to state 328
-- On CLASS shift to state 329
-- On AT shift to state 338
-- On ABSTRACT shift to state 342
-- On type_parameters shift to state 404
-- On type_ shift to state 433
-- On static_initializer shift to state 457
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifiers shift to state 458
-- On modifier shift to state 391
-- On method_header shift to state 695
-- On method_declaration shift to state 697
-- On list(class_body_declaration) shift to state 742
-- On interface_declaration shift to state 699
-- On instance_initializer shift to state 700
-- On identifier_ shift to state 38
-- On identifier shift to state 478
-- On generic_method_or_constructor_decl shift to state 701
-- On field_declaration shift to state 702
-- On enum_declaration shift to state 703
-- On constructor_declarator shift to state 704
-- On constructor_declaration shift to state 707
-- On class_or_interface_type shift to state 49
-- On class_member_declaration shift to state 708
-- On class_header shift to state 396
-- On class_declaration shift to state 709
-- On class_body_declaration shift to state 710
-- On block shift to state 712
-- On array_type shift to state 51
-- On annotation_type_declaration shift to state 713
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(class_body_declaration) ->

State 313:
## Known stack suffix:
## STATIC
## LR(1) items:
modifier -> STATIC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
static_initializer -> STATIC . block [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LC shift to state 233
-- On block shift to state 314
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> STATIC

State 314:
## Known stack suffix:
## STATIC block
## LR(1) items:
static_initializer -> STATIC block . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production static_initializer -> STATIC block

State 315:
## Known stack suffix:
## SM
## LR(1) items:
class_member_declaration -> SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_member_declaration -> SM

State 316:
## Known stack suffix:
## FINAL
## LR(1) items:
modifier -> FINAL . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> FINAL

State 317:
## Known stack suffix:
## ENUM
## LR(1) items:
enum_declaration -> ENUM . identifier optl(interfaces) enum_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 318
## Reductions:

State 318:
## Known stack suffix:
## ENUM identifier
## LR(1) items:
enum_declaration -> ENUM identifier . optl(interfaces) enum_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IMPLEMENTS shift to state 319
-- On optl(interfaces) shift to state 324
-- On interfaces shift to state 337
## Reductions:
-- On LC
--   reduce production optl(interfaces) ->

State 319:
## Known stack suffix:
## IMPLEMENTS
## LR(1) items:
interfaces -> IMPLEMENTS . listc(reference_type) [ LC EOF ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On reference_type shift to state 320
-- On primitive_type shift to state 30
-- On name shift to state 32
-- On listc(reference_type) shift to state 321
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 320:
## Known stack suffix:
## reference_type
## LR(1) items:
listc(reference_type) -> reference_type . [ LC EOF CM ]
## Transitions:
## Reductions:
-- On LC EOF CM
--   reduce production listc(reference_type) -> reference_type

State 321:
## Known stack suffix:
## IMPLEMENTS listc(reference_type)
## LR(1) items:
interfaces -> IMPLEMENTS listc(reference_type) . [ LC EOF ]
listc(reference_type) -> listc(reference_type) . CM reference_type [ LC EOF CM ]
## Transitions:
-- On CM shift to state 322
## Reductions:
-- On LC EOF
--   reduce production interfaces -> IMPLEMENTS listc(reference_type)

State 322:
## Known stack suffix:
## listc(reference_type) CM
## LR(1) items:
listc(reference_type) -> listc(reference_type) CM . reference_type [ LC EOF CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On reference_type shift to state 323
-- On primitive_type shift to state 30
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 323:
## Known stack suffix:
## listc(reference_type) CM reference_type
## LR(1) items:
listc(reference_type) -> listc(reference_type) CM reference_type . [ LC EOF CM ]
## Transitions:
## Reductions:
-- On LC EOF CM
--   reduce production listc(reference_type) -> listc(reference_type) CM reference_type

State 324:
## Known stack suffix:
## ENUM identifier optl(interfaces)
## LR(1) items:
enum_declaration -> ENUM identifier optl(interfaces) . enum_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 325
-- On enum_body shift to state 741
## Reductions:

State 325:
## Known stack suffix:
## LC
## LR(1) items:
enum_body -> LC . optl(enum_body_declarations) RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
enum_body -> LC . listc(enum_constant) optl(enum_body_declarations) RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
enum_body -> LC . listc(enum_constant) CM optl(enum_body_declarations) RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 326
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 16
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On DOTS shift to state 714
-- On DEFAULT shift to state 328
-- On AT shift to state 83
-- On ABSTRACT shift to state 342
-- On optl(enum_body_declarations) shift to state 715
-- On modifiers shift to state 717
-- On modifier shift to state 391
-- On listc(enum_constant) shift to state 731
-- On identifier shift to state 718
-- On enum_constant_bis shift to state 735
-- On enum_constant shift to state 740
-- On enum_body_declarations shift to state 737
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production optl(enum_body_declarations) ->

State 326:
## Known stack suffix:
## SM
## LR(1) items:
enum_body_declarations -> SM . list(class_body_declaration) [ RC ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 69
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 313
-- On SM shift to state 315
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On LT shift to state 20
-- On LC shift to state 233
-- On INTERFACE shift to state 17
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On ENUM shift to state 317
-- On DOTS shift to state 327
-- On DEFAULT shift to state 328
-- On CLASS shift to state 329
-- On AT shift to state 338
-- On ABSTRACT shift to state 342
-- On type_parameters shift to state 404
-- On type_ shift to state 433
-- On static_initializer shift to state 457
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifiers shift to state 458
-- On modifier shift to state 391
-- On method_header shift to state 695
-- On method_declaration shift to state 697
-- On list(class_body_declaration) shift to state 698
-- On interface_declaration shift to state 699
-- On instance_initializer shift to state 700
-- On identifier_ shift to state 38
-- On identifier shift to state 478
-- On generic_method_or_constructor_decl shift to state 701
-- On field_declaration shift to state 702
-- On enum_declaration shift to state 703
-- On constructor_declarator shift to state 704
-- On constructor_declaration shift to state 707
-- On class_or_interface_type shift to state 49
-- On class_member_declaration shift to state 708
-- On class_header shift to state 396
-- On class_declaration shift to state 709
-- On class_body_declaration shift to state 710
-- On block shift to state 712
-- On array_type shift to state 51
-- On annotation_type_declaration shift to state 713
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(class_body_declaration) ->

State 327:
## Known stack suffix:
## DOTS
## LR(1) items:
class_member_declaration -> DOTS . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_member_declaration -> DOTS

State 328:
## Known stack suffix:
## DEFAULT
## LR(1) items:
modifier -> DEFAULT . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> DEFAULT

State 329:
## Known stack suffix:
## CLASS
## LR(1) items:
class_header -> CLASS . identifier optl(type_parameters) option(super) optl(interfaces) [ LC EOF ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 330
## Reductions:

State 330:
## Known stack suffix:
## CLASS identifier
## LR(1) items:
class_header -> CLASS identifier . optl(type_parameters) option(super) optl(interfaces) [ LC EOF ]
## Transitions:
-- On LT shift to state 20
-- On type_parameters shift to state 63
-- On optl(type_parameters) shift to state 331
## Reductions:
-- On LC IMPLEMENTS EXTENDS EOF
--   reduce production optl(type_parameters) ->

State 331:
## Known stack suffix:
## CLASS identifier optl(type_parameters)
## LR(1) items:
class_header -> CLASS identifier optl(type_parameters) . option(super) optl(interfaces) [ LC EOF ]
## Transitions:
-- On EXTENDS shift to state 332
-- On super shift to state 334
-- On option(super) shift to state 335
## Reductions:
-- On LC IMPLEMENTS EOF
--   reduce production option(super) ->

State 332:
## Known stack suffix:
## EXTENDS
## LR(1) items:
super -> EXTENDS . type_ [ LC IMPLEMENTS EOF ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On type_ shift to state 333
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 333:
## Known stack suffix:
## EXTENDS type_
## LR(1) items:
super -> EXTENDS type_ . [ LC IMPLEMENTS EOF ]
## Transitions:
## Reductions:
-- On LC IMPLEMENTS EOF
--   reduce production super -> EXTENDS type_

State 334:
## Known stack suffix:
## super
## LR(1) items:
option(super) -> super . [ LC IMPLEMENTS EOF ]
## Transitions:
## Reductions:
-- On LC IMPLEMENTS EOF
--   reduce production option(super) -> super

State 335:
## Known stack suffix:
## CLASS identifier optl(type_parameters) option(super)
## LR(1) items:
class_header -> CLASS identifier optl(type_parameters) option(super) . optl(interfaces) [ LC EOF ]
## Transitions:
-- On IMPLEMENTS shift to state 319
-- On optl(interfaces) shift to state 336
-- On interfaces shift to state 337
## Reductions:
-- On LC EOF
--   reduce production optl(interfaces) ->

State 336:
## Known stack suffix:
## CLASS identifier optl(type_parameters) option(super) optl(interfaces)
## LR(1) items:
class_header -> CLASS identifier optl(type_parameters) option(super) optl(interfaces) . [ LC EOF ]
## Transitions:
## Reductions:
-- On LC EOF
--   reduce production class_header -> CLASS identifier optl(type_parameters) option(super) optl(interfaces)

State 337:
## Known stack suffix:
## interfaces
## LR(1) items:
optl(interfaces) -> interfaces . [ LC EOF ]
## Transitions:
## Reductions:
-- On LC EOF
--   reduce production optl(interfaces) -> interfaces

State 338:
## Known stack suffix:
## AT
## LR(1) items:
annotation -> AT . qualified_ident [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
annotation -> AT . qualified_ident LP annotation_element RP [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
annotation_type_declaration -> AT . INTERFACE identifier annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On INTERFACE shift to state 339
-- On IDENTIFIER shift to state 11
-- On qualified_ident shift to state 84
## Reductions:

State 339:
## Known stack suffix:
## AT INTERFACE
## LR(1) items:
annotation_type_declaration -> AT INTERFACE . identifier annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 340
## Reductions:

State 340:
## Known stack suffix:
## AT INTERFACE identifier
## LR(1) items:
annotation_type_declaration -> AT INTERFACE identifier . annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LC shift to state 341
-- On annotation_type_body shift to state 403
## Reductions:

State 341:
## Known stack suffix:
## LC
## LR(1) items:
annotation_type_body -> LC . list(annotation_type_element_declaration) RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On INTERFACE shift to state 17
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On ENUM shift to state 317
-- On DEFAULT shift to state 328
-- On CLASS shift to state 329
-- On AT shift to state 338
-- On ABSTRACT shift to state 342
-- On type_ shift to state 343
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifiers shift to state 363
-- On modifier shift to state 391
-- On list(annotation_type_element_declaration) shift to state 392
-- On interface_declaration shift to state 394
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On enum_declaration shift to state 395
-- On class_or_interface_type shift to state 49
-- On class_header shift to state 396
-- On class_declaration shift to state 398
-- On array_type shift to state 51
-- On annotation_type_element_rest shift to state 399
-- On annotation_type_element_declaration shift to state 400
-- On annotation_type_declaration shift to state 402
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(annotation_type_element_declaration) ->

State 342:
## Known stack suffix:
## ABSTRACT
## LR(1) items:
modifier -> ABSTRACT . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> ABSTRACT

State 343:
## Known stack suffix:
## type_
## LR(1) items:
annotation_type_element_rest -> type_ . identifier annotation_method_or_constant_rest SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 344
## Reductions:

State 344:
## Known stack suffix:
## type_ identifier
## LR(1) items:
annotation_type_element_rest -> type_ identifier . annotation_method_or_constant_rest SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 345
-- On annotation_method_or_constant_rest shift to state 361
## Reductions:

State 345:
## Known stack suffix:
## LP
## LR(1) items:
annotation_method_or_constant_rest -> LP . RP [ SM ]
annotation_method_or_constant_rest -> LP . RP DEFAULT element_value [ SM ]
## Transitions:
-- On RP shift to state 346
## Reductions:

State 346:
## Known stack suffix:
## LP RP
## LR(1) items:
annotation_method_or_constant_rest -> LP RP . [ SM ]
annotation_method_or_constant_rest -> LP RP . DEFAULT element_value [ SM ]
## Transitions:
-- On DEFAULT shift to state 347
## Reductions:
-- On SM
--   reduce production annotation_method_or_constant_rest -> LP RP

State 347:
## Known stack suffix:
## LP RP DEFAULT
## LR(1) items:
annotation_method_or_constant_rest -> LP RP DEFAULT . element_value [ SM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On LC shift to state 348
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On AT shift to state 83
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On expr1 shift to state 352
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On element_value_array_initializer shift to state 353
-- On element_value shift to state 360
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 355
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On annotation shift to state 356
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 348:
## Known stack suffix:
## LC
## LR(1) items:
element_value_array_initializer -> LC . RC [ SM RP RC CM ]
element_value_array_initializer -> LC . listc(element_value) option(CM) RC [ SM RP RC CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On RC shift to state 349
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On LC shift to state 348
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On AT shift to state 83
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc(element_value) shift to state 350
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On expr1 shift to state 352
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On element_value_array_initializer shift to state 353
-- On element_value shift to state 359
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 355
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On annotation shift to state 356
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 349:
## Known stack suffix:
## LC RC
## LR(1) items:
element_value_array_initializer -> LC RC . [ SM RP RC CM ]
## Transitions:
## Reductions:
-- On SM RP RC CM
--   reduce production element_value_array_initializer -> LC RC

State 350:
## Known stack suffix:
## LC listc(element_value)
## LR(1) items:
element_value_array_initializer -> LC listc(element_value) . option(CM) RC [ SM RP RC CM ]
listc(element_value) -> listc(element_value) . CM element_value [ RC CM ]
## Transitions:
-- On CM shift to state 351
-- On option(CM) shift to state 357
## Reductions:
-- On RC
--   reduce production option(CM) ->

State 351:
## Known stack suffix:
## listc(element_value) CM
## LR(1) items:
listc(element_value) -> listc(element_value) CM . element_value [ RC CM ]
option(CM) -> CM . [ RC ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On LC shift to state 348
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On AT shift to state 83
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On expr1 shift to state 352
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On element_value_array_initializer shift to state 353
-- On element_value shift to state 354
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 355
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On annotation shift to state 356
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RC
--   reduce production option(CM) -> CM

State 352:
## Known stack suffix:
## expr1
## LR(1) items:
element_value -> expr1 . [ SM RP RC CM ]
## Transitions:
## Reductions:
-- On SM RP RC CM
--   reduce production element_value -> expr1

State 353:
## Known stack suffix:
## element_value_array_initializer
## LR(1) items:
element_value -> element_value_array_initializer . [ SM RP RC CM ]
## Transitions:
## Reductions:
-- On SM RP RC CM
--   reduce production element_value -> element_value_array_initializer

State 354:
## Known stack suffix:
## listc(element_value) CM element_value
## LR(1) items:
listc(element_value) -> listc(element_value) CM element_value . [ RC CM ]
## Transitions:
## Reductions:
-- On RC CM
--   reduce production listc(element_value) -> listc(element_value) CM element_value

State 355:
## Known stack suffix:
## conditional_expression
## LR(1) items:
expr1 -> conditional_expression . [ SM RP RC CM ]
## Transitions:
## Reductions:
-- On SM RP RC CM
--   reduce production expr1 -> conditional_expression

State 356:
## Known stack suffix:
## annotation
## LR(1) items:
element_value -> annotation . [ SM RP RC CM ]
## Transitions:
## Reductions:
-- On SM RP RC CM
--   reduce production element_value -> annotation

State 357:
## Known stack suffix:
## LC listc(element_value) option(CM)
## LR(1) items:
element_value_array_initializer -> LC listc(element_value) option(CM) . RC [ SM RP RC CM ]
## Transitions:
-- On RC shift to state 358
## Reductions:

State 358:
## Known stack suffix:
## LC listc(element_value) option(CM) RC
## LR(1) items:
element_value_array_initializer -> LC listc(element_value) option(CM) RC . [ SM RP RC CM ]
## Transitions:
## Reductions:
-- On SM RP RC CM
--   reduce production element_value_array_initializer -> LC listc(element_value) option(CM) RC

State 359:
## Known stack suffix:
## element_value
## LR(1) items:
listc(element_value) -> element_value . [ RC CM ]
## Transitions:
## Reductions:
-- On RC CM
--   reduce production listc(element_value) -> element_value

State 360:
## Known stack suffix:
## LP RP DEFAULT element_value
## LR(1) items:
annotation_method_or_constant_rest -> LP RP DEFAULT element_value . [ SM ]
## Transitions:
## Reductions:
-- On SM
--   reduce production annotation_method_or_constant_rest -> LP RP DEFAULT element_value

State 361:
## Known stack suffix:
## type_ identifier annotation_method_or_constant_rest
## LR(1) items:
annotation_type_element_rest -> type_ identifier annotation_method_or_constant_rest . SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 362
## Reductions:

State 362:
## Known stack suffix:
## type_ identifier annotation_method_or_constant_rest SM
## LR(1) items:
annotation_type_element_rest -> type_ identifier annotation_method_or_constant_rest SM . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production annotation_type_element_rest -> type_ identifier annotation_method_or_constant_rest SM

State 363:
## Known stack suffix:
## modifiers
## LR(1) items:
annotation_type_declaration -> modifiers . AT INTERFACE identifier annotation_type_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
annotation_type_element_rest -> modifiers . type_ identifier annotation_method_or_constant_rest SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
class_header -> modifiers . CLASS identifier optl(type_parameters) option(super) optl(interfaces) [ LC ]
enum_declaration -> modifiers . ENUM identifier optl(interfaces) enum_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
interface_declaration -> modifiers . INTERFACE identifier optl(type_parameters) optl(extends_interfaces) interface_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
modifiers -> modifiers . modifier [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On INTERFACE shift to state 364
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On ENUM shift to state 372
-- On DEFAULT shift to state 328
-- On CLASS shift to state 376
-- On AT shift to state 381
-- On ABSTRACT shift to state 342
-- On type_ shift to state 385
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifier shift to state 389
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
-- On annotation shift to state 390
## Reductions:

State 364:
## Known stack suffix:
## modifiers INTERFACE
## LR(1) items:
interface_declaration -> modifiers INTERFACE . identifier optl(type_parameters) optl(extends_interfaces) interface_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 365
## Reductions:

State 365:
## Known stack suffix:
## modifiers INTERFACE identifier
## LR(1) items:
interface_declaration -> modifiers INTERFACE identifier . optl(type_parameters) optl(extends_interfaces) interface_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LT shift to state 20
-- On type_parameters shift to state 63
-- On optl(type_parameters) shift to state 366
## Reductions:
-- On LC EXTENDS
--   reduce production optl(type_parameters) ->

State 366:
## Known stack suffix:
## modifiers INTERFACE identifier optl(type_parameters)
## LR(1) items:
interface_declaration -> modifiers INTERFACE identifier optl(type_parameters) . optl(extends_interfaces) interface_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On EXTENDS shift to state 65
-- On optl(extends_interfaces) shift to state 367
-- On extends_interfaces shift to state 369
## Reductions:
-- On LC
--   reduce production optl(extends_interfaces) ->

State 367:
## Known stack suffix:
## modifiers INTERFACE identifier optl(type_parameters) optl(extends_interfaces)
## LR(1) items:
interface_declaration -> modifiers INTERFACE identifier optl(type_parameters) optl(extends_interfaces) . interface_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 68
-- On interface_body shift to state 368
## Reductions:

State 368:
## Known stack suffix:
## modifiers INTERFACE identifier optl(type_parameters) optl(extends_interfaces) interface_body
## LR(1) items:
interface_declaration -> modifiers INTERFACE identifier optl(type_parameters) optl(extends_interfaces) interface_body . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production interface_declaration -> modifiers INTERFACE identifier optl(type_parameters) optl(extends_interfaces) interface_body

State 369:
## Known stack suffix:
## extends_interfaces
## LR(1) items:
extends_interfaces -> extends_interfaces . CM reference_type [ LC CM ]
optl(extends_interfaces) -> extends_interfaces . [ LC ]
## Transitions:
-- On CM shift to state 370
## Reductions:
-- On LC
--   reduce production optl(extends_interfaces) -> extends_interfaces

State 370:
## Known stack suffix:
## extends_interfaces CM
## LR(1) items:
extends_interfaces -> extends_interfaces CM . reference_type [ LC CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On reference_type shift to state 371
-- On primitive_type shift to state 30
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 371:
## Known stack suffix:
## extends_interfaces CM reference_type
## LR(1) items:
extends_interfaces -> extends_interfaces CM reference_type . [ LC CM ]
## Transitions:
## Reductions:
-- On LC CM
--   reduce production extends_interfaces -> extends_interfaces CM reference_type

State 372:
## Known stack suffix:
## modifiers ENUM
## LR(1) items:
enum_declaration -> modifiers ENUM . identifier optl(interfaces) enum_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 373
## Reductions:

State 373:
## Known stack suffix:
## modifiers ENUM identifier
## LR(1) items:
enum_declaration -> modifiers ENUM identifier . optl(interfaces) enum_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IMPLEMENTS shift to state 319
-- On optl(interfaces) shift to state 374
-- On interfaces shift to state 337
## Reductions:
-- On LC
--   reduce production optl(interfaces) ->

State 374:
## Known stack suffix:
## modifiers ENUM identifier optl(interfaces)
## LR(1) items:
enum_declaration -> modifiers ENUM identifier optl(interfaces) . enum_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 325
-- On enum_body shift to state 375
## Reductions:

State 375:
## Known stack suffix:
## modifiers ENUM identifier optl(interfaces) enum_body
## LR(1) items:
enum_declaration -> modifiers ENUM identifier optl(interfaces) enum_body . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production enum_declaration -> modifiers ENUM identifier optl(interfaces) enum_body

State 376:
## Known stack suffix:
## modifiers CLASS
## LR(1) items:
class_header -> modifiers CLASS . identifier optl(type_parameters) option(super) optl(interfaces) [ LC EOF ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 377
## Reductions:

State 377:
## Known stack suffix:
## modifiers CLASS identifier
## LR(1) items:
class_header -> modifiers CLASS identifier . optl(type_parameters) option(super) optl(interfaces) [ LC EOF ]
## Transitions:
-- On LT shift to state 20
-- On type_parameters shift to state 63
-- On optl(type_parameters) shift to state 378
## Reductions:
-- On LC IMPLEMENTS EXTENDS EOF
--   reduce production optl(type_parameters) ->

State 378:
## Known stack suffix:
## modifiers CLASS identifier optl(type_parameters)
## LR(1) items:
class_header -> modifiers CLASS identifier optl(type_parameters) . option(super) optl(interfaces) [ LC EOF ]
## Transitions:
-- On EXTENDS shift to state 332
-- On super shift to state 334
-- On option(super) shift to state 379
## Reductions:
-- On LC IMPLEMENTS EOF
--   reduce production option(super) ->

State 379:
## Known stack suffix:
## modifiers CLASS identifier optl(type_parameters) option(super)
## LR(1) items:
class_header -> modifiers CLASS identifier optl(type_parameters) option(super) . optl(interfaces) [ LC EOF ]
## Transitions:
-- On IMPLEMENTS shift to state 319
-- On optl(interfaces) shift to state 380
-- On interfaces shift to state 337
## Reductions:
-- On LC EOF
--   reduce production optl(interfaces) ->

State 380:
## Known stack suffix:
## modifiers CLASS identifier optl(type_parameters) option(super) optl(interfaces)
## LR(1) items:
class_header -> modifiers CLASS identifier optl(type_parameters) option(super) optl(interfaces) . [ LC EOF ]
## Transitions:
## Reductions:
-- On LC EOF
--   reduce production class_header -> modifiers CLASS identifier optl(type_parameters) option(super) optl(interfaces)

State 381:
## Known stack suffix:
## modifiers AT
## LR(1) items:
annotation -> AT . qualified_ident [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
annotation -> AT . qualified_ident LP annotation_element RP [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
annotation_type_declaration -> modifiers AT . INTERFACE identifier annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On INTERFACE shift to state 382
-- On IDENTIFIER shift to state 11
-- On qualified_ident shift to state 84
## Reductions:

State 382:
## Known stack suffix:
## modifiers AT INTERFACE
## LR(1) items:
annotation_type_declaration -> modifiers AT INTERFACE . identifier annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 383
## Reductions:

State 383:
## Known stack suffix:
## modifiers AT INTERFACE identifier
## LR(1) items:
annotation_type_declaration -> modifiers AT INTERFACE identifier . annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LC shift to state 341
-- On annotation_type_body shift to state 384
## Reductions:

State 384:
## Known stack suffix:
## modifiers AT INTERFACE identifier annotation_type_body
## LR(1) items:
annotation_type_declaration -> modifiers AT INTERFACE identifier annotation_type_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production annotation_type_declaration -> modifiers AT INTERFACE identifier annotation_type_body

State 385:
## Known stack suffix:
## modifiers type_
## LR(1) items:
annotation_type_element_rest -> modifiers type_ . identifier annotation_method_or_constant_rest SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 386
## Reductions:

State 386:
## Known stack suffix:
## modifiers type_ identifier
## LR(1) items:
annotation_type_element_rest -> modifiers type_ identifier . annotation_method_or_constant_rest SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 345
-- On annotation_method_or_constant_rest shift to state 387
## Reductions:

State 387:
## Known stack suffix:
## modifiers type_ identifier annotation_method_or_constant_rest
## LR(1) items:
annotation_type_element_rest -> modifiers type_ identifier annotation_method_or_constant_rest . SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 388
## Reductions:

State 388:
## Known stack suffix:
## modifiers type_ identifier annotation_method_or_constant_rest SM
## LR(1) items:
annotation_type_element_rest -> modifiers type_ identifier annotation_method_or_constant_rest SM . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production annotation_type_element_rest -> modifiers type_ identifier annotation_method_or_constant_rest SM

State 389:
## Known stack suffix:
## modifiers modifier
## LR(1) items:
modifiers -> modifiers modifier . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifiers -> modifiers modifier

State 390:
## Known stack suffix:
## annotation
## LR(1) items:
modifier -> annotation . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> annotation

State 391:
## Known stack suffix:
## modifier
## LR(1) items:
modifiers -> modifier . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifiers -> modifier

State 392:
## Known stack suffix:
## LC list(annotation_type_element_declaration)
## LR(1) items:
annotation_type_body -> LC list(annotation_type_element_declaration) . RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On RC shift to state 393
## Reductions:

State 393:
## Known stack suffix:
## LC list(annotation_type_element_declaration) RC
## LR(1) items:
annotation_type_body -> LC list(annotation_type_element_declaration) RC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production annotation_type_body -> LC list(annotation_type_element_declaration) RC

State 394:
## Known stack suffix:
## interface_declaration
## LR(1) items:
annotation_type_element_rest -> interface_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production annotation_type_element_rest -> interface_declaration

State 395:
## Known stack suffix:
## enum_declaration
## LR(1) items:
annotation_type_element_rest -> enum_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production annotation_type_element_rest -> enum_declaration

State 396:
## Known stack suffix:
## class_header
## LR(1) items:
class_declaration -> class_header . class_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 312
-- On class_body shift to state 397
## Reductions:

State 397:
## Known stack suffix:
## class_header class_body
## LR(1) items:
class_declaration -> class_header class_body . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production class_declaration -> class_header class_body

State 398:
## Known stack suffix:
## class_declaration
## LR(1) items:
annotation_type_element_rest -> class_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production annotation_type_element_rest -> class_declaration

State 399:
## Known stack suffix:
## annotation_type_element_rest
## LR(1) items:
annotation_type_element_declaration -> annotation_type_element_rest . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production annotation_type_element_declaration -> annotation_type_element_rest

State 400:
## Known stack suffix:
## annotation_type_element_declaration
## LR(1) items:
list(annotation_type_element_declaration) -> annotation_type_element_declaration . list(annotation_type_element_declaration) [ RC ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On INTERFACE shift to state 17
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On ENUM shift to state 317
-- On DEFAULT shift to state 328
-- On CLASS shift to state 329
-- On AT shift to state 338
-- On ABSTRACT shift to state 342
-- On type_ shift to state 343
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifiers shift to state 363
-- On modifier shift to state 391
-- On list(annotation_type_element_declaration) shift to state 401
-- On interface_declaration shift to state 394
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On enum_declaration shift to state 395
-- On class_or_interface_type shift to state 49
-- On class_header shift to state 396
-- On class_declaration shift to state 398
-- On array_type shift to state 51
-- On annotation_type_element_rest shift to state 399
-- On annotation_type_element_declaration shift to state 400
-- On annotation_type_declaration shift to state 402
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(annotation_type_element_declaration) ->

State 401:
## Known stack suffix:
## annotation_type_element_declaration list(annotation_type_element_declaration)
## LR(1) items:
list(annotation_type_element_declaration) -> annotation_type_element_declaration list(annotation_type_element_declaration) . [ RC ]
## Transitions:
## Reductions:
-- On RC
--   reduce production list(annotation_type_element_declaration) -> annotation_type_element_declaration list(annotation_type_element_declaration)

State 402:
## Known stack suffix:
## annotation_type_declaration
## LR(1) items:
annotation_type_element_rest -> annotation_type_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production annotation_type_element_rest -> annotation_type_declaration

State 403:
## Known stack suffix:
## AT INTERFACE identifier annotation_type_body
## LR(1) items:
annotation_type_declaration -> AT INTERFACE identifier annotation_type_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production annotation_type_declaration -> AT INTERFACE identifier annotation_type_body

State 404:
## Known stack suffix:
## type_parameters
## LR(1) items:
generic_method_or_constructor_decl -> type_parameters . type_ identifier formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
generic_method_or_constructor_decl -> type_parameters . VOID identifier formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On VOID shift to state 405
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On type_ shift to state 428
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 405:
## Known stack suffix:
## type_parameters VOID
## LR(1) items:
generic_method_or_constructor_decl -> type_parameters VOID . identifier formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 406
## Reductions:

State 406:
## Known stack suffix:
## type_parameters VOID identifier
## LR(1) items:
generic_method_or_constructor_decl -> type_parameters VOID identifier . formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 407
-- On formal_parameters shift to state 423
## Reductions:

State 407:
## Known stack suffix:
## LP
## LR(1) items:
formal_parameters -> LP . listc0(formal_parameter) RP [ THROWS SM LC ]
## Transitions:
-- On FINAL shift to state 81
-- On DOTS shift to state 82
-- On AT shift to state 83
-- On variable_modifier shift to state 408
-- On optl(listc(formal_parameter)) shift to state 410
-- On listc0(formal_parameter) shift to state 411
-- On listc(formal_parameter) shift to state 413
-- On list(variable_modifier) shift to state 415
-- On formal_parameter shift to state 422
-- On annotation shift to state 113
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER
--   reduce production list(variable_modifier) ->
-- On RP
--   reduce production optl(listc(formal_parameter)) ->

State 408:
## Known stack suffix:
## variable_modifier
## LR(1) items:
list(variable_modifier) -> variable_modifier . list(variable_modifier) [ PRIMITIVE_TYPE IDENTIFIER ]
## Transitions:
-- On FINAL shift to state 81
-- On AT shift to state 83
-- On variable_modifier shift to state 408
-- On list(variable_modifier) shift to state 409
-- On annotation shift to state 113
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER
--   reduce production list(variable_modifier) ->

State 409:
## Known stack suffix:
## variable_modifier list(variable_modifier)
## LR(1) items:
list(variable_modifier) -> variable_modifier list(variable_modifier) . [ PRIMITIVE_TYPE IDENTIFIER ]
## Transitions:
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER
--   reduce production list(variable_modifier) -> variable_modifier list(variable_modifier)

State 410:
## Known stack suffix:
## optl(listc(formal_parameter))
## LR(1) items:
listc0(formal_parameter) -> optl(listc(formal_parameter)) . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production listc0(formal_parameter) -> optl(listc(formal_parameter))

State 411:
## Known stack suffix:
## LP listc0(formal_parameter)
## LR(1) items:
formal_parameters -> LP listc0(formal_parameter) . RP [ THROWS SM LC ]
## Transitions:
-- On RP shift to state 412
## Reductions:

State 412:
## Known stack suffix:
## LP listc0(formal_parameter) RP
## LR(1) items:
formal_parameters -> LP listc0(formal_parameter) RP . [ THROWS SM LC ]
## Transitions:
## Reductions:
-- On THROWS SM LC
--   reduce production formal_parameters -> LP listc0(formal_parameter) RP

State 413:
## Known stack suffix:
## listc(formal_parameter)
## LR(1) items:
listc(formal_parameter) -> listc(formal_parameter) . CM formal_parameter [ RP CM ]
optl(listc(formal_parameter)) -> listc(formal_parameter) . [ RP ]
## Transitions:
-- On CM shift to state 414
## Reductions:
-- On RP
--   reduce production optl(listc(formal_parameter)) -> listc(formal_parameter)

State 414:
## Known stack suffix:
## listc(formal_parameter) CM
## LR(1) items:
listc(formal_parameter) -> listc(formal_parameter) CM . formal_parameter [ RP CM ]
## Transitions:
-- On FINAL shift to state 81
-- On DOTS shift to state 82
-- On AT shift to state 83
-- On variable_modifier shift to state 408
-- On list(variable_modifier) shift to state 415
-- On formal_parameter shift to state 421
-- On annotation shift to state 113
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER
--   reduce production list(variable_modifier) ->

State 415:
## Known stack suffix:
## list(variable_modifier)
## LR(1) items:
formal_parameter -> list(variable_modifier) . type_ variable_declarator_id_bis [ RP CM ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On type_ shift to state 416
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 416:
## Known stack suffix:
## list(variable_modifier) type_
## LR(1) items:
formal_parameter -> list(variable_modifier) type_ . variable_declarator_id_bis [ RP CM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On DOTS shift to state 417
-- On variable_declarator_id_bis shift to state 419
-- On variable_declarator_id shift to state 420
-- On identifier shift to state 128
## Reductions:

State 417:
## Known stack suffix:
## DOTS
## LR(1) items:
variable_declarator_id_bis -> DOTS . variable_declarator_id [ RP CM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 418
-- On identifier shift to state 128
## Reductions:

State 418:
## Known stack suffix:
## DOTS variable_declarator_id
## LR(1) items:
variable_declarator_id -> variable_declarator_id . LB_RB [ RP LB_RB CM ]
variable_declarator_id_bis -> DOTS variable_declarator_id . [ RP CM ]
## Transitions:
-- On LB_RB shift to state 127
## Reductions:
-- On RP CM
--   reduce production variable_declarator_id_bis -> DOTS variable_declarator_id

State 419:
## Known stack suffix:
## list(variable_modifier) type_ variable_declarator_id_bis
## LR(1) items:
formal_parameter -> list(variable_modifier) type_ variable_declarator_id_bis . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production formal_parameter -> list(variable_modifier) type_ variable_declarator_id_bis

State 420:
## Known stack suffix:
## variable_declarator_id
## LR(1) items:
variable_declarator_id -> variable_declarator_id . LB_RB [ RP LB_RB CM ]
variable_declarator_id_bis -> variable_declarator_id . [ RP CM ]
## Transitions:
-- On LB_RB shift to state 127
## Reductions:
-- On RP CM
--   reduce production variable_declarator_id_bis -> variable_declarator_id

State 421:
## Known stack suffix:
## listc(formal_parameter) CM formal_parameter
## LR(1) items:
listc(formal_parameter) -> listc(formal_parameter) CM formal_parameter . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production listc(formal_parameter) -> listc(formal_parameter) CM formal_parameter

State 422:
## Known stack suffix:
## formal_parameter
## LR(1) items:
listc(formal_parameter) -> formal_parameter . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production listc(formal_parameter) -> formal_parameter

State 423:
## Known stack suffix:
## type_parameters VOID identifier formal_parameters
## LR(1) items:
generic_method_or_constructor_decl -> type_parameters VOID identifier formal_parameters . optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 71
-- On throws shift to state 77
-- On optl(throws) shift to state 424
## Reductions:
-- On SM LC
--   reduce production optl(throws) ->

State 424:
## Known stack suffix:
## type_parameters VOID identifier formal_parameters optl(throws)
## LR(1) items:
generic_method_or_constructor_decl -> type_parameters VOID identifier formal_parameters optl(throws) . method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 425
-- On LC shift to state 233
-- On method_body shift to state 426
-- On block shift to state 427
## Reductions:

State 425:
## Known stack suffix:
## SM
## LR(1) items:
method_body -> SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production method_body -> SM

State 426:
## Known stack suffix:
## type_parameters VOID identifier formal_parameters optl(throws) method_body
## LR(1) items:
generic_method_or_constructor_decl -> type_parameters VOID identifier formal_parameters optl(throws) method_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production generic_method_or_constructor_decl -> type_parameters VOID identifier formal_parameters optl(throws) method_body

State 427:
## Known stack suffix:
## block
## LR(1) items:
method_body -> block . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production method_body -> block

State 428:
## Known stack suffix:
## type_parameters type_
## LR(1) items:
generic_method_or_constructor_decl -> type_parameters type_ . identifier formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 429
## Reductions:

State 429:
## Known stack suffix:
## type_parameters type_ identifier
## LR(1) items:
generic_method_or_constructor_decl -> type_parameters type_ identifier . formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 407
-- On formal_parameters shift to state 430
## Reductions:

State 430:
## Known stack suffix:
## type_parameters type_ identifier formal_parameters
## LR(1) items:
generic_method_or_constructor_decl -> type_parameters type_ identifier formal_parameters . optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 71
-- On throws shift to state 77
-- On optl(throws) shift to state 431
## Reductions:
-- On SM LC
--   reduce production optl(throws) ->

State 431:
## Known stack suffix:
## type_parameters type_ identifier formal_parameters optl(throws)
## LR(1) items:
generic_method_or_constructor_decl -> type_parameters type_ identifier formal_parameters optl(throws) . method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 425
-- On LC shift to state 233
-- On method_body shift to state 432
-- On block shift to state 427
## Reductions:

State 432:
## Known stack suffix:
## type_parameters type_ identifier formal_parameters optl(throws) method_body
## LR(1) items:
generic_method_or_constructor_decl -> type_parameters type_ identifier formal_parameters optl(throws) method_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production generic_method_or_constructor_decl -> type_parameters type_ identifier formal_parameters optl(throws) method_body

State 433:
## Known stack suffix:
## type_
## LR(1) items:
field_declaration -> type_ . listc(variable_declarator) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
method_header -> type_ . method_declarator optl(throws) [ SM LC ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 434
-- On variable_declarator shift to state 449
-- On method_declarator shift to state 450
-- On listc(variable_declarator) shift to state 452
-- On identifier shift to state 456
## Reductions:

State 434:
## Known stack suffix:
## variable_declarator_id
## LR(1) items:
variable_declarator -> variable_declarator_id . [ SM CM ]
variable_declarator -> variable_declarator_id . EQ variable_initializer [ SM CM ]
variable_declarator_id -> variable_declarator_id . LB_RB [ SM LB_RB EQ CM ]
## Transitions:
-- On LB_RB shift to state 127
-- On EQ shift to state 435
## Reductions:
-- On SM CM
--   reduce production variable_declarator -> variable_declarator_id

State 435:
## Known stack suffix:
## variable_declarator_id EQ
## LR(1) items:
variable_declarator -> variable_declarator_id EQ . variable_initializer [ SM CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On LC shift to state 436
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On variable_initializer shift to state 448
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 444
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_initializer shift to state 445
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 436:
## Known stack suffix:
## LC
## LR(1) items:
array_initializer -> LC . option(CM) RC [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
array_initializer -> LC . listc(variable_initializer) option(CM) RC [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On LC shift to state 436
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On CM shift to state 437
-- On variable_initializer shift to state 438
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On option(CM) shift to state 439
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc(variable_initializer) shift to state 441
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 444
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_initializer shift to state 445
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RC
--   reduce production option(CM) ->

State 437:
## Known stack suffix:
## CM
## LR(1) items:
option(CM) -> CM . [ RC ]
## Transitions:
## Reductions:
-- On RC
--   reduce production option(CM) -> CM

State 438:
## Known stack suffix:
## variable_initializer
## LR(1) items:
listc(variable_initializer) -> variable_initializer . [ RC CM ]
## Transitions:
## Reductions:
-- On RC CM
--   reduce production listc(variable_initializer) -> variable_initializer

State 439:
## Known stack suffix:
## LC option(CM)
## LR(1) items:
array_initializer -> LC option(CM) . RC [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RC shift to state 440
## Reductions:

State 440:
## Known stack suffix:
## LC option(CM) RC
## LR(1) items:
array_initializer -> LC option(CM) RC . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production array_initializer -> LC option(CM) RC

State 441:
## Known stack suffix:
## LC listc(variable_initializer)
## LR(1) items:
array_initializer -> LC listc(variable_initializer) . option(CM) RC [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
listc(variable_initializer) -> listc(variable_initializer) . CM variable_initializer [ RC CM ]
## Transitions:
-- On CM shift to state 442
-- On option(CM) shift to state 446
## Reductions:
-- On RC
--   reduce production option(CM) ->

State 442:
## Known stack suffix:
## listc(variable_initializer) CM
## LR(1) items:
listc(variable_initializer) -> listc(variable_initializer) CM . variable_initializer [ RC CM ]
option(CM) -> CM . [ RC ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On LC shift to state 436
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On variable_initializer shift to state 443
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 444
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_initializer shift to state 445
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RC
--   reduce production option(CM) -> CM

State 443:
## Known stack suffix:
## listc(variable_initializer) CM variable_initializer
## LR(1) items:
listc(variable_initializer) -> listc(variable_initializer) CM variable_initializer . [ RC CM ]
## Transitions:
## Reductions:
-- On RC CM
--   reduce production listc(variable_initializer) -> listc(variable_initializer) CM variable_initializer

State 444:
## Known stack suffix:
## expression
## LR(1) items:
variable_initializer -> expression . [ SM RC CM ]
## Transitions:
## Reductions:
-- On SM RC CM
--   reduce production variable_initializer -> expression

State 445:
## Known stack suffix:
## array_initializer
## LR(1) items:
variable_initializer -> array_initializer . [ SM RC CM ]
## Transitions:
## Reductions:
-- On SM RC CM
--   reduce production variable_initializer -> array_initializer

State 446:
## Known stack suffix:
## LC listc(variable_initializer) option(CM)
## LR(1) items:
array_initializer -> LC listc(variable_initializer) option(CM) . RC [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RC shift to state 447
## Reductions:

State 447:
## Known stack suffix:
## LC listc(variable_initializer) option(CM) RC
## LR(1) items:
array_initializer -> LC listc(variable_initializer) option(CM) RC . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production array_initializer -> LC listc(variable_initializer) option(CM) RC

State 448:
## Known stack suffix:
## variable_declarator_id EQ variable_initializer
## LR(1) items:
variable_declarator -> variable_declarator_id EQ variable_initializer . [ SM CM ]
## Transitions:
## Reductions:
-- On SM CM
--   reduce production variable_declarator -> variable_declarator_id EQ variable_initializer

State 449:
## Known stack suffix:
## variable_declarator
## LR(1) items:
listc(variable_declarator) -> variable_declarator . [ SM CM ]
## Transitions:
## Reductions:
-- On SM CM
--   reduce production listc(variable_declarator) -> variable_declarator

State 450:
## Known stack suffix:
## type_ method_declarator
## LR(1) items:
method_declarator -> method_declarator . LB_RB [ THROWS SM LC LB_RB EOF ]
method_header -> type_ method_declarator . optl(throws) [ SM LC EOF ]
## Transitions:
-- On THROWS shift to state 71
-- On LB_RB shift to state 76
-- On throws shift to state 77
-- On optl(throws) shift to state 451
## Reductions:
-- On SM LC EOF
--   reduce production optl(throws) ->

State 451:
## Known stack suffix:
## type_ method_declarator optl(throws)
## LR(1) items:
method_header -> type_ method_declarator optl(throws) . [ SM LC EOF ]
## Transitions:
## Reductions:
-- On SM LC EOF
--   reduce production method_header -> type_ method_declarator optl(throws)

State 452:
## Known stack suffix:
## type_ listc(variable_declarator)
## LR(1) items:
field_declaration -> type_ listc(variable_declarator) . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
listc(variable_declarator) -> listc(variable_declarator) . CM variable_declarator [ SM CM ]
## Transitions:
-- On SM shift to state 453
-- On CM shift to state 454
## Reductions:

State 453:
## Known stack suffix:
## type_ listc(variable_declarator) SM
## LR(1) items:
field_declaration -> type_ listc(variable_declarator) SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production field_declaration -> type_ listc(variable_declarator) SM

State 454:
## Known stack suffix:
## listc(variable_declarator) CM
## LR(1) items:
listc(variable_declarator) -> listc(variable_declarator) CM . variable_declarator [ SM CM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 434
-- On variable_declarator shift to state 455
-- On identifier shift to state 128
## Reductions:

State 455:
## Known stack suffix:
## listc(variable_declarator) CM variable_declarator
## LR(1) items:
listc(variable_declarator) -> listc(variable_declarator) CM variable_declarator . [ SM CM ]
## Transitions:
## Reductions:
-- On SM CM
--   reduce production listc(variable_declarator) -> listc(variable_declarator) CM variable_declarator

State 456:
## Known stack suffix:
## identifier
## LR(1) items:
method_declarator -> identifier . LP listc0(formal_parameter) RP [ THROWS SM LC LB_RB EOF ]
variable_declarator_id -> identifier . [ SM LB_RB EQ CM ]
## Transitions:
-- On LP shift to state 80
## Reductions:
-- On SM LB_RB EQ CM
--   reduce production variable_declarator_id -> identifier

State 457:
## Known stack suffix:
## static_initializer
## LR(1) items:
class_body_declaration -> static_initializer . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_body_declaration -> static_initializer

State 458:
## Known stack suffix:
## modifiers
## LR(1) items:
annotation_type_declaration -> modifiers . AT INTERFACE identifier annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
class_header -> modifiers . CLASS identifier optl(type_parameters) option(super) optl(interfaces) [ LC ]
constructor_declaration -> modifiers . constructor_declarator optl(throws) constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
enum_declaration -> modifiers . ENUM identifier optl(interfaces) enum_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
field_declaration -> modifiers . type_ listc(variable_declarator) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
generic_method_or_constructor_decl -> modifiers . type_parameters type_ identifier formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
generic_method_or_constructor_decl -> modifiers . type_parameters VOID identifier formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
interface_declaration -> modifiers . INTERFACE identifier optl(type_parameters) optl(extends_interfaces) interface_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
method_header -> modifiers . type_ method_declarator optl(throws) [ SM LC ]
method_header -> modifiers . VOID method_declarator optl(throws) [ SM LC ]
modifiers -> modifiers . modifier [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 459
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On LT shift to state 20
-- On INTERFACE shift to state 364
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On ENUM shift to state 372
-- On DEFAULT shift to state 328
-- On CLASS shift to state 376
-- On AT shift to state 381
-- On ABSTRACT shift to state 342
-- On type_parameters shift to state 462
-- On type_ shift to state 473
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifier shift to state 389
-- On identifier_ shift to state 38
-- On identifier shift to state 478
-- On constructor_declarator shift to state 482
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
-- On annotation shift to state 390
## Reductions:

State 459:
## Known stack suffix:
## modifiers VOID
## LR(1) items:
method_header -> modifiers VOID . method_declarator optl(throws) [ SM LC EOF ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On method_declarator shift to state 460
-- On identifier shift to state 79
## Reductions:

State 460:
## Known stack suffix:
## modifiers VOID method_declarator
## LR(1) items:
method_declarator -> method_declarator . LB_RB [ THROWS SM LC LB_RB EOF ]
method_header -> modifiers VOID method_declarator . optl(throws) [ SM LC EOF ]
## Transitions:
-- On THROWS shift to state 71
-- On LB_RB shift to state 76
-- On throws shift to state 77
-- On optl(throws) shift to state 461
## Reductions:
-- On SM LC EOF
--   reduce production optl(throws) ->

State 461:
## Known stack suffix:
## modifiers VOID method_declarator optl(throws)
## LR(1) items:
method_header -> modifiers VOID method_declarator optl(throws) . [ SM LC EOF ]
## Transitions:
## Reductions:
-- On SM LC EOF
--   reduce production method_header -> modifiers VOID method_declarator optl(throws)

State 462:
## Known stack suffix:
## modifiers type_parameters
## LR(1) items:
generic_method_or_constructor_decl -> modifiers type_parameters . type_ identifier formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
generic_method_or_constructor_decl -> modifiers type_parameters . VOID identifier formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On VOID shift to state 463
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On type_ shift to state 468
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 463:
## Known stack suffix:
## modifiers type_parameters VOID
## LR(1) items:
generic_method_or_constructor_decl -> modifiers type_parameters VOID . identifier formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 464
## Reductions:

State 464:
## Known stack suffix:
## modifiers type_parameters VOID identifier
## LR(1) items:
generic_method_or_constructor_decl -> modifiers type_parameters VOID identifier . formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 407
-- On formal_parameters shift to state 465
## Reductions:

State 465:
## Known stack suffix:
## modifiers type_parameters VOID identifier formal_parameters
## LR(1) items:
generic_method_or_constructor_decl -> modifiers type_parameters VOID identifier formal_parameters . optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 71
-- On throws shift to state 77
-- On optl(throws) shift to state 466
## Reductions:
-- On SM LC
--   reduce production optl(throws) ->

State 466:
## Known stack suffix:
## modifiers type_parameters VOID identifier formal_parameters optl(throws)
## LR(1) items:
generic_method_or_constructor_decl -> modifiers type_parameters VOID identifier formal_parameters optl(throws) . method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 425
-- On LC shift to state 233
-- On method_body shift to state 467
-- On block shift to state 427
## Reductions:

State 467:
## Known stack suffix:
## modifiers type_parameters VOID identifier formal_parameters optl(throws) method_body
## LR(1) items:
generic_method_or_constructor_decl -> modifiers type_parameters VOID identifier formal_parameters optl(throws) method_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production generic_method_or_constructor_decl -> modifiers type_parameters VOID identifier formal_parameters optl(throws) method_body

State 468:
## Known stack suffix:
## modifiers type_parameters type_
## LR(1) items:
generic_method_or_constructor_decl -> modifiers type_parameters type_ . identifier formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 469
## Reductions:

State 469:
## Known stack suffix:
## modifiers type_parameters type_ identifier
## LR(1) items:
generic_method_or_constructor_decl -> modifiers type_parameters type_ identifier . formal_parameters optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 407
-- On formal_parameters shift to state 470
## Reductions:

State 470:
## Known stack suffix:
## modifiers type_parameters type_ identifier formal_parameters
## LR(1) items:
generic_method_or_constructor_decl -> modifiers type_parameters type_ identifier formal_parameters . optl(throws) method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 71
-- On throws shift to state 77
-- On optl(throws) shift to state 471
## Reductions:
-- On SM LC
--   reduce production optl(throws) ->

State 471:
## Known stack suffix:
## modifiers type_parameters type_ identifier formal_parameters optl(throws)
## LR(1) items:
generic_method_or_constructor_decl -> modifiers type_parameters type_ identifier formal_parameters optl(throws) . method_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 425
-- On LC shift to state 233
-- On method_body shift to state 472
-- On block shift to state 427
## Reductions:

State 472:
## Known stack suffix:
## modifiers type_parameters type_ identifier formal_parameters optl(throws) method_body
## LR(1) items:
generic_method_or_constructor_decl -> modifiers type_parameters type_ identifier formal_parameters optl(throws) method_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production generic_method_or_constructor_decl -> modifiers type_parameters type_ identifier formal_parameters optl(throws) method_body

State 473:
## Known stack suffix:
## modifiers type_
## LR(1) items:
field_declaration -> modifiers type_ . listc(variable_declarator) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
method_header -> modifiers type_ . method_declarator optl(throws) [ SM LC ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 434
-- On variable_declarator shift to state 449
-- On method_declarator shift to state 474
-- On listc(variable_declarator) shift to state 476
-- On identifier shift to state 456
## Reductions:

State 474:
## Known stack suffix:
## modifiers type_ method_declarator
## LR(1) items:
method_declarator -> method_declarator . LB_RB [ THROWS SM LC LB_RB EOF ]
method_header -> modifiers type_ method_declarator . optl(throws) [ SM LC EOF ]
## Transitions:
-- On THROWS shift to state 71
-- On LB_RB shift to state 76
-- On throws shift to state 77
-- On optl(throws) shift to state 475
## Reductions:
-- On SM LC EOF
--   reduce production optl(throws) ->

State 475:
## Known stack suffix:
## modifiers type_ method_declarator optl(throws)
## LR(1) items:
method_header -> modifiers type_ method_declarator optl(throws) . [ SM LC EOF ]
## Transitions:
## Reductions:
-- On SM LC EOF
--   reduce production method_header -> modifiers type_ method_declarator optl(throws)

State 476:
## Known stack suffix:
## modifiers type_ listc(variable_declarator)
## LR(1) items:
field_declaration -> modifiers type_ listc(variable_declarator) . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
listc(variable_declarator) -> listc(variable_declarator) . CM variable_declarator [ SM CM ]
## Transitions:
-- On SM shift to state 477
-- On CM shift to state 454
## Reductions:

State 477:
## Known stack suffix:
## modifiers type_ listc(variable_declarator) SM
## LR(1) items:
field_declaration -> modifiers type_ listc(variable_declarator) SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production field_declaration -> modifiers type_ listc(variable_declarator) SM

State 478:
## Known stack suffix:
## identifier
## LR(1) items:
constructor_declarator -> identifier . LP listc0(formal_parameter) RP [ THROWS LC ]
identifier_ -> identifier . [ LB_RB IDENTIFIER DOT ]
identifier_ -> identifier . LT_GENERIC listc0(type_argument) GT [ LB_RB IDENTIFIER DOT ]
## Transitions:
-- On LT_GENERIC shift to state 40
-- On LP shift to state 479
## Reductions:
-- On LB_RB IDENTIFIER DOT
--   reduce production identifier_ -> identifier

State 479:
## Known stack suffix:
## identifier LP
## LR(1) items:
constructor_declarator -> identifier LP . listc0(formal_parameter) RP [ THROWS LC ]
## Transitions:
-- On FINAL shift to state 81
-- On DOTS shift to state 82
-- On AT shift to state 83
-- On variable_modifier shift to state 408
-- On optl(listc(formal_parameter)) shift to state 410
-- On listc0(formal_parameter) shift to state 480
-- On listc(formal_parameter) shift to state 413
-- On list(variable_modifier) shift to state 415
-- On formal_parameter shift to state 422
-- On annotation shift to state 113
## Reductions:
-- On PRIMITIVE_TYPE IDENTIFIER
--   reduce production list(variable_modifier) ->
-- On RP
--   reduce production optl(listc(formal_parameter)) ->

State 480:
## Known stack suffix:
## identifier LP listc0(formal_parameter)
## LR(1) items:
constructor_declarator -> identifier LP listc0(formal_parameter) . RP [ THROWS LC ]
## Transitions:
-- On RP shift to state 481
## Reductions:

State 481:
## Known stack suffix:
## identifier LP listc0(formal_parameter) RP
## LR(1) items:
constructor_declarator -> identifier LP listc0(formal_parameter) RP . [ THROWS LC ]
## Transitions:
## Reductions:
-- On THROWS LC
--   reduce production constructor_declarator -> identifier LP listc0(formal_parameter) RP

State 482:
## Known stack suffix:
## modifiers constructor_declarator
## LR(1) items:
constructor_declaration -> modifiers constructor_declarator . optl(throws) constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 71
-- On throws shift to state 77
-- On optl(throws) shift to state 483
## Reductions:
-- On LC
--   reduce production optl(throws) ->

State 483:
## Known stack suffix:
## modifiers constructor_declarator optl(throws)
## LR(1) items:
constructor_declaration -> modifiers constructor_declarator optl(throws) . constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LC shift to state 484
-- On constructor_body shift to state 694
## Reductions:

State 484:
## Known stack suffix:
## LC
## LR(1) items:
constructor_body -> LC . list(block_statement) RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
constructor_body -> LC . explicit_constructor_invocation list(block_statement) RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 234
-- On VOLATILE shift to state 1
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TRANSIENT shift to state 2
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 488
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 493
-- On SWITCH shift to state 498
-- On SUPER shift to state 656
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On NATIVE shift to state 16
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FINAL shift to state 316
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DEFAULT shift to state 328
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On CLASS shift to state 329
-- On BREAK shift to state 585
-- On AT shift to state 83
-- On ASSERT shift to state 588
-- On ABSTRACT shift to state 342
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On type_ shift to state 641
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 642
-- On return_statement shift to state 603
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 663
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 675
-- On modifiers shift to state 644
-- On modifier shift to state 391
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On local_variable_declaration_statement shift to state 646
-- On local_variable_declaration shift to state 647
-- On literal shift to state 187
-- On list(block_statement) shift to state 687
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On explicit_constructor_invocation shift to state 689
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On class_header shift to state 396
-- On class_declaration shift to state 649
-- On break_statement shift to state 615
-- On block_statement shift to state 692
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(block_statement) ->

State 485:
## Known stack suffix:
## THROW
## LR(1) items:
throw_statement -> THROW . expression SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 486
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 486:
## Known stack suffix:
## THROW expression
## LR(1) items:
throw_statement -> THROW expression . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 487
## Reductions:

State 487:
## Known stack suffix:
## THROW expression SM
## LR(1) items:
throw_statement -> THROW expression SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production throw_statement -> THROW expression SM

State 488:
## Known stack suffix:
## THIS
## LR(1) items:
explicit_constructor_invocation -> THIS . LP listc0(argument) RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
primary_no_new_array -> THIS . [ LB INCR DOT DECR COLONCOLON ]
## Transitions:
-- On LP shift to state 489
## Reductions:
-- On LB INCR DOT DECR COLONCOLON
--   reduce production primary_no_new_array -> THIS

State 489:
## Known stack suffix:
## THIS LP
## LR(1) items:
explicit_constructor_invocation -> THIS LP . listc0(argument) RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On optl(listc(argument)) shift to state 224
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc0(argument) shift to state 490
-- On listc(argument) shift to state 300
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 304
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) ->

State 490:
## Known stack suffix:
## THIS LP listc0(argument)
## LR(1) items:
explicit_constructor_invocation -> THIS LP listc0(argument) . RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 491
## Reductions:

State 491:
## Known stack suffix:
## THIS LP listc0(argument) RP
## LR(1) items:
explicit_constructor_invocation -> THIS LP listc0(argument) RP . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 492
## Reductions:

State 492:
## Known stack suffix:
## THIS LP listc0(argument) RP SM
## LR(1) items:
explicit_constructor_invocation -> THIS LP listc0(argument) RP SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production explicit_constructor_invocation -> THIS LP listc0(argument) RP SM

State 493:
## Known stack suffix:
## SYNCHRONIZED
## LR(1) items:
modifier -> SYNCHRONIZED . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
synchronized_statement -> SYNCHRONIZED . LP expression RP block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 494
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> SYNCHRONIZED

State 494:
## Known stack suffix:
## SYNCHRONIZED LP
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LP . expression RP block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 495
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 495:
## Known stack suffix:
## SYNCHRONIZED LP expression
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LP expression . RP block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 496
## Reductions:

State 496:
## Known stack suffix:
## SYNCHRONIZED LP expression RP
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LP expression RP . block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 233
-- On block shift to state 497
## Reductions:

State 497:
## Known stack suffix:
## SYNCHRONIZED LP expression RP block
## LR(1) items:
synchronized_statement -> SYNCHRONIZED LP expression RP block . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production synchronized_statement -> SYNCHRONIZED LP expression RP block

State 498:
## Known stack suffix:
## SWITCH
## LR(1) items:
switch_statement -> SWITCH . LP expression RP switch_block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 499
## Reductions:

State 499:
## Known stack suffix:
## SWITCH LP
## LR(1) items:
switch_statement -> SWITCH LP . expression RP switch_block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 500
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 500:
## Known stack suffix:
## SWITCH LP expression
## LR(1) items:
switch_statement -> SWITCH LP expression . RP switch_block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 501
## Reductions:

State 501:
## Known stack suffix:
## SWITCH LP expression RP
## LR(1) items:
switch_statement -> SWITCH LP expression RP . switch_block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 502
-- On switch_block shift to state 655
## Reductions:

State 502:
## Known stack suffix:
## LC
## LR(1) items:
switch_block -> LC . RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block -> LC . nonempty_list(switch_label) RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block -> LC . switch_block_statement_groups RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block -> LC . switch_block_statement_groups nonempty_list(switch_label) RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RC shift to state 503
-- On DEFAULT_COLON shift to state 504
-- On CASE shift to state 506
-- On switch_label shift to state 510
-- On switch_block_statement_groups shift to state 512
-- On switch_block_statement_group shift to state 652
-- On nonempty_list(switch_label) shift to state 653
## Reductions:

State 503:
## Known stack suffix:
## LC RC
## LR(1) items:
switch_block -> LC RC . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_block -> LC RC

State 504:
## Known stack suffix:
## DEFAULT_COLON
## LR(1) items:
switch_label -> DEFAULT_COLON . COLON [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On COLON shift to state 505
## Reductions:

State 505:
## Known stack suffix:
## DEFAULT_COLON COLON
## LR(1) items:
switch_label -> DEFAULT_COLON COLON . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_label -> DEFAULT_COLON COLON

State 506:
## Known stack suffix:
## CASE
## LR(1) items:
switch_label -> CASE . constant_expression COLON [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 507
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On constant_expression shift to state 508
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 507:
## Known stack suffix:
## expression
## LR(1) items:
constant_expression -> expression . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production constant_expression -> expression

State 508:
## Known stack suffix:
## CASE constant_expression
## LR(1) items:
switch_label -> CASE constant_expression . COLON [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On COLON shift to state 509
## Reductions:

State 509:
## Known stack suffix:
## CASE constant_expression COLON
## LR(1) items:
switch_label -> CASE constant_expression COLON . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_label -> CASE constant_expression COLON

State 510:
## Known stack suffix:
## switch_label
## LR(1) items:
nonempty_list(switch_label) -> switch_label . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
nonempty_list(switch_label) -> switch_label . nonempty_list(switch_label) [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On DEFAULT_COLON shift to state 504
-- On CASE shift to state 506
-- On switch_label shift to state 510
-- On nonempty_list(switch_label) shift to state 511
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production nonempty_list(switch_label) -> switch_label

State 511:
## Known stack suffix:
## switch_label nonempty_list(switch_label)
## LR(1) items:
nonempty_list(switch_label) -> switch_label nonempty_list(switch_label) . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production nonempty_list(switch_label) -> switch_label nonempty_list(switch_label)

State 512:
## Known stack suffix:
## LC switch_block_statement_groups
## LR(1) items:
switch_block -> LC switch_block_statement_groups . RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block -> LC switch_block_statement_groups . nonempty_list(switch_label) RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block_statement_groups -> switch_block_statement_groups . switch_block_statement_group [ RC DEFAULT_COLON CASE ]
## Transitions:
-- On RC shift to state 513
-- On DEFAULT_COLON shift to state 504
-- On CASE shift to state 506
-- On switch_label shift to state 510
-- On switch_block_statement_group shift to state 514
-- On nonempty_list(switch_label) shift to state 515
## Reductions:

State 513:
## Known stack suffix:
## LC switch_block_statement_groups RC
## LR(1) items:
switch_block -> LC switch_block_statement_groups RC . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_block -> LC switch_block_statement_groups RC

State 514:
## Known stack suffix:
## switch_block_statement_groups switch_block_statement_group
## LR(1) items:
switch_block_statement_groups -> switch_block_statement_groups switch_block_statement_group . [ RC DEFAULT_COLON CASE ]
## Transitions:
## Reductions:
-- On RC DEFAULT_COLON CASE
--   reduce production switch_block_statement_groups -> switch_block_statement_groups switch_block_statement_group

State 515:
## Known stack suffix:
## LC switch_block_statement_groups nonempty_list(switch_label)
## LR(1) items:
switch_block -> LC switch_block_statement_groups nonempty_list(switch_label) . RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block_statement_group -> nonempty_list(switch_label) . nonempty_list(block_statement) [ RC DEFAULT_COLON CASE ]
## Transitions:
-- On WHILE shift to state 234
-- On VOLATILE shift to state 1
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TRANSIENT shift to state 2
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 493
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On RC shift to state 521
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On NATIVE shift to state 16
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FINAL shift to state 316
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DEFAULT shift to state 328
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On CLASS shift to state 329
-- On BREAK shift to state 585
-- On AT shift to state 83
-- On ASSERT shift to state 588
-- On ABSTRACT shift to state 342
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On type_ shift to state 641
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 642
-- On return_statement shift to state 603
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On nonempty_list(block_statement) shift to state 643
-- On name shift to state 225
-- On modifiers shift to state 644
-- On modifier shift to state 391
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On local_variable_declaration_statement shift to state 646
-- On local_variable_declaration shift to state 647
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On class_header shift to state 396
-- On class_declaration shift to state 649
-- On break_statement shift to state 615
-- On block_statement shift to state 650
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On annotation shift to state 390
## Reductions:

State 516:
## Known stack suffix:
## SM
## LR(1) items:
empty_statement -> SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
--   reduce production empty_statement -> SM

State 517:
## Known stack suffix:
## RETURN
## LR(1) items:
return_statement -> RETURN . option(expression) SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On option(expression) shift to state 518
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 520
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On SM
--   reduce production option(expression) ->

State 518:
## Known stack suffix:
## RETURN option(expression)
## LR(1) items:
return_statement -> RETURN option(expression) . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 519
## Reductions:

State 519:
## Known stack suffix:
## RETURN option(expression) SM
## LR(1) items:
return_statement -> RETURN option(expression) SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production return_statement -> RETURN option(expression) SM

State 520:
## Known stack suffix:
## expression
## LR(1) items:
option(expression) -> expression . [ SM ]
## Transitions:
## Reductions:
-- On SM
--   reduce production option(expression) -> expression

State 521:
## Known stack suffix:
## LC switch_block_statement_groups nonempty_list(switch_label) RC
## LR(1) items:
switch_block -> LC switch_block_statement_groups nonempty_list(switch_label) RC . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_block -> LC switch_block_statement_groups nonempty_list(switch_label) RC

State 522:
## Known stack suffix:
## IF
## LR(1) items:
if_then_else_statement -> IF . LP expression RP statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_statement -> IF . LP expression RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 523
## Reductions:

State 523:
## Known stack suffix:
## IF LP
## LR(1) items:
if_then_else_statement -> IF LP . expression RP statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_statement -> IF LP . expression RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 524
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 524:
## Known stack suffix:
## IF LP expression
## LR(1) items:
if_then_else_statement -> IF LP expression . RP statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_statement -> IF LP expression . RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 525
## Reductions:

State 525:
## Known stack suffix:
## IF LP expression RP
## LR(1) items:
if_then_else_statement -> IF LP expression RP . statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_statement -> IF LP expression RP . statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 526
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 530
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 531
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 536
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On BREAK shift to state 585
-- On ASSERT shift to state 588
-- On while_statement_no_short_if shift to state 623
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 624
-- On statement_no_short_if shift to state 639
-- On statement_expression shift to state 600
-- On statement shift to state 636
-- On return_statement shift to state 603
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement_no_short_if shift to state 626
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement_no_short_if shift to state 627
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 628
-- On for_statement_no_short_if shift to state 631
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:

State 526:
## Known stack suffix:
## WHILE
## LR(1) items:
while_statement -> WHILE . LP expression RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE . LP expression RP statement_no_short_if [ ELSE ]
## Transitions:
-- On LP shift to state 527
## Reductions:

State 527:
## Known stack suffix:
## WHILE LP
## LR(1) items:
while_statement -> WHILE LP . expression RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE LP . expression RP statement_no_short_if [ ELSE ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 528
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 528:
## Known stack suffix:
## WHILE LP expression
## LR(1) items:
while_statement -> WHILE LP expression . RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE LP expression . RP statement_no_short_if [ ELSE ]
## Transitions:
-- On RP shift to state 529
## Reductions:

State 529:
## Known stack suffix:
## WHILE LP expression RP
## LR(1) items:
while_statement -> WHILE LP expression RP . statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
while_statement_no_short_if -> WHILE LP expression RP . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 526
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 530
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 531
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 536
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On BREAK shift to state 585
-- On ASSERT shift to state 588
-- On while_statement_no_short_if shift to state 623
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 624
-- On statement_no_short_if shift to state 637
-- On statement_expression shift to state 600
-- On statement shift to state 638
-- On return_statement shift to state 603
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement_no_short_if shift to state 626
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement_no_short_if shift to state 627
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 628
-- On for_statement_no_short_if shift to state 631
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:

State 530:
## Known stack suffix:
## SYNCHRONIZED
## LR(1) items:
synchronized_statement -> SYNCHRONIZED . LP expression RP block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 494
## Reductions:

State 531:
## Known stack suffix:
## IF
## LR(1) items:
if_then_else_statement -> IF . LP expression RP statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF . LP expression RP statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF . LP expression RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 532
## Reductions:

State 532:
## Known stack suffix:
## IF LP
## LR(1) items:
if_then_else_statement -> IF LP . expression RP statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LP . expression RP statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF LP . expression RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 533
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 533:
## Known stack suffix:
## IF LP expression
## LR(1) items:
if_then_else_statement -> IF LP expression . RP statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LP expression . RP statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF LP expression . RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 534
## Reductions:

State 534:
## Known stack suffix:
## IF LP expression RP
## LR(1) items:
if_then_else_statement -> IF LP expression RP . statement_no_short_if ELSE statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LP expression RP . statement_no_short_if ELSE statement_no_short_if [ ELSE ]
if_then_statement -> IF LP expression RP . statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 526
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 530
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 531
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 536
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On BREAK shift to state 585
-- On ASSERT shift to state 588
-- On while_statement_no_short_if shift to state 623
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 624
-- On statement_no_short_if shift to state 632
-- On statement_expression shift to state 600
-- On statement shift to state 636
-- On return_statement shift to state 603
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement_no_short_if shift to state 626
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement_no_short_if shift to state 627
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 628
-- On for_statement_no_short_if shift to state 631
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:

State 535:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
identifier -> IDENTIFIER . [ OPERATOR_EQ LT_GENERIC LP LB_RB LB INCR IDENTIFIER EQ DOT DECR COLONCOLON COLON ]
statement_expression -> IDENTIFIER . [ SM RP CM ]
## Transitions:
## Reductions:
-- On OPERATOR_EQ LT_GENERIC LP LB_RB LB INCR IDENTIFIER EQ DOT DECR COLONCOLON COLON
--   reduce production identifier -> IDENTIFIER
-- On SM RP CM
--   reduce production statement_expression -> IDENTIFIER

State 536:
## Known stack suffix:
## FOR
## LR(1) items:
for_statement -> FOR . LP for_control RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
for_statement_no_short_if -> FOR . LP for_control RP statement_no_short_if [ ELSE ]
## Transitions:
-- On LP shift to state 537
## Reductions:

State 537:
## Known stack suffix:
## FOR LP
## LR(1) items:
for_statement -> FOR LP . for_control RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
for_statement_no_short_if -> FOR LP . for_control RP statement_no_short_if [ ELSE ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TRANSIENT shift to state 2
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 3
-- On SUPER shift to state 95
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On NATIVE shift to state 16
-- On LP shift to state 255
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 535
-- On FINAL shift to state 316
-- On FALSE shift to state 144
-- On DOTS shift to state 538
-- On DEFAULT shift to state 328
-- On DECR shift to state 145
-- On AT shift to state 83
-- On ABSTRACT shift to state 342
-- On typed_metavar shift to state 539
-- On type_ shift to state 540
-- On statement_expression shift to state 546
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On modifiers shift to state 552
-- On modifier shift to state 391
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On local_variable_declaration shift to state 558
-- On literal shift to state 187
-- On listc(statement_expression) shift to state 559
-- On left_hand_side shift to state 227
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On for_var_control shift to state 564
-- On for_init_opt shift to state 565
-- On for_init shift to state 572
-- On for_control shift to state 573
-- On field_access shift to state 250
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On assignment shift to state 563
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On annotation shift to state 390
## Reductions:
-- On SM
--   reduce production for_init_opt ->

State 538:
## Known stack suffix:
## DOTS
## LR(1) items:
for_control -> DOTS . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production for_control -> DOTS

State 539:
## Known stack suffix:
## typed_metavar
## LR(1) items:
left_hand_side -> typed_metavar . [ OPERATOR_EQ EQ ]
primary_no_new_array -> typed_metavar . [ XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND ]
statement_expression -> typed_metavar . [ SM RP CM ]
## Transitions:
## Reductions:
-- On OPERATOR_EQ EQ
--   reduce production left_hand_side -> typed_metavar
-- On XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND
--   reduce production primary_no_new_array -> typed_metavar
-- On SM RP CM
--   reduce production statement_expression -> typed_metavar

State 540:
## Known stack suffix:
## type_
## LR(1) items:
for_var_control -> type_ . variable_declarator_id for_var_control_rest [ RP ]
local_variable_declaration -> type_ . listc(variable_declarator) [ SM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 541
-- On variable_declarator shift to state 449
-- On listc(variable_declarator) shift to state 545
-- On identifier shift to state 128
## Reductions:

State 541:
## Known stack suffix:
## type_ variable_declarator_id
## LR(1) items:
for_var_control -> type_ variable_declarator_id . for_var_control_rest [ RP ]
variable_declarator -> variable_declarator_id . [ SM CM ]
variable_declarator -> variable_declarator_id . EQ variable_initializer [ SM CM ]
variable_declarator_id -> variable_declarator_id . LB_RB [ SM LB_RB EQ COLON CM ]
## Transitions:
-- On LB_RB shift to state 127
-- On EQ shift to state 435
-- On COLON shift to state 542
-- On for_var_control_rest shift to state 544
## Reductions:
-- On SM CM
--   reduce production variable_declarator -> variable_declarator_id

State 542:
## Known stack suffix:
## COLON
## LR(1) items:
for_var_control_rest -> COLON . expression [ RP ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 543
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 543:
## Known stack suffix:
## COLON expression
## LR(1) items:
for_var_control_rest -> COLON expression . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production for_var_control_rest -> COLON expression

State 544:
## Known stack suffix:
## type_ variable_declarator_id for_var_control_rest
## LR(1) items:
for_var_control -> type_ variable_declarator_id for_var_control_rest . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production for_var_control -> type_ variable_declarator_id for_var_control_rest

State 545:
## Known stack suffix:
## type_ listc(variable_declarator)
## LR(1) items:
listc(variable_declarator) -> listc(variable_declarator) . CM variable_declarator [ SM CM ]
local_variable_declaration -> type_ listc(variable_declarator) . [ SM ]
## Transitions:
-- On CM shift to state 454
## Reductions:
-- On SM
--   reduce production local_variable_declaration -> type_ listc(variable_declarator)

State 546:
## Known stack suffix:
## statement_expression
## LR(1) items:
listc(statement_expression) -> statement_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On SM RP CM
--   reduce production listc(statement_expression) -> statement_expression

State 547:
## Known stack suffix:
## pre_increment_expression
## LR(1) items:
statement_expression -> pre_increment_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On SM RP CM
--   reduce production statement_expression -> pre_increment_expression

State 548:
## Known stack suffix:
## pre_decrement_expression
## LR(1) items:
statement_expression -> pre_decrement_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On SM RP CM
--   reduce production statement_expression -> pre_decrement_expression

State 549:
## Known stack suffix:
## postfix_expression
## LR(1) items:
post_decrement_expression -> postfix_expression . DECR [ SM RP INCR DECR CM ]
post_increment_expression -> postfix_expression . INCR [ SM RP INCR DECR CM ]
## Transitions:
-- On INCR shift to state 172
-- On DECR shift to state 173
## Reductions:

State 550:
## Known stack suffix:
## post_increment_expression
## LR(1) items:
postfix_expression -> post_increment_expression . [ XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND AND_AND AND ]
statement_expression -> post_increment_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND AND_AND AND
--   reduce production postfix_expression -> post_increment_expression
-- On SM RP CM
--   reduce production statement_expression -> post_increment_expression

State 551:
## Known stack suffix:
## post_decrement_expression
## LR(1) items:
postfix_expression -> post_decrement_expression . [ XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND AND_AND AND ]
statement_expression -> post_decrement_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND AND_AND AND
--   reduce production postfix_expression -> post_decrement_expression
-- On SM RP CM
--   reduce production statement_expression -> post_decrement_expression

State 552:
## Known stack suffix:
## modifiers
## LR(1) items:
for_var_control -> modifiers . type_ variable_declarator_id for_var_control_rest [ RP ]
local_variable_declaration -> modifiers . type_ listc(variable_declarator) [ SM ]
modifiers -> modifiers . modifier [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On DEFAULT shift to state 328
-- On AT shift to state 83
-- On ABSTRACT shift to state 342
-- On type_ shift to state 553
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifier shift to state 389
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
-- On annotation shift to state 390
## Reductions:

State 553:
## Known stack suffix:
## modifiers type_
## LR(1) items:
for_var_control -> modifiers type_ . variable_declarator_id for_var_control_rest [ RP ]
local_variable_declaration -> modifiers type_ . listc(variable_declarator) [ SM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 554
-- On variable_declarator shift to state 449
-- On listc(variable_declarator) shift to state 556
-- On identifier shift to state 128
## Reductions:

State 554:
## Known stack suffix:
## modifiers type_ variable_declarator_id
## LR(1) items:
for_var_control -> modifiers type_ variable_declarator_id . for_var_control_rest [ RP ]
variable_declarator -> variable_declarator_id . [ SM CM ]
variable_declarator -> variable_declarator_id . EQ variable_initializer [ SM CM ]
variable_declarator_id -> variable_declarator_id . LB_RB [ SM LB_RB EQ COLON CM ]
## Transitions:
-- On LB_RB shift to state 127
-- On EQ shift to state 435
-- On COLON shift to state 542
-- On for_var_control_rest shift to state 555
## Reductions:
-- On SM CM
--   reduce production variable_declarator -> variable_declarator_id

State 555:
## Known stack suffix:
## modifiers type_ variable_declarator_id for_var_control_rest
## LR(1) items:
for_var_control -> modifiers type_ variable_declarator_id for_var_control_rest . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production for_var_control -> modifiers type_ variable_declarator_id for_var_control_rest

State 556:
## Known stack suffix:
## modifiers type_ listc(variable_declarator)
## LR(1) items:
listc(variable_declarator) -> listc(variable_declarator) . CM variable_declarator [ SM CM ]
local_variable_declaration -> modifiers type_ listc(variable_declarator) . [ SM ]
## Transitions:
-- On CM shift to state 454
## Reductions:
-- On SM
--   reduce production local_variable_declaration -> modifiers type_ listc(variable_declarator)

State 557:
## Known stack suffix:
## method_invocation
## LR(1) items:
primary_no_new_array -> method_invocation . [ XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND ]
statement_expression -> method_invocation . [ SM RP CM ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND
--   reduce production primary_no_new_array -> method_invocation
-- On SM RP CM
--   reduce production statement_expression -> method_invocation

State 558:
## Known stack suffix:
## local_variable_declaration
## LR(1) items:
for_init -> local_variable_declaration . [ SM ]
## Transitions:
## Reductions:
-- On SM
--   reduce production for_init -> local_variable_declaration

State 559:
## Known stack suffix:
## listc(statement_expression)
## LR(1) items:
for_init -> listc(statement_expression) . [ SM ]
listc(statement_expression) -> listc(statement_expression) . CM statement_expression [ SM CM ]
## Transitions:
-- On CM shift to state 560
## Reductions:
-- On SM
--   reduce production for_init -> listc(statement_expression)

State 560:
## Known stack suffix:
## listc(statement_expression) CM
## LR(1) items:
listc(statement_expression) -> listc(statement_expression) CM . statement_expression [ SM RP CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 535
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On typed_metavar shift to state 539
-- On statement_expression shift to state 561
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:

State 561:
## Known stack suffix:
## listc(statement_expression) CM statement_expression
## LR(1) items:
listc(statement_expression) -> listc(statement_expression) CM statement_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On SM RP CM
--   reduce production listc(statement_expression) -> listc(statement_expression) CM statement_expression

State 562:
## Known stack suffix:
## class_instance_creation_expression
## LR(1) items:
primary_no_new_array -> class_instance_creation_expression . [ XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND ]
statement_expression -> class_instance_creation_expression . [ SM RP CM ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND
--   reduce production primary_no_new_array -> class_instance_creation_expression
-- On SM RP CM
--   reduce production statement_expression -> class_instance_creation_expression

State 563:
## Known stack suffix:
## assignment
## LR(1) items:
statement_expression -> assignment . [ SM RP CM ]
## Transitions:
## Reductions:
-- On SM RP CM
--   reduce production statement_expression -> assignment

State 564:
## Known stack suffix:
## for_var_control
## LR(1) items:
for_control -> for_var_control . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production for_control -> for_var_control

State 565:
## Known stack suffix:
## for_init_opt
## LR(1) items:
for_control -> for_init_opt . SM option(expression) SM optl(for_update) [ RP ]
## Transitions:
-- On SM shift to state 566
## Reductions:

State 566:
## Known stack suffix:
## for_init_opt SM
## LR(1) items:
for_control -> for_init_opt SM . option(expression) SM optl(for_update) [ RP ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On option(expression) shift to state 567
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 520
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On SM
--   reduce production option(expression) ->

State 567:
## Known stack suffix:
## for_init_opt SM option(expression)
## LR(1) items:
for_control -> for_init_opt SM option(expression) . SM optl(for_update) [ RP ]
## Transitions:
-- On SM shift to state 568
## Reductions:

State 568:
## Known stack suffix:
## for_init_opt SM option(expression) SM
## LR(1) items:
for_control -> for_init_opt SM option(expression) SM . optl(for_update) [ RP ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 535
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On typed_metavar shift to state 539
-- On statement_expression shift to state 546
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On optl(for_update) shift to state 569
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On listc(statement_expression) shift to state 570
-- On left_hand_side shift to state 227
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On for_update shift to state 571
-- On field_access shift to state 250
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:
-- On RP
--   reduce production optl(for_update) ->

State 569:
## Known stack suffix:
## for_init_opt SM option(expression) SM optl(for_update)
## LR(1) items:
for_control -> for_init_opt SM option(expression) SM optl(for_update) . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production for_control -> for_init_opt SM option(expression) SM optl(for_update)

State 570:
## Known stack suffix:
## listc(statement_expression)
## LR(1) items:
for_update -> listc(statement_expression) . [ RP ]
listc(statement_expression) -> listc(statement_expression) . CM statement_expression [ RP CM ]
## Transitions:
-- On CM shift to state 560
## Reductions:
-- On RP
--   reduce production for_update -> listc(statement_expression)

State 571:
## Known stack suffix:
## for_update
## LR(1) items:
optl(for_update) -> for_update . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production optl(for_update) -> for_update

State 572:
## Known stack suffix:
## for_init
## LR(1) items:
for_init_opt -> for_init . [ SM ]
## Transitions:
## Reductions:
-- On SM
--   reduce production for_init_opt -> for_init

State 573:
## Known stack suffix:
## FOR LP for_control
## LR(1) items:
for_statement -> FOR LP for_control . RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
for_statement_no_short_if -> FOR LP for_control . RP statement_no_short_if [ ELSE ]
## Transitions:
-- On RP shift to state 574
## Reductions:

State 574:
## Known stack suffix:
## FOR LP for_control RP
## LR(1) items:
for_statement -> FOR LP for_control RP . statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
for_statement_no_short_if -> FOR LP for_control RP . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 526
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 530
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 531
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 536
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On BREAK shift to state 585
-- On ASSERT shift to state 588
-- On while_statement_no_short_if shift to state 623
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 624
-- On statement_no_short_if shift to state 625
-- On statement_expression shift to state 600
-- On statement shift to state 602
-- On return_statement shift to state 603
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement_no_short_if shift to state 626
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement_no_short_if shift to state 627
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 628
-- On for_statement_no_short_if shift to state 631
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:

State 575:
## Known stack suffix:
## DOTS
## LR(1) items:
statement -> DOTS . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> DOTS

State 576:
## Known stack suffix:
## DO
## LR(1) items:
do_statement -> DO . statement WHILE LP expression RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 234
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 530
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On BREAK shift to state 585
-- On ASSERT shift to state 588
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 617
-- On return_statement shift to state 603
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:

State 577:
## Known stack suffix:
## FOR
## LR(1) items:
for_statement -> FOR . LP for_control RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 578
## Reductions:

State 578:
## Known stack suffix:
## FOR LP
## LR(1) items:
for_statement -> FOR LP . for_control RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TRANSIENT shift to state 2
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 3
-- On SUPER shift to state 95
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On NATIVE shift to state 16
-- On LP shift to state 255
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 535
-- On FINAL shift to state 316
-- On FALSE shift to state 144
-- On DOTS shift to state 538
-- On DEFAULT shift to state 328
-- On DECR shift to state 145
-- On AT shift to state 83
-- On ABSTRACT shift to state 342
-- On typed_metavar shift to state 539
-- On type_ shift to state 540
-- On statement_expression shift to state 546
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On modifiers shift to state 552
-- On modifier shift to state 391
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On local_variable_declaration shift to state 558
-- On literal shift to state 187
-- On listc(statement_expression) shift to state 559
-- On left_hand_side shift to state 227
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On for_var_control shift to state 564
-- On for_init_opt shift to state 565
-- On for_init shift to state 572
-- On for_control shift to state 579
-- On field_access shift to state 250
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On assignment shift to state 563
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On annotation shift to state 390
## Reductions:
-- On SM
--   reduce production for_init_opt ->

State 579:
## Known stack suffix:
## FOR LP for_control
## LR(1) items:
for_statement -> FOR LP for_control . RP statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 580
## Reductions:

State 580:
## Known stack suffix:
## FOR LP for_control RP
## LR(1) items:
for_statement -> FOR LP for_control RP . statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 234
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 530
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On BREAK shift to state 585
-- On ASSERT shift to state 588
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 602
-- On return_statement shift to state 603
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:

State 581:
## Known stack suffix:
## CONTINUE
## LR(1) items:
continue_statement -> CONTINUE . option(identifier) SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On option(identifier) shift to state 582
-- On identifier shift to state 584
## Reductions:
-- On SM
--   reduce production option(identifier) ->

State 582:
## Known stack suffix:
## CONTINUE option(identifier)
## LR(1) items:
continue_statement -> CONTINUE option(identifier) . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 583
## Reductions:

State 583:
## Known stack suffix:
## CONTINUE option(identifier) SM
## LR(1) items:
continue_statement -> CONTINUE option(identifier) SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production continue_statement -> CONTINUE option(identifier) SM

State 584:
## Known stack suffix:
## identifier
## LR(1) items:
option(identifier) -> identifier . [ SM ]
## Transitions:
## Reductions:
-- On SM
--   reduce production option(identifier) -> identifier

State 585:
## Known stack suffix:
## BREAK
## LR(1) items:
break_statement -> BREAK . option(identifier) SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On option(identifier) shift to state 586
-- On identifier shift to state 584
## Reductions:
-- On SM
--   reduce production option(identifier) ->

State 586:
## Known stack suffix:
## BREAK option(identifier)
## LR(1) items:
break_statement -> BREAK option(identifier) . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 587
## Reductions:

State 587:
## Known stack suffix:
## BREAK option(identifier) SM
## LR(1) items:
break_statement -> BREAK option(identifier) SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production break_statement -> BREAK option(identifier) SM

State 588:
## Known stack suffix:
## ASSERT
## LR(1) items:
statement_without_trailing_substatement -> ASSERT . expression SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
statement_without_trailing_substatement -> ASSERT . expression COLON expression SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 589
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 589:
## Known stack suffix:
## ASSERT expression
## LR(1) items:
statement_without_trailing_substatement -> ASSERT expression . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
statement_without_trailing_substatement -> ASSERT expression . COLON expression SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 590
-- On COLON shift to state 591
## Reductions:

State 590:
## Known stack suffix:
## ASSERT expression SM
## LR(1) items:
statement_without_trailing_substatement -> ASSERT expression SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> ASSERT expression SM

State 591:
## Known stack suffix:
## ASSERT expression COLON
## LR(1) items:
statement_without_trailing_substatement -> ASSERT expression COLON . expression SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 592
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 592:
## Known stack suffix:
## ASSERT expression COLON expression
## LR(1) items:
statement_without_trailing_substatement -> ASSERT expression COLON expression . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 593
## Reductions:

State 593:
## Known stack suffix:
## ASSERT expression COLON expression SM
## LR(1) items:
statement_without_trailing_substatement -> ASSERT expression COLON expression SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> ASSERT expression COLON expression SM

State 594:
## Known stack suffix:
## while_statement
## LR(1) items:
statement -> while_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> while_statement

State 595:
## Known stack suffix:
## try_statement
## LR(1) items:
statement_without_trailing_substatement -> try_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> try_statement

State 596:
## Known stack suffix:
## throw_statement
## LR(1) items:
statement_without_trailing_substatement -> throw_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> throw_statement

State 597:
## Known stack suffix:
## synchronized_statement
## LR(1) items:
statement_without_trailing_substatement -> synchronized_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> synchronized_statement

State 598:
## Known stack suffix:
## switch_statement
## LR(1) items:
statement_without_trailing_substatement -> switch_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> switch_statement

State 599:
## Known stack suffix:
## statement_without_trailing_substatement
## LR(1) items:
statement -> statement_without_trailing_substatement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> statement_without_trailing_substatement

State 600:
## Known stack suffix:
## statement_expression
## LR(1) items:
expression_statement -> statement_expression . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 601
## Reductions:

State 601:
## Known stack suffix:
## statement_expression SM
## LR(1) items:
expression_statement -> statement_expression SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production expression_statement -> statement_expression SM

State 602:
## Known stack suffix:
## FOR LP for_control RP statement
## LR(1) items:
for_statement -> FOR LP for_control RP statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production for_statement -> FOR LP for_control RP statement

State 603:
## Known stack suffix:
## return_statement
## LR(1) items:
statement_without_trailing_substatement -> return_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> return_statement

State 604:
## Known stack suffix:
## labeled_statement
## LR(1) items:
statement -> labeled_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> labeled_statement

State 605:
## Known stack suffix:
## if_then_statement
## LR(1) items:
statement -> if_then_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> if_then_statement

State 606:
## Known stack suffix:
## if_then_else_statement
## LR(1) items:
statement -> if_then_else_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> if_then_else_statement

State 607:
## Known stack suffix:
## identifier
## LR(1) items:
identifier_ -> identifier . [ XOR URS TIMES SRS PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND ]
identifier_ -> identifier . LT_GENERIC listc0(type_argument) GT [ XOR URS TIMES SRS PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND ]
labeled_statement -> identifier . COLON statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LT_GENERIC shift to state 40
-- On COLON shift to state 608
## Reductions:
-- On XOR URS TIMES SRS PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND
--   reduce production identifier_ -> identifier

State 608:
## Known stack suffix:
## identifier COLON
## LR(1) items:
labeled_statement -> identifier COLON . statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 234
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 530
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On BREAK shift to state 585
-- On ASSERT shift to state 588
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 609
-- On return_statement shift to state 603
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:

State 609:
## Known stack suffix:
## identifier COLON statement
## LR(1) items:
labeled_statement -> identifier COLON statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production labeled_statement -> identifier COLON statement

State 610:
## Known stack suffix:
## for_statement
## LR(1) items:
statement -> for_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> for_statement

State 611:
## Known stack suffix:
## expression_statement
## LR(1) items:
statement_without_trailing_substatement -> expression_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> expression_statement

State 612:
## Known stack suffix:
## empty_statement
## LR(1) items:
statement_without_trailing_substatement -> empty_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> empty_statement

State 613:
## Known stack suffix:
## do_statement
## LR(1) items:
statement_without_trailing_substatement -> do_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> do_statement

State 614:
## Known stack suffix:
## continue_statement
## LR(1) items:
statement_without_trailing_substatement -> continue_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> continue_statement

State 615:
## Known stack suffix:
## break_statement
## LR(1) items:
statement_without_trailing_substatement -> break_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> break_statement

State 616:
## Known stack suffix:
## block
## LR(1) items:
statement_without_trailing_substatement -> block . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement_without_trailing_substatement -> block

State 617:
## Known stack suffix:
## DO statement
## LR(1) items:
do_statement -> DO statement . WHILE LP expression RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 618
## Reductions:

State 618:
## Known stack suffix:
## DO statement WHILE
## LR(1) items:
do_statement -> DO statement WHILE . LP expression RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 619
## Reductions:

State 619:
## Known stack suffix:
## DO statement WHILE LP
## LR(1) items:
do_statement -> DO statement WHILE LP . expression RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 620
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 620:
## Known stack suffix:
## DO statement WHILE LP expression
## LR(1) items:
do_statement -> DO statement WHILE LP expression . RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 621
## Reductions:

State 621:
## Known stack suffix:
## DO statement WHILE LP expression RP
## LR(1) items:
do_statement -> DO statement WHILE LP expression RP . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 622
## Reductions:

State 622:
## Known stack suffix:
## DO statement WHILE LP expression RP SM
## LR(1) items:
do_statement -> DO statement WHILE LP expression RP SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production do_statement -> DO statement WHILE LP expression RP SM

State 623:
## Known stack suffix:
## while_statement_no_short_if
## LR(1) items:
statement_no_short_if -> while_statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production statement_no_short_if -> while_statement_no_short_if

State 624:
## Known stack suffix:
## statement_without_trailing_substatement
## LR(1) items:
statement -> statement_without_trailing_substatement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
statement_no_short_if -> statement_without_trailing_substatement . [ ELSE ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production statement -> statement_without_trailing_substatement
-- On ELSE
--   reduce production statement_no_short_if -> statement_without_trailing_substatement

State 625:
## Known stack suffix:
## FOR LP for_control RP statement_no_short_if
## LR(1) items:
for_statement_no_short_if -> FOR LP for_control RP statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production for_statement_no_short_if -> FOR LP for_control RP statement_no_short_if

State 626:
## Known stack suffix:
## labeled_statement_no_short_if
## LR(1) items:
statement_no_short_if -> labeled_statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production statement_no_short_if -> labeled_statement_no_short_if

State 627:
## Known stack suffix:
## if_then_else_statement_no_short_if
## LR(1) items:
statement_no_short_if -> if_then_else_statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production statement_no_short_if -> if_then_else_statement_no_short_if

State 628:
## Known stack suffix:
## identifier
## LR(1) items:
identifier_ -> identifier . [ OPERATOR_EQ LP LB_RB LB INCR EQ DOT DECR COLONCOLON ]
identifier_ -> identifier . LT_GENERIC listc0(type_argument) GT [ OPERATOR_EQ LP LB_RB LB INCR EQ DOT DECR COLONCOLON ]
labeled_statement -> identifier . COLON statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
labeled_statement_no_short_if -> identifier . COLON statement_no_short_if [ ELSE ]
## Transitions:
-- On LT_GENERIC shift to state 40
-- On COLON shift to state 629
## Reductions:
-- On OPERATOR_EQ LP LB_RB LB INCR EQ DOT DECR COLONCOLON
--   reduce production identifier_ -> identifier

State 629:
## Known stack suffix:
## identifier COLON
## LR(1) items:
labeled_statement -> identifier COLON . statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
labeled_statement_no_short_if -> identifier COLON . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 526
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 530
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 531
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 536
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On BREAK shift to state 585
-- On ASSERT shift to state 588
-- On while_statement_no_short_if shift to state 623
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 624
-- On statement_no_short_if shift to state 630
-- On statement_expression shift to state 600
-- On statement shift to state 609
-- On return_statement shift to state 603
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement_no_short_if shift to state 626
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement_no_short_if shift to state 627
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 628
-- On for_statement_no_short_if shift to state 631
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:

State 630:
## Known stack suffix:
## identifier COLON statement_no_short_if
## LR(1) items:
labeled_statement_no_short_if -> identifier COLON statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production labeled_statement_no_short_if -> identifier COLON statement_no_short_if

State 631:
## Known stack suffix:
## for_statement_no_short_if
## LR(1) items:
statement_no_short_if -> for_statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production statement_no_short_if -> for_statement_no_short_if

State 632:
## Known stack suffix:
## IF LP expression RP statement_no_short_if
## LR(1) items:
if_then_else_statement -> IF LP expression RP statement_no_short_if . ELSE statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LP expression RP statement_no_short_if . ELSE statement_no_short_if [ ELSE ]
## Transitions:
-- On ELSE shift to state 633
## Reductions:

State 633:
## Known stack suffix:
## IF LP expression RP statement_no_short_if ELSE
## LR(1) items:
if_then_else_statement -> IF LP expression RP statement_no_short_if ELSE . statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
if_then_else_statement_no_short_if -> IF LP expression RP statement_no_short_if ELSE . statement_no_short_if [ ELSE ]
## Transitions:
-- On WHILE shift to state 526
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 530
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 531
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 536
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On BREAK shift to state 585
-- On ASSERT shift to state 588
-- On while_statement_no_short_if shift to state 623
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 624
-- On statement_no_short_if shift to state 634
-- On statement_expression shift to state 600
-- On statement shift to state 635
-- On return_statement shift to state 603
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement_no_short_if shift to state 626
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement_no_short_if shift to state 627
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 628
-- On for_statement_no_short_if shift to state 631
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:

State 634:
## Known stack suffix:
## IF LP expression RP statement_no_short_if ELSE statement_no_short_if
## LR(1) items:
if_then_else_statement_no_short_if -> IF LP expression RP statement_no_short_if ELSE statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production if_then_else_statement_no_short_if -> IF LP expression RP statement_no_short_if ELSE statement_no_short_if

State 635:
## Known stack suffix:
## IF LP expression RP statement_no_short_if ELSE statement
## LR(1) items:
if_then_else_statement -> IF LP expression RP statement_no_short_if ELSE statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production if_then_else_statement -> IF LP expression RP statement_no_short_if ELSE statement

State 636:
## Known stack suffix:
## IF LP expression RP statement
## LR(1) items:
if_then_statement -> IF LP expression RP statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production if_then_statement -> IF LP expression RP statement

State 637:
## Known stack suffix:
## WHILE LP expression RP statement_no_short_if
## LR(1) items:
while_statement_no_short_if -> WHILE LP expression RP statement_no_short_if . [ ELSE ]
## Transitions:
## Reductions:
-- On ELSE
--   reduce production while_statement_no_short_if -> WHILE LP expression RP statement_no_short_if

State 638:
## Known stack suffix:
## WHILE LP expression RP statement
## LR(1) items:
while_statement -> WHILE LP expression RP statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production while_statement -> WHILE LP expression RP statement

State 639:
## Known stack suffix:
## IF LP expression RP statement_no_short_if
## LR(1) items:
if_then_else_statement -> IF LP expression RP statement_no_short_if . ELSE statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On ELSE shift to state 640
## Reductions:

State 640:
## Known stack suffix:
## IF LP expression RP statement_no_short_if ELSE
## LR(1) items:
if_then_else_statement -> IF LP expression RP statement_no_short_if ELSE . statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 234
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 530
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On BREAK shift to state 585
-- On ASSERT shift to state 588
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 635
-- On return_statement shift to state 603
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
## Reductions:

State 641:
## Known stack suffix:
## type_
## LR(1) items:
local_variable_declaration -> type_ . listc(variable_declarator) [ SM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 434
-- On variable_declarator shift to state 449
-- On listc(variable_declarator) shift to state 545
-- On identifier shift to state 128
## Reductions:

State 642:
## Known stack suffix:
## statement
## LR(1) items:
block_statement -> statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production block_statement -> statement

State 643:
## Known stack suffix:
## nonempty_list(switch_label) nonempty_list(block_statement)
## LR(1) items:
switch_block_statement_group -> nonempty_list(switch_label) nonempty_list(block_statement) . [ RC DEFAULT_COLON CASE ]
## Transitions:
## Reductions:
-- On RC DEFAULT_COLON CASE
--   reduce production switch_block_statement_group -> nonempty_list(switch_label) nonempty_list(block_statement)

State 644:
## Known stack suffix:
## modifiers
## LR(1) items:
class_header -> modifiers . CLASS identifier optl(type_parameters) option(super) optl(interfaces) [ LC ]
local_variable_declaration -> modifiers . type_ listc(variable_declarator) [ SM ]
modifiers -> modifiers . modifier [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On DEFAULT shift to state 328
-- On CLASS shift to state 376
-- On AT shift to state 83
-- On ABSTRACT shift to state 342
-- On type_ shift to state 645
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifier shift to state 389
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
-- On annotation shift to state 390
## Reductions:

State 645:
## Known stack suffix:
## modifiers type_
## LR(1) items:
local_variable_declaration -> modifiers type_ . listc(variable_declarator) [ SM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 434
-- On variable_declarator shift to state 449
-- On listc(variable_declarator) shift to state 556
-- On identifier shift to state 128
## Reductions:

State 646:
## Known stack suffix:
## local_variable_declaration_statement
## LR(1) items:
block_statement -> local_variable_declaration_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production block_statement -> local_variable_declaration_statement

State 647:
## Known stack suffix:
## local_variable_declaration
## LR(1) items:
local_variable_declaration_statement -> local_variable_declaration . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 648
## Reductions:

State 648:
## Known stack suffix:
## local_variable_declaration SM
## LR(1) items:
local_variable_declaration_statement -> local_variable_declaration SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production local_variable_declaration_statement -> local_variable_declaration SM

State 649:
## Known stack suffix:
## class_declaration
## LR(1) items:
block_statement -> class_declaration . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production block_statement -> class_declaration

State 650:
## Known stack suffix:
## block_statement
## LR(1) items:
nonempty_list(block_statement) -> block_statement . [ RC DEFAULT_COLON CASE ]
nonempty_list(block_statement) -> block_statement . nonempty_list(block_statement) [ RC DEFAULT_COLON CASE ]
## Transitions:
-- On WHILE shift to state 234
-- On VOLATILE shift to state 1
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TRANSIENT shift to state 2
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 493
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On NATIVE shift to state 16
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FINAL shift to state 316
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DEFAULT shift to state 328
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On CLASS shift to state 329
-- On BREAK shift to state 585
-- On AT shift to state 83
-- On ASSERT shift to state 588
-- On ABSTRACT shift to state 342
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On type_ shift to state 641
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 642
-- On return_statement shift to state 603
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On nonempty_list(block_statement) shift to state 651
-- On name shift to state 225
-- On modifiers shift to state 644
-- On modifier shift to state 391
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On local_variable_declaration_statement shift to state 646
-- On local_variable_declaration shift to state 647
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On class_header shift to state 396
-- On class_declaration shift to state 649
-- On break_statement shift to state 615
-- On block_statement shift to state 650
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On annotation shift to state 390
## Reductions:
-- On RC DEFAULT_COLON CASE
--   reduce production nonempty_list(block_statement) -> block_statement

State 651:
## Known stack suffix:
## block_statement nonempty_list(block_statement)
## LR(1) items:
nonempty_list(block_statement) -> block_statement nonempty_list(block_statement) . [ RC DEFAULT_COLON CASE ]
## Transitions:
## Reductions:
-- On RC DEFAULT_COLON CASE
--   reduce production nonempty_list(block_statement) -> block_statement nonempty_list(block_statement)

State 652:
## Known stack suffix:
## switch_block_statement_group
## LR(1) items:
switch_block_statement_groups -> switch_block_statement_group . [ RC DEFAULT_COLON CASE ]
## Transitions:
## Reductions:
-- On RC DEFAULT_COLON CASE
--   reduce production switch_block_statement_groups -> switch_block_statement_group

State 653:
## Known stack suffix:
## LC nonempty_list(switch_label)
## LR(1) items:
switch_block -> LC nonempty_list(switch_label) . RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
switch_block_statement_group -> nonempty_list(switch_label) . nonempty_list(block_statement) [ RC DEFAULT_COLON CASE ]
## Transitions:
-- On WHILE shift to state 234
-- On VOLATILE shift to state 1
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TRANSIENT shift to state 2
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 493
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On RC shift to state 654
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On NATIVE shift to state 16
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FINAL shift to state 316
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DEFAULT shift to state 328
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On CLASS shift to state 329
-- On BREAK shift to state 585
-- On AT shift to state 83
-- On ASSERT shift to state 588
-- On ABSTRACT shift to state 342
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On type_ shift to state 641
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 642
-- On return_statement shift to state 603
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On nonempty_list(block_statement) shift to state 643
-- On name shift to state 225
-- On modifiers shift to state 644
-- On modifier shift to state 391
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On local_variable_declaration_statement shift to state 646
-- On local_variable_declaration shift to state 647
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On class_header shift to state 396
-- On class_declaration shift to state 649
-- On break_statement shift to state 615
-- On block_statement shift to state 650
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On annotation shift to state 390
## Reductions:

State 654:
## Known stack suffix:
## LC nonempty_list(switch_label) RC
## LR(1) items:
switch_block -> LC nonempty_list(switch_label) RC . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_block -> LC nonempty_list(switch_label) RC

State 655:
## Known stack suffix:
## SWITCH LP expression RP switch_block
## LR(1) items:
switch_statement -> SWITCH LP expression RP switch_block . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production switch_statement -> SWITCH LP expression RP switch_block

State 656:
## Known stack suffix:
## SUPER
## LR(1) items:
explicit_constructor_invocation -> SUPER . LP listc0(argument) RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
field_access -> SUPER . DOT identifier [ OPERATOR_EQ LB INCR EQ DOT DECR COLONCOLON ]
method_invocation -> SUPER . DOT identifier LP listc0(argument) RP [ SM LB INCR DOT DECR COLONCOLON ]
method_reference -> SUPER . COLONCOLON identifier [ LB INCR DOT DECR COLONCOLON ]
## Transitions:
-- On LP shift to state 657
-- On DOT shift to state 96
-- On COLONCOLON shift to state 661
## Reductions:

State 657:
## Known stack suffix:
## SUPER LP
## LR(1) items:
explicit_constructor_invocation -> SUPER LP . listc0(argument) RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On optl(listc(argument)) shift to state 224
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc0(argument) shift to state 658
-- On listc(argument) shift to state 300
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 304
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) ->

State 658:
## Known stack suffix:
## SUPER LP listc0(argument)
## LR(1) items:
explicit_constructor_invocation -> SUPER LP listc0(argument) . RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 659
## Reductions:

State 659:
## Known stack suffix:
## SUPER LP listc0(argument) RP
## LR(1) items:
explicit_constructor_invocation -> SUPER LP listc0(argument) RP . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 660
## Reductions:

State 660:
## Known stack suffix:
## SUPER LP listc0(argument) RP SM
## LR(1) items:
explicit_constructor_invocation -> SUPER LP listc0(argument) RP SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production explicit_constructor_invocation -> SUPER LP listc0(argument) RP SM

State 661:
## Known stack suffix:
## SUPER COLONCOLON
## LR(1) items:
method_reference -> SUPER COLONCOLON . identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 662
## Reductions:

State 662:
## Known stack suffix:
## SUPER COLONCOLON identifier
## LR(1) items:
method_reference -> SUPER COLONCOLON identifier . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_reference -> SUPER COLONCOLON identifier

State 663:
## Known stack suffix:
## primary
## LR(1) items:
class_instance_creation_expression -> primary . DOT NEW identifier LP listc0(argument) RP option(class_body) [ SM LB INCR DOT DECR COLONCOLON ]
explicit_constructor_invocation -> primary . DOT SUPER LP listc0(argument) RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
field_access -> primary . DOT identifier [ OPERATOR_EQ LB INCR EQ DOT DECR COLONCOLON ]
method_invocation -> primary . DOT identifier LP listc0(argument) RP [ SM LB INCR DOT DECR COLONCOLON ]
method_invocation -> primary . DOT DOTS [ SM LB INCR DOT DECR COLONCOLON ]
method_reference -> primary . COLONCOLON identifier [ LB INCR DOT DECR COLONCOLON ]
postfix_expression -> primary . [ INCR DECR ]
## Transitions:
-- On DOT shift to state 664
-- On COLONCOLON shift to state 284
## Reductions:
-- On INCR DECR
--   reduce production postfix_expression -> primary

State 664:
## Known stack suffix:
## primary DOT
## LR(1) items:
class_instance_creation_expression -> primary DOT . NEW identifier LP listc0(argument) RP option(class_body) [ SM LB INCR DOT DECR COLONCOLON ]
explicit_constructor_invocation -> primary DOT . SUPER LP listc0(argument) RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
field_access -> primary DOT . identifier [ OPERATOR_EQ LB INCR EQ DOT DECR COLONCOLON ]
method_invocation -> primary DOT . identifier LP listc0(argument) RP [ SM LB INCR DOT DECR COLONCOLON ]
method_invocation -> primary DOT . DOTS [ SM LB INCR DOT DECR COLONCOLON ]
## Transitions:
-- On SUPER shift to state 665
-- On NEW shift to state 161
-- On IDENTIFIER shift to state 18
-- On DOTS shift to state 670
-- On identifier shift to state 671
## Reductions:

State 665:
## Known stack suffix:
## primary DOT SUPER
## LR(1) items:
explicit_constructor_invocation -> primary DOT SUPER . LP listc0(argument) RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 666
## Reductions:

State 666:
## Known stack suffix:
## primary DOT SUPER LP
## LR(1) items:
explicit_constructor_invocation -> primary DOT SUPER LP . listc0(argument) RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On optl(listc(argument)) shift to state 224
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc0(argument) shift to state 667
-- On listc(argument) shift to state 300
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 304
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) ->

State 667:
## Known stack suffix:
## primary DOT SUPER LP listc0(argument)
## LR(1) items:
explicit_constructor_invocation -> primary DOT SUPER LP listc0(argument) . RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 668
## Reductions:

State 668:
## Known stack suffix:
## primary DOT SUPER LP listc0(argument) RP
## LR(1) items:
explicit_constructor_invocation -> primary DOT SUPER LP listc0(argument) RP . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 669
## Reductions:

State 669:
## Known stack suffix:
## primary DOT SUPER LP listc0(argument) RP SM
## LR(1) items:
explicit_constructor_invocation -> primary DOT SUPER LP listc0(argument) RP SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production explicit_constructor_invocation -> primary DOT SUPER LP listc0(argument) RP SM

State 670:
## Known stack suffix:
## primary DOT DOTS
## LR(1) items:
method_invocation -> primary DOT DOTS . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_invocation -> primary DOT DOTS

State 671:
## Known stack suffix:
## primary DOT identifier
## LR(1) items:
field_access -> primary DOT identifier . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_invocation -> primary DOT identifier . LP listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LP shift to state 672
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production field_access -> primary DOT identifier

State 672:
## Known stack suffix:
## primary DOT identifier LP
## LR(1) items:
method_invocation -> primary DOT identifier LP . listc0(argument) RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On optl(listc(argument)) shift to state 224
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc0(argument) shift to state 673
-- On listc(argument) shift to state 300
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 304
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) ->

State 673:
## Known stack suffix:
## primary DOT identifier LP listc0(argument)
## LR(1) items:
method_invocation -> primary DOT identifier LP listc0(argument) . RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 674
## Reductions:

State 674:
## Known stack suffix:
## primary DOT identifier LP listc0(argument) RP
## LR(1) items:
method_invocation -> primary DOT identifier LP listc0(argument) RP . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_invocation -> primary DOT identifier LP listc0(argument) RP

State 675:
## Known stack suffix:
## name
## LR(1) items:
array_access -> name . LB expression RB [ OPERATOR_EQ LB INCR EQ DOT DECR COLONCOLON ]
class_instance_creation_expression -> name . DOT NEW identifier LP listc0(argument) RP option(class_body) [ SM LB INCR DOT DECR COLONCOLON ]
class_literal -> name . DOT CLASS [ LB INCR DOT DECR COLONCOLON ]
class_or_interface_type -> name . [ LB_RB IDENTIFIER ]
explicit_constructor_invocation -> name . DOT SUPER LP listc0(argument) RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
field_access -> name . DOT SUPER DOT identifier [ OPERATOR_EQ LB INCR EQ DOT DECR COLONCOLON ]
left_hand_side -> name . [ OPERATOR_EQ EQ ]
method_invocation -> name . LP listc0(argument) RP [ SM LB INCR DOT DECR COLONCOLON ]
method_invocation -> name . DOT SUPER DOT identifier LP listc0(argument) RP [ SM LB INCR DOT DECR COLONCOLON ]
method_invocation -> name . DOT DOTS [ SM LB INCR DOT DECR COLONCOLON ]
method_reference -> name . COLONCOLON identifier [ LB INCR DOT DECR COLONCOLON ]
method_reference -> name . COLONCOLON NEW [ LB INCR DOT DECR COLONCOLON ]
method_reference -> name . DOT SUPER COLONCOLON identifier [ LB INCR DOT DECR COLONCOLON ]
name -> name . DOT identifier_ [ OPERATOR_EQ LP LB_RB LB INCR IDENTIFIER EQ DOT DECR COLONCOLON ]
name -> name . DOT LT_GENERIC listc(type_argument) GT identifier_ [ OPERATOR_EQ LP LB_RB LB INCR IDENTIFIER EQ DOT DECR COLONCOLON ]
postfix_expression -> name . [ INCR DECR ]
primary_no_new_array -> name . DOT THIS [ LB INCR DOT DECR COLONCOLON ]
## Transitions:
-- On LP shift to state 177
-- On LB shift to state 226
-- On DOT shift to state 676
-- On COLONCOLON shift to state 684
## Reductions:
-- On LB_RB IDENTIFIER
--   reduce production class_or_interface_type -> name
-- On OPERATOR_EQ EQ
--   reduce production left_hand_side -> name
-- On INCR DECR
--   reduce production postfix_expression -> name

State 676:
## Known stack suffix:
## name DOT
## LR(1) items:
class_instance_creation_expression -> name DOT . NEW identifier LP listc0(argument) RP option(class_body) [ SM LB INCR DOT DECR COLONCOLON ]
class_literal -> name DOT . CLASS [ LB INCR DOT DECR COLONCOLON ]
explicit_constructor_invocation -> name DOT . SUPER LP listc0(argument) RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
field_access -> name DOT . SUPER DOT identifier [ OPERATOR_EQ LB INCR EQ DOT DECR COLONCOLON ]
method_invocation -> name DOT . SUPER DOT identifier LP listc0(argument) RP [ SM LB INCR DOT DECR COLONCOLON ]
method_invocation -> name DOT . DOTS [ SM LB INCR DOT DECR COLONCOLON ]
method_reference -> name DOT . SUPER COLONCOLON identifier [ LB INCR DOT DECR COLONCOLON ]
name -> name DOT . identifier_ [ OPERATOR_EQ LP LB_RB LB INCR IDENTIFIER EQ DOT DECR COLONCOLON ]
name -> name DOT . LT_GENERIC listc(type_argument) GT identifier_ [ OPERATOR_EQ LP LB_RB LB INCR IDENTIFIER EQ DOT DECR COLONCOLON ]
primary_no_new_array -> name DOT . THIS [ LB INCR DOT DECR COLONCOLON ]
## Transitions:
-- On THIS shift to state 293
-- On SUPER shift to state 677
-- On NEW shift to state 307
-- On LT_GENERIC shift to state 34
-- On IDENTIFIER shift to state 18
-- On DOTS shift to state 682
-- On CLASS shift to state 683
-- On identifier_ shift to state 58
-- On identifier shift to state 39
## Reductions:

State 677:
## Known stack suffix:
## name DOT SUPER
## LR(1) items:
explicit_constructor_invocation -> name DOT SUPER . LP listc0(argument) RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
field_access -> name DOT SUPER . DOT identifier [ OPERATOR_EQ LB INCR EQ DOT DECR COLONCOLON ]
method_invocation -> name DOT SUPER . DOT identifier LP listc0(argument) RP [ SM LB INCR DOT DECR COLONCOLON ]
method_reference -> name DOT SUPER . COLONCOLON identifier [ LB INCR DOT DECR COLONCOLON ]
## Transitions:
-- On LP shift to state 678
-- On DOT shift to state 295
-- On COLONCOLON shift to state 305
## Reductions:

State 678:
## Known stack suffix:
## name DOT SUPER LP
## LR(1) items:
explicit_constructor_invocation -> name DOT SUPER LP . listc0(argument) RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On optl(listc(argument)) shift to state 224
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc0(argument) shift to state 679
-- On listc(argument) shift to state 300
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 304
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) ->

State 679:
## Known stack suffix:
## name DOT SUPER LP listc0(argument)
## LR(1) items:
explicit_constructor_invocation -> name DOT SUPER LP listc0(argument) . RP SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 680
## Reductions:

State 680:
## Known stack suffix:
## name DOT SUPER LP listc0(argument) RP
## LR(1) items:
explicit_constructor_invocation -> name DOT SUPER LP listc0(argument) RP . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 681
## Reductions:

State 681:
## Known stack suffix:
## name DOT SUPER LP listc0(argument) RP SM
## LR(1) items:
explicit_constructor_invocation -> name DOT SUPER LP listc0(argument) RP SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production explicit_constructor_invocation -> name DOT SUPER LP listc0(argument) RP SM

State 682:
## Known stack suffix:
## name DOT DOTS
## LR(1) items:
method_invocation -> name DOT DOTS . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_invocation -> name DOT DOTS

State 683:
## Known stack suffix:
## name DOT CLASS
## LR(1) items:
class_literal -> name DOT CLASS . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production class_literal -> name DOT CLASS

State 684:
## Known stack suffix:
## name COLONCOLON
## LR(1) items:
method_reference -> name COLONCOLON . identifier [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
method_reference -> name COLONCOLON . NEW [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On NEW shift to state 685
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 686
## Reductions:

State 685:
## Known stack suffix:
## name COLONCOLON NEW
## LR(1) items:
method_reference -> name COLONCOLON NEW . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_reference -> name COLONCOLON NEW

State 686:
## Known stack suffix:
## name COLONCOLON identifier
## LR(1) items:
method_reference -> name COLONCOLON identifier . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_reference -> name COLONCOLON identifier

State 687:
## Known stack suffix:
## LC list(block_statement)
## LR(1) items:
constructor_body -> LC list(block_statement) . RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On RC shift to state 688
## Reductions:

State 688:
## Known stack suffix:
## LC list(block_statement) RC
## LR(1) items:
constructor_body -> LC list(block_statement) RC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production constructor_body -> LC list(block_statement) RC

State 689:
## Known stack suffix:
## LC explicit_constructor_invocation
## LR(1) items:
constructor_body -> LC explicit_constructor_invocation . list(block_statement) RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On WHILE shift to state 234
-- On VOLATILE shift to state 1
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TRANSIENT shift to state 2
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 493
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On NATIVE shift to state 16
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FINAL shift to state 316
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DEFAULT shift to state 328
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On CLASS shift to state 329
-- On BREAK shift to state 585
-- On AT shift to state 83
-- On ASSERT shift to state 588
-- On ABSTRACT shift to state 342
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On type_ shift to state 641
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 642
-- On return_statement shift to state 603
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On modifiers shift to state 644
-- On modifier shift to state 391
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On local_variable_declaration_statement shift to state 646
-- On local_variable_declaration shift to state 647
-- On literal shift to state 187
-- On list(block_statement) shift to state 690
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On class_header shift to state 396
-- On class_declaration shift to state 649
-- On break_statement shift to state 615
-- On block_statement shift to state 692
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(block_statement) ->

State 690:
## Known stack suffix:
## LC explicit_constructor_invocation list(block_statement)
## LR(1) items:
constructor_body -> LC explicit_constructor_invocation list(block_statement) . RC [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On RC shift to state 691
## Reductions:

State 691:
## Known stack suffix:
## LC explicit_constructor_invocation list(block_statement) RC
## LR(1) items:
constructor_body -> LC explicit_constructor_invocation list(block_statement) RC . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production constructor_body -> LC explicit_constructor_invocation list(block_statement) RC

State 692:
## Known stack suffix:
## block_statement
## LR(1) items:
list(block_statement) -> block_statement . list(block_statement) [ RC ]
## Transitions:
-- On WHILE shift to state 234
-- On VOLATILE shift to state 1
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TRANSIENT shift to state 2
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 493
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On NATIVE shift to state 16
-- On LP shift to state 255
-- On LC shift to state 233
-- On INCR shift to state 143
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FINAL shift to state 316
-- On FALSE shift to state 144
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DEFAULT shift to state 328
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On CLASS shift to state 329
-- On BREAK shift to state 585
-- On AT shift to state 83
-- On ASSERT shift to state 588
-- On ABSTRACT shift to state 342
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On type_ shift to state 641
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 642
-- On return_statement shift to state 603
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On name shift to state 225
-- On modifiers shift to state 644
-- On modifier shift to state 391
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On local_variable_declaration_statement shift to state 646
-- On local_variable_declaration shift to state 647
-- On literal shift to state 187
-- On list(block_statement) shift to state 693
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On class_header shift to state 396
-- On class_declaration shift to state 649
-- On break_statement shift to state 615
-- On block_statement shift to state 692
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(block_statement) ->

State 693:
## Known stack suffix:
## block_statement list(block_statement)
## LR(1) items:
list(block_statement) -> block_statement list(block_statement) . [ RC ]
## Transitions:
## Reductions:
-- On RC
--   reduce production list(block_statement) -> block_statement list(block_statement)

State 694:
## Known stack suffix:
## modifiers constructor_declarator optl(throws) constructor_body
## LR(1) items:
constructor_declaration -> modifiers constructor_declarator optl(throws) constructor_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production constructor_declaration -> modifiers constructor_declarator optl(throws) constructor_body

State 695:
## Known stack suffix:
## method_header
## LR(1) items:
method_declaration -> method_header . method_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 425
-- On LC shift to state 233
-- On method_body shift to state 696
-- On block shift to state 427
## Reductions:

State 696:
## Known stack suffix:
## method_header method_body
## LR(1) items:
method_declaration -> method_header method_body . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production method_declaration -> method_header method_body

State 697:
## Known stack suffix:
## method_declaration
## LR(1) items:
class_member_declaration -> method_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_member_declaration -> method_declaration

State 698:
## Known stack suffix:
## SM list(class_body_declaration)
## LR(1) items:
enum_body_declarations -> SM list(class_body_declaration) . [ RC ]
## Transitions:
## Reductions:
-- On RC
--   reduce production enum_body_declarations -> SM list(class_body_declaration)

State 699:
## Known stack suffix:
## interface_declaration
## LR(1) items:
class_member_declaration -> interface_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_member_declaration -> interface_declaration

State 700:
## Known stack suffix:
## instance_initializer
## LR(1) items:
class_body_declaration -> instance_initializer . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_body_declaration -> instance_initializer

State 701:
## Known stack suffix:
## generic_method_or_constructor_decl
## LR(1) items:
class_member_declaration -> generic_method_or_constructor_decl . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_member_declaration -> generic_method_or_constructor_decl

State 702:
## Known stack suffix:
## field_declaration
## LR(1) items:
class_member_declaration -> field_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_member_declaration -> field_declaration

State 703:
## Known stack suffix:
## enum_declaration
## LR(1) items:
class_member_declaration -> enum_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_member_declaration -> enum_declaration

State 704:
## Known stack suffix:
## constructor_declarator
## LR(1) items:
constructor_declaration -> constructor_declarator . optl(throws) constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 71
-- On throws shift to state 77
-- On optl(throws) shift to state 705
## Reductions:
-- On LC
--   reduce production optl(throws) ->

State 705:
## Known stack suffix:
## constructor_declarator optl(throws)
## LR(1) items:
constructor_declaration -> constructor_declarator optl(throws) . constructor_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LC shift to state 484
-- On constructor_body shift to state 706
## Reductions:

State 706:
## Known stack suffix:
## constructor_declarator optl(throws) constructor_body
## LR(1) items:
constructor_declaration -> constructor_declarator optl(throws) constructor_body . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production constructor_declaration -> constructor_declarator optl(throws) constructor_body

State 707:
## Known stack suffix:
## constructor_declaration
## LR(1) items:
class_body_declaration -> constructor_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_body_declaration -> constructor_declaration

State 708:
## Known stack suffix:
## class_member_declaration
## LR(1) items:
class_body_declaration -> class_member_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_body_declaration -> class_member_declaration

State 709:
## Known stack suffix:
## class_declaration
## LR(1) items:
class_member_declaration -> class_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_member_declaration -> class_declaration

State 710:
## Known stack suffix:
## class_body_declaration
## LR(1) items:
list(class_body_declaration) -> class_body_declaration . list(class_body_declaration) [ RC ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 69
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 313
-- On SM shift to state 315
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On LT shift to state 20
-- On LC shift to state 233
-- On INTERFACE shift to state 17
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On ENUM shift to state 317
-- On DOTS shift to state 327
-- On DEFAULT shift to state 328
-- On CLASS shift to state 329
-- On AT shift to state 338
-- On ABSTRACT shift to state 342
-- On type_parameters shift to state 404
-- On type_ shift to state 433
-- On static_initializer shift to state 457
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifiers shift to state 458
-- On modifier shift to state 391
-- On method_header shift to state 695
-- On method_declaration shift to state 697
-- On list(class_body_declaration) shift to state 711
-- On interface_declaration shift to state 699
-- On instance_initializer shift to state 700
-- On identifier_ shift to state 38
-- On identifier shift to state 478
-- On generic_method_or_constructor_decl shift to state 701
-- On field_declaration shift to state 702
-- On enum_declaration shift to state 703
-- On constructor_declarator shift to state 704
-- On constructor_declaration shift to state 707
-- On class_or_interface_type shift to state 49
-- On class_member_declaration shift to state 708
-- On class_header shift to state 396
-- On class_declaration shift to state 709
-- On class_body_declaration shift to state 710
-- On block shift to state 712
-- On array_type shift to state 51
-- On annotation_type_declaration shift to state 713
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(class_body_declaration) ->

State 711:
## Known stack suffix:
## class_body_declaration list(class_body_declaration)
## LR(1) items:
list(class_body_declaration) -> class_body_declaration list(class_body_declaration) . [ RC ]
## Transitions:
## Reductions:
-- On RC
--   reduce production list(class_body_declaration) -> class_body_declaration list(class_body_declaration)

State 712:
## Known stack suffix:
## block
## LR(1) items:
instance_initializer -> block . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production instance_initializer -> block

State 713:
## Known stack suffix:
## annotation_type_declaration
## LR(1) items:
class_member_declaration -> annotation_type_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production class_member_declaration -> annotation_type_declaration

State 714:
## Known stack suffix:
## DOTS
## LR(1) items:
enum_body_declarations -> DOTS . [ RC ]
## Transitions:
## Reductions:
-- On RC
--   reduce production enum_body_declarations -> DOTS

State 715:
## Known stack suffix:
## LC optl(enum_body_declarations)
## LR(1) items:
enum_body -> LC optl(enum_body_declarations) . RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RC shift to state 716
## Reductions:

State 716:
## Known stack suffix:
## LC optl(enum_body_declarations) RC
## LR(1) items:
enum_body -> LC optl(enum_body_declarations) RC . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production enum_body -> LC optl(enum_body_declarations) RC

State 717:
## Known stack suffix:
## modifiers
## LR(1) items:
enum_constant -> modifiers . enum_constant_bis [ SM RC DOTS CM ]
modifiers -> modifiers . modifier [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 16
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On DEFAULT shift to state 328
-- On AT shift to state 83
-- On ABSTRACT shift to state 342
-- On modifier shift to state 389
-- On identifier shift to state 718
-- On enum_constant_bis shift to state 730
-- On annotation shift to state 390
## Reductions:

State 718:
## Known stack suffix:
## identifier
## LR(1) items:
enum_constant_bis -> identifier . [ SM RC DOTS CM ]
enum_constant_bis -> identifier . LP listc0(argument) RP [ SM RC DOTS CM ]
enum_constant_bis -> identifier . LC list(method_declaration) RC [ SM RC DOTS CM ]
## Transitions:
-- On LP shift to state 719
-- On LC shift to state 722
## Reductions:
-- On SM RC DOTS CM
--   reduce production enum_constant_bis -> identifier

State 719:
## Known stack suffix:
## identifier LP
## LR(1) items:
enum_constant_bis -> identifier LP . listc0(argument) RP [ SM RC DOTS CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On optl(listc(argument)) shift to state 224
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc0(argument) shift to state 720
-- On listc(argument) shift to state 300
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 304
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) ->

State 720:
## Known stack suffix:
## identifier LP listc0(argument)
## LR(1) items:
enum_constant_bis -> identifier LP listc0(argument) . RP [ SM RC DOTS CM ]
## Transitions:
-- On RP shift to state 721
## Reductions:

State 721:
## Known stack suffix:
## identifier LP listc0(argument) RP
## LR(1) items:
enum_constant_bis -> identifier LP listc0(argument) RP . [ SM RC DOTS CM ]
## Transitions:
## Reductions:
-- On SM RC DOTS CM
--   reduce production enum_constant_bis -> identifier LP listc0(argument) RP

State 722:
## Known stack suffix:
## identifier LC
## LR(1) items:
enum_constant_bis -> identifier LC . list(method_declaration) RC [ SM RC DOTS CM ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 69
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On DEFAULT shift to state 328
-- On AT shift to state 83
-- On ABSTRACT shift to state 342
-- On type_ shift to state 723
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifiers shift to state 724
-- On modifier shift to state 391
-- On method_header shift to state 695
-- On method_declaration shift to state 726
-- On list(method_declaration) shift to state 728
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(method_declaration) ->

State 723:
## Known stack suffix:
## type_
## LR(1) items:
method_header -> type_ . method_declarator optl(throws) [ SM LC ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On method_declarator shift to state 450
-- On identifier shift to state 79
## Reductions:

State 724:
## Known stack suffix:
## modifiers
## LR(1) items:
method_header -> modifiers . type_ method_declarator optl(throws) [ SM LC ]
method_header -> modifiers . VOID method_declarator optl(throws) [ SM LC ]
modifiers -> modifiers . modifier [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 459
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On DEFAULT shift to state 328
-- On AT shift to state 83
-- On ABSTRACT shift to state 342
-- On type_ shift to state 725
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifier shift to state 389
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
-- On annotation shift to state 390
## Reductions:

State 725:
## Known stack suffix:
## modifiers type_
## LR(1) items:
method_header -> modifiers type_ . method_declarator optl(throws) [ SM LC ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On method_declarator shift to state 474
-- On identifier shift to state 79
## Reductions:

State 726:
## Known stack suffix:
## method_declaration
## LR(1) items:
list(method_declaration) -> method_declaration . list(method_declaration) [ RC ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 69
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On DEFAULT shift to state 328
-- On AT shift to state 83
-- On ABSTRACT shift to state 342
-- On type_ shift to state 723
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifiers shift to state 724
-- On modifier shift to state 391
-- On method_header shift to state 695
-- On method_declaration shift to state 726
-- On list(method_declaration) shift to state 727
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(method_declaration) ->

State 727:
## Known stack suffix:
## method_declaration list(method_declaration)
## LR(1) items:
list(method_declaration) -> method_declaration list(method_declaration) . [ RC ]
## Transitions:
## Reductions:
-- On RC
--   reduce production list(method_declaration) -> method_declaration list(method_declaration)

State 728:
## Known stack suffix:
## identifier LC list(method_declaration)
## LR(1) items:
enum_constant_bis -> identifier LC list(method_declaration) . RC [ SM RC DOTS CM ]
## Transitions:
-- On RC shift to state 729
## Reductions:

State 729:
## Known stack suffix:
## identifier LC list(method_declaration) RC
## LR(1) items:
enum_constant_bis -> identifier LC list(method_declaration) RC . [ SM RC DOTS CM ]
## Transitions:
## Reductions:
-- On SM RC DOTS CM
--   reduce production enum_constant_bis -> identifier LC list(method_declaration) RC

State 730:
## Known stack suffix:
## modifiers enum_constant_bis
## LR(1) items:
enum_constant -> modifiers enum_constant_bis . [ SM RC DOTS CM ]
## Transitions:
## Reductions:
-- On SM RC DOTS CM
--   reduce production enum_constant -> modifiers enum_constant_bis

State 731:
## Known stack suffix:
## LC listc(enum_constant)
## LR(1) items:
enum_body -> LC listc(enum_constant) . optl(enum_body_declarations) RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
enum_body -> LC listc(enum_constant) . CM optl(enum_body_declarations) RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
listc(enum_constant) -> listc(enum_constant) . CM enum_constant [ SM RC DOTS CM ]
## Transitions:
-- On SM shift to state 326
-- On DOTS shift to state 714
-- On CM shift to state 732
-- On optl(enum_body_declarations) shift to state 738
-- On enum_body_declarations shift to state 737
## Reductions:
-- On RC
--   reduce production optl(enum_body_declarations) ->

State 732:
## Known stack suffix:
## LC listc(enum_constant) CM
## LR(1) items:
enum_body -> LC listc(enum_constant) CM . optl(enum_body_declarations) RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
listc(enum_constant) -> listc(enum_constant) CM . enum_constant [ SM RC DOTS CM ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 326
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 16
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On DOTS shift to state 714
-- On DEFAULT shift to state 328
-- On AT shift to state 83
-- On ABSTRACT shift to state 342
-- On optl(enum_body_declarations) shift to state 733
-- On modifiers shift to state 717
-- On modifier shift to state 391
-- On identifier shift to state 718
-- On enum_constant_bis shift to state 735
-- On enum_constant shift to state 736
-- On enum_body_declarations shift to state 737
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production optl(enum_body_declarations) ->

State 733:
## Known stack suffix:
## LC listc(enum_constant) CM optl(enum_body_declarations)
## LR(1) items:
enum_body -> LC listc(enum_constant) CM optl(enum_body_declarations) . RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RC shift to state 734
## Reductions:

State 734:
## Known stack suffix:
## LC listc(enum_constant) CM optl(enum_body_declarations) RC
## LR(1) items:
enum_body -> LC listc(enum_constant) CM optl(enum_body_declarations) RC . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production enum_body -> LC listc(enum_constant) CM optl(enum_body_declarations) RC

State 735:
## Known stack suffix:
## enum_constant_bis
## LR(1) items:
enum_constant -> enum_constant_bis . [ SM RC DOTS CM ]
## Transitions:
## Reductions:
-- On SM RC DOTS CM
--   reduce production enum_constant -> enum_constant_bis

State 736:
## Known stack suffix:
## listc(enum_constant) CM enum_constant
## LR(1) items:
listc(enum_constant) -> listc(enum_constant) CM enum_constant . [ SM RC DOTS CM ]
## Transitions:
## Reductions:
-- On SM RC DOTS CM
--   reduce production listc(enum_constant) -> listc(enum_constant) CM enum_constant

State 737:
## Known stack suffix:
## enum_body_declarations
## LR(1) items:
optl(enum_body_declarations) -> enum_body_declarations . [ RC ]
## Transitions:
## Reductions:
-- On RC
--   reduce production optl(enum_body_declarations) -> enum_body_declarations

State 738:
## Known stack suffix:
## LC listc(enum_constant) optl(enum_body_declarations)
## LR(1) items:
enum_body -> LC listc(enum_constant) optl(enum_body_declarations) . RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RC shift to state 739
## Reductions:

State 739:
## Known stack suffix:
## LC listc(enum_constant) optl(enum_body_declarations) RC
## LR(1) items:
enum_body -> LC listc(enum_constant) optl(enum_body_declarations) RC . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production enum_body -> LC listc(enum_constant) optl(enum_body_declarations) RC

State 740:
## Known stack suffix:
## enum_constant
## LR(1) items:
listc(enum_constant) -> enum_constant . [ SM RC DOTS CM ]
## Transitions:
## Reductions:
-- On SM RC DOTS CM
--   reduce production listc(enum_constant) -> enum_constant

State 741:
## Known stack suffix:
## ENUM identifier optl(interfaces) enum_body
## LR(1) items:
enum_declaration -> ENUM identifier optl(interfaces) enum_body . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production enum_declaration -> ENUM identifier optl(interfaces) enum_body

State 742:
## Known stack suffix:
## LC list(class_body_declaration)
## LR(1) items:
class_body -> LC list(class_body_declaration) . RC [ XOR WHILE VOLATILE VOID URS TString TRY TRUE TRANSIENT TInt TIMES THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SRS SM RP RETURN RDots RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS PACKAGE OR_OR OR NULL NOT_EQ NEW NATIVE MOD MINUS LT LS LP LE LC LB INTERFACE INSTANCEOF INCR IMPORT IF IDENTIFIER GT GE FOR FINAL FALSE EQ_EQ EOF ENUM DOTS DOT DO DIV DEFAULT_COLON DEFAULT DECR CONTINUE COND COLONCOLON COLON CM CLASS CASE BREAK AT ASSERT AND_AND AND ABSTRACT ]
## Transitions:
-- On RC shift to state 743
## Reductions:

State 743:
## Known stack suffix:
## LC list(class_body_declaration) RC
## LR(1) items:
class_body -> LC list(class_body_declaration) RC . [ XOR WHILE VOLATILE VOID URS TString TRY TRUE TRANSIENT TInt TIMES THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SRS SM RP RETURN RDots RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS PACKAGE OR_OR OR NULL NOT_EQ NEW NATIVE MOD MINUS LT LS LP LE LC LB INTERFACE INSTANCEOF INCR IMPORT IF IDENTIFIER GT GE FOR FINAL FALSE EQ_EQ EOF ENUM DOTS DOT DO DIV DEFAULT_COLON DEFAULT DECR CONTINUE COND COLONCOLON COLON CM CLASS CASE BREAK AT ASSERT AND_AND AND ABSTRACT ]
## Transitions:
## Reductions:
-- On XOR WHILE VOLATILE VOID URS TString TRY TRUE TRANSIENT TInt TIMES THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SRS SM RP RETURN RDots RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS PACKAGE OR_OR OR NULL NOT_EQ NEW NATIVE MOD MINUS LT LS LP LE LC LB INTERFACE INSTANCEOF INCR IMPORT IF IDENTIFIER GT GE FOR FINAL FALSE EQ_EQ EOF ENUM DOTS DOT DO DIV DEFAULT_COLON DEFAULT DECR CONTINUE COND COLONCOLON COLON CM CLASS CASE BREAK AT ASSERT AND_AND AND ABSTRACT
--   reduce production class_body -> LC list(class_body_declaration) RC

State 744:
## Known stack suffix:
## name DOT NEW identifier LP listc0(argument) RP option(class_body)
## LR(1) items:
class_instance_creation_expression -> name DOT NEW identifier LP listc0(argument) RP option(class_body) . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production class_instance_creation_expression -> name DOT NEW identifier LP listc0(argument) RP option(class_body)

State 745:
## Known stack suffix:
## class_body
## LR(1) items:
option(class_body) -> class_body . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production option(class_body) -> class_body

State 746:
## Known stack suffix:
## local_variable_type
## LR(1) items:
resource -> local_variable_type . identifier EQ expression [ SM RP ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 747
## Reductions:

State 747:
## Known stack suffix:
## local_variable_type identifier
## LR(1) items:
resource -> local_variable_type identifier . EQ expression [ SM RP ]
## Transitions:
-- On EQ shift to state 748
## Reductions:

State 748:
## Known stack suffix:
## local_variable_type identifier EQ
## LR(1) items:
resource -> local_variable_type identifier EQ . expression [ SM RP ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 749
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 749:
## Known stack suffix:
## local_variable_type identifier EQ expression
## LR(1) items:
resource -> local_variable_type identifier EQ expression . [ SM RP ]
## Transitions:
## Reductions:
-- On SM RP
--   reduce production resource -> local_variable_type identifier EQ expression

State 750:
## Known stack suffix:
## LP list_sep(resource,SM)
## LR(1) items:
list_sep(resource,SM) -> list_sep(resource,SM) . SM resource [ SM RP ]
resource_specification -> LP list_sep(resource,SM) . option(SM) RP [ LC ]
## Transitions:
-- On SM shift to state 751
-- On option(SM) shift to state 754
## Reductions:
-- On RP
--   reduce production option(SM) ->

State 751:
## Known stack suffix:
## list_sep(resource,SM) SM
## LR(1) items:
list_sep(resource,SM) -> list_sep(resource,SM) SM . resource [ SM RP ]
option(SM) -> SM . [ RP ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On LP shift to state 255
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 81
-- On FALSE shift to state 144
-- On AT shift to state 83
-- On variable_modifier shift to state 111
-- On variable_access shift to state 280
-- On unann_type shift to state 281
-- On typed_metavar shift to state 149
-- On type_ shift to state 118
-- On resource shift to state 752
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 283
-- On nonempty_list(variable_modifier) shift to state 286
-- On name shift to state 291
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On local_variable_type shift to state 746
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 753
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On annotation shift to state 113
## Reductions:
-- On RP
--   reduce production option(SM) -> SM

State 752:
## Known stack suffix:
## list_sep(resource,SM) SM resource
## LR(1) items:
list_sep(resource,SM) -> list_sep(resource,SM) SM resource . [ SM RP ]
## Transitions:
## Reductions:
-- On SM RP
--   reduce production list_sep(resource,SM) -> list_sep(resource,SM) SM resource

State 753:
## Known stack suffix:
## field_access
## LR(1) items:
primary_no_new_array -> field_access . [ LB DOT COLONCOLON ]
variable_access -> field_access . [ SM RP ]
## Transitions:
## Reductions:
-- On LB DOT COLONCOLON
--   reduce production primary_no_new_array -> field_access
-- On SM RP
--   reduce production variable_access -> field_access

State 754:
## Known stack suffix:
## LP list_sep(resource,SM) option(SM)
## LR(1) items:
resource_specification -> LP list_sep(resource,SM) option(SM) . RP [ LC ]
## Transitions:
-- On RP shift to state 755
## Reductions:

State 755:
## Known stack suffix:
## LP list_sep(resource,SM) option(SM) RP
## LR(1) items:
resource_specification -> LP list_sep(resource,SM) option(SM) RP . [ LC ]
## Transitions:
## Reductions:
-- On LC
--   reduce production resource_specification -> LP list_sep(resource,SM) option(SM) RP

State 756:
## Known stack suffix:
## TRY resource_specification
## LR(1) items:
try_statement -> TRY resource_specification . block list(catch_clause) option(finally) [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 233
-- On block shift to state 757
## Reductions:

State 757:
## Known stack suffix:
## TRY resource_specification block
## LR(1) items:
try_statement -> TRY resource_specification block . list(catch_clause) option(finally) [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On CATCH shift to state 758
-- On list(catch_clause) shift to state 773
-- On catch_clause shift to state 778
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production list(catch_clause) ->

State 758:
## Known stack suffix:
## CATCH
## LR(1) items:
catch_clause -> CATCH . LP catch_formal_parameter RP block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
catch_clause -> CATCH . LP catch_formal_parameter RP empty_statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LP shift to state 759
## Reductions:

State 759:
## Known stack suffix:
## CATCH LP
## LR(1) items:
catch_clause -> CATCH LP . catch_formal_parameter RP block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
catch_clause -> CATCH LP . catch_formal_parameter RP empty_statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 81
-- On AT shift to state 83
-- On variable_modifier shift to state 111
-- On type_ shift to state 760
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On nonempty_list(variable_modifier) shift to state 761
-- On name shift to state 32
-- On list_sep(type_,OR) shift to state 762
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On catch_type shift to state 767
-- On catch_formal_parameter shift to state 769
-- On array_type shift to state 51
-- On annotation shift to state 113
## Reductions:

State 760:
## Known stack suffix:
## type_
## LR(1) items:
list_sep(type_,OR) -> type_ . [ OR IDENTIFIER ]
## Transitions:
## Reductions:
-- On OR IDENTIFIER
--   reduce production list_sep(type_,OR) -> type_

State 761:
## Known stack suffix:
## nonempty_list(variable_modifier)
## LR(1) items:
catch_formal_parameter -> nonempty_list(variable_modifier) . catch_type variable_declarator_id [ RP ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On type_ shift to state 760
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On list_sep(type_,OR) shift to state 762
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On catch_type shift to state 765
-- On array_type shift to state 51
## Reductions:

State 762:
## Known stack suffix:
## list_sep(type_,OR)
## LR(1) items:
catch_type -> list_sep(type_,OR) . [ IDENTIFIER ]
list_sep(type_,OR) -> list_sep(type_,OR) . OR type_ [ OR IDENTIFIER ]
## Transitions:
-- On OR shift to state 763
## Reductions:
-- On IDENTIFIER
--   reduce production catch_type -> list_sep(type_,OR)

State 763:
## Known stack suffix:
## list_sep(type_,OR) OR
## LR(1) items:
list_sep(type_,OR) -> list_sep(type_,OR) OR . type_ [ OR IDENTIFIER ]
## Transitions:
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On type_ shift to state 764
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 764:
## Known stack suffix:
## list_sep(type_,OR) OR type_
## LR(1) items:
list_sep(type_,OR) -> list_sep(type_,OR) OR type_ . [ OR IDENTIFIER ]
## Transitions:
## Reductions:
-- On OR IDENTIFIER
--   reduce production list_sep(type_,OR) -> list_sep(type_,OR) OR type_

State 765:
## Known stack suffix:
## nonempty_list(variable_modifier) catch_type
## LR(1) items:
catch_formal_parameter -> nonempty_list(variable_modifier) catch_type . variable_declarator_id [ RP ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 766
-- On identifier shift to state 128
## Reductions:

State 766:
## Known stack suffix:
## nonempty_list(variable_modifier) catch_type variable_declarator_id
## LR(1) items:
catch_formal_parameter -> nonempty_list(variable_modifier) catch_type variable_declarator_id . [ RP ]
variable_declarator_id -> variable_declarator_id . LB_RB [ RP LB_RB ]
## Transitions:
-- On LB_RB shift to state 127
## Reductions:
-- On RP
--   reduce production catch_formal_parameter -> nonempty_list(variable_modifier) catch_type variable_declarator_id

State 767:
## Known stack suffix:
## catch_type
## LR(1) items:
catch_formal_parameter -> catch_type . variable_declarator_id [ RP ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 768
-- On identifier shift to state 128
## Reductions:

State 768:
## Known stack suffix:
## catch_type variable_declarator_id
## LR(1) items:
catch_formal_parameter -> catch_type variable_declarator_id . [ RP ]
variable_declarator_id -> variable_declarator_id . LB_RB [ RP LB_RB ]
## Transitions:
-- On LB_RB shift to state 127
## Reductions:
-- On RP
--   reduce production catch_formal_parameter -> catch_type variable_declarator_id

State 769:
## Known stack suffix:
## CATCH LP catch_formal_parameter
## LR(1) items:
catch_clause -> CATCH LP catch_formal_parameter . RP block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
catch_clause -> CATCH LP catch_formal_parameter . RP empty_statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RP shift to state 770
## Reductions:

State 770:
## Known stack suffix:
## CATCH LP catch_formal_parameter RP
## LR(1) items:
catch_clause -> CATCH LP catch_formal_parameter RP . block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
catch_clause -> CATCH LP catch_formal_parameter RP . empty_statement [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 516
-- On LC shift to state 233
-- On empty_statement shift to state 771
-- On block shift to state 772
## Reductions:

State 771:
## Known stack suffix:
## CATCH LP catch_formal_parameter RP empty_statement
## LR(1) items:
catch_clause -> CATCH LP catch_formal_parameter RP empty_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
--   reduce production catch_clause -> CATCH LP catch_formal_parameter RP empty_statement

State 772:
## Known stack suffix:
## CATCH LP catch_formal_parameter RP block
## LR(1) items:
catch_clause -> CATCH LP catch_formal_parameter RP block . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
--   reduce production catch_clause -> CATCH LP catch_formal_parameter RP block

State 773:
## Known stack suffix:
## TRY resource_specification block list(catch_clause)
## LR(1) items:
try_statement -> TRY resource_specification block list(catch_clause) . option(finally) [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On FINALLY shift to state 774
-- On option(finally) shift to state 776
-- On finally shift to state 777
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production option(finally) ->

State 774:
## Known stack suffix:
## FINALLY
## LR(1) items:
finally -> FINALLY . block [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On LC shift to state 233
-- On block shift to state 775
## Reductions:

State 775:
## Known stack suffix:
## FINALLY block
## LR(1) items:
finally -> FINALLY block . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production finally -> FINALLY block

State 776:
## Known stack suffix:
## TRY resource_specification block list(catch_clause) option(finally)
## LR(1) items:
try_statement -> TRY resource_specification block list(catch_clause) option(finally) . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production try_statement -> TRY resource_specification block list(catch_clause) option(finally)

State 777:
## Known stack suffix:
## finally
## LR(1) items:
option(finally) -> finally . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production option(finally) -> finally

State 778:
## Known stack suffix:
## catch_clause
## LR(1) items:
list(catch_clause) -> catch_clause . list(catch_clause) [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On CATCH shift to state 758
-- On list(catch_clause) shift to state 779
-- On catch_clause shift to state 778
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production list(catch_clause) ->

State 779:
## Known stack suffix:
## catch_clause list(catch_clause)
## LR(1) items:
list(catch_clause) -> catch_clause list(catch_clause) . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production list(catch_clause) -> catch_clause list(catch_clause)

State 780:
## Known stack suffix:
## TRY block
## LR(1) items:
try_statement -> TRY block . nonempty_list(catch_clause) [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
try_statement -> TRY block . list(catch_clause) finally [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On CATCH shift to state 758
-- On nonempty_list(catch_clause) shift to state 781
-- On list(catch_clause) shift to state 782
-- On catch_clause shift to state 784
## Reductions:
-- On FINALLY
--   reduce production list(catch_clause) ->

State 781:
## Known stack suffix:
## TRY block nonempty_list(catch_clause)
## LR(1) items:
try_statement -> TRY block nonempty_list(catch_clause) . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production try_statement -> TRY block nonempty_list(catch_clause)

State 782:
## Known stack suffix:
## TRY block list(catch_clause)
## LR(1) items:
try_statement -> TRY block list(catch_clause) . finally [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On FINALLY shift to state 774
-- On finally shift to state 783
## Reductions:

State 783:
## Known stack suffix:
## TRY block list(catch_clause) finally
## LR(1) items:
try_statement -> TRY block list(catch_clause) finally . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production try_statement -> TRY block list(catch_clause) finally

State 784:
## Known stack suffix:
## catch_clause
## LR(1) items:
list(catch_clause) -> catch_clause . list(catch_clause) [ FINALLY ]
nonempty_list(catch_clause) -> catch_clause . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
nonempty_list(catch_clause) -> catch_clause . nonempty_list(catch_clause) [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On CATCH shift to state 758
-- On nonempty_list(catch_clause) shift to state 785
-- On list(catch_clause) shift to state 779
-- On catch_clause shift to state 784
## Reductions:
-- On FINALLY
--   reduce production list(catch_clause) ->
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production nonempty_list(catch_clause) -> catch_clause

State 785:
## Known stack suffix:
## catch_clause nonempty_list(catch_clause)
## LR(1) items:
nonempty_list(catch_clause) -> catch_clause nonempty_list(catch_clause) . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
--   reduce production nonempty_list(catch_clause) -> catch_clause nonempty_list(catch_clause)

State 786:
## Known stack suffix:
## LC list(block_statement)
## LR(1) items:
block -> LC list(block_statement) . RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RP RETURN RDots RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE COLON CM CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RC shift to state 787
## Reductions:

State 787:
## Known stack suffix:
## LC list(block_statement) RC
## LR(1) items:
block -> LC list(block_statement) RC . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RP RETURN RDots RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE COLON CM CLASS CATCH CASE BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RP RETURN RDots RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE COLON CM CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
--   reduce production block -> LC list(block_statement) RC

State 788:
## Known stack suffix:
## lambda_parameters ARROW lambda_body
## LR(1) items:
lambda_expression -> lambda_parameters ARROW lambda_body . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production lambda_expression -> lambda_parameters ARROW lambda_body

State 789:
## Known stack suffix:
## expression
## LR(1) items:
lambda_body -> expression . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production lambda_body -> expression

State 790:
## Known stack suffix:
## block
## LR(1) items:
lambda_body -> block . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production lambda_body -> block

State 791:
## Known stack suffix:
## left_hand_side assignment_operator expression
## LR(1) items:
assignment -> left_hand_side assignment_operator expression . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production assignment -> left_hand_side assignment_operator expression

State 792:
## Known stack suffix:
## name LB expression
## LR(1) items:
array_access -> name LB expression . RB [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RB shift to state 793
## Reductions:

State 793:
## Known stack suffix:
## name LB expression RB
## LR(1) items:
array_access -> name LB expression RB . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production array_access -> name LB expression RB

State 794:
## Known stack suffix:
## name LP listc0(argument)
## LR(1) items:
method_invocation -> name LP listc0(argument) . RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 795
## Reductions:

State 795:
## Known stack suffix:
## name LP listc0(argument) RP
## LR(1) items:
method_invocation -> name LP listc0(argument) RP . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_invocation -> name LP listc0(argument) RP

State 796:
## Known stack suffix:
## DOTS MINUS multiplicative_expression
## LR(1) items:
additive_expression -> DOTS MINUS multiplicative_expression . [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . TIMES unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . DIV unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . MOD unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On TIMES shift to state 183
-- On MOD shift to state 202
-- On DIV shift to state 204
## Reductions:
-- On XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production additive_expression -> DOTS MINUS multiplicative_expression

State 797:
## Known stack suffix:
## shift_expression URS additive_expression
## LR(1) items:
additive_expression -> additive_expression . PLUS multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . MINUS multiplicative_expression [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . PLUS DOTS [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
additive_expression -> additive_expression . MINUS DOTS [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
shift_expression -> shift_expression URS additive_expression . [ XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
## Transitions:
-- On PLUS shift to state 207
-- On MINUS shift to state 210
## Reductions:
-- On XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production shift_expression -> shift_expression URS additive_expression

State 798:
## Known stack suffix:
## primary DOT NEW identifier LP listc0(argument)
## LR(1) items:
class_instance_creation_expression -> primary DOT NEW identifier LP listc0(argument) . RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 799
## Reductions:

State 799:
## Known stack suffix:
## primary DOT NEW identifier LP listc0(argument) RP
## LR(1) items:
class_instance_creation_expression -> primary DOT NEW identifier LP listc0(argument) RP . option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LC shift to state 312
-- On option(class_body) shift to state 800
-- On class_body shift to state 745
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production option(class_body) ->

State 800:
## Known stack suffix:
## primary DOT NEW identifier LP listc0(argument) RP option(class_body)
## LR(1) items:
class_instance_creation_expression -> primary DOT NEW identifier LP listc0(argument) RP option(class_body) . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production class_instance_creation_expression -> primary DOT NEW identifier LP listc0(argument) RP option(class_body)

State 801:
## Known stack suffix:
## DOTS PLUS multiplicative_expression
## LR(1) items:
additive_expression -> DOTS PLUS multiplicative_expression . [ XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . TIMES unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . DIV unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
multiplicative_expression -> multiplicative_expression . MOD unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On TIMES shift to state 183
-- On MOD shift to state 202
-- On DIV shift to state 204
## Reductions:
-- On XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
--   reduce production additive_expression -> DOTS PLUS multiplicative_expression

State 802:
## Known stack suffix:
## primary_no_new_array LB expression
## LR(1) items:
array_access -> primary_no_new_array LB expression . RB [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RB shift to state 803
## Reductions:

State 803:
## Known stack suffix:
## primary_no_new_array LB expression RB
## LR(1) items:
array_access -> primary_no_new_array LB expression RB . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production array_access -> primary_no_new_array LB expression RB

State 804:
## Known stack suffix:
## DECR unary_expression
## LR(1) items:
pre_decrement_expression -> DECR unary_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production pre_decrement_expression -> DECR unary_expression

State 805:
## Known stack suffix:
## INCR unary_expression
## LR(1) items:
pre_increment_expression -> INCR unary_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production pre_increment_expression -> INCR unary_expression

State 806:
## Known stack suffix:
## LDots expression
## LR(1) items:
assignment_expression -> LDots expression . RDots [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
-- On RDots shift to state 807
## Reductions:

State 807:
## Known stack suffix:
## LDots expression RDots
## LR(1) items:
assignment_expression -> LDots expression RDots . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production assignment_expression -> LDots expression RDots

State 808:
## Known stack suffix:
## LP primitive_type
## LR(1) items:
array_type -> primitive_type . LB_RB [ RP LB_RB IDENTIFIER DOT COLONCOLON ]
cast_expression -> LP primitive_type . RP unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
class_literal -> primitive_type . DOT CLASS [ XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLONCOLON AND_AND AND ]
type_ -> primitive_type . [ IDENTIFIER ]
## Transitions:
-- On RP shift to state 809
-- On LB_RB shift to state 31
-- On DOT shift to state 151
## Reductions:
-- On IDENTIFIER
--   reduce production type_ -> primitive_type

State 809:
## Known stack suffix:
## LP primitive_type RP
## LR(1) items:
cast_expression -> LP primitive_type RP . unary_expression [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 810
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 810:
## Known stack suffix:
## LP primitive_type RP unary_expression
## LR(1) items:
cast_expression -> LP primitive_type RP unary_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production cast_expression -> LP primitive_type RP unary_expression

State 811:
## Known stack suffix:
## LP expression
## LR(1) items:
cast_expression -> LP expression . RP unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
cast_lambda_expression -> LP expression . RP lambda_expression [ SM RP RDots RC RB EOF COLON CM ]
primary_no_new_array -> LP expression . RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 812
## Reductions:

State 812:
## Known stack suffix:
## LP expression RP
## LR(1) items:
cast_expression -> LP expression RP . unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
cast_lambda_expression -> LP expression RP . lambda_expression [ SM RP RDots RC RB EOF COLON CM ]
primary_no_new_array -> LP expression RP . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 107
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 813
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 814
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> LP expression RP

State 813:
## Known stack suffix:
## LP expression RP unary_expression_not_plus_minus
## LR(1) items:
cast_expression -> LP expression RP unary_expression_not_plus_minus . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production cast_expression -> LP expression RP unary_expression_not_plus_minus

State 814:
## Known stack suffix:
## LP expression RP lambda_expression
## LR(1) items:
cast_lambda_expression -> LP expression RP lambda_expression . [ SM RP RDots RC RB EOF COLON CM ]
## Transitions:
## Reductions:
-- On SM RP RDots RC RB EOF COLON CM
--   reduce production cast_lambda_expression -> LP expression RP lambda_expression

State 815:
## Known stack suffix:
## LP array_type
## LR(1) items:
array_type -> array_type . LB_RB [ RP LB_RB IDENTIFIER DOT COLONCOLON ]
cast_expression -> LP array_type . RP unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
class_literal -> array_type . DOT CLASS [ XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLONCOLON AND_AND AND ]
method_reference -> array_type . COLONCOLON identifier [ XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLONCOLON AND_AND AND ]
method_reference -> array_type . COLONCOLON NEW [ XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLONCOLON AND_AND AND ]
reference_type -> array_type . [ IDENTIFIER ]
## Transitions:
-- On RP shift to state 816
-- On LB_RB shift to state 52
-- On DOT shift to state 194
-- On COLONCOLON shift to state 196
## Reductions:
-- On IDENTIFIER
--   reduce production reference_type -> array_type

State 816:
## Known stack suffix:
## LP array_type RP
## LR(1) items:
cast_expression -> LP array_type RP . unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On LP shift to state 107
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 817
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:

State 817:
## Known stack suffix:
## LP array_type RP unary_expression_not_plus_minus
## LR(1) items:
cast_expression -> LP array_type RP unary_expression_not_plus_minus . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production cast_expression -> LP array_type RP unary_expression_not_plus_minus

State 818:
## Known stack suffix:
## LP expression
## LR(1) items:
cast_expression -> LP expression . RP unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
primary_no_new_array -> LP expression . RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 819
## Reductions:

State 819:
## Known stack suffix:
## LP expression RP
## LR(1) items:
cast_expression -> LP expression RP . unary_expression_not_plus_minus [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
primary_no_new_array -> LP expression RP . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On LP shift to state 107
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 813
-- On typed_metavar shift to state 149
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production primary_no_new_array -> LP expression RP

State 820:
## Known stack suffix:
## MINUS unary_expression
## LR(1) items:
unary_expression -> MINUS unary_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production unary_expression -> MINUS unary_expression

State 821:
## Known stack suffix:
## LB expression
## LR(1) items:
dim_expr -> LB expression . RB [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RB shift to state 822
## Reductions:

State 822:
## Known stack suffix:
## LB expression RB
## LR(1) items:
dim_expr -> LB expression RB . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production dim_expr -> LB expression RB

State 823:
## Known stack suffix:
## NEW primitive_type nonempty_list(dim_expr)
## LR(1) items:
array_creation_expression -> NEW primitive_type nonempty_list(dim_expr) . dims_opt [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 104
-- On dims_opt shift to state 824
-- On dims shift to state 825
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production dims_opt ->

State 824:
## Known stack suffix:
## NEW primitive_type nonempty_list(dim_expr) dims_opt
## LR(1) items:
array_creation_expression -> NEW primitive_type nonempty_list(dim_expr) dims_opt . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production array_creation_expression -> NEW primitive_type nonempty_list(dim_expr) dims_opt

State 825:
## Known stack suffix:
## dims
## LR(1) items:
dims -> dims . LB_RB [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
dims_opt -> dims . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 826
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production dims_opt -> dims

State 826:
## Known stack suffix:
## dims LB_RB
## LR(1) items:
dims -> dims LB_RB . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LC LB_RB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LC LB_RB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production dims -> dims LB_RB

State 827:
## Known stack suffix:
## NEW primitive_type dims
## LR(1) items:
array_creation_expression_with_initializer -> NEW primitive_type dims . array_initializer [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
dims -> dims . LB_RB [ LC LB_RB ]
## Transitions:
-- On LC shift to state 436
-- On LB_RB shift to state 826
-- On array_initializer shift to state 828
## Reductions:

State 828:
## Known stack suffix:
## NEW primitive_type dims array_initializer
## LR(1) items:
array_creation_expression_with_initializer -> NEW primitive_type dims array_initializer . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production array_creation_expression_with_initializer -> NEW primitive_type dims array_initializer

State 829:
## Known stack suffix:
## dim_expr
## LR(1) items:
nonempty_list(dim_expr) -> dim_expr . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
nonempty_list(dim_expr) -> dim_expr . nonempty_list(dim_expr) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LB shift to state 105
-- On nonempty_list(dim_expr) shift to state 830
-- On dim_expr shift to state 829
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production nonempty_list(dim_expr) -> dim_expr

State 830:
## Known stack suffix:
## dim_expr nonempty_list(dim_expr)
## LR(1) items:
nonempty_list(dim_expr) -> dim_expr nonempty_list(dim_expr) . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production nonempty_list(dim_expr) -> dim_expr nonempty_list(dim_expr)

State 831:
## Known stack suffix:
## NEW name
## LR(1) items:
array_creation_expression -> NEW name . nonempty_list(dim_expr) dims_opt [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
array_creation_expression_with_initializer -> NEW name . dims array_initializer [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
class_instance_creation_expression -> NEW name . LP listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
name -> name . DOT identifier_ [ LP LB_RB LB DOT ]
name -> name . DOT LT_GENERIC listc(type_argument) GT identifier_ [ LP LB_RB LB DOT ]
## Transitions:
-- On LP shift to state 832
-- On LB_RB shift to state 104
-- On LB shift to state 105
-- On DOT shift to state 33
-- On nonempty_list(dim_expr) shift to state 836
-- On dims shift to state 838
-- On dim_expr shift to state 829
## Reductions:

State 832:
## Known stack suffix:
## NEW name LP
## LR(1) items:
class_instance_creation_expression -> NEW name LP . listc0(argument) RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 155
-- On FALSE shift to state 144
-- On DOTS shift to state 156
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 164
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On optl(listc(argument)) shift to state 224
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On listc0(argument) shift to state 833
-- On listc(argument) shift to state 300
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 250
-- On expression shift to state 302
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On assignment_expression shift to state 276
-- On assignment shift to state 277
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On argument shift to state 304
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:
-- On RP
--   reduce production optl(listc(argument)) ->

State 833:
## Known stack suffix:
## NEW name LP listc0(argument)
## LR(1) items:
class_instance_creation_expression -> NEW name LP listc0(argument) . RP option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 834
## Reductions:

State 834:
## Known stack suffix:
## NEW name LP listc0(argument) RP
## LR(1) items:
class_instance_creation_expression -> NEW name LP listc0(argument) RP . option(class_body) [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LC shift to state 312
-- On option(class_body) shift to state 835
-- On class_body shift to state 745
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production option(class_body) ->

State 835:
## Known stack suffix:
## NEW name LP listc0(argument) RP option(class_body)
## LR(1) items:
class_instance_creation_expression -> NEW name LP listc0(argument) RP option(class_body) . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production class_instance_creation_expression -> NEW name LP listc0(argument) RP option(class_body)

State 836:
## Known stack suffix:
## NEW name nonempty_list(dim_expr)
## LR(1) items:
array_creation_expression -> NEW name nonempty_list(dim_expr) . dims_opt [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On LB_RB shift to state 104
-- On dims_opt shift to state 837
-- On dims shift to state 825
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production dims_opt ->

State 837:
## Known stack suffix:
## NEW name nonempty_list(dim_expr) dims_opt
## LR(1) items:
array_creation_expression -> NEW name nonempty_list(dim_expr) dims_opt . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production array_creation_expression -> NEW name nonempty_list(dim_expr) dims_opt

State 838:
## Known stack suffix:
## NEW name dims
## LR(1) items:
array_creation_expression_with_initializer -> NEW name dims . array_initializer [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
dims -> dims . LB_RB [ LC LB_RB ]
## Transitions:
-- On LC shift to state 436
-- On LB_RB shift to state 826
-- On array_initializer shift to state 839
## Reductions:

State 839:
## Known stack suffix:
## NEW name dims array_initializer
## LR(1) items:
array_creation_expression_with_initializer -> NEW name dims array_initializer . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production array_creation_expression_with_initializer -> NEW name dims array_initializer

State 840:
## Known stack suffix:
## NOT unary_expression
## LR(1) items:
unary_expression_not_plus_minus -> NOT unary_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production unary_expression_not_plus_minus -> NOT unary_expression

State 841:
## Known stack suffix:
## PLUS unary_expression
## LR(1) items:
unary_expression -> PLUS unary_expression . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
--   reduce production unary_expression -> PLUS unary_expression

State 842:
## Known stack suffix:
## SUPER DOT identifier LP listc0(argument)
## LR(1) items:
method_invocation -> SUPER DOT identifier LP listc0(argument) . RP [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
-- On RP shift to state 843
## Reductions:

State 843:
## Known stack suffix:
## SUPER DOT identifier LP listc0(argument) RP
## LR(1) items:
method_invocation -> SUPER DOT identifier LP listc0(argument) RP . [ XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
--   reduce production method_invocation -> SUPER DOT identifier LP listc0(argument) RP

State 844:
## Known stack suffix:
## DOTS
## LR(1) items:
additive_expression -> DOTS . PLUS multiplicative_expression [ XOR URS SRS RP PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND AND_AND AND ]
additive_expression -> DOTS . MINUS multiplicative_expression [ XOR URS SRS RP PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND AND_AND AND ]
element_value_pair -> DOTS . [ RP CM ]
## Transitions:
-- On PLUS shift to state 157
-- On MINUS shift to state 168
## Reductions:
-- On RP CM
--   reduce production element_value_pair -> DOTS

State 845:
## Known stack suffix:
## listc(element_value_pair)
## LR(1) items:
annotation_element -> listc(element_value_pair) . [ RP ]
listc(element_value_pair) -> listc(element_value_pair) . CM element_value_pair [ RP CM ]
## Transitions:
-- On CM shift to state 846
## Reductions:
-- On RP
--   reduce production annotation_element -> listc(element_value_pair)

State 846:
## Known stack suffix:
## listc(element_value_pair) CM
## LR(1) items:
listc(element_value_pair) -> listc(element_value_pair) CM . element_value_pair [ RP CM ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On DOTS shift to state 847
-- On identifier shift to state 848
-- On element_value_pair shift to state 851
## Reductions:

State 847:
## Known stack suffix:
## DOTS
## LR(1) items:
element_value_pair -> DOTS . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production element_value_pair -> DOTS

State 848:
## Known stack suffix:
## identifier
## LR(1) items:
element_value_pair -> identifier . EQ element_value [ RP CM ]
## Transitions:
-- On EQ shift to state 849
## Reductions:

State 849:
## Known stack suffix:
## identifier EQ
## LR(1) items:
element_value_pair -> identifier EQ . element_value [ RP CM ]
## Transitions:
-- On VOID shift to state 86
-- On TString shift to state 89
-- On TRUE shift to state 90
-- On TInt shift to state 91
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SUPER shift to state 95
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On MINUS shift to state 106
-- On LP shift to state 107
-- On LC shift to state 348
-- On INCR shift to state 143
-- On IDENTIFIER shift to state 18
-- On FALSE shift to state 144
-- On DOTS shift to state 167
-- On DECR shift to state 145
-- On COMPL shift to state 146
-- On AT shift to state 83
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 149
-- On shift_expression shift to state 165
-- On relational_expression shift to state 178
-- On primitive_type shift to state 150
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 169
-- On pre_decrement_expression shift to state 170
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 174
-- On post_decrement_expression shift to state 175
-- On name shift to state 176
-- On multiplicative_expression shift to state 182
-- On method_reference shift to state 185
-- On method_invocation shift to state 186
-- On literal shift to state 187
-- On inclusive_or_expression shift to state 237
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On field_access shift to state 188
-- On expr1 shift to state 352
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On element_value_array_initializer shift to state 353
-- On element_value shift to state 850
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 355
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 189
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 191
-- On cast_expression shift to state 192
-- On array_type shift to state 193
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 201
-- On annotation shift to state 356
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 850:
## Known stack suffix:
## identifier EQ element_value
## LR(1) items:
element_value_pair -> identifier EQ element_value . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production element_value_pair -> identifier EQ element_value

State 851:
## Known stack suffix:
## listc(element_value_pair) CM element_value_pair
## LR(1) items:
listc(element_value_pair) -> listc(element_value_pair) CM element_value_pair . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production listc(element_value_pair) -> listc(element_value_pair) CM element_value_pair

State 852:
## Known stack suffix:
## identifier
## LR(1) items:
element_value_pair -> identifier . EQ element_value [ RP CM ]
identifier_ -> identifier . [ XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLONCOLON AND_AND AND ]
identifier_ -> identifier . LT_GENERIC listc0(type_argument) GT [ XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLONCOLON AND_AND AND ]
## Transitions:
-- On LT_GENERIC shift to state 40
-- On EQ shift to state 849
## Reductions:
-- On XOR URS TIMES SRS RP PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LP LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLONCOLON AND_AND AND
--   reduce production identifier_ -> identifier

State 853:
## Known stack suffix:
## element_value_pair
## LR(1) items:
listc(element_value_pair) -> element_value_pair . [ RP CM ]
## Transitions:
## Reductions:
-- On RP CM
--   reduce production listc(element_value_pair) -> element_value_pair

State 854:
## Known stack suffix:
## element_value
## LR(1) items:
annotation_element -> element_value . [ RP ]
## Transitions:
## Reductions:
-- On RP
--   reduce production annotation_element -> element_value

State 855:
## Known stack suffix:
## AT qualified_ident LP annotation_element
## LR(1) items:
annotation -> AT qualified_ident LP annotation_element . RP [ VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL EOF ENUM DEFAULT CM CLASS AT ABSTRACT ]
## Transitions:
-- On RP shift to state 856
## Reductions:

State 856:
## Known stack suffix:
## AT qualified_ident LP annotation_element RP
## LR(1) items:
annotation -> AT qualified_ident LP annotation_element RP . [ VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL EOF ENUM DEFAULT CM CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL EOF ENUM DEFAULT CM CLASS AT ABSTRACT
--   reduce production annotation -> AT qualified_ident LP annotation_element RP

State 857:
## Known stack suffix:
## identifier LP listc0(formal_parameter)
## LR(1) items:
method_declarator -> identifier LP listc0(formal_parameter) . RP [ THROWS SM LC LB_RB EOF ]
## Transitions:
-- On RP shift to state 858
## Reductions:

State 858:
## Known stack suffix:
## identifier LP listc0(formal_parameter) RP
## LR(1) items:
method_declarator -> identifier LP listc0(formal_parameter) RP . [ THROWS SM LC LB_RB EOF ]
## Transitions:
## Reductions:
-- On THROWS SM LC LB_RB EOF
--   reduce production method_declarator -> identifier LP listc0(formal_parameter) RP

State 859:
## Known stack suffix:
## SM
## LR(1) items:
interface_member_declaration -> SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> SM

State 860:
## Known stack suffix:
## DOTS
## LR(1) items:
interface_member_declaration -> DOTS . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> DOTS

State 861:
## Known stack suffix:
## type_parameters
## LR(1) items:
interface_generic_method_decl -> type_parameters . type_ identifier formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
interface_generic_method_decl -> type_parameters . VOID identifier formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On VOID shift to state 862
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On type_ shift to state 867
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 862:
## Known stack suffix:
## type_parameters VOID
## LR(1) items:
interface_generic_method_decl -> type_parameters VOID . identifier formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 863
## Reductions:

State 863:
## Known stack suffix:
## type_parameters VOID identifier
## LR(1) items:
interface_generic_method_decl -> type_parameters VOID identifier . formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 407
-- On formal_parameters shift to state 864
## Reductions:

State 864:
## Known stack suffix:
## type_parameters VOID identifier formal_parameters
## LR(1) items:
interface_generic_method_decl -> type_parameters VOID identifier formal_parameters . optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 71
-- On throws shift to state 77
-- On optl(throws) shift to state 865
## Reductions:
-- On SM
--   reduce production optl(throws) ->

State 865:
## Known stack suffix:
## type_parameters VOID identifier formal_parameters optl(throws)
## LR(1) items:
interface_generic_method_decl -> type_parameters VOID identifier formal_parameters optl(throws) . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 866
## Reductions:

State 866:
## Known stack suffix:
## type_parameters VOID identifier formal_parameters optl(throws) SM
## LR(1) items:
interface_generic_method_decl -> type_parameters VOID identifier formal_parameters optl(throws) SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_generic_method_decl -> type_parameters VOID identifier formal_parameters optl(throws) SM

State 867:
## Known stack suffix:
## type_parameters type_
## LR(1) items:
interface_generic_method_decl -> type_parameters type_ . identifier formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 868
## Reductions:

State 868:
## Known stack suffix:
## type_parameters type_ identifier
## LR(1) items:
interface_generic_method_decl -> type_parameters type_ identifier . formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 407
-- On formal_parameters shift to state 869
## Reductions:

State 869:
## Known stack suffix:
## type_parameters type_ identifier formal_parameters
## LR(1) items:
interface_generic_method_decl -> type_parameters type_ identifier formal_parameters . optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 71
-- On throws shift to state 77
-- On optl(throws) shift to state 870
## Reductions:
-- On SM
--   reduce production optl(throws) ->

State 870:
## Known stack suffix:
## type_parameters type_ identifier formal_parameters optl(throws)
## LR(1) items:
interface_generic_method_decl -> type_parameters type_ identifier formal_parameters optl(throws) . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 871
## Reductions:

State 871:
## Known stack suffix:
## type_parameters type_ identifier formal_parameters optl(throws) SM
## LR(1) items:
interface_generic_method_decl -> type_parameters type_ identifier formal_parameters optl(throws) SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_generic_method_decl -> type_parameters type_ identifier formal_parameters optl(throws) SM

State 872:
## Known stack suffix:
## type_
## LR(1) items:
constant_declaration -> type_ . listc(variable_declarator) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
method_header -> type_ . method_declarator optl(throws) [ SM LC ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 434
-- On variable_declarator shift to state 449
-- On method_declarator shift to state 450
-- On listc(variable_declarator) shift to state 873
-- On identifier shift to state 456
## Reductions:

State 873:
## Known stack suffix:
## type_ listc(variable_declarator)
## LR(1) items:
constant_declaration -> type_ listc(variable_declarator) . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
listc(variable_declarator) -> listc(variable_declarator) . CM variable_declarator [ SM CM ]
## Transitions:
-- On SM shift to state 874
-- On CM shift to state 454
## Reductions:

State 874:
## Known stack suffix:
## type_ listc(variable_declarator) SM
## LR(1) items:
constant_declaration -> type_ listc(variable_declarator) SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production constant_declaration -> type_ listc(variable_declarator) SM

State 875:
## Known stack suffix:
## modifiers
## LR(1) items:
annotation_type_declaration -> modifiers . AT INTERFACE identifier annotation_type_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
class_header -> modifiers . CLASS identifier optl(type_parameters) option(super) optl(interfaces) [ LC ]
constant_declaration -> modifiers . type_ listc(variable_declarator) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
enum_declaration -> modifiers . ENUM identifier optl(interfaces) enum_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
interface_declaration -> modifiers . INTERFACE identifier optl(type_parameters) optl(extends_interfaces) interface_body [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
interface_generic_method_decl -> modifiers . type_parameters type_ identifier formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
interface_generic_method_decl -> modifiers . type_parameters VOID identifier formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
method_header -> modifiers . type_ method_declarator optl(throws) [ SM LC ]
method_header -> modifiers . VOID method_declarator optl(throws) [ SM LC ]
modifiers -> modifiers . modifier [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 459
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On LT shift to state 20
-- On INTERFACE shift to state 364
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On ENUM shift to state 372
-- On DEFAULT shift to state 328
-- On CLASS shift to state 376
-- On AT shift to state 381
-- On ABSTRACT shift to state 342
-- On type_parameters shift to state 876
-- On type_ shift to state 887
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifier shift to state 389
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
-- On annotation shift to state 390
## Reductions:

State 876:
## Known stack suffix:
## modifiers type_parameters
## LR(1) items:
interface_generic_method_decl -> modifiers type_parameters . type_ identifier formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
interface_generic_method_decl -> modifiers type_parameters . VOID identifier formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On VOID shift to state 877
-- On PRIMITIVE_TYPE shift to state 28
-- On IDENTIFIER shift to state 18
-- On type_ shift to state 882
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
## Reductions:

State 877:
## Known stack suffix:
## modifiers type_parameters VOID
## LR(1) items:
interface_generic_method_decl -> modifiers type_parameters VOID . identifier formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 878
## Reductions:

State 878:
## Known stack suffix:
## modifiers type_parameters VOID identifier
## LR(1) items:
interface_generic_method_decl -> modifiers type_parameters VOID identifier . formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 407
-- On formal_parameters shift to state 879
## Reductions:

State 879:
## Known stack suffix:
## modifiers type_parameters VOID identifier formal_parameters
## LR(1) items:
interface_generic_method_decl -> modifiers type_parameters VOID identifier formal_parameters . optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 71
-- On throws shift to state 77
-- On optl(throws) shift to state 880
## Reductions:
-- On SM
--   reduce production optl(throws) ->

State 880:
## Known stack suffix:
## modifiers type_parameters VOID identifier formal_parameters optl(throws)
## LR(1) items:
interface_generic_method_decl -> modifiers type_parameters VOID identifier formal_parameters optl(throws) . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 881
## Reductions:

State 881:
## Known stack suffix:
## modifiers type_parameters VOID identifier formal_parameters optl(throws) SM
## LR(1) items:
interface_generic_method_decl -> modifiers type_parameters VOID identifier formal_parameters optl(throws) SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_generic_method_decl -> modifiers type_parameters VOID identifier formal_parameters optl(throws) SM

State 882:
## Known stack suffix:
## modifiers type_parameters type_
## LR(1) items:
interface_generic_method_decl -> modifiers type_parameters type_ . identifier formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On identifier shift to state 883
## Reductions:

State 883:
## Known stack suffix:
## modifiers type_parameters type_ identifier
## LR(1) items:
interface_generic_method_decl -> modifiers type_parameters type_ identifier . formal_parameters optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On LP shift to state 407
-- On formal_parameters shift to state 884
## Reductions:

State 884:
## Known stack suffix:
## modifiers type_parameters type_ identifier formal_parameters
## LR(1) items:
interface_generic_method_decl -> modifiers type_parameters type_ identifier formal_parameters . optl(throws) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On THROWS shift to state 71
-- On throws shift to state 77
-- On optl(throws) shift to state 885
## Reductions:
-- On SM
--   reduce production optl(throws) ->

State 885:
## Known stack suffix:
## modifiers type_parameters type_ identifier formal_parameters optl(throws)
## LR(1) items:
interface_generic_method_decl -> modifiers type_parameters type_ identifier formal_parameters optl(throws) . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On SM shift to state 886
## Reductions:

State 886:
## Known stack suffix:
## modifiers type_parameters type_ identifier formal_parameters optl(throws) SM
## LR(1) items:
interface_generic_method_decl -> modifiers type_parameters type_ identifier formal_parameters optl(throws) SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_generic_method_decl -> modifiers type_parameters type_ identifier formal_parameters optl(throws) SM

State 887:
## Known stack suffix:
## modifiers type_
## LR(1) items:
constant_declaration -> modifiers type_ . listc(variable_declarator) SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
method_header -> modifiers type_ . method_declarator optl(throws) [ SM LC ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 434
-- On variable_declarator shift to state 449
-- On method_declarator shift to state 474
-- On listc(variable_declarator) shift to state 888
-- On identifier shift to state 456
## Reductions:

State 888:
## Known stack suffix:
## modifiers type_ listc(variable_declarator)
## LR(1) items:
constant_declaration -> modifiers type_ listc(variable_declarator) . SM [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
listc(variable_declarator) -> listc(variable_declarator) . CM variable_declarator [ SM CM ]
## Transitions:
-- On SM shift to state 889
-- On CM shift to state 454
## Reductions:

State 889:
## Known stack suffix:
## modifiers type_ listc(variable_declarator) SM
## LR(1) items:
constant_declaration -> modifiers type_ listc(variable_declarator) SM . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production constant_declaration -> modifiers type_ listc(variable_declarator) SM

State 890:
## Known stack suffix:
## method_declaration
## LR(1) items:
interface_method_declaration -> method_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_method_declaration -> method_declaration

State 891:
## Known stack suffix:
## LC list(interface_member_declaration)
## LR(1) items:
interface_body -> LC list(interface_member_declaration) . RC [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On RC shift to state 892
## Reductions:

State 892:
## Known stack suffix:
## LC list(interface_member_declaration) RC
## LR(1) items:
interface_body -> LC list(interface_member_declaration) RC . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production interface_body -> LC list(interface_member_declaration) RC

State 893:
## Known stack suffix:
## interface_method_declaration
## LR(1) items:
interface_member_declaration -> interface_method_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> interface_method_declaration

State 894:
## Known stack suffix:
## interface_member_declaration
## LR(1) items:
list(interface_member_declaration) -> interface_member_declaration . list(interface_member_declaration) [ RC ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 69
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 859
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On NATIVE shift to state 16
-- On LT shift to state 20
-- On INTERFACE shift to state 17
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On ENUM shift to state 317
-- On DOTS shift to state 860
-- On DEFAULT shift to state 328
-- On CLASS shift to state 329
-- On AT shift to state 338
-- On ABSTRACT shift to state 342
-- On type_parameters shift to state 861
-- On type_ shift to state 872
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifiers shift to state 875
-- On modifier shift to state 391
-- On method_header shift to state 695
-- On method_declaration shift to state 890
-- On list(interface_member_declaration) shift to state 895
-- On interface_method_declaration shift to state 893
-- On interface_member_declaration shift to state 894
-- On interface_generic_method_decl shift to state 896
-- On interface_declaration shift to state 897
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On enum_declaration shift to state 898
-- On constant_declaration shift to state 899
-- On class_or_interface_type shift to state 49
-- On class_header shift to state 396
-- On class_declaration shift to state 900
-- On array_type shift to state 51
-- On annotation_type_declaration shift to state 901
-- On annotation shift to state 390
## Reductions:
-- On RC
--   reduce production list(interface_member_declaration) ->

State 895:
## Known stack suffix:
## interface_member_declaration list(interface_member_declaration)
## LR(1) items:
list(interface_member_declaration) -> interface_member_declaration list(interface_member_declaration) . [ RC ]
## Transitions:
## Reductions:
-- On RC
--   reduce production list(interface_member_declaration) -> interface_member_declaration list(interface_member_declaration)

State 896:
## Known stack suffix:
## interface_generic_method_decl
## LR(1) items:
interface_member_declaration -> interface_generic_method_decl . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> interface_generic_method_decl

State 897:
## Known stack suffix:
## interface_declaration
## LR(1) items:
interface_member_declaration -> interface_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> interface_declaration

State 898:
## Known stack suffix:
## enum_declaration
## LR(1) items:
interface_member_declaration -> enum_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> enum_declaration

State 899:
## Known stack suffix:
## constant_declaration
## LR(1) items:
interface_member_declaration -> constant_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> constant_declaration

State 900:
## Known stack suffix:
## class_declaration
## LR(1) items:
interface_member_declaration -> class_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> class_declaration

State 901:
## Known stack suffix:
## annotation_type_declaration
## LR(1) items:
interface_member_declaration -> annotation_type_declaration . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
--   reduce production interface_member_declaration -> annotation_type_declaration

State 902:
## Known stack suffix:
## INTERFACE identifier optl(type_parameters) optl(extends_interfaces) interface_body
## LR(1) items:
interface_declaration -> INTERFACE identifier optl(type_parameters) optl(extends_interfaces) interface_body . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production interface_declaration -> INTERFACE identifier optl(type_parameters) optl(extends_interfaces) interface_body

State 903:
## Known stack suffix:
## IMPORT
## LR(1) items:
import_declaration -> IMPORT . option(STATIC) name SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
import_declaration -> IMPORT . option(STATIC) name DOT TIMES SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On STATIC shift to state 904
-- On option(STATIC) shift to state 905
## Reductions:
-- On IDENTIFIER
--   reduce production option(STATIC) ->

State 904:
## Known stack suffix:
## STATIC
## LR(1) items:
option(STATIC) -> STATIC . [ IDENTIFIER ]
## Transitions:
## Reductions:
-- On IDENTIFIER
--   reduce production option(STATIC) -> STATIC

State 905:
## Known stack suffix:
## IMPORT option(STATIC)
## LR(1) items:
import_declaration -> IMPORT option(STATIC) . name SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
import_declaration -> IMPORT option(STATIC) . name DOT TIMES SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On name shift to state 906
-- On identifier_ shift to state 38
-- On identifier shift to state 39
## Reductions:

State 906:
## Known stack suffix:
## IMPORT option(STATIC) name
## LR(1) items:
import_declaration -> IMPORT option(STATIC) name . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
import_declaration -> IMPORT option(STATIC) name . DOT TIMES SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
name -> name . DOT identifier_ [ SM DOT ]
name -> name . DOT LT_GENERIC listc(type_argument) GT identifier_ [ SM DOT ]
## Transitions:
-- On SM shift to state 907
-- On DOT shift to state 908
## Reductions:

State 907:
## Known stack suffix:
## IMPORT option(STATIC) name SM
## LR(1) items:
import_declaration -> IMPORT option(STATIC) name SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production import_declaration -> IMPORT option(STATIC) name SM

State 908:
## Known stack suffix:
## IMPORT option(STATIC) name DOT
## LR(1) items:
import_declaration -> IMPORT option(STATIC) name DOT . TIMES SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
name -> name DOT . identifier_ [ SM DOT ]
name -> name DOT . LT_GENERIC listc(type_argument) GT identifier_ [ SM DOT ]
## Transitions:
-- On TIMES shift to state 909
-- On LT_GENERIC shift to state 34
-- On IDENTIFIER shift to state 18
-- On identifier_ shift to state 58
-- On identifier shift to state 39
## Reductions:

State 909:
## Known stack suffix:
## IMPORT option(STATIC) name DOT TIMES
## LR(1) items:
import_declaration -> IMPORT option(STATIC) name DOT TIMES . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On SM shift to state 910
## Reductions:

State 910:
## Known stack suffix:
## IMPORT option(STATIC) name DOT TIMES SM
## LR(1) items:
import_declaration -> IMPORT option(STATIC) name DOT TIMES SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production import_declaration -> IMPORT option(STATIC) name DOT TIMES SM

State 911:
## Known stack suffix:
## type_declaration
## LR(1) items:
list(type_declaration) -> type_declaration . list(type_declaration) [ EOF ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 6
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 16
-- On INTERFACE shift to state 17
-- On FINAL shift to state 316
-- On ENUM shift to state 317
-- On DEFAULT shift to state 328
-- On CLASS shift to state 329
-- On AT shift to state 338
-- On ABSTRACT shift to state 342
-- On type_declaration shift to state 911
-- On modifiers shift to state 912
-- On modifier shift to state 391
-- On list(type_declaration) shift to state 913
-- On interface_declaration shift to state 914
-- On enum_declaration shift to state 915
-- On class_header shift to state 396
-- On class_declaration shift to state 916
-- On annotation_type_declaration shift to state 917
-- On annotation shift to state 390
## Reductions:
-- On EOF
--   reduce production list(type_declaration) ->

State 912:
## Known stack suffix:
## modifiers
## LR(1) items:
annotation_type_declaration -> modifiers . AT INTERFACE identifier annotation_type_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
class_header -> modifiers . CLASS identifier optl(type_parameters) option(super) optl(interfaces) [ LC ]
enum_declaration -> modifiers . ENUM identifier optl(interfaces) enum_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
interface_declaration -> modifiers . INTERFACE identifier optl(type_parameters) optl(extends_interfaces) interface_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
modifiers -> modifiers . modifier [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 16
-- On INTERFACE shift to state 364
-- On FINAL shift to state 316
-- On ENUM shift to state 372
-- On DEFAULT shift to state 328
-- On CLASS shift to state 376
-- On AT shift to state 381
-- On ABSTRACT shift to state 342
-- On modifier shift to state 389
-- On annotation shift to state 390
## Reductions:

State 913:
## Known stack suffix:
## type_declaration list(type_declaration)
## LR(1) items:
list(type_declaration) -> type_declaration list(type_declaration) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production list(type_declaration) -> type_declaration list(type_declaration)

State 914:
## Known stack suffix:
## interface_declaration
## LR(1) items:
type_declaration -> interface_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production type_declaration -> interface_declaration

State 915:
## Known stack suffix:
## enum_declaration
## LR(1) items:
type_declaration -> enum_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production type_declaration -> enum_declaration

State 916:
## Known stack suffix:
## class_declaration
## LR(1) items:
type_declaration -> class_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production type_declaration -> class_declaration

State 917:
## Known stack suffix:
## annotation_type_declaration
## LR(1) items:
type_declaration -> annotation_type_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production type_declaration -> annotation_type_declaration

State 918:
## Known stack suffix:
## package_declaration
## LR(1) items:
compilation_unit -> package_declaration . nonempty_list(import_declaration) list(type_declaration) [ EOF ]
compilation_unit -> package_declaration . list(type_declaration) [ EOF ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 6
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 16
-- On INTERFACE shift to state 17
-- On IMPORT shift to state 903
-- On FINAL shift to state 316
-- On ENUM shift to state 317
-- On DEFAULT shift to state 328
-- On CLASS shift to state 329
-- On AT shift to state 338
-- On ABSTRACT shift to state 342
-- On type_declaration shift to state 911
-- On nonempty_list(import_declaration) shift to state 919
-- On modifiers shift to state 912
-- On modifier shift to state 391
-- On list(type_declaration) shift to state 921
-- On interface_declaration shift to state 914
-- On import_declaration shift to state 922
-- On enum_declaration shift to state 915
-- On class_header shift to state 396
-- On class_declaration shift to state 916
-- On annotation_type_declaration shift to state 917
-- On annotation shift to state 390
## Reductions:
-- On EOF
--   reduce production list(type_declaration) ->

State 919:
## Known stack suffix:
## package_declaration nonempty_list(import_declaration)
## LR(1) items:
compilation_unit -> package_declaration nonempty_list(import_declaration) . list(type_declaration) [ EOF ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 6
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 16
-- On INTERFACE shift to state 17
-- On FINAL shift to state 316
-- On ENUM shift to state 317
-- On DEFAULT shift to state 328
-- On CLASS shift to state 329
-- On AT shift to state 338
-- On ABSTRACT shift to state 342
-- On type_declaration shift to state 911
-- On modifiers shift to state 912
-- On modifier shift to state 391
-- On list(type_declaration) shift to state 920
-- On interface_declaration shift to state 914
-- On enum_declaration shift to state 915
-- On class_header shift to state 396
-- On class_declaration shift to state 916
-- On annotation_type_declaration shift to state 917
-- On annotation shift to state 390
## Reductions:
-- On EOF
--   reduce production list(type_declaration) ->

State 920:
## Known stack suffix:
## package_declaration nonempty_list(import_declaration) list(type_declaration)
## LR(1) items:
compilation_unit -> package_declaration nonempty_list(import_declaration) list(type_declaration) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production compilation_unit -> package_declaration nonempty_list(import_declaration) list(type_declaration)

State 921:
## Known stack suffix:
## package_declaration list(type_declaration)
## LR(1) items:
compilation_unit -> package_declaration list(type_declaration) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production compilation_unit -> package_declaration list(type_declaration)

State 922:
## Known stack suffix:
## import_declaration
## LR(1) items:
nonempty_list(import_declaration) -> import_declaration . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
nonempty_list(import_declaration) -> import_declaration . nonempty_list(import_declaration) [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On IMPORT shift to state 903
-- On nonempty_list(import_declaration) shift to state 923
-- On import_declaration shift to state 922
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production nonempty_list(import_declaration) -> import_declaration

State 923:
## Known stack suffix:
## import_declaration nonempty_list(import_declaration)
## LR(1) items:
nonempty_list(import_declaration) -> import_declaration nonempty_list(import_declaration) . [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
## Reductions:
-- On VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production nonempty_list(import_declaration) -> import_declaration nonempty_list(import_declaration)

State 924:
## Known stack suffix:
## nonempty_list(import_declaration)
## LR(1) items:
compilation_unit -> nonempty_list(import_declaration) . list(type_declaration) [ EOF ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 6
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On NATIVE shift to state 16
-- On INTERFACE shift to state 17
-- On FINAL shift to state 316
-- On ENUM shift to state 317
-- On DEFAULT shift to state 328
-- On CLASS shift to state 329
-- On AT shift to state 338
-- On ABSTRACT shift to state 342
-- On type_declaration shift to state 911
-- On modifiers shift to state 912
-- On modifier shift to state 391
-- On list(type_declaration) shift to state 925
-- On interface_declaration shift to state 914
-- On enum_declaration shift to state 915
-- On class_header shift to state 396
-- On class_declaration shift to state 916
-- On annotation_type_declaration shift to state 917
-- On annotation shift to state 390
## Reductions:
-- On EOF
--   reduce production list(type_declaration) ->

State 925:
## Known stack suffix:
## nonempty_list(import_declaration) list(type_declaration)
## LR(1) items:
compilation_unit -> nonempty_list(import_declaration) list(type_declaration) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production compilation_unit -> nonempty_list(import_declaration) list(type_declaration)

State 926:
## Known stack suffix:
## modifiers
## LR(1) items:
annotation_type_declaration -> modifiers . AT INTERFACE identifier annotation_type_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
class_header -> modifiers . CLASS identifier optl(type_parameters) option(super) optl(interfaces) [ LC ]
enum_declaration -> modifiers . ENUM identifier optl(interfaces) enum_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
interface_declaration -> modifiers . INTERFACE identifier optl(type_parameters) optl(extends_interfaces) interface_body [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
modifiers -> modifiers . modifier [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PACKAGE NATIVE INTERFACE FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
package_declaration -> modifiers . PACKAGE qualified_ident SM [ VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PACKAGE shift to state 927
-- On NATIVE shift to state 16
-- On INTERFACE shift to state 364
-- On FINAL shift to state 316
-- On ENUM shift to state 372
-- On DEFAULT shift to state 328
-- On CLASS shift to state 376
-- On AT shift to state 381
-- On ABSTRACT shift to state 342
-- On modifier shift to state 389
-- On annotation shift to state 390
## Reductions:

State 927:
## Known stack suffix:
## modifiers PACKAGE
## LR(1) items:
package_declaration -> modifiers PACKAGE . qualified_ident SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On IDENTIFIER shift to state 11
-- On qualified_ident shift to state 928
## Reductions:

State 928:
## Known stack suffix:
## modifiers PACKAGE qualified_ident
## LR(1) items:
package_declaration -> modifiers PACKAGE qualified_ident . SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
qualified_ident -> qualified_ident . DOT IDENTIFIER [ SM DOT ]
## Transitions:
-- On SM shift to state 929
-- On DOT shift to state 14
## Reductions:

State 929:
## Known stack suffix:
## modifiers PACKAGE qualified_ident SM
## LR(1) items:
package_declaration -> modifiers PACKAGE qualified_ident SM . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production package_declaration -> modifiers PACKAGE qualified_ident SM

State 930:
## Known stack suffix:
## list(type_declaration)
## LR(1) items:
compilation_unit -> list(type_declaration) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production compilation_unit -> list(type_declaration)

State 931:
## Known stack suffix:
## goal
## LR(1) items:
goal' -> goal . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept goal

State 932:
## Known stack suffix:
## compilation_unit
## LR(1) items:
goal -> compilation_unit . EOF [ # ]
## Transitions:
-- On EOF shift to state 933
## Reductions:

State 933:
## Known stack suffix:
## compilation_unit EOF
## LR(1) items:
goal -> compilation_unit EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production goal -> compilation_unit EOF

State 934:
## Known stack suffix:
##
## LR(1) items:
sgrep_spatch_pattern' -> . sgrep_spatch_pattern [ # ]
## Transitions:
-- On WHILE shift to state 234
-- On VOLATILE shift to state 1
-- On VOID shift to state 935
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TRANSIENT shift to state 2
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 493
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On PLUS shift to state 99
-- On PACKAGE shift to state 10
-- On NULL shift to state 100
-- On NOT shift to state 101
-- On NEW shift to state 102
-- On NATIVE shift to state 16
-- On MINUS shift to state 106
-- On LP_LAMBDA shift to state 108
-- On LP shift to state 141
-- On LDots shift to state 142
-- On LC shift to state 233
-- On INTERFACE shift to state 17
-- On INCR shift to state 143
-- On IMPORT shift to state 903
-- On IF shift to state 522
-- On IDENTIFIER shift to state 936
-- On FOR shift to state 577
-- On FINAL shift to state 316
-- On FALSE shift to state 144
-- On ENUM shift to state 317
-- On DOTS shift to state 156
-- On DO shift to state 576
-- On DEFAULT shift to state 328
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On COMPL shift to state 146
-- On CLASS shift to state 329
-- On BREAK shift to state 585
-- On AT shift to state 83
-- On ASSERT shift to state 588
-- On ABSTRACT shift to state 342
-- On while_statement shift to state 937
-- On unary_expression_not_plus_minus shift to state 147
-- On unary_expression shift to state 158
-- On typed_metavar shift to state 539
-- On type_ shift to state 938
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 939
-- On statement_no_dots shift to state 940
-- On statement_expression shift to state 600
-- On shift_expression shift to state 165
-- On sgrep_spatch_pattern shift to state 941
-- On return_statement shift to state 603
-- On relational_expression shift to state 178
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 942
-- On pre_decrement_expression shift to state 943
-- On postfix_expression shift to state 171
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On package_declaration shift to state 944
-- On name shift to state 225
-- On multiplicative_expression shift to state 182
-- On modifiers shift to state 945
-- On modifier shift to state 391
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On method_header shift to state 947
-- On method_declaration shift to state 949
-- On local_variable_declaration_statement shift to state 950
-- On local_variable_declaration shift to state 647
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On lambda_parameters shift to state 231
-- On lambda_expression shift to state 236
-- On labeled_statement shift to state 951
-- On item_other shift to state 952
-- On item_no_dots shift to state 953
-- On interface_declaration shift to state 961
-- On inclusive_or_expression shift to state 237
-- On import_declaration shift to state 962
-- On if_then_statement shift to state 966
-- On if_then_else_statement shift to state 967
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 968
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On expression shift to state 969
-- On exclusive_or_expression shift to state 262
-- On equality_expression shift to state 241
-- On enum_declaration shift to state 963
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On declaration shift to state 964
-- On continue_statement shift to state 614
-- On conditional_or_expression shift to state 263
-- On conditional_expression shift to state 274
-- On conditional_and_expression shift to state 273
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On class_header shift to state 971
-- On class_declaration shift to state 965
-- On cast_lambda_expression shift to state 275
-- On cast_expression shift to state 192
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment_expression shift to state 276
-- On assignment shift to state 973
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On annotation shift to state 974
-- On and_expression shift to state 249
-- On additive_expression shift to state 215
## Reductions:

State 935:
## Known stack suffix:
## VOID
## LR(1) items:
class_literal -> VOID . DOT CLASS [ XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON AND_AND AND ]
method_header -> VOID . method_declarator optl(throws) [ SM LC EOF ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On DOT shift to state 87
-- On method_declarator shift to state 70
-- On identifier shift to state 79
## Reductions:

State 936:
## Known stack suffix:
## IDENTIFIER
## LR(1) items:
identifier -> IDENTIFIER . [ XOR URS TIMES SRS PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT_GENERIC LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON AND_AND AND ]
lambda_parameters -> IDENTIFIER . [ ARROW ]
statement_expression -> IDENTIFIER . [ SM ]
## Transitions:
## Reductions:
-- On XOR URS TIMES SRS PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT_GENERIC LT LS LP LE LB_RB LB INSTANCEOF INCR IDENTIFIER GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON AND_AND AND
--   reduce production identifier -> IDENTIFIER
-- On ARROW
--   reduce production lambda_parameters -> IDENTIFIER
-- On SM
--   reduce production statement_expression -> IDENTIFIER

State 937:
## Known stack suffix:
## while_statement
## LR(1) items:
statement_no_dots -> while_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production statement_no_dots -> while_statement

State 938:
## Known stack suffix:
## type_
## LR(1) items:
local_variable_declaration -> type_ . listc(variable_declarator) [ SM ]
method_header -> type_ . method_declarator optl(throws) [ SM LC EOF ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 434
-- On variable_declarator shift to state 449
-- On method_declarator shift to state 450
-- On listc(variable_declarator) shift to state 545
-- On identifier shift to state 456
## Reductions:

State 939:
## Known stack suffix:
## statement_without_trailing_substatement
## LR(1) items:
statement_no_dots -> statement_without_trailing_substatement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production statement_no_dots -> statement_without_trailing_substatement

State 940:
## Known stack suffix:
## statement_no_dots
## LR(1) items:
item_no_dots -> statement_no_dots . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production item_no_dots -> statement_no_dots

State 941:
## Known stack suffix:
## sgrep_spatch_pattern
## LR(1) items:
sgrep_spatch_pattern' -> sgrep_spatch_pattern . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept sgrep_spatch_pattern

State 942:
## Known stack suffix:
## pre_increment_expression
## LR(1) items:
statement_expression -> pre_increment_expression . [ SM ]
unary_expression -> pre_increment_expression . [ XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND AND_AND AND ]
## Transitions:
## Reductions:
-- On SM
--   reduce production statement_expression -> pre_increment_expression
-- On XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND AND_AND AND
--   reduce production unary_expression -> pre_increment_expression

State 943:
## Known stack suffix:
## pre_decrement_expression
## LR(1) items:
statement_expression -> pre_decrement_expression . [ SM ]
unary_expression -> pre_decrement_expression . [ XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND AND_AND AND ]
## Transitions:
## Reductions:
-- On SM
--   reduce production statement_expression -> pre_decrement_expression
-- On XOR URS TIMES SRS PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND AND_AND AND
--   reduce production unary_expression -> pre_decrement_expression

State 944:
## Known stack suffix:
## package_declaration
## LR(1) items:
item_other -> package_declaration . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production item_other -> package_declaration

State 945:
## Known stack suffix:
## modifiers
## LR(1) items:
class_header -> modifiers . CLASS identifier optl(type_parameters) option(super) optl(interfaces) [ LC EOF ]
enum_declaration -> modifiers . ENUM identifier optl(interfaces) enum_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
interface_declaration -> modifiers . INTERFACE identifier optl(type_parameters) optl(extends_interfaces) interface_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
local_variable_declaration -> modifiers . type_ listc(variable_declarator) [ SM ]
method_header -> modifiers . type_ method_declarator optl(throws) [ SM LC EOF ]
method_header -> modifiers . VOID method_declarator optl(throws) [ SM LC EOF ]
modifiers -> modifiers . modifier [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
package_declaration -> modifiers . PACKAGE qualified_ident SM [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
-- On VOLATILE shift to state 1
-- On VOID shift to state 459
-- On TRANSIENT shift to state 2
-- On SYNCHRONIZED shift to state 3
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On PACKAGE shift to state 927
-- On NATIVE shift to state 16
-- On INTERFACE shift to state 364
-- On IDENTIFIER shift to state 18
-- On FINAL shift to state 316
-- On ENUM shift to state 372
-- On DEFAULT shift to state 328
-- On CLASS shift to state 376
-- On AT shift to state 83
-- On ABSTRACT shift to state 342
-- On type_ shift to state 946
-- On reference_type shift to state 119
-- On primitive_type shift to state 120
-- On name shift to state 32
-- On modifier shift to state 389
-- On identifier_ shift to state 38
-- On identifier shift to state 39
-- On class_or_interface_type shift to state 49
-- On array_type shift to state 51
-- On annotation shift to state 390
## Reductions:

State 946:
## Known stack suffix:
## modifiers type_
## LR(1) items:
local_variable_declaration -> modifiers type_ . listc(variable_declarator) [ SM ]
method_header -> modifiers type_ . method_declarator optl(throws) [ SM LC EOF ]
## Transitions:
-- On IDENTIFIER shift to state 18
-- On variable_declarator_id shift to state 434
-- On variable_declarator shift to state 449
-- On method_declarator shift to state 474
-- On listc(variable_declarator) shift to state 556
-- On identifier shift to state 456
## Reductions:

State 947:
## Known stack suffix:
## method_header
## LR(1) items:
method_declaration -> method_header . method_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
sgrep_spatch_pattern -> method_header . EOF [ # ]
## Transitions:
-- On SM shift to state 425
-- On LC shift to state 233
-- On EOF shift to state 948
-- On method_body shift to state 696
-- On block shift to state 427
## Reductions:

State 948:
## Known stack suffix:
## method_header EOF
## LR(1) items:
sgrep_spatch_pattern -> method_header EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production sgrep_spatch_pattern -> method_header EOF

State 949:
## Known stack suffix:
## method_declaration
## LR(1) items:
declaration -> method_declaration . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production declaration -> method_declaration

State 950:
## Known stack suffix:
## local_variable_declaration_statement
## LR(1) items:
item_other -> local_variable_declaration_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production item_other -> local_variable_declaration_statement

State 951:
## Known stack suffix:
## labeled_statement
## LR(1) items:
statement_no_dots -> labeled_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production statement_no_dots -> labeled_statement

State 952:
## Known stack suffix:
## item_other
## LR(1) items:
item_no_dots -> item_other . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production item_no_dots -> item_other

State 953:
## Known stack suffix:
## item_no_dots
## LR(1) items:
sgrep_spatch_pattern -> item_no_dots . EOF [ # ]
sgrep_spatch_pattern -> item_no_dots . nonempty_list(item) EOF [ # ]
## Transitions:
-- On WHILE shift to state 234
-- On VOLATILE shift to state 1
-- On VOID shift to state 935
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TRANSIENT shift to state 2
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 493
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On PACKAGE shift to state 10
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On NATIVE shift to state 16
-- On LP shift to state 255
-- On LC shift to state 233
-- On INTERFACE shift to state 17
-- On INCR shift to state 143
-- On IMPORT shift to state 903
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FINAL shift to state 316
-- On FALSE shift to state 144
-- On EOF shift to state 954
-- On ENUM shift to state 317
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DEFAULT shift to state 328
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On CLASS shift to state 329
-- On BREAK shift to state 585
-- On AT shift to state 83
-- On ASSERT shift to state 588
-- On ABSTRACT shift to state 342
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On type_ shift to state 938
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 955
-- On return_statement shift to state 603
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On package_declaration shift to state 944
-- On nonempty_list(item) shift to state 956
-- On name shift to state 225
-- On modifiers shift to state 945
-- On modifier shift to state 391
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On method_header shift to state 695
-- On method_declaration shift to state 949
-- On local_variable_declaration_statement shift to state 950
-- On local_variable_declaration shift to state 647
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On item_other shift to state 958
-- On item shift to state 959
-- On interface_declaration shift to state 961
-- On import_declaration shift to state 962
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On enum_declaration shift to state 963
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On declaration shift to state 964
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On class_header shift to state 396
-- On class_declaration shift to state 965
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On annotation shift to state 390
## Reductions:

State 954:
## Known stack suffix:
## item_no_dots EOF
## LR(1) items:
sgrep_spatch_pattern -> item_no_dots EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production sgrep_spatch_pattern -> item_no_dots EOF

State 955:
## Known stack suffix:
## statement
## LR(1) items:
item -> statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production item -> statement

State 956:
## Known stack suffix:
## item_no_dots nonempty_list(item)
## LR(1) items:
sgrep_spatch_pattern -> item_no_dots nonempty_list(item) . EOF [ # ]
## Transitions:
-- On EOF shift to state 957
## Reductions:

State 957:
## Known stack suffix:
## item_no_dots nonempty_list(item) EOF
## LR(1) items:
sgrep_spatch_pattern -> item_no_dots nonempty_list(item) EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production sgrep_spatch_pattern -> item_no_dots nonempty_list(item) EOF

State 958:
## Known stack suffix:
## item_other
## LR(1) items:
item -> item_other . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production item -> item_other

State 959:
## Known stack suffix:
## item
## LR(1) items:
nonempty_list(item) -> item . [ EOF ]
nonempty_list(item) -> item . nonempty_list(item) [ EOF ]
## Transitions:
-- On WHILE shift to state 234
-- On VOLATILE shift to state 1
-- On VOID shift to state 935
-- On TString shift to state 89
-- On TRY shift to state 253
-- On TRUE shift to state 90
-- On TRANSIENT shift to state 2
-- On TInt shift to state 91
-- On THROW shift to state 485
-- On THIS shift to state 92
-- On TFloat shift to state 93
-- On TChar shift to state 94
-- On SYNCHRONIZED shift to state 493
-- On SWITCH shift to state 498
-- On SUPER shift to state 95
-- On STRICTFP shift to state 4
-- On STATIC shift to state 5
-- On SM shift to state 516
-- On RETURN shift to state 517
-- On PUBLIC shift to state 7
-- On PROTECTED shift to state 8
-- On PRIVATE shift to state 9
-- On PRIMITIVE_TYPE shift to state 28
-- On PACKAGE shift to state 10
-- On NULL shift to state 100
-- On NEW shift to state 102
-- On NATIVE shift to state 16
-- On LP shift to state 255
-- On LC shift to state 233
-- On INTERFACE shift to state 17
-- On INCR shift to state 143
-- On IMPORT shift to state 903
-- On IF shift to state 522
-- On IDENTIFIER shift to state 535
-- On FOR shift to state 577
-- On FINAL shift to state 316
-- On FALSE shift to state 144
-- On ENUM shift to state 317
-- On DOTS shift to state 575
-- On DO shift to state 576
-- On DEFAULT shift to state 328
-- On DECR shift to state 145
-- On CONTINUE shift to state 581
-- On CLASS shift to state 329
-- On BREAK shift to state 585
-- On AT shift to state 83
-- On ASSERT shift to state 588
-- On ABSTRACT shift to state 342
-- On while_statement shift to state 594
-- On typed_metavar shift to state 539
-- On type_ shift to state 938
-- On try_statement shift to state 595
-- On throw_statement shift to state 596
-- On synchronized_statement shift to state 597
-- On switch_statement shift to state 598
-- On statement_without_trailing_substatement shift to state 599
-- On statement_expression shift to state 600
-- On statement shift to state 955
-- On return_statement shift to state 603
-- On reference_type shift to state 119
-- On primitive_type shift to state 259
-- On primary_no_new_array shift to state 153
-- On primary shift to state 159
-- On pre_increment_expression shift to state 547
-- On pre_decrement_expression shift to state 548
-- On postfix_expression shift to state 549
-- On post_increment_expression shift to state 550
-- On post_decrement_expression shift to state 551
-- On package_declaration shift to state 944
-- On nonempty_list(item) shift to state 960
-- On name shift to state 225
-- On modifiers shift to state 945
-- On modifier shift to state 391
-- On method_reference shift to state 185
-- On method_invocation shift to state 557
-- On method_header shift to state 695
-- On method_declaration shift to state 949
-- On local_variable_declaration_statement shift to state 950
-- On local_variable_declaration shift to state 647
-- On literal shift to state 187
-- On left_hand_side shift to state 227
-- On labeled_statement shift to state 604
-- On item_other shift to state 958
-- On item shift to state 959
-- On interface_declaration shift to state 961
-- On import_declaration shift to state 962
-- On if_then_statement shift to state 605
-- On if_then_else_statement shift to state 606
-- On identifier_ shift to state 38
-- On identifier shift to state 607
-- On for_statement shift to state 610
-- On field_access shift to state 250
-- On expression_statement shift to state 611
-- On enum_declaration shift to state 963
-- On empty_statement shift to state 612
-- On do_statement shift to state 613
-- On declaration shift to state 964
-- On continue_statement shift to state 614
-- On class_or_interface_type shift to state 49
-- On class_literal shift to state 190
-- On class_instance_creation_expression shift to state 562
-- On class_header shift to state 396
-- On class_declaration shift to state 965
-- On break_statement shift to state 615
-- On block shift to state 616
-- On assignment shift to state 563
-- On array_type shift to state 279
-- On array_creation_expression_with_initializer shift to state 199
-- On array_creation_expression shift to state 200
-- On array_access shift to state 278
-- On annotation shift to state 390
## Reductions:
-- On EOF
--   reduce production nonempty_list(item) -> item

State 960:
## Known stack suffix:
## item nonempty_list(item)
## LR(1) items:
nonempty_list(item) -> item nonempty_list(item) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production nonempty_list(item) -> item nonempty_list(item)

State 961:
## Known stack suffix:
## interface_declaration
## LR(1) items:
declaration -> interface_declaration . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production declaration -> interface_declaration

State 962:
## Known stack suffix:
## import_declaration
## LR(1) items:
item_other -> import_declaration . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production item_other -> import_declaration

State 963:
## Known stack suffix:
## enum_declaration
## LR(1) items:
declaration -> enum_declaration . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production declaration -> enum_declaration

State 964:
## Known stack suffix:
## declaration
## LR(1) items:
item_other -> declaration . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production item_other -> declaration

State 965:
## Known stack suffix:
## class_declaration
## LR(1) items:
declaration -> class_declaration . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production declaration -> class_declaration

State 966:
## Known stack suffix:
## if_then_statement
## LR(1) items:
statement_no_dots -> if_then_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production statement_no_dots -> if_then_statement

State 967:
## Known stack suffix:
## if_then_else_statement
## LR(1) items:
statement_no_dots -> if_then_else_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production statement_no_dots -> if_then_else_statement

State 968:
## Known stack suffix:
## for_statement
## LR(1) items:
statement_no_dots -> for_statement . [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
## Transitions:
## Reductions:
-- On WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
--   reduce production statement_no_dots -> for_statement

State 969:
## Known stack suffix:
## expression
## LR(1) items:
sgrep_spatch_pattern -> expression . EOF [ # ]
## Transitions:
-- On EOF shift to state 970
## Reductions:

State 970:
## Known stack suffix:
## expression EOF
## LR(1) items:
sgrep_spatch_pattern -> expression EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production sgrep_spatch_pattern -> expression EOF

State 971:
## Known stack suffix:
## class_header
## LR(1) items:
class_declaration -> class_header . class_body [ WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT ]
sgrep_spatch_pattern -> class_header . EOF [ # ]
## Transitions:
-- On LC shift to state 312
-- On EOF shift to state 972
-- On class_body shift to state 397
## Reductions:

State 972:
## Known stack suffix:
## class_header EOF
## LR(1) items:
sgrep_spatch_pattern -> class_header EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production sgrep_spatch_pattern -> class_header EOF

State 973:
## Known stack suffix:
## assignment
## LR(1) items:
assignment_expression -> assignment . [ EOF ]
statement_expression -> assignment . [ SM ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production assignment_expression -> assignment
-- On SM
--   reduce production statement_expression -> assignment

State 974:
## Known stack suffix:
## annotation
## LR(1) items:
modifier -> annotation . [ VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT ]
sgrep_spatch_pattern -> annotation . EOF [ # ]
## Transitions:
-- On EOF shift to state 975
## Reductions:
-- On VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
--   reduce production modifier -> annotation

State 975:
## Known stack suffix:
## annotation EOF
## LR(1) items:
sgrep_spatch_pattern -> annotation EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production sgrep_spatch_pattern -> annotation EOF

