File "pfff_java.mly", line 227, characters 33-38:
Warning: the token CONST is unused.
File "pfff_java.mly", line 228, characters 43-47:
Warning: the token GOTO is unused.
File "pfff_java.mly", line 165, characters 22-30:
Warning: the token TComment is unused.
File "pfff_java.mly", line 165, characters 31-46:
Warning: the token TCommentNewline is unused.
File "pfff_java.mly", line 165, characters 47-60:
Warning: the token TCommentSpace is unused.
File "pfff_java.mly", line 153, characters 22-30:
Warning: the token TUnknown is unused.
Grammar has 224 nonterminal symbols, among which 2 start symbols.
Grammar has 103 terminal symbols.
Grammar has 539 productions.
nullable(while_statement_no_short_if) = false
nullable(while_statement) = false
nullable(variable_modifier) = false
nullable(variable_initializer) = false
nullable(variable_declarator_id_bis) = false
nullable(variable_declarator_id) = false
nullable(variable_declarator) = false
nullable(variable_arity_parameter) = false
nullable(variable_access) = false
nullable(unary_expression_not_plus_minus) = false
nullable(unary_expression) = false
nullable(unann_type) = false
nullable(typed_metavar) = false
nullable(type_parameters) = false
nullable(type_parameter) = false
nullable(type_declaration) = false
nullable(type_argument) = false
nullable(type_) = false
nullable(try_statement) = false
nullable(throws) = false
nullable(throw_statement) = false
nullable(synchronized_statement) = false
nullable(switch_statement) = false
nullable(switch_label) = false
nullable(switch_block_statement_groups) = false
nullable(switch_block_statement_group) = false
nullable(switch_block) = false
nullable(super) = false
nullable(static_initializer) = false
nullable(statement_without_trailing_substatement) = false
nullable(statement_no_short_if) = false
nullable(statement_no_dots) = false
nullable(statement_expression) = false
nullable(statement) = false
nullable(shift_expression) = false
nullable(sgrep_spatch_pattern) = false
nullable(return_statement) = false
nullable(resource_specification) = false
nullable(resource) = false
nullable(relational_expression) = false
nullable(reference_type) = false
nullable(qualified_ident) = false
nullable(primitive_type) = false
nullable(primary_no_new_array) = false
nullable(primary) = false
nullable(pre_increment_expression) = false
nullable(pre_decrement_expression) = false
nullable(postfix_expression) = false
nullable(post_increment_expression) = false
nullable(post_decrement_expression) = false
nullable(package_declaration) = false
nullable(optl(type_parameters)) = true
nullable(optl(throws)) = true
nullable(optl(listc(type_argument))) = true
nullable(optl(listc(formal_parameter))) = true
nullable(optl(listc(argument))) = true
nullable(optl(interfaces)) = true
nullable(optl(for_update)) = true
nullable(optl(extends_interfaces)) = true
nullable(optl(enum_body_declarations)) = true
nullable(option(super)) = true
nullable(option(identifier)) = true
nullable(option(finally)) = true
nullable(option(expression)) = true
nullable(option(class_body)) = true
nullable(option(STATIC)) = true
nullable(option(SM)) = true
nullable(option(CM)) = true
nullable(nonempty_list(variable_modifier)) = false
nullable(nonempty_list(switch_label)) = false
nullable(nonempty_list(item)) = false
nullable(nonempty_list(import_declaration)) = false
nullable(nonempty_list(dim_expr)) = false
nullable(nonempty_list(catch_clause)) = false
nullable(nonempty_list(block_statement)) = false
nullable(name) = false
nullable(multiplicative_expression) = false
nullable(modifiers) = false
nullable(modifier) = false
nullable(method_reference) = false
nullable(method_invocation) = false
nullable(method_header) = false
nullable(method_declarator) = false
nullable(method_declaration) = false
nullable(method_body) = false
nullable(local_variable_type) = false
nullable(local_variable_declaration_statement) = false
nullable(local_variable_declaration) = false
nullable(literal) = false
nullable(listc0(type_argument)) = true
nullable(listc0(formal_parameter)) = true
nullable(listc0(argument)) = true
nullable(listc(variable_initializer)) = false
nullable(listc(variable_declarator)) = false
nullable(listc(type_parameter)) = false
nullable(listc(type_argument)) = false
nullable(listc(statement_expression)) = false
nullable(listc(reference_type)) = false
nullable(listc(name)) = false
nullable(listc(lambda_param)) = false
nullable(listc(identifier)) = false
nullable(listc(formal_parameter)) = false
nullable(listc(enum_constant)) = false
nullable(listc(element_value_pair)) = false
nullable(listc(element_value)) = false
nullable(listc(argument)) = false
nullable(list_sep(type_,OR)) = false
nullable(list_sep(resource,SM)) = false
nullable(list_sep(reference_type,AND)) = false
nullable(list(variable_modifier)) = true
nullable(list(type_declaration)) = true
nullable(list(method_declaration)) = true
nullable(list(interface_member_declaration)) = true
nullable(list(class_body_declaration)) = true
nullable(list(catch_clause)) = true
nullable(list(block_statement)) = true
nullable(list(annotation_type_element_declaration)) = true
nullable(left_hand_side) = false
nullable(lambda_parameters) = false
nullable(lambda_parameter_type) = false
nullable(lambda_parameter_list) = false
nullable(lambda_param) = false
nullable(lambda_expression) = false
nullable(lambda_body) = false
nullable(labeled_statement_no_short_if) = false
nullable(labeled_statement) = false
nullable(item_other) = false
nullable(item_no_dots) = false
nullable(item) = false
nullable(interfaces) = false
nullable(interface_method_declaration) = false
nullable(interface_member_declaration) = false
nullable(interface_generic_method_decl) = false
nullable(interface_declaration) = false
nullable(interface_body) = false
nullable(instance_initializer) = false
nullable(inclusive_or_expression) = false
nullable(import_declaration) = false
nullable(if_then_statement) = false
nullable(if_then_else_statement_no_short_if) = false
nullable(if_then_else_statement) = false
nullable(identifier_) = false
nullable(identifier) = false
nullable(goal) = false
nullable(generic_method_or_constructor_decl) = false
nullable(formal_parameters) = false
nullable(formal_parameter) = false
nullable(for_var_control_rest) = false
nullable(for_var_control) = false
nullable(for_update) = false
nullable(for_statement_no_short_if) = false
nullable(for_statement) = false
nullable(for_init_opt) = true
nullable(for_init) = false
nullable(for_control) = false
nullable(finally) = false
nullable(field_declaration) = false
nullable(field_access) = false
nullable(extends_interfaces) = false
nullable(expression_statement) = false
nullable(expression) = false
nullable(expr1) = false
nullable(explicit_constructor_invocation) = false
nullable(exclusive_or_expression) = false
nullable(equality_expression) = false
nullable(enum_declaration) = false
nullable(enum_constant_bis) = false
nullable(enum_constant) = false
nullable(enum_body_declarations) = false
nullable(enum_body) = false
nullable(empty_statement) = false
nullable(element_value_pair) = false
nullable(element_value_array_initializer) = false
nullable(element_value) = false
nullable(do_statement) = false
nullable(dims_opt) = true
nullable(dims) = false
nullable(dim_expr) = false
nullable(declaration) = false
nullable(continue_statement) = false
nullable(constructor_declarator) = false
nullable(constructor_declaration) = false
nullable(constructor_body) = false
nullable(constant_expression) = false
nullable(constant_declaration) = false
nullable(conditional_or_expression) = false
nullable(conditional_expression) = false
nullable(conditional_and_expression) = false
nullable(compilation_unit) = true
nullable(class_or_interface_type) = false
nullable(class_member_declaration) = false
nullable(class_literal) = false
nullable(class_instance_creation_expression) = false
nullable(class_header) = false
nullable(class_declaration) = false
nullable(class_body_declaration) = false
nullable(class_body) = false
nullable(catch_type) = false
nullable(catch_formal_parameter) = false
nullable(catch_clause) = false
nullable(cast_lambda_expression) = false
nullable(cast_expression) = false
nullable(break_statement) = false
nullable(bound) = false
nullable(block_statement) = false
nullable(block) = false
nullable(assignment_operator) = false
nullable(assignment_expression) = false
nullable(assignment) = false
nullable(array_type) = false
nullable(array_initializer) = false
nullable(array_creation_expression_with_initializer) = false
nullable(array_creation_expression) = false
nullable(array_access) = false
nullable(argument) = false
nullable(annotation_type_element_rest) = false
nullable(annotation_type_element_declaration) = false
nullable(annotation_type_declaration) = false
nullable(annotation_type_body) = false
nullable(annotation_method_or_constant_rest) = false
nullable(annotation_element) = true
nullable(annotation) = false
nullable(and_expression) = false
nullable(additive_expression) = false
first(while_statement_no_short_if) = WHILE
first(while_statement) = WHILE
first(variable_modifier) = FINAL AT
first(variable_initializer) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots LC INCR IDENTIFIER FALSE DOTS DECR COMPL
first(variable_declarator_id_bis) = IDENTIFIER DOTS
first(variable_declarator_id) = IDENTIFIER
first(variable_declarator) = IDENTIFIER
first(variable_arity_parameter) = PRIMITIVE_TYPE IDENTIFIER FINAL AT
first(variable_access) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(unary_expression_not_plus_minus) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NOT NEW LP IDENTIFIER FALSE COMPL
first(unary_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DECR COMPL
first(unann_type) = PRIMITIVE_TYPE IDENTIFIER
first(typed_metavar) = LP
first(type_parameters) = LT
first(type_parameter) = IDENTIFIER
first(type_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL ENUM DEFAULT CLASS AT ABSTRACT
first(type_argument) = PRIMITIVE_TYPE IDENTIFIER COND
first(type_) = PRIMITIVE_TYPE IDENTIFIER
first(try_statement) = TRY
first(throws) = THROWS
first(throw_statement) = THROW
first(synchronized_statement) = SYNCHRONIZED
first(switch_statement) = SWITCH
first(switch_label) = DEFAULT_COLON CASE
first(switch_block_statement_groups) = DEFAULT_COLON CASE
first(switch_block_statement_group) = DEFAULT_COLON CASE
first(switch_block) = LC
first(super) = EXTENDS
first(static_initializer) = STATIC
first(statement_without_trailing_substatement) = VOID TString TRY TRUE TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER SM RETURN PRIMITIVE_TYPE NULL NEW LP LC INCR IDENTIFIER FALSE DO DECR CONTINUE BREAK ASSERT
first(statement_no_short_if) = WHILE VOID TString TRY TRUE TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER SM RETURN PRIMITIVE_TYPE NULL NEW LP LC INCR IF IDENTIFIER FOR FALSE DO DECR CONTINUE BREAK ASSERT
first(statement_no_dots) = WHILE VOID TString TRY TRUE TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER SM RETURN PRIMITIVE_TYPE NULL NEW LP LC INCR IF IDENTIFIER FOR FALSE DO DECR CONTINUE BREAK ASSERT
first(statement_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP INCR IDENTIFIER FALSE DECR
first(statement) = WHILE VOID TString TRY TRUE TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER SM RETURN PRIMITIVE_TYPE NULL NEW LP LC INCR IF IDENTIFIER FOR FALSE DOTS DO DECR CONTINUE BREAK ASSERT
first(shift_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DOTS DECR COMPL
first(sgrep_spatch_pattern) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS PACKAGE NULL NOT NEW NATIVE MINUS LP_LAMBDA LP LDots LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE ENUM DOTS DO DEFAULT DECR CONTINUE COMPL CLASS BREAK AT ASSERT ABSTRACT
first(return_statement) = RETURN
first(resource_specification) = LP
first(resource) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FINAL FALSE AT
first(relational_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DOTS DECR COMPL
first(reference_type) = PRIMITIVE_TYPE IDENTIFIER
first(qualified_ident) = IDENTIFIER
first(primitive_type) = PRIMITIVE_TYPE
first(primary_no_new_array) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(primary) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(pre_increment_expression) = INCR
first(pre_decrement_expression) = DECR
first(postfix_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(post_increment_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(post_decrement_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(package_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PACKAGE NATIVE FINAL DEFAULT AT ABSTRACT
first(optl(type_parameters)) = LT
first(optl(throws)) = THROWS
first(optl(listc(type_argument))) = PRIMITIVE_TYPE IDENTIFIER COND
first(optl(listc(formal_parameter))) = PRIMITIVE_TYPE IDENTIFIER FINAL DOTS AT
first(optl(listc(argument))) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL
first(optl(interfaces)) = IMPLEMENTS
first(optl(for_update)) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP INCR IDENTIFIER FALSE DECR
first(optl(extends_interfaces)) = EXTENDS
first(optl(enum_body_declarations)) = SM DOTS
first(option(super)) = EXTENDS
first(option(identifier)) = IDENTIFIER
first(option(finally)) = FINALLY
first(option(expression)) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL
first(option(class_body)) = LC
first(option(STATIC)) = STATIC
first(option(SM)) = SM
first(option(CM)) = CM
first(nonempty_list(variable_modifier)) = FINAL AT
first(nonempty_list(switch_label)) = DEFAULT_COLON CASE
first(nonempty_list(item)) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
first(nonempty_list(import_declaration)) = IMPORT
first(nonempty_list(dim_expr)) = LB
first(nonempty_list(catch_clause)) = CATCH
first(nonempty_list(block_statement)) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
first(name) = IDENTIFIER
first(multiplicative_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DECR COMPL
first(modifiers) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE FINAL DEFAULT AT ABSTRACT
first(modifier) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE FINAL DEFAULT AT ABSTRACT
first(method_reference) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(method_invocation) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(method_header) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT
first(method_declarator) = IDENTIFIER
first(method_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT
first(method_body) = SM LC
first(local_variable_type) = PRIMITIVE_TYPE IDENTIFIER
first(local_variable_declaration_statement) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT
first(local_variable_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT
first(literal) = TString TRUE TInt TFloat TChar NULL FALSE
first(listc0(type_argument)) = PRIMITIVE_TYPE IDENTIFIER COND
first(listc0(formal_parameter)) = PRIMITIVE_TYPE IDENTIFIER FINAL DOTS AT
first(listc0(argument)) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL
first(listc(variable_initializer)) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots LC INCR IDENTIFIER FALSE DOTS DECR COMPL
first(listc(variable_declarator)) = IDENTIFIER
first(listc(type_parameter)) = IDENTIFIER
first(listc(type_argument)) = PRIMITIVE_TYPE IDENTIFIER COND
first(listc(statement_expression)) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP INCR IDENTIFIER FALSE DECR
first(listc(reference_type)) = PRIMITIVE_TYPE IDENTIFIER
first(listc(name)) = IDENTIFIER
first(listc(lambda_param)) = VAR PRIMITIVE_TYPE IDENTIFIER FINAL AT
first(listc(identifier)) = IDENTIFIER
first(listc(formal_parameter)) = PRIMITIVE_TYPE IDENTIFIER FINAL DOTS AT
first(listc(enum_constant)) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT
first(listc(element_value_pair)) = IDENTIFIER DOTS
first(listc(element_value)) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP LC INCR IDENTIFIER FALSE DOTS DECR COMPL AT
first(listc(argument)) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL
first(list_sep(type_,OR)) = PRIMITIVE_TYPE IDENTIFIER
first(list_sep(resource,SM)) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FINAL FALSE AT
first(list_sep(reference_type,AND)) = PRIMITIVE_TYPE IDENTIFIER
first(list(variable_modifier)) = FINAL AT
first(list(type_declaration)) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL ENUM DEFAULT CLASS AT ABSTRACT
first(list(method_declaration)) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT
first(list(interface_member_declaration)) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
first(list(class_body_declaration)) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
first(list(catch_clause)) = CATCH
first(list(block_statement)) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
first(list(annotation_type_element_declaration)) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
first(left_hand_side) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(lambda_parameters) = LP_LAMBDA IDENTIFIER
first(lambda_parameter_type) = VAR PRIMITIVE_TYPE IDENTIFIER
first(lambda_parameter_list) = VAR PRIMITIVE_TYPE IDENTIFIER FINAL AT
first(lambda_param) = VAR PRIMITIVE_TYPE IDENTIFIER FINAL AT
first(lambda_expression) = LP_LAMBDA IDENTIFIER
first(lambda_body) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots LC INCR IDENTIFIER FALSE DOTS DECR COMPL
first(labeled_statement_no_short_if) = IDENTIFIER
first(labeled_statement) = IDENTIFIER
first(item_other) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE INTERFACE IMPORT IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
first(item_no_dots) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE ENUM DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
first(item) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
first(interfaces) = IMPLEMENTS
first(interface_method_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT
first(interface_member_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
first(interface_generic_method_decl) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE LT FINAL DEFAULT AT ABSTRACT
first(interface_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL DEFAULT AT ABSTRACT
first(interface_body) = LC
first(instance_initializer) = LC
first(inclusive_or_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DOTS DECR COMPL
first(import_declaration) = IMPORT
first(if_then_statement) = IF
first(if_then_else_statement_no_short_if) = IF
first(if_then_else_statement) = IF
first(identifier_) = IDENTIFIER
first(identifier) = IDENTIFIER
first(goal) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PACKAGE NATIVE INTERFACE IMPORT FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT
first(generic_method_or_constructor_decl) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE LT FINAL DEFAULT AT ABSTRACT
first(formal_parameters) = LP
first(formal_parameter) = PRIMITIVE_TYPE IDENTIFIER FINAL DOTS AT
first(for_var_control_rest) = COLON
first(for_var_control) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT
first(for_update) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP INCR IDENTIFIER FALSE DECR
first(for_statement_no_short_if) = FOR
first(for_statement) = FOR
first(for_init_opt) = VOLATILE VOID TString TRUE TRANSIENT TInt THIS TFloat TChar SYNCHRONIZED SUPER STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP INCR IDENTIFIER FINAL FALSE DEFAULT DECR AT ABSTRACT
first(for_init) = VOLATILE VOID TString TRUE TRANSIENT TInt THIS TFloat TChar SYNCHRONIZED SUPER STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP INCR IDENTIFIER FINAL FALSE DEFAULT DECR AT ABSTRACT
first(for_control) = VOLATILE VOID TString TRUE TRANSIENT TInt THIS TFloat TChar SYNCHRONIZED SUPER STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP INCR IDENTIFIER FINAL FALSE DOTS DEFAULT DECR AT ABSTRACT
first(finally) = FINALLY
first(field_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT
first(field_access) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(extends_interfaces) = EXTENDS
first(expression_statement) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP INCR IDENTIFIER FALSE DECR
first(expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL
first(expr1) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DOTS DECR COMPL
first(explicit_constructor_invocation) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(exclusive_or_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DOTS DECR COMPL
first(equality_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DOTS DECR COMPL
first(enum_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE FINAL ENUM DEFAULT AT ABSTRACT
first(enum_constant_bis) = IDENTIFIER
first(enum_constant) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT
first(enum_body_declarations) = SM DOTS
first(enum_body) = LC
first(empty_statement) = SM
first(element_value_pair) = IDENTIFIER DOTS
first(element_value_array_initializer) = LC
first(element_value) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP LC INCR IDENTIFIER FALSE DOTS DECR COMPL AT
first(do_statement) = DO
first(dims_opt) = LB_RB
first(dims) = LB_RB
first(dim_expr) = LB
first(declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
first(continue_statement) = CONTINUE
first(constructor_declarator) = IDENTIFIER
first(constructor_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT
first(constructor_body) = LC
first(constant_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL
first(constant_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL DEFAULT AT ABSTRACT
first(conditional_or_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DOTS DECR COMPL
first(conditional_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DOTS DECR COMPL
first(conditional_and_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DOTS DECR COMPL
first(compilation_unit) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PACKAGE NATIVE INTERFACE IMPORT FINAL ENUM DEFAULT CLASS AT ABSTRACT
first(class_or_interface_type) = IDENTIFIER
first(class_member_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
first(class_literal) = VOID PRIMITIVE_TYPE IDENTIFIER
first(class_instance_creation_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(class_header) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE FINAL DEFAULT CLASS AT ABSTRACT
first(class_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE FINAL DEFAULT CLASS AT ABSTRACT
first(class_body_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
first(class_body) = LC
first(catch_type) = PRIMITIVE_TYPE IDENTIFIER
first(catch_formal_parameter) = PRIMITIVE_TYPE IDENTIFIER FINAL AT
first(catch_clause) = CATCH
first(cast_lambda_expression) = LP
first(cast_expression) = LP
first(break_statement) = BREAK
first(bound) = PRIMITIVE_TYPE IDENTIFIER
first(block_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
first(block) = LC
first(assignment_operator) = OPERATOR_EQ EQ
first(assignment_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL
first(assignment) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(array_type) = PRIMITIVE_TYPE IDENTIFIER
first(array_initializer) = LC
first(array_creation_expression_with_initializer) = NEW
first(array_creation_expression) = NEW
first(array_access) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NULL NEW LP IDENTIFIER FALSE
first(argument) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL
first(annotation_type_element_rest) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
first(annotation_type_element_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
first(annotation_type_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE FINAL DEFAULT AT ABSTRACT
first(annotation_type_body) = LC
first(annotation_method_or_constant_rest) = LP
first(annotation_element) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP LC INCR IDENTIFIER FALSE DOTS DECR COMPL AT
first(annotation) = AT
first(and_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DOTS DECR COMPL
first(additive_expression) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP INCR IDENTIFIER FALSE DOTS DECR COMPL
minimal(while_statement_no_short_if) = (* 5 *) WHILE LP TRUE RP SM
minimal(while_statement) = (* 5 *) WHILE LP TRUE RP DOTS
minimal(variable_modifier) = (* 1 *) FINAL
minimal(variable_initializer) = (* 1 *) TRUE
minimal(variable_declarator_id_bis) = (* 1 *) IDENTIFIER
minimal(variable_declarator_id) = (* 1 *) IDENTIFIER
minimal(variable_declarator) = (* 1 *) IDENTIFIER
minimal(variable_arity_parameter) = (* 3 *) PRIMITIVE_TYPE DOTS IDENTIFIER
minimal(variable_access) = (* 1 *) IDENTIFIER
minimal(unary_expression_not_plus_minus) = (* 1 *) TRUE
minimal(unary_expression) = (* 1 *) TRUE
minimal(unann_type) = (* 1 *) PRIMITIVE_TYPE
minimal(typed_metavar) = (* 4 *) LP PRIMITIVE_TYPE IDENTIFIER RP
minimal(type_parameters) = (* 3 *) LT IDENTIFIER GT
minimal(type_parameter) = (* 1 *) IDENTIFIER
minimal(type_declaration) = (* 1 *) SM
minimal(type_argument) = (* 1 *) IDENTIFIER
minimal(type_) = (* 1 *) PRIMITIVE_TYPE
minimal(try_statement) = (* 6 *) TRY LC RC FINALLY LC RC
minimal(throws) = (* 2 *) THROWS IDENTIFIER
minimal(throw_statement) = (* 3 *) THROW TRUE SM
minimal(synchronized_statement) = (* 6 *) SYNCHRONIZED LP TRUE RP LC RC
minimal(switch_statement) = (* 6 *) SWITCH LP TRUE RP LC RC
minimal(switch_label) = (* 2 *) DEFAULT_COLON COLON
minimal(switch_block_statement_groups) = (* 3 *) DEFAULT_COLON COLON DOTS
minimal(switch_block_statement_group) = (* 3 *) DEFAULT_COLON COLON DOTS
minimal(switch_block) = (* 2 *) LC RC
minimal(super) = (* 2 *) EXTENDS PRIMITIVE_TYPE
minimal(static_initializer) = (* 3 *) STATIC LC RC
minimal(statement_without_trailing_substatement) = (* 1 *) SM
minimal(statement_no_short_if) = (* 1 *) SM
minimal(statement_no_dots) = (* 1 *) SM
minimal(statement_expression) = (* 1 *) IDENTIFIER
minimal(statement) = (* 1 *) DOTS
minimal(shift_expression) = (* 1 *) TRUE
minimal(sgrep_spatch_pattern) = (* 2 *) TRUE EOF
minimal(return_statement) = (* 2 *) RETURN SM
minimal(resource_specification) = (* 3 *) LP IDENTIFIER RP
minimal(resource) = (* 1 *) IDENTIFIER
minimal(relational_expression) = (* 1 *) TRUE
minimal(reference_type) = (* 1 *) IDENTIFIER
minimal(qualified_ident) = (* 1 *) IDENTIFIER
minimal(primitive_type) = (* 1 *) PRIMITIVE_TYPE
minimal(primary_no_new_array) = (* 1 *) TRUE
minimal(primary) = (* 1 *) TRUE
minimal(pre_increment_expression) = (* 2 *) INCR TRUE
minimal(pre_decrement_expression) = (* 2 *) DECR TRUE
minimal(postfix_expression) = (* 1 *) TRUE
minimal(post_increment_expression) = (* 2 *) TRUE INCR
minimal(post_decrement_expression) = (* 2 *) TRUE DECR
minimal(package_declaration) = (* 3 *) PACKAGE IDENTIFIER SM
minimal(optl(type_parameters)) = (* 0 *)
minimal(optl(throws)) = (* 0 *)
minimal(optl(listc(type_argument))) = (* 0 *)
minimal(optl(listc(formal_parameter))) = (* 0 *)
minimal(optl(listc(argument))) = (* 0 *)
minimal(optl(interfaces)) = (* 0 *)
minimal(optl(for_update)) = (* 0 *)
minimal(optl(extends_interfaces)) = (* 0 *)
minimal(optl(enum_body_declarations)) = (* 0 *)
minimal(option(super)) = (* 0 *)
minimal(option(identifier)) = (* 0 *)
minimal(option(finally)) = (* 0 *)
minimal(option(expression)) = (* 0 *)
minimal(option(class_body)) = (* 0 *)
minimal(option(STATIC)) = (* 0 *)
minimal(option(SM)) = (* 0 *)
minimal(option(CM)) = (* 0 *)
minimal(nonempty_list(variable_modifier)) = (* 1 *) FINAL
minimal(nonempty_list(switch_label)) = (* 2 *) DEFAULT_COLON COLON
minimal(nonempty_list(item)) = (* 1 *) DOTS
minimal(nonempty_list(import_declaration)) = (* 3 *) IMPORT IDENTIFIER SM
minimal(nonempty_list(dim_expr)) = (* 3 *) LB TRUE RB
minimal(nonempty_list(catch_clause)) = (* 6 *) CATCH LP PRIMITIVE_TYPE IDENTIFIER RP SM
minimal(nonempty_list(block_statement)) = (* 1 *) DOTS
minimal(name) = (* 1 *) IDENTIFIER
minimal(multiplicative_expression) = (* 1 *) TRUE
minimal(modifiers) = (* 1 *) PUBLIC
minimal(modifier) = (* 1 *) PUBLIC
minimal(method_reference) = (* 3 *) IDENTIFIER COLONCOLON IDENTIFIER
minimal(method_invocation) = (* 3 *) IDENTIFIER LP RP
minimal(method_header) = (* 4 *) PRIMITIVE_TYPE IDENTIFIER LP RP
minimal(method_declarator) = (* 3 *) IDENTIFIER LP RP
minimal(method_declaration) = (* 5 *) PRIMITIVE_TYPE IDENTIFIER LP RP SM
minimal(method_body) = (* 1 *) SM
minimal(local_variable_type) = (* 1 *) PRIMITIVE_TYPE
minimal(local_variable_declaration_statement) = (* 3 *) PRIMITIVE_TYPE IDENTIFIER SM
minimal(local_variable_declaration) = (* 2 *) PRIMITIVE_TYPE IDENTIFIER
minimal(literal) = (* 1 *) TRUE
minimal(listc0(type_argument)) = (* 0 *)
minimal(listc0(formal_parameter)) = (* 0 *)
minimal(listc0(argument)) = (* 0 *)
minimal(listc(variable_initializer)) = (* 1 *) TRUE
minimal(listc(variable_declarator)) = (* 1 *) IDENTIFIER
minimal(listc(type_parameter)) = (* 1 *) IDENTIFIER
minimal(listc(type_argument)) = (* 1 *) IDENTIFIER
minimal(listc(statement_expression)) = (* 1 *) IDENTIFIER
minimal(listc(reference_type)) = (* 1 *) IDENTIFIER
minimal(listc(name)) = (* 1 *) IDENTIFIER
minimal(listc(lambda_param)) = (* 2 *) PRIMITIVE_TYPE IDENTIFIER
minimal(listc(identifier)) = (* 1 *) IDENTIFIER
minimal(listc(formal_parameter)) = (* 1 *) DOTS
minimal(listc(enum_constant)) = (* 1 *) IDENTIFIER
minimal(listc(element_value_pair)) = (* 1 *) DOTS
minimal(listc(element_value)) = (* 1 *) TRUE
minimal(listc(argument)) = (* 1 *) TRUE
minimal(list_sep(type_,OR)) = (* 1 *) PRIMITIVE_TYPE
minimal(list_sep(resource,SM)) = (* 1 *) IDENTIFIER
minimal(list_sep(reference_type,AND)) = (* 1 *) IDENTIFIER
minimal(list(variable_modifier)) = (* 0 *)
minimal(list(type_declaration)) = (* 0 *)
minimal(list(method_declaration)) = (* 0 *)
minimal(list(interface_member_declaration)) = (* 0 *)
minimal(list(class_body_declaration)) = (* 0 *)
minimal(list(catch_clause)) = (* 0 *)
minimal(list(block_statement)) = (* 0 *)
minimal(list(annotation_type_element_declaration)) = (* 0 *)
minimal(left_hand_side) = (* 1 *) IDENTIFIER
minimal(lambda_parameters) = (* 1 *) IDENTIFIER
minimal(lambda_parameter_type) = (* 1 *) PRIMITIVE_TYPE
minimal(lambda_parameter_list) = (* 1 *) IDENTIFIER
minimal(lambda_param) = (* 2 *) PRIMITIVE_TYPE IDENTIFIER
minimal(lambda_expression) = (* 3 *) IDENTIFIER ARROW TRUE
minimal(lambda_body) = (* 1 *) TRUE
minimal(labeled_statement_no_short_if) = (* 3 *) IDENTIFIER COLON SM
minimal(labeled_statement) = (* 3 *) IDENTIFIER COLON DOTS
minimal(item_other) = (* 3 *) IMPORT IDENTIFIER SM
minimal(item_no_dots) = (* 1 *) SM
minimal(item) = (* 1 *) DOTS
minimal(interfaces) = (* 2 *) IMPLEMENTS IDENTIFIER
minimal(interface_method_declaration) = (* 5 *) PRIMITIVE_TYPE IDENTIFIER LP RP SM
minimal(interface_member_declaration) = (* 1 *) SM
minimal(interface_generic_method_decl) = (* 8 *) LT IDENTIFIER GT PRIMITIVE_TYPE IDENTIFIER LP RP SM
minimal(interface_declaration) = (* 4 *) INTERFACE IDENTIFIER LC RC
minimal(interface_body) = (* 2 *) LC RC
minimal(instance_initializer) = (* 2 *) LC RC
minimal(inclusive_or_expression) = (* 1 *) TRUE
minimal(import_declaration) = (* 3 *) IMPORT IDENTIFIER SM
minimal(if_then_statement) = (* 5 *) IF LP TRUE RP DOTS
minimal(if_then_else_statement_no_short_if) = (* 7 *) IF LP TRUE RP SM ELSE SM
minimal(if_then_else_statement) = (* 7 *) IF LP TRUE RP SM ELSE DOTS
minimal(identifier_) = (* 1 *) IDENTIFIER
minimal(identifier) = (* 1 *) IDENTIFIER
minimal(goal) = (* 1 *) EOF
minimal(generic_method_or_constructor_decl) = (* 8 *) LT IDENTIFIER GT PRIMITIVE_TYPE IDENTIFIER LP RP SM
minimal(formal_parameters) = (* 2 *) LP RP
minimal(formal_parameter) = (* 1 *) DOTS
minimal(for_var_control_rest) = (* 2 *) COLON TRUE
minimal(for_var_control) = (* 4 *) PRIMITIVE_TYPE IDENTIFIER COLON TRUE
minimal(for_update) = (* 1 *) IDENTIFIER
minimal(for_statement_no_short_if) = (* 5 *) FOR LP DOTS RP SM
minimal(for_statement) = (* 5 *) FOR LP DOTS RP DOTS
minimal(for_init_opt) = (* 0 *)
minimal(for_init) = (* 1 *) IDENTIFIER
minimal(for_control) = (* 1 *) DOTS
minimal(finally) = (* 3 *) FINALLY LC RC
minimal(field_declaration) = (* 3 *) PRIMITIVE_TYPE IDENTIFIER SM
minimal(field_access) = (* 3 *) SUPER DOT IDENTIFIER
minimal(extends_interfaces) = (* 2 *) EXTENDS IDENTIFIER
minimal(expression_statement) = (* 2 *) IDENTIFIER SM
minimal(expression) = (* 1 *) TRUE
minimal(expr1) = (* 1 *) TRUE
minimal(explicit_constructor_invocation) = (* 4 *) THIS LP RP SM
minimal(exclusive_or_expression) = (* 1 *) TRUE
minimal(equality_expression) = (* 1 *) TRUE
minimal(enum_declaration) = (* 4 *) ENUM IDENTIFIER LC RC
minimal(enum_constant_bis) = (* 1 *) IDENTIFIER
minimal(enum_constant) = (* 1 *) IDENTIFIER
minimal(enum_body_declarations) = (* 1 *) SM
minimal(enum_body) = (* 2 *) LC RC
minimal(empty_statement) = (* 1 *) SM
minimal(element_value_pair) = (* 1 *) DOTS
minimal(element_value_array_initializer) = (* 2 *) LC RC
minimal(element_value) = (* 1 *) TRUE
minimal(do_statement) = (* 7 *) DO DOTS WHILE LP TRUE RP SM
minimal(dims_opt) = (* 0 *)
minimal(dims) = (* 1 *) LB_RB
minimal(dim_expr) = (* 3 *) LB TRUE RB
minimal(declaration) = (* 4 *) CLASS IDENTIFIER LC RC
minimal(continue_statement) = (* 2 *) CONTINUE SM
minimal(constructor_declarator) = (* 3 *) IDENTIFIER LP RP
minimal(constructor_declaration) = (* 5 *) IDENTIFIER LP RP LC RC
minimal(constructor_body) = (* 2 *) LC RC
minimal(constant_expression) = (* 1 *) TRUE
minimal(constant_declaration) = (* 3 *) PRIMITIVE_TYPE IDENTIFIER SM
minimal(conditional_or_expression) = (* 1 *) TRUE
minimal(conditional_expression) = (* 1 *) TRUE
minimal(conditional_and_expression) = (* 1 *) TRUE
minimal(compilation_unit) = (* 0 *)
minimal(class_or_interface_type) = (* 1 *) IDENTIFIER
minimal(class_member_declaration) = (* 1 *) SM
minimal(class_literal) = (* 3 *) PRIMITIVE_TYPE DOT CLASS
minimal(class_instance_creation_expression) = (* 4 *) NEW IDENTIFIER LP RP
minimal(class_header) = (* 2 *) CLASS IDENTIFIER
minimal(class_declaration) = (* 4 *) CLASS IDENTIFIER LC RC
minimal(class_body_declaration) = (* 1 *) SM
minimal(class_body) = (* 2 *) LC RC
minimal(catch_type) = (* 1 *) PRIMITIVE_TYPE
minimal(catch_formal_parameter) = (* 2 *) PRIMITIVE_TYPE IDENTIFIER
minimal(catch_clause) = (* 6 *) CATCH LP PRIMITIVE_TYPE IDENTIFIER RP SM
minimal(cast_lambda_expression) = (* 6 *) LP TRUE RP IDENTIFIER ARROW TRUE
minimal(cast_expression) = (* 4 *) LP PRIMITIVE_TYPE RP TRUE
minimal(break_statement) = (* 2 *) BREAK SM
minimal(bound) = (* 1 *) IDENTIFIER
minimal(block_statement) = (* 1 *) DOTS
minimal(block) = (* 2 *) LC RC
minimal(assignment_operator) = (* 1 *) EQ
minimal(assignment_expression) = (* 1 *) TRUE
minimal(assignment) = (* 3 *) IDENTIFIER EQ TRUE
minimal(array_type) = (* 2 *) PRIMITIVE_TYPE LB_RB
minimal(array_initializer) = (* 2 *) LC RC
minimal(array_creation_expression_with_initializer) = (* 5 *) NEW PRIMITIVE_TYPE LB_RB LC RC
minimal(array_creation_expression) = (* 5 *) NEW PRIMITIVE_TYPE LB TRUE RB
minimal(array_access) = (* 4 *) IDENTIFIER LB TRUE RB
minimal(argument) = (* 1 *) TRUE
minimal(annotation_type_element_rest) = (* 4 *) CLASS IDENTIFIER LC RC
minimal(annotation_type_element_declaration) = (* 4 *) CLASS IDENTIFIER LC RC
minimal(annotation_type_declaration) = (* 5 *) AT INTERFACE IDENTIFIER LC RC
minimal(annotation_type_body) = (* 2 *) LC RC
minimal(annotation_method_or_constant_rest) = (* 2 *) LP RP
minimal(annotation_element) = (* 0 *)
minimal(annotation) = (* 2 *) AT IDENTIFIER
minimal(and_expression) = (* 1 *) TRUE
minimal(additive_expression) = (* 1 *) TRUE
maximal(while_statement_no_short_if) = infinity
maximal(while_statement) = infinity
maximal(variable_modifier) = infinity
maximal(variable_initializer) = infinity
maximal(variable_declarator_id_bis) = infinity
maximal(variable_declarator_id) = infinity
maximal(variable_declarator) = infinity
maximal(variable_arity_parameter) = infinity
maximal(variable_access) = infinity
maximal(unary_expression_not_plus_minus) = infinity
maximal(unary_expression) = infinity
maximal(unann_type) = infinity
maximal(typed_metavar) = infinity
maximal(type_parameters) = infinity
maximal(type_parameter) = infinity
maximal(type_declaration) = infinity
maximal(type_argument) = infinity
maximal(type_) = infinity
maximal(try_statement) = infinity
maximal(throws) = infinity
maximal(throw_statement) = infinity
maximal(synchronized_statement) = infinity
maximal(switch_statement) = infinity
maximal(switch_label) = infinity
maximal(switch_block_statement_groups) = infinity
maximal(switch_block_statement_group) = infinity
maximal(switch_block) = infinity
maximal(super) = infinity
maximal(static_initializer) = infinity
maximal(statement_without_trailing_substatement) = infinity
maximal(statement_no_short_if) = infinity
maximal(statement_no_dots) = infinity
maximal(statement_expression) = infinity
maximal(statement) = infinity
maximal(shift_expression) = infinity
maximal(sgrep_spatch_pattern) = infinity
maximal(return_statement) = infinity
maximal(resource_specification) = infinity
maximal(resource) = infinity
maximal(relational_expression) = infinity
maximal(reference_type) = infinity
maximal(qualified_ident) = infinity
maximal(primitive_type) = 1
maximal(primary_no_new_array) = infinity
maximal(primary) = infinity
maximal(pre_increment_expression) = infinity
maximal(pre_decrement_expression) = infinity
maximal(postfix_expression) = infinity
maximal(post_increment_expression) = infinity
maximal(post_decrement_expression) = infinity
maximal(package_declaration) = infinity
maximal(optl(type_parameters)) = infinity
maximal(optl(throws)) = infinity
maximal(optl(listc(type_argument))) = infinity
maximal(optl(listc(formal_parameter))) = infinity
maximal(optl(listc(argument))) = infinity
maximal(optl(interfaces)) = infinity
maximal(optl(for_update)) = infinity
maximal(optl(extends_interfaces)) = infinity
maximal(optl(enum_body_declarations)) = infinity
maximal(option(super)) = infinity
maximal(option(identifier)) = 1
maximal(option(finally)) = infinity
maximal(option(expression)) = infinity
maximal(option(class_body)) = infinity
maximal(option(STATIC)) = 1
maximal(option(SM)) = 1
maximal(option(CM)) = 1
maximal(nonempty_list(variable_modifier)) = infinity
maximal(nonempty_list(switch_label)) = infinity
maximal(nonempty_list(item)) = infinity
maximal(nonempty_list(import_declaration)) = infinity
maximal(nonempty_list(dim_expr)) = infinity
maximal(nonempty_list(catch_clause)) = infinity
maximal(nonempty_list(block_statement)) = infinity
maximal(name) = infinity
maximal(multiplicative_expression) = infinity
maximal(modifiers) = infinity
maximal(modifier) = infinity
maximal(method_reference) = infinity
maximal(method_invocation) = infinity
maximal(method_header) = infinity
maximal(method_declarator) = infinity
maximal(method_declaration) = infinity
maximal(method_body) = infinity
maximal(local_variable_type) = infinity
maximal(local_variable_declaration_statement) = infinity
maximal(local_variable_declaration) = infinity
maximal(literal) = 1
maximal(listc0(type_argument)) = infinity
maximal(listc0(formal_parameter)) = infinity
maximal(listc0(argument)) = infinity
maximal(listc(variable_initializer)) = infinity
maximal(listc(variable_declarator)) = infinity
maximal(listc(type_parameter)) = infinity
maximal(listc(type_argument)) = infinity
maximal(listc(statement_expression)) = infinity
maximal(listc(reference_type)) = infinity
maximal(listc(name)) = infinity
maximal(listc(lambda_param)) = infinity
maximal(listc(identifier)) = infinity
maximal(listc(formal_parameter)) = infinity
maximal(listc(enum_constant)) = infinity
maximal(listc(element_value_pair)) = infinity
maximal(listc(element_value)) = infinity
maximal(listc(argument)) = infinity
maximal(list_sep(type_,OR)) = infinity
maximal(list_sep(resource,SM)) = infinity
maximal(list_sep(reference_type,AND)) = infinity
maximal(list(variable_modifier)) = infinity
maximal(list(type_declaration)) = infinity
maximal(list(method_declaration)) = infinity
maximal(list(interface_member_declaration)) = infinity
maximal(list(class_body_declaration)) = infinity
maximal(list(catch_clause)) = infinity
maximal(list(block_statement)) = infinity
maximal(list(annotation_type_element_declaration)) = infinity
maximal(left_hand_side) = infinity
maximal(lambda_parameters) = infinity
maximal(lambda_parameter_type) = infinity
maximal(lambda_parameter_list) = infinity
maximal(lambda_param) = infinity
maximal(lambda_expression) = infinity
maximal(lambda_body) = infinity
maximal(labeled_statement_no_short_if) = infinity
maximal(labeled_statement) = infinity
maximal(item_other) = infinity
maximal(item_no_dots) = infinity
maximal(item) = infinity
maximal(interfaces) = infinity
maximal(interface_method_declaration) = infinity
maximal(interface_member_declaration) = infinity
maximal(interface_generic_method_decl) = infinity
maximal(interface_declaration) = infinity
maximal(interface_body) = infinity
maximal(instance_initializer) = infinity
maximal(inclusive_or_expression) = infinity
maximal(import_declaration) = infinity
maximal(if_then_statement) = infinity
maximal(if_then_else_statement_no_short_if) = infinity
maximal(if_then_else_statement) = infinity
maximal(identifier_) = infinity
maximal(identifier) = 1
maximal(goal) = infinity
maximal(generic_method_or_constructor_decl) = infinity
maximal(formal_parameters) = infinity
maximal(formal_parameter) = infinity
maximal(for_var_control_rest) = infinity
maximal(for_var_control) = infinity
maximal(for_update) = infinity
maximal(for_statement_no_short_if) = infinity
maximal(for_statement) = infinity
maximal(for_init_opt) = infinity
maximal(for_init) = infinity
maximal(for_control) = infinity
maximal(finally) = infinity
maximal(field_declaration) = infinity
maximal(field_access) = infinity
maximal(extends_interfaces) = infinity
maximal(expression_statement) = infinity
maximal(expression) = infinity
maximal(expr1) = infinity
maximal(explicit_constructor_invocation) = infinity
maximal(exclusive_or_expression) = infinity
maximal(equality_expression) = infinity
maximal(enum_declaration) = infinity
maximal(enum_constant_bis) = infinity
maximal(enum_constant) = infinity
maximal(enum_body_declarations) = infinity
maximal(enum_body) = infinity
maximal(empty_statement) = 1
maximal(element_value_pair) = infinity
maximal(element_value_array_initializer) = infinity
maximal(element_value) = infinity
maximal(do_statement) = infinity
maximal(dims_opt) = infinity
maximal(dims) = infinity
maximal(dim_expr) = infinity
maximal(declaration) = infinity
maximal(continue_statement) = 3
maximal(constructor_declarator) = infinity
maximal(constructor_declaration) = infinity
maximal(constructor_body) = infinity
maximal(constant_expression) = infinity
maximal(constant_declaration) = infinity
maximal(conditional_or_expression) = infinity
maximal(conditional_expression) = infinity
maximal(conditional_and_expression) = infinity
maximal(compilation_unit) = infinity
maximal(class_or_interface_type) = infinity
maximal(class_member_declaration) = infinity
maximal(class_literal) = infinity
maximal(class_instance_creation_expression) = infinity
maximal(class_header) = infinity
maximal(class_declaration) = infinity
maximal(class_body_declaration) = infinity
maximal(class_body) = infinity
maximal(catch_type) = infinity
maximal(catch_formal_parameter) = infinity
maximal(catch_clause) = infinity
maximal(cast_lambda_expression) = infinity
maximal(cast_expression) = infinity
maximal(break_statement) = 3
maximal(bound) = infinity
maximal(block_statement) = infinity
maximal(block) = infinity
maximal(assignment_operator) = 1
maximal(assignment_expression) = infinity
maximal(assignment) = infinity
maximal(array_type) = infinity
maximal(array_initializer) = infinity
maximal(array_creation_expression_with_initializer) = infinity
maximal(array_creation_expression) = infinity
maximal(array_access) = infinity
maximal(argument) = infinity
maximal(annotation_type_element_rest) = infinity
maximal(annotation_type_element_declaration) = infinity
maximal(annotation_type_declaration) = infinity
maximal(annotation_type_body) = infinity
maximal(annotation_method_or_constant_rest) = infinity
maximal(annotation_element) = infinity
maximal(annotation) = infinity
maximal(and_expression) = infinity
maximal(additive_expression) = infinity
follow(while_statement_no_short_if) = ELSE
follow(while_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(variable_modifier) = VAR PRIMITIVE_TYPE IDENTIFIER FINAL AT
follow(variable_initializer) = SM RC CM
follow(variable_declarator_id_bis) = RP CM
follow(variable_declarator_id) = SM RP LB_RB EQ COLON CM
follow(variable_declarator) = SM CM
follow(variable_arity_parameter) = RP CM
follow(variable_access) = SM RP
follow(unary_expression_not_plus_minus) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
follow(unary_expression) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
follow(unann_type) = IDENTIFIER DOTS
follow(typed_metavar) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(type_parameters) = VOID PRIMITIVE_TYPE LC IMPLEMENTS IDENTIFIER EXTENDS EOF
follow(type_parameter) = GT CM
follow(type_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT
follow(type_argument) = GT CM
follow(type_) = OR LC IMPLEMENTS IDENTIFIER EOF DOTS
follow(try_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(throws) = SM LC EOF
follow(throw_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(synchronized_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(switch_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(switch_label) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(switch_block_statement_groups) = RC DEFAULT_COLON CASE
follow(switch_block_statement_group) = RC DEFAULT_COLON CASE
follow(switch_block) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(super) = LC IMPLEMENTS EOF
follow(static_initializer) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(statement_without_trailing_substatement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(statement_no_short_if) = ELSE
follow(statement_no_dots) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(statement_expression) = SM RP CM
follow(statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(shift_expression) = XOR URS SRS SM RP RDots RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
follow(sgrep_spatch_pattern) = #
follow(return_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(resource_specification) = LC
follow(resource) = SM RP
follow(relational_expression) = XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
follow(reference_type) = XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS COND COLON CM AND_AND AND
follow(qualified_ident) = VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT LP INTERFACE IDENTIFIER FINAL EOF ENUM DOT DEFAULT CM CLASS AT ABSTRACT
follow(primitive_type) = RP OR LC LB_RB LB IMPLEMENTS IDENTIFIER EOF DOTS DOT
follow(primary_no_new_array) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(primary) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(pre_increment_expression) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
follow(pre_decrement_expression) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
follow(postfix_expression) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND
follow(post_increment_expression) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND
follow(post_decrement_expression) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DIV DECR COND COLON CM AND_AND AND
follow(package_declaration) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(optl(type_parameters)) = LC IMPLEMENTS EXTENDS EOF
follow(optl(throws)) = SM LC EOF
follow(optl(listc(type_argument))) = GT
follow(optl(listc(formal_parameter))) = RP
follow(optl(listc(argument))) = RP
follow(optl(interfaces)) = LC EOF
follow(optl(for_update)) = RP
follow(optl(extends_interfaces)) = LC
follow(optl(enum_body_declarations)) = RC
follow(option(super)) = LC IMPLEMENTS EOF
follow(option(identifier)) = SM
follow(option(finally)) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(option(expression)) = SM
follow(option(class_body)) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(option(STATIC)) = IDENTIFIER
follow(option(SM)) = RP
follow(option(CM)) = RC
follow(nonempty_list(variable_modifier)) = VAR PRIMITIVE_TYPE IDENTIFIER
follow(nonempty_list(switch_label)) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(nonempty_list(item)) = EOF
follow(nonempty_list(import_declaration)) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM DEFAULT CLASS AT ABSTRACT
follow(nonempty_list(dim_expr)) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(nonempty_list(catch_clause)) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(nonempty_list(block_statement)) = RC DEFAULT_COLON CASE
follow(name) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(multiplicative_expression) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
follow(modifiers) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
follow(modifier) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
follow(method_reference) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(method_invocation) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(method_header) = SM LC EOF
follow(method_declarator) = THROWS SM LC LB_RB EOF
follow(method_declaration) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(method_body) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(local_variable_type) = IDENTIFIER
follow(local_variable_declaration_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(local_variable_declaration) = SM
follow(literal) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(listc0(type_argument)) = GT
follow(listc0(formal_parameter)) = RP
follow(listc0(argument)) = RP
follow(listc(variable_initializer)) = RC CM
follow(listc(variable_declarator)) = SM CM
follow(listc(type_parameter)) = GT CM
follow(listc(type_argument)) = GT CM
follow(listc(statement_expression)) = SM RP CM
follow(listc(reference_type)) = LC EOF CM
follow(listc(name)) = SM LC EOF CM
follow(listc(lambda_param)) = RP CM
follow(listc(identifier)) = RP CM
follow(listc(formal_parameter)) = RP CM
follow(listc(enum_constant)) = SM RC DOTS CM
follow(listc(element_value_pair)) = RP CM
follow(listc(element_value)) = RC CM
follow(listc(argument)) = RP CM
follow(list_sep(type_,OR)) = OR IDENTIFIER
follow(list_sep(resource,SM)) = SM RP
follow(list_sep(reference_type,AND)) = GT CM AND
follow(list(variable_modifier)) = PRIMITIVE_TYPE IDENTIFIER
follow(list(type_declaration)) = EOF
follow(list(method_declaration)) = RC
follow(list(interface_member_declaration)) = RC
follow(list(class_body_declaration)) = RC
follow(list(catch_clause)) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(list(block_statement)) = RC
follow(list(annotation_type_element_declaration)) = RC
follow(left_hand_side) = OPERATOR_EQ EQ
follow(lambda_parameters) = ARROW
follow(lambda_parameter_type) = IDENTIFIER
follow(lambda_parameter_list) = RP
follow(lambda_param) = RP CM
follow(lambda_expression) = SM RP RDots RC RB EOF COLON CM
follow(lambda_body) = SM RP RDots RC RB EOF COLON CM
follow(labeled_statement_no_short_if) = ELSE
follow(labeled_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(item_other) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(item_no_dots) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(item) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(interfaces) = LC EOF
follow(interface_method_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(interface_member_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(interface_generic_method_decl) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(interface_declaration) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(interface_body) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(instance_initializer) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(inclusive_or_expression) = SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND
follow(import_declaration) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(if_then_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(if_then_else_statement_no_short_if) = ELSE
follow(if_then_else_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(identifier_) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(identifier) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT_GENERIC LT LS LP LE LC LB_RB LB INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE EXTENDS EQ_EQ EQ EOF DOTS DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(goal) = #
follow(generic_method_or_constructor_decl) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(formal_parameters) = THROWS SM LC
follow(formal_parameter) = RP CM
follow(for_var_control_rest) = RP
follow(for_var_control) = RP
follow(for_update) = RP
follow(for_statement_no_short_if) = ELSE
follow(for_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(for_init_opt) = SM
follow(for_init) = SM
follow(for_control) = RP
follow(finally) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(field_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(field_access) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(extends_interfaces) = LC CM
follow(expression_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(expression) = SM RP RDots RC RB EOF COLON CM
follow(expr1) = SM RP RC CM
follow(explicit_constructor_invocation) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(exclusive_or_expression) = XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND
follow(equality_expression) = XOR SM RP RDots RC RB OR_OR OR NOT_EQ EQ_EQ EOF COND COLON CM AND_AND AND
follow(enum_declaration) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(enum_constant_bis) = SM RC DOTS CM
follow(enum_constant) = SM RC DOTS CM
follow(enum_body_declarations) = RC
follow(enum_body) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(empty_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
follow(element_value_pair) = RP CM
follow(element_value_array_initializer) = SM RP RC CM
follow(element_value) = SM RP RC CM
follow(do_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(dims_opt) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(dims) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LC LB_RB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(dim_expr) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(declaration) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(continue_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(constructor_declarator) = THROWS LC
follow(constructor_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(constructor_body) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(constant_expression) = COLON
follow(constant_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(conditional_or_expression) = SM RP RDots RC RB OR_OR EOF COND COLON CM
follow(conditional_expression) = SM RP RDots RC RB EOF COLON CM
follow(conditional_and_expression) = SM RP RDots RC RB OR_OR EOF COND COLON CM AND_AND
follow(compilation_unit) = EOF
follow(class_or_interface_type) = XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS COND COLON CM AND_AND AND
follow(class_member_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(class_literal) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(class_instance_creation_expression) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(class_header) = LC EOF
follow(class_declaration) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(class_body_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(class_body) = XOR WHILE VOLATILE VOID URS TString TRY TRUE TRANSIENT TInt TIMES THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SRS SM RP RETURN RDots RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS PACKAGE OR_OR OR NULL NOT_EQ NEW NATIVE MOD MINUS LT LS LP LE LC LB INTERFACE INSTANCEOF INCR IMPORT IF IDENTIFIER GT GE FOR FINAL FALSE EQ_EQ EOF ENUM DOTS DOT DO DIV DEFAULT_COLON DEFAULT DECR CONTINUE COND COLONCOLON COLON CM CLASS CASE BREAK AT ASSERT AND_AND AND ABSTRACT
follow(catch_type) = IDENTIFIER
follow(catch_formal_parameter) = RP
follow(catch_clause) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
follow(cast_lambda_expression) = SM RP RDots RC RB EOF COLON CM
follow(cast_expression) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF DIV COND COLON CM AND_AND AND
follow(break_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(bound) = GT CM
follow(block_statement) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NULL NEW NATIVE LP LC INCR IF IDENTIFIER FOR FINAL FALSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(block) = WHILE VOLATILE VOID TString TRY TRUE TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RP RETURN RDots RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NULL NEW NATIVE LT LP LC INTERFACE INCR IMPORT IF IDENTIFIER FOR FINALLY FINAL FALSE EOF ENUM ELSE DOTS DO DEFAULT_COLON DEFAULT DECR CONTINUE COLON CM CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
follow(assignment_operator) = VOID TString TRUE TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NULL NOT NEW MINUS LP_LAMBDA LP LDots INCR IDENTIFIER FALSE DOTS DECR COMPL
follow(assignment_expression) = SM RP RDots RC RB EOF COLON CM
follow(assignment) = SM RP RDots RC RB EOF COLON CM
follow(array_type) = XOR SM RP RDots RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ EOF DOTS DOT COND COLONCOLON COLON CM AND_AND AND
follow(array_initializer) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(array_creation_expression_with_initializer) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(array_creation_expression) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(array_access) = XOR URS TIMES SRS SM RP RDots RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ EOF DOT DIV DECR COND COLONCOLON COLON CM AND_AND AND
follow(argument) = RP CM
follow(annotation_type_element_rest) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
follow(annotation_type_element_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM DEFAULT CLASS AT ABSTRACT
follow(annotation_type_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(annotation_type_body) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM DOTS DEFAULT CLASS AT ABSTRACT
follow(annotation_method_or_constant_rest) = SM
follow(annotation_element) = RP
follow(annotation) = VOLATILE VOID VAR TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PACKAGE NATIVE LT INTERFACE IDENTIFIER FINAL EOF ENUM DEFAULT CM CLASS AT ABSTRACT
follow(and_expression) = XOR SM RP RDots RC RB OR_OR OR EOF COND COLON CM AND_AND AND
follow(additive_expression) = XOR URS SRS SM RP RDots RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ EOF COND COLON CM AND_AND AND
Built an LR(0) automaton with 976 states.
The grammar is not SLR(1) -- 22 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 976 states.
418 out of 976 states have a default reduction.
338 out of 976 states are represented.
0 out of 331 symbols keep track of their start position.
0 out of 331 symbols keep track of their end position.
322 out of 541 productions exploit shiftreduce optimization.
0 out of 976 states can peek at an error.
2723 functions before inlining, 393 functions after inlining.
