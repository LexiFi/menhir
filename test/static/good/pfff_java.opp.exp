File "pfff_java.mly", line 227, characters 33-38:
Warning: the token CONST is unused.
File "pfff_java.mly", line 228, characters 43-47:
Warning: the token GOTO is unused.
File "pfff_java.mly", line 165, characters 22-30:
Warning: the token TComment is unused.
File "pfff_java.mly", line 165, characters 31-46:
Warning: the token TCommentNewline is unused.
File "pfff_java.mly", line 165, characters 47-60:
Warning: the token TCommentSpace is unused.
File "pfff_java.mly", line 153, characters 22-30:
Warning: the token TUnknown is unused.
%{
open Common
open AST_generic_ (* for the arithmetic operator *)
open Ast_java
module PI = Parse_info

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
let empty_body = PI.fake_bracket []
let fake_dot = Parse_info.fake_info "."

(* todo? use a Ast.special? *)
let super_ident ii = ("super", ii)

let named_type (str, ii) = TBasic (str,ii)
let void_type ii = named_type ("void", ii)

(* we have to use a 'name' to specify reference types in the grammar
 * because of some ambiguity but what we really wanted was an
 * identifier followed by some type arguments.
 *)
let (class_type: name_or_class_type -> class_type) = fun xs ->
  xs |> List.map (function
  | Id x -> x, []
  | Id_then_TypeArgs (x, xs) -> x, xs
  | TypeArgs_then_Id _ -> raise Parsing.Parse_error
  )

let (name: name_or_class_type -> expr) = fun xs ->
  let ys =
    xs |> List.map (function
     | Id x -> [], x
     | Id_then_TypeArgs (x, xs) ->
      (* this is ok because of the ugly trick we do for Cast
       * where we transform a Name into a ref_type
       *)
        xs, x
     | TypeArgs_then_Id (xs, Id x) ->
        xs, x
     | TypeArgs_then_Id (_xs, _) ->
        raise Parsing.Parse_error
     )
  in
  (* TODO: we should not discard the type information *)
  let ys = ys |> List.map snd in

  (* x.y.z -> Dot (Dot (NameId x, y), z) *)
  let ys = List.rev ys in
  (* z.y.x -> Dot (Dot (NameId x, y), z) *)

  let rec aux xs =
    match xs with
    | [] -> raise Impossible
    | [x] -> NameId x
    | [y;x] -> Dot (NameId x, fake_dot, y)
    | z::xs ->
        let e = aux xs in
        Dot (e, fake_dot, z)
  in
  aux ys

let fix_name arg =
   (* Ambiguity. It could be a field access (Dot) or a qualified
    * name (Name). See ast_java.ml note on the Dot constructor for
    * more information.
    * The last dot has to be a Dot and not a Name at least,
    * but more elements of Name could be a Dot too.
    * Hence the switch to just NameId instead of the code below
    *)
   (*
   match List.rev arg with
   | (Id id)::x::xs ->
       Dot (Name (name (List.rev (x::xs))), Parse_info.fake_info ".", id)
   | _ ->
       Name (name arg)
   *)
   name arg

let (qualified_ident: name_or_class_type -> qualified_ident) = fun xs ->
  xs |> List.map (function
  | Id x -> x
  | Id_then_TypeArgs _ -> raise Parsing.Parse_error
  | TypeArgs_then_Id _ -> raise Parsing.Parse_error
  )


let expr_to_typename expr =
(*
    match expr with
    | Name name ->
        TClass (name |> List.map (fun (xs, id) -> id, xs))
    (* ugly, undo what was done in postfix_expression *)
    | Dot (Name name, _, id) ->
        TClass ((name @ [[], id]) |> List.map (fun (xs, id) -> id, xs))
    | _ ->
        pr2 "cast_expression pb";
        pr2_gen expr;
        raise Todo
*)
  (* TODO: we lost the type information with the switch to NameId and Dot *)
  let rec aux e =
    match e with
    | NameId id -> [id]
    | Dot (e, _, id) -> aux e @ [id]
    | _ ->
        pr2 "cast_expression pb";
        pr2_gen expr;
        raise Todo
   in
   let xs = aux expr in
   TClass (xs |> List.map (fun id -> id, []))

let mk_stmt_or_stmts = function
  | [] -> AStmts []
  | [x] -> AStmt x
  | xs -> AStmts xs
%}
%start goal
%start sgrep_spatch_pattern
%token <Parse_info.t> ABSTRACT
%token <Parse_info.t> AND
%token <Parse_info.t> AND_AND
%token <Parse_info.t> ARROW
%token <Parse_info.t> ASSERT
%token <Parse_info.t> AT
%token <Parse_info.t> BREAK
%token <Parse_info.t> CASE
%token <Parse_info.t> CATCH
%token <Parse_info.t> CLASS
%token <Parse_info.t> CM
%token <Parse_info.t> COLON
%token <Parse_info.t> COLONCOLON
%token <Parse_info.t> COMPL
%token <Parse_info.t> COND
%token <Parse_info.t> CONST
%token <Parse_info.t> CONTINUE
%token <Parse_info.t> DECR
%token <Parse_info.t> DEFAULT
%token <Parse_info.t> DEFAULT_COLON
%token <Parse_info.t> DIV
%token <Parse_info.t> DO
%token <Parse_info.t> DOT
%token <Parse_info.t> DOTS
%token <Parse_info.t> ELSE
%token <Parse_info.t> ENUM
%token <Parse_info.t> EOF
%token <Parse_info.t> EQ
%token <Parse_info.t> EQ_EQ
%token <Parse_info.t> EXTENDS
%token <Parse_info.t> FALSE
%token <Parse_info.t> FINAL
%token <Parse_info.t> FINALLY
%token <Parse_info.t> FOR
%token <Parse_info.t> GE
%token <Parse_info.t> GOTO
%token <Parse_info.t> GT
%token <(string * Parse_info.t)> IDENTIFIER
%token <Parse_info.t> IF
%token <Parse_info.t> IMPLEMENTS
%token <Parse_info.t> IMPORT
%token <Parse_info.t> INCR
%token <Parse_info.t> INSTANCEOF
%token <Parse_info.t> INTERFACE
%token <Parse_info.t> LB
%token <Parse_info.t> LB_RB
%token <Parse_info.t> LC
%token <Parse_info.t> LDots
%token <Parse_info.t> LE
%token <Parse_info.t> LP
%token <Parse_info.t> LP_LAMBDA
%token <Parse_info.t> LS
%token <Parse_info.t> LT
%token <Parse_info.t> LT_GENERIC
%token <Parse_info.t> MINUS
%token <Parse_info.t> MOD
%token <Parse_info.t> NATIVE
%token <Parse_info.t> NEW
%token <Parse_info.t> NOT
%token <Parse_info.t> NOT_EQ
%token <Parse_info.t> NULL
%token <(AST_generic_.operator * Parse_info.t)> OPERATOR_EQ
%token <Parse_info.t> OR
%token <Parse_info.t> OR_OR
%token <Parse_info.t> PACKAGE
%token <Parse_info.t> PLUS
%token <(string * Parse_info.t)> PRIMITIVE_TYPE
%token <Parse_info.t> PRIVATE
%token <Parse_info.t> PROTECTED
%token <Parse_info.t> PUBLIC
%token <Parse_info.t> RB
%token <Parse_info.t> RC
%token <Parse_info.t> RDots
%token <Parse_info.t> RETURN
%token <Parse_info.t> RP
%token <Parse_info.t> SM
%token <Parse_info.t> SRS
%token <Parse_info.t> STATIC
%token <Parse_info.t> STRICTFP
%token <Parse_info.t> SUPER
%token <Parse_info.t> SWITCH
%token <Parse_info.t> SYNCHRONIZED
%token <string * Parse_info.t> TChar
%token <Parse_info.t> TComment
%token <Parse_info.t> TCommentNewline
%token <Parse_info.t> TCommentSpace
%token <float option * Parse_info.t> TFloat
%token <Parse_info.t> THIS
%token <Parse_info.t> THROW
%token <Parse_info.t> THROWS
%token <Parse_info.t> TIMES
%token <int option * Parse_info.t> TInt
%token <Parse_info.t> TRANSIENT
%token <Parse_info.t> TRUE
%token <Parse_info.t> TRY
%token <string * Parse_info.t> TString
%token <Parse_info.t> TUnknown
%token <Parse_info.t> URS
%token <Parse_info.t> VAR
%token <Parse_info.t> VOID
%token <Parse_info.t> VOLATILE
%token <Parse_info.t> WHILE
%token <Parse_info.t> XOR
%type <Ast_java.program> goal
%type <Ast_java.any> sgrep_spatch_pattern
%%

option_CM_:
  
    {    ( None )} [@name none_CM]
| x = CM
    {    ( Some x )} [@name some_CM]

option_SM_:
  
    {    ( None )} [@name none_SM]
| x = SM
    {    ( Some x )} [@name some_SM]

option_STATIC_:
  
    {    ( None )} [@name none_STATIC]
| x = STATIC
    {    ( Some x )} [@name some_STATIC]

option_class_body_:
  
    {    ( None )} [@name none_class_body]
| x = class_body
    {    ( Some x )} [@name some_class_body]

option_expression_:
  
    {    ( None )} [@name none_expression]
| x = expression
    {    ( Some x )} [@name some_expression]

option_finally_:
  
    {    ( None )} [@name none_finally]
| x = finally
    {    ( Some x )} [@name some_finally]

option_identifier_:
  
    {    ( None )} [@name none_identifier]
| x = identifier
    {    ( Some x )} [@name some_identifier]

option_super_:
  
    {    ( None )} [@name none_super]
| x = super
    {    ( Some x )} [@name some_super]

list_annotation_type_element_declaration_:
  
    {    ( [] )} [@name nil_annotation_type_element_declaration]
| x = annotation_type_element_declaration xs = list_annotation_type_element_declaration_
    {    ( x :: xs )} [@name cons_annotation_type_element_declaration]

list_block_statement_:
  
    {    ( [] )} [@name nil_block_statement]
| x = block_statement xs = list_block_statement_
    {    ( x :: xs )} [@name cons_block_statement]

list_catch_clause_:
  
    {    ( [] )} [@name nil_catch_clause]
| x = catch_clause xs = list_catch_clause_
    {    ( x :: xs )} [@name cons_catch_clause]

list_class_body_declaration_:
  
    {    ( [] )} [@name nil_class_body_declaration]
| x = class_body_declaration xs = list_class_body_declaration_
    {    ( x :: xs )} [@name cons_class_body_declaration]

list_interface_member_declaration_:
  
    {    ( [] )} [@name nil_interface_member_declaration]
| x = interface_member_declaration xs = list_interface_member_declaration_
    {    ( x :: xs )} [@name cons_interface_member_declaration]

list_method_declaration_:
  
    {    ( [] )} [@name nil_method_declaration]
| x = method_declaration xs = list_method_declaration_
    {    ( x :: xs )} [@name cons_method_declaration]

list_type_declaration_:
  
    {    ( [] )} [@name nil_type_declaration]
| x = type_declaration xs = list_type_declaration_
    {    ( x :: xs )} [@name cons_type_declaration]

list_variable_modifier_:
  
    {    ( [] )} [@name nil_variable_modifier]
| x = variable_modifier xs = list_variable_modifier_
    {    ( x :: xs )} [@name cons_variable_modifier]

nonempty_list_block_statement_:
  x = block_statement
    {    ( [ x ] )} [@name one_block_statement]
| x = block_statement xs = nonempty_list_block_statement_
    {    ( x :: xs )} [@name more_block_statement]

nonempty_list_catch_clause_:
  x = catch_clause
    {    ( [ x ] )} [@name one_catch_clause]
| x = catch_clause xs = nonempty_list_catch_clause_
    {    ( x :: xs )} [@name more_catch_clause]

nonempty_list_dim_expr_:
  x = dim_expr
    {    ( [ x ] )} [@name one_dim_expr]
| x = dim_expr xs = nonempty_list_dim_expr_
    {    ( x :: xs )} [@name more_dim_expr]

nonempty_list_import_declaration_:
  x = import_declaration
    {    ( [ x ] )} [@name one_import_declaration]
| x = import_declaration xs = nonempty_list_import_declaration_
    {    ( x :: xs )} [@name more_import_declaration]

nonempty_list_item_:
  x = item
    {    ( [ x ] )} [@name one_item]
| x = item xs = nonempty_list_item_
    {    ( x :: xs )} [@name more_item]

nonempty_list_switch_label_:
  x = switch_label
    {    ( [ x ] )} [@name one_switch_label]
| x = switch_label xs = nonempty_list_switch_label_
    {    ( x :: xs )} [@name more_switch_label]

nonempty_list_variable_modifier_:
  x = variable_modifier
    {    ( [ x ] )} [@name one_variable_modifier]
| x = variable_modifier xs = nonempty_list_variable_modifier_
    {    ( x :: xs )} [@name more_variable_modifier]

optl_enum_body_declarations_:
  
    {               ( [] )}
| _1 = enum_body_declarations
    {               ( _1 )}

optl_extends_interfaces_:
  
    {               ( [] )}
| _1 = extends_interfaces
    {               ( _1 )}

optl_for_update_:
  
    {               ( [] )}
| _1 = for_update
    {               ( _1 )}

optl_interfaces_:
  
    {               ( [] )}
| _1 = interfaces
    {               ( _1 )}

optl_listc_argument__:
  
    {               ( [] )}
| _1 = listc_argument_
    {               ( _1 )}

optl_listc_formal_parameter__:
  
    {               ( [] )}
| _1 = listc_formal_parameter_
    {               ( _1 )}

optl_listc_type_argument__:
  
    {               ( [] )}
| _1 = listc_type_argument_
    {               ( _1 )}

optl_throws_:
  
    {               ( [] )}
| _1 = throws
    {               ( _1 )}

optl_type_parameters_:
  
    {               ( [] )}
| _1 = type_parameters
    {               ( _1 )}

listc_argument_:
  _1 = argument
    {     ( [_1] )}
| _1 = listc_argument_ _2 = CM _3 = argument
    {                  ( _1 @ [_3] )}

listc_element_value_:
  _1 = element_value
    {     ( [_1] )}
| _1 = listc_element_value_ _2 = CM _3 = element_value
    {                  ( _1 @ [_3] )}

listc_element_value_pair_:
  _1 = element_value_pair
    {     ( [_1] )}
| _1 = listc_element_value_pair_ _2 = CM _3 = element_value_pair
    {                  ( _1 @ [_3] )}

listc_enum_constant_:
  _1 = enum_constant
    {     ( [_1] )}
| _1 = listc_enum_constant_ _2 = CM _3 = enum_constant
    {                  ( _1 @ [_3] )}

listc_formal_parameter_:
  _1 = formal_parameter
    {     ( [_1] )}
| _1 = listc_formal_parameter_ _2 = CM _3 = formal_parameter
    {                  ( _1 @ [_3] )}

listc_identifier_:
  _1 = identifier
    {     ( [_1] )}
| _1 = listc_identifier_ _2 = CM _3 = identifier
    {                  ( _1 @ [_3] )}

listc_lambda_param_:
  _1 = lambda_param
    {     ( [_1] )}
| _1 = listc_lambda_param_ _2 = CM _3 = lambda_param
    {                  ( _1 @ [_3] )}

listc_name_:
  _1 = name
    {     ( [_1] )}
| _1 = listc_name_ _2 = CM _3 = name
    {                  ( _1 @ [_3] )}

listc_reference_type_:
  _1 = reference_type
    {     ( [_1] )}
| _1 = listc_reference_type_ _2 = CM _3 = reference_type
    {                  ( _1 @ [_3] )}

listc_statement_expression_:
  _1 = statement_expression
    {     ( [_1] )}
| _1 = listc_statement_expression_ _2 = CM _3 = statement_expression
    {                  ( _1 @ [_3] )}

listc_type_argument_:
  _1 = type_argument
    {     ( [_1] )}
| _1 = listc_type_argument_ _2 = CM _3 = type_argument
    {                  ( _1 @ [_3] )}

listc_type_parameter_:
  _1 = type_parameter
    {     ( [_1] )}
| _1 = listc_type_parameter_ _2 = CM _3 = type_parameter
    {                  ( _1 @ [_3] )}

listc_variable_declarator_:
  _1 = variable_declarator
    {     ( [_1] )}
| _1 = listc_variable_declarator_ _2 = CM _3 = variable_declarator
    {                  ( _1 @ [_3] )}

listc_variable_initializer_:
  _1 = variable_initializer
    {     ( [_1] )}
| _1 = listc_variable_initializer_ _2 = CM _3 = variable_initializer
    {                  ( _1 @ [_3] )}

listc0_argument_:
  _1 = optl_listc_argument__
    {                          ( _1 )}

listc0_formal_parameter_:
  _1 = optl_listc_formal_parameter__
    {                          ( _1 )}

listc0_type_argument_:
  _1 = optl_listc_type_argument__
    {                          ( _1 )}

list_sep_reference_type_AND_:
  _1 = reference_type
    {                          ( [_1] )}
| _1 = list_sep_reference_type_AND_ _2 = AND _3 = reference_type
    {                          ( _1 @ [_3] )}

list_sep_resource_SM_:
  _1 = resource
    {                          ( [_1] )}
| _1 = list_sep_resource_SM_ _2 = SM _3 = resource
    {                          ( _1 @ [_3] )}

list_sep_type__OR_:
  _1 = type_
    {                          ( [_1] )}
| _1 = list_sep_type__OR_ _2 = OR _3 = type_
    {                          ( _1 @ [_3] )}

goal:
  _1 = compilation_unit _2 = EOF
    {                            ( _1 )}

compilation_unit:
  _1 = package_declaration _2 = nonempty_list_import_declaration_ _3 = list_type_declaration_
    {    ( [DirectiveStmt _1] @ (_2 |> List.map (fun x -> DirectiveStmt x)) @ List.flatten _3 )}
| _1 = package_declaration _2 = list_type_declaration_
    {    ( [DirectiveStmt _1] @ List.flatten _2 )}
| _1 = nonempty_list_import_declaration_ _2 = list_type_declaration_
    {    ( (_1 |> List.map (fun x -> DirectiveStmt x)) @ List.flatten _2 )}
| _1 = list_type_declaration_
    {    ( List.flatten _1 )}

declaration:
  _1 = class_declaration
    {                          ( Class _1 )}
| _1 = interface_declaration
    {                          ( Class _1 )}
| _1 = enum_declaration
    {                          ( Enum _1 )}
| _1 = method_declaration
    {                          ( Method _1 )}

sgrep_spatch_pattern:
  _1 = expression _2 = EOF
    {                                 ( AExpr _1 )}
| _1 = item_no_dots _2 = EOF
    {                                 ( mk_stmt_or_stmts _1 )}
| _1 = item_no_dots _2 = nonempty_list_item_ _3 = EOF
    {                                 ( mk_stmt_or_stmts (_1 @ (List.flatten _2)) )}
| _1 = annotation _2 = EOF
    {                  ( AMod (Annotation _1, Common2.fst3 _1) )}
| _1 = class_header _2 = EOF
    {                     ( Partial (PartialDecl (Class _1)) )}
| _1 = method_header _2 = EOF
    {                     ( Partial (PartialDecl (Method _1)) )}

item:
  _1 = statement
    {             ( [_1] )}
| _1 = item_other
    {              ( _1 )}

item_no_dots:
  _1 = statement_no_dots
    {                     ( [_1] )}
| _1 = item_other
    {              ( _1 )}

item_other:
  _1 = declaration
    {                       ( [DeclStmt _1] )}
| _1 = import_declaration
    {                       ( [DirectiveStmt _1] )}
| _1 = package_declaration
    {                       ( [DirectiveStmt _1] )}
| _1 = local_variable_declaration_statement
    {                                        ( _1 )}

statement_no_dots:
  _1 = statement_without_trailing_substatement
    {                                            ( _1 )}
| _1 = labeled_statement
    {                      ( _1 )}
| _1 = if_then_statement
    {                      ( _1 )}
| _1 = if_then_else_statement
    {                           ( _1 )}
| _1 = while_statement
    {                    ( _1 )}
| _1 = for_statement
    {                  ( _1 )}

package_declaration:
  _2 = PACKAGE _3 = qualified_ident _4 = SM
    {let _1 =               ( [] ) in
  ( Package (_2, _3, _4) (* TODO $1*))}
| _1 = modifiers _2 = PACKAGE _3 = qualified_ident _4 = SM
    {let _1 =               ( List.rev _1 ) in
  ( Package (_2, _3, _4) (* TODO $1*))}

import_declaration:
  _1 = IMPORT _2 = option_STATIC_ _3 = name _4 = SM
    {    ( (Import (_2,
      (match List.rev (qualified_ident _3) with
      | x::xs -> ImportFrom (_1, List.rev xs, x)
      | [] -> raise Impossible
      ))) )}
| _1 = IMPORT _2 = option_STATIC_ _3 = name _4 = DOT _5 = TIMES _6 = SM
    {    ( (Import (_2, ImportAll (_1, qualified_ident _3, _5))))}

type_declaration:
  _1 = class_declaration
    {                          ( [DeclStmt (Class _1)] )}
| _1 = interface_declaration
    {                          ( [DeclStmt (Class _1)] )}
| _1 = SM
    {        ( [] )}
| _1 = enum_declaration
    {                               ( [DeclStmt (Enum _1)] )}
| _1 = annotation_type_declaration
    {                               ( [DeclStmt (Class _1)] )}

identifier:
  _1 = IDENTIFIER
    {                       ( _1 )}

qualified_ident:
  _1 = IDENTIFIER
    {                                   ( [_1] )}
| _1 = qualified_ident _2 = DOT _3 = IDENTIFIER
    {                                   ( _1 @ [_3] )}

name:
  _1 = identifier_
    {                         ( [_1] )}
| _1 = name _2 = DOT _3 = identifier_
    {                         ( _1 @ [_3] )}
| _1 = name _2 = DOT _3 = LT_GENERIC _4 = listc_type_argument_ _5 = GT _6 = identifier_
    {     ( _1@[TypeArgs_then_Id(_4,_6)] )}

identifier_:
  _1 = identifier
    {                                                  ( Id _1 )}
| _1 = identifier _2 = LT_GENERIC _3 = listc0_type_argument_ _4 = GT
    {                                                  ( Id_then_TypeArgs(_1, _3) )}

type_:
  _1 = primitive_type
    {                   ( _1 )}
| _1 = reference_type
    {                   ( _1 )}

primitive_type:
  _1 = PRIMITIVE_TYPE
    {                                ( named_type _1 )}

class_or_interface_type:
  _1 = name
    {                              ( TClass (class_type _1) )}

reference_type:
  _1 = class_or_interface_type
    {                           ( _1 )}
| _1 = array_type
    {              ( _1 )}

array_type:
  _1 = primitive_type _2 = LB_RB
    {                                                ( TArray (_2, _1, _2) )}
| _1 = class_or_interface_type _2 = LB_RB
    {                                                ( TArray (_2, _1, _2) )}
| _1 = array_type _2 = LB_RB
    {                                                ( TArray (_2, _1, _2) )}

type_argument:
  _1 = reference_type
    {                  ( TArgument _1 )}
| _1 = COND
    {                  ( TWildCard (_1, None) )}
| _1 = COND _2 = EXTENDS _3 = reference_type
    {                               ( TWildCard (_1, Some ((false,_2), _3)) )}
| _1 = COND _2 = SUPER _3 = reference_type
    {                               ( TWildCard (_1, Some ((true, _2), _3)) )}

type_parameters:
  _1 = LT _2 = listc_type_parameter_ _3 = GT
    {                                             ( _2 )}

type_parameter:
  _1 = identifier
    {                            ( TParam (_1, []) )}
| _1 = identifier _2 = EXTENDS _3 = bound
    {                            ( TParam (_1, _3) )}

bound:
  _1 = list_sep_reference_type_AND_
    {                                     ( _1 )}

typed_metavar:
  _1 = LP _2 = type_ _3 = IDENTIFIER _4 = RP
    {   ( Flag_parsing.sgrep_guard (TypedMetavar(_3, _2))  )}

primary:
  _1 = primary_no_new_array
    {                              ( _1 )}
| _1 = array_creation_expression
    {                              ( _1 )}

primary_no_new_array:
  _1 = literal
    {                                      ( _1 )}
| _1 = THIS
    {                                      ( This _1 )}
| _1 = LP _2 = expression _3 = RP
    {                                      ( _2 )}
| _1 = class_instance_creation_expression
    {                                      ( _1 )}
| _1 = field_access
    {                                      ( _1 )}
| _1 = method_invocation
    {                                      ( _1 )}
| _1 = array_access
    {                                      ( _1 )}
| _1 = typed_metavar
    {                       ( _1 )}
| _1 = name _2 = DOT _3 = THIS
    {                       ( Dot (name _1, _2, ("this", _3)) )}
| _1 = class_literal
    {                       ( _1 )}
| _1 = method_reference
    {                    ( _1 )}
| _1 = array_creation_expression_with_initializer
    {                                              ( _1 )}

literal:
  _1 = TRUE
    {           ( Literal (Bool (true, _1)) )}
| _1 = FALSE
    {           ( Literal (Bool (false, _1)) )}
| _1 = TInt
    {           ( Literal (Int (_1)) )}
| _1 = TFloat
    {           ( Literal (Float (_1)) )}
| _1 = TChar
    {           ( Literal (Char (_1)) )}
| _1 = TString
    {           ( Literal (String (_1)) )}
| _1 = NULL
    {           ( Literal (Null _1) )}

class_literal:
  _1 = primitive_type _2 = DOT _3 = CLASS
    {                             ( ClassLiteral (_1, _3) )}
| _1 = name _2 = DOT _3 = CLASS
    {                             ( ClassLiteral (TClass (class_type (_1)), _3) )}
| _1 = array_type _2 = DOT _3 = CLASS
    {                             ( ClassLiteral (_1, _3) )}
| _1 = VOID _2 = DOT _3 = CLASS
    {                             ( ClassLiteral (void_type _1, _3) )}

class_instance_creation_expression:
  _1 = NEW _2 = name _3 = LP _4 = listc0_argument_ _5 = RP _6 = option_class_body_
    {   ( NewClass (_1, TClass (class_type _2), (_3,_4,_5), _6) )}
| _1 = primary _2 = DOT _3 = NEW _4 = identifier _5 = LP _6 = listc0_argument_ _7 = RP _8 = option_class_body_
    {   ( NewQualifiedClass (_1, _2, _3, TClass ([_4,[]]), (_5,_6,_7), _8) )}
| _1 = name _2 = DOT _3 = NEW _4 = identifier _5 = LP _6 = listc0_argument_ _7 = RP _8 = option_class_body_
    {   ( NewQualifiedClass (((name _1)), _2, _3,TClass [_4,[]],(_5,_6,_7),_8))}

array_creation_expression:
  _1 = NEW _2 = primitive_type _3 = nonempty_list_dim_expr_ _4 = dims_opt
    {       ( NewArray (_1, _2, _3, _4, None) )}
| _1 = NEW _2 = name _3 = nonempty_list_dim_expr_ _4 = dims_opt
    {       ( NewArray (_1, TClass (class_type (_2)), _3, _4, None) )}

array_creation_expression_with_initializer:
  _1 = NEW _2 = primitive_type _3 = dims _4 = array_initializer
    {       ( NewArray (_1, _2, [], _3, Some _4) )}
| _1 = NEW _2 = name _3 = dims _4 = array_initializer
    {       ( NewArray (_1, TClass (class_type (_2)), [], _3, Some _4) )}

dim_expr:
  _1 = LB _2 = expression _3 = RB
    {                              ( _2 )}

dims:
  _1 = LB_RB
    {               ( 1 )}
| _1 = dims _2 = LB_RB
    {               ( _1 + 1 )}

field_access:
  _1 = primary _2 = DOT _3 = identifier
    {                                 ( Dot (_1, _2, _3) )}
| _1 = SUPER _2 = DOT _3 = identifier
    {                                 ( Dot (NameId (super_ident _1), _2, _3) )}
| _1 = name _2 = DOT _3 = SUPER _4 = DOT _5 = identifier
    {                                 ( Dot (Dot (name _1,_2,super_ident _3),_2,_5))}

array_access:
  _1 = name _2 = LB _3 = expression _4 = RB
    {    ( ArrayAccess (((name _1)),(_2, _3, _4)) )}
| _1 = primary_no_new_array _2 = LB _3 = expression _4 = RB
    {    ( ArrayAccess (_1, (_2, _3, _4)) )}

method_invocation:
  _1 = name _2 = LP _3 = listc0_argument_ _4 = RP
    {    ( Call (name _1, (_2, _3, _4))
         (* match List.rev $1 with
          (* TODO: lose information of TypeArgs_then_Id *)
          | ((Id x) | (TypeArgs_then_Id (_, Id x)))::xs ->
              let tok = snd x in
              (match xs with
              (* old: I used to add an implicit this.x but we don't do that in
               * tree-sitter, so better not do it either *)
              | [] -> Call (Name (name $1), ($2, $3, $4))
              | _ -> Call (Dot (Name (name (List.rev xs)),tok,x),($2,$3,$4))
              )
          | _ ->
              pr2 "method_invocation pb";
              pr2_gen $1;
              raise Impossible
         *)
        )}
| _1 = primary _2 = DOT _3 = identifier _4 = LP _5 = listc0_argument_ _6 = RP
    { ( Call ((Dot (_1, _2, _3)), (_4,_5,_6)) )}
| _1 = SUPER _2 = DOT _3 = identifier _4 = LP _5 = listc0_argument_ _6 = RP
    { ( Call ((Dot (NameId (super_ident _1), _2, _3)), (_4,_5,_6)) )}
| _1 = name _2 = DOT _3 = SUPER _4 = DOT _5 = identifier _6 = LP _7 = listc0_argument_ _8 = RP
    { ( Call (Dot (Dot (name _1, _2, super_ident _3), _4, _5), (_6,_7,_8)))}
| _1 = primary _2 = DOT _3 = DOTS
    {                        ( ObjAccessEllipsis (_1, _2) )}
| _1 = name _2 = DOT _3 = DOTS
    {                        ( ObjAccessEllipsis (fix_name _1, _2) )}

argument:
  _1 = expression
    {                     ( _1 )}

postfix_expression:
  _1 = primary
    {            ( _1 )}
| _1 = name
    {            ( fix_name _1 )}
| _1 = post_increment_expression
    {                              ( _1 )}
| _1 = post_decrement_expression
    {                              ( _1 )}

post_increment_expression:
  _1 = postfix_expression _2 = INCR
    {  ( Postfix (_1, (Incr, _2)) )}

post_decrement_expression:
  _1 = postfix_expression _2 = DECR
    {  ( Postfix (_1, (Decr, _2)) )}

unary_expression:
  _1 = pre_increment_expression
    {                             ( _1 )}
| _1 = pre_decrement_expression
    {                             ( _1 )}
| _1 = PLUS _2 = unary_expression
    {                             ( Unary ((Plus,_1), _2) )}
| _1 = MINUS _2 = unary_expression
    {                             ( Unary ((Minus,_1), _2) )}
| _1 = unary_expression_not_plus_minus
    {                                    ( _1 )}

pre_increment_expression:
  _1 = INCR _2 = unary_expression
    {  ( Prefix ((Incr, _1), _2) )}

pre_decrement_expression:
  _1 = DECR _2 = unary_expression
    {  ( Prefix ((Decr, _1), _2) )}

unary_expression_not_plus_minus:
  _1 = postfix_expression
    {                       ( _1 )}
| _1 = COMPL _2 = unary_expression
    {                           ( Unary ((BitNot,_1), _2) )}
| _1 = NOT _2 = unary_expression
    {                           ( Unary ((Not,_1), _2) )}
| _1 = cast_expression
    {                    ( _1 )}

cast_expression:
  _1 = LP _2 = primitive_type _3 = RP _4 = unary_expression
    {                                            ( Cast ((_1,[_2],_3), _4) )}
| _1 = LP _2 = array_type _3 = RP _4 = unary_expression_not_plus_minus
    {                                                      ( Cast((_1,[_2],_3),_4))}
| _1 = LP _2 = expression _3 = RP _4 = unary_expression_not_plus_minus
    { (  Cast ((_1,[expr_to_typename _2],_3), _4) )}

cast_lambda_expression:
  _1 = LP _2 = expression _3 = RP _4 = lambda_expression
    {     ( Cast ((_1,[expr_to_typename _2],_3), _4) )}

multiplicative_expression:
  _1 = unary_expression
    {                     ( _1 )}
| _1 = multiplicative_expression _2 = TIMES _3 = unary_expression
    {                                                    ( Infix (_1, (Mult,_2),_3))}
| _1 = multiplicative_expression _2 = DIV _3 = unary_expression
    {                                                    ( Infix (_1, (Div,_2),_3))}
| _1 = multiplicative_expression _2 = MOD _3 = unary_expression
    {                                                    ( Infix (_1, (Mod,_2),_3))}

additive_expression:
  _1 = multiplicative_expression
    {                              ( _1 )}
| _1 = additive_expression _2 = PLUS _3 = multiplicative_expression
    {                                                       ( Infix(_1,(Plus,_2),_3))}
| _1 = additive_expression _2 = MINUS _3 = multiplicative_expression
    {                                                       ( Infix(_1,(Minus,_2),_3))}
| _1 = DOTS _2 = PLUS _3 = multiplicative_expression
    {                                                       ( Flag_parsing.sgrep_guard (Infix (Ellipsis _1, (Plus, _2), _3)) )}
| _1 = DOTS _2 = MINUS _3 = multiplicative_expression
    {                                                       ( Flag_parsing.sgrep_guard (Infix (Ellipsis _1, (Minus, _2), _3)) )}
| _1 = additive_expression _2 = PLUS _3 = DOTS
    {                                                       ( Flag_parsing.sgrep_guard (Infix (_1, (Plus, _2), Ellipsis _3)) )}
| _1 = additive_expression _2 = MINUS _3 = DOTS
    {                                                       ( Flag_parsing.sgrep_guard (Infix (_1, (Minus, _2), Ellipsis _3)) )}

shift_expression:
  _1 = additive_expression
    {                        ( _1 )}
| _1 = shift_expression _2 = LS _3 = additive_expression
    {                                            ( Infix (_1, (LSL,_2), _3) )}
| _1 = shift_expression _2 = SRS _3 = additive_expression
    {                                             ( Infix (_1, (LSR,_2), _3) )}
| _1 = shift_expression _2 = URS _3 = additive_expression
    {                                             ( Infix (_1, (ASR,_2), _3) )}

relational_expression:
  _1 = shift_expression
    {                     ( _1 )}
| _1 = relational_expression _2 = LT _3 = shift_expression
    {                                              ( Infix (_1, (Lt,_2), _3) )}
| _1 = relational_expression _2 = GT _3 = shift_expression
    {                                              ( Infix (_1, (Gt,_2), _3) )}
| _1 = relational_expression _2 = LE _3 = shift_expression
    {                                              ( Infix (_1, (LtE,_2), _3) )}
| _1 = relational_expression _2 = GE _3 = shift_expression
    {                                              ( Infix (_1, (GtE,_2), _3) )}
| _1 = relational_expression _2 = INSTANCEOF _3 = reference_type
    {                                                    ( InstanceOf (_1, _3) )}

equality_expression:
  _1 = relational_expression
    {                          ( _1 )}
| _1 = equality_expression _2 = EQ_EQ _3 = relational_expression
    {                                                    ( Infix (_1, (Eq,_2), _3) )}
| _1 = equality_expression _2 = NOT_EQ _3 = relational_expression
    {                                                    ( Infix (_1,(NotEq,_2),_3))}

and_expression:
  _1 = equality_expression
    {                        ( _1 )}
| _1 = and_expression _2 = AND _3 = equality_expression
    {                                           ( Infix (_1, (BitAnd,_2), _3) )}

exclusive_or_expression:
  _1 = and_expression
    {                   ( _1 )}
| _1 = exclusive_or_expression _2 = XOR _3 = and_expression
    {                                               ( Infix (_1, (BitXor,_2), _3) )}

inclusive_or_expression:
  _1 = exclusive_or_expression
    {                            ( _1 )}
| _1 = inclusive_or_expression _2 = OR _3 = exclusive_or_expression
    {                                                       ( Infix (_1, (BitOr,_2), _3) )}

conditional_and_expression:
  _1 = inclusive_or_expression
    {                            ( _1 )}
| _1 = conditional_and_expression _2 = AND_AND _3 = inclusive_or_expression
    {     ( Infix(_1,(And,_2),_3) )}

conditional_or_expression:
  _1 = conditional_and_expression
    {                               ( _1 )}
| _1 = conditional_or_expression _2 = OR_OR _3 = conditional_and_expression
    {     ( Infix (_1, (Or, _2), _3) )}

conditional_expression:
  _1 = conditional_or_expression
    {     ( _1 )}
| _1 = conditional_or_expression _2 = COND _3 = expression _4 = COLON _5 = conditional_expression
    {     ( Conditional (_1, _3, _5) )}
| _1 = conditional_or_expression _2 = COND _3 = expression _4 = COLON _5 = lambda_expression
    {     ( Conditional (_1, _3, _5) )}

assignment_expression:
  _1 = conditional_expression
    {                           ( _1 )}
| _1 = assignment
    {                           ( _1 )}
| _1 = DOTS
    {                            ( Flag_parsing.sgrep_guard (Ellipsis _1) )}
| _1 = LDots _2 = expression _3 = RDots
    {                            ( Flag_parsing.sgrep_guard (DeepEllipsis (_1,_2,_3)))}

assignment:
  _1 = left_hand_side _2 = assignment_operator _3 = expression
    {                                                           ( _2 _1 _3 )}

left_hand_side:
  _1 = name
    {                 ( (name _1) )}
| _1 = field_access
    {                 ( _1 )}
| _1 = array_access
    {                 ( _1 )}
| _1 = typed_metavar
    {                 ( _1 )}

assignment_operator:
  _1 = EQ
    {                ( (fun e1 e2 -> Assign (e1, _1, e2))  )}
| _1 = OPERATOR_EQ
    {                ( (fun e1 e2 -> AssignOp (e1, _1, e2)) )}

lambda_expression:
  _1 = lambda_parameters _2 = ARROW _3 = lambda_body
    {                                                       ( Lambda (_1, _2, _3) )}

lambda_parameters:
  _1 = IDENTIFIER
    {                                       ( [mk_param_id _1] )}
| _1 = LP_LAMBDA _2 = lambda_parameter_list _3 = RP
    {                                       ( _2 )}
| _1 = LP_LAMBDA _2 = RP
    {                                       ( [] )}

lambda_parameter_list:
  _1 = listc_identifier_
    {                       ( _1 |> List.map mk_param_id )}
| _1 = listc_lambda_param_
    {                       ( _1 )}

lambda_param:
  _1 = nonempty_list_variable_modifier_ _2 = lambda_parameter_type _3 = variable_declarator_id
    {    ( ParamClassic (canon_var _1 _2 _3)  )}
| _1 = lambda_parameter_type _2 = variable_declarator_id
    {    ( ParamClassic (canon_var [] _1 _2) )}
| _1 = variable_arity_parameter
    {                            ( _1 )}

lambda_parameter_type:
  _1 = unann_type
    {              ( Some _1 )}
| _1 = VAR
    {              ( None )}

unann_type:
  _1 = type_
    {                  ( _1 )}

variable_arity_parameter:
  _1 = nonempty_list_variable_modifier_ _2 = unann_type _3 = DOTS _4 = identifier
    {    ( ParamClassic (canon_var _1 (Some _2) (IdentDecl _4)) )}
| _1 = unann_type _2 = DOTS _3 = identifier
    {    ( ParamClassic (canon_var [] (Some _1) (IdentDecl _3)) )}

lambda_body:
  _1 = expression
    {              ( Expr (_1, PI.sc) )}
| _1 = block
    {              ( _1 )}

method_reference:
  _1 = name _2 = COLONCOLON _3 = identifier
    {    ( (* TODO? probably a type? *)
       MethodRef (Right (TClass (class_type _1)), _2, [], _3)
    )}
| _1 = primary _2 = COLONCOLON _3 = identifier
    {                                    ( MethodRef (Left _1, _2, [], _3) )}
| _1 = array_type _2 = COLONCOLON _3 = identifier
    {                                    ( MethodRef (Right _1, _2, [], _3) )}
| _1 = name _2 = COLONCOLON _3 = NEW
    {    ( MethodRef (Right (TClass (class_type _1)), _2, [], new_id _3) )}
| _1 = array_type _2 = COLONCOLON _3 = NEW
    {                                    ( MethodRef (Right _1, _2, [], new_id _3) )}
| _1 = SUPER _2 = COLONCOLON _3 = identifier
    {                                    ( MethodRef (Left (super _1), _2, [], _3) )}
| _1 = name _2 = DOT _3 = SUPER _4 = COLONCOLON _5 = identifier
    {   ( let e = Dot (fix_name _1, _2, super_ident _3) in
     MethodRef (Left e, _4, [], _5) )}

expression:
  _1 = assignment_expression
    {                          ( _1 )}
| _1 = lambda_expression
    {                     ( _1 )}
| _1 = cast_lambda_expression
    {                          ( _1 )}

constant_expression:
  _1 = expression
    {                                 ( _1 )}

statement:
  _1 = statement_without_trailing_substatement
    {                                            ( _1 )}
| _1 = labeled_statement
    {                      ( _1 )}
| _1 = if_then_statement
    {                      ( _1 )}
| _1 = if_then_else_statement
    {                           ( _1 )}
| _1 = while_statement
    {                    ( _1 )}
| _1 = for_statement
    {                  ( _1 )}
| _1 = DOTS
    {         ( Flag_parsing.sgrep_guard (Expr (Ellipsis _1, PI.sc)) )}

statement_without_trailing_substatement:
  _1 = block
    {          ( _1 )}
| _1 = empty_statement
    {                    ( _1 )}
| _1 = expression_statement
    {                         ( _1 )}
| _1 = switch_statement
    {                     ( _1 )}
| _1 = do_statement
    {                 ( _1 )}
| _1 = break_statement
    {                    ( _1 )}
| _1 = continue_statement
    {                       ( _1 )}
| _1 = return_statement
    {                     ( _1 )}
| _1 = synchronized_statement
    {                           ( _1 )}
| _1 = throw_statement
    {                    ( _1 )}
| _1 = try_statement
    {                  ( _1 )}
| _1 = ASSERT _2 = expression _3 = SM
    {                                        ( Assert (_1, _2, None) )}
| _1 = ASSERT _2 = expression _3 = COLON _4 = expression _5 = SM
    {                                        ( Assert (_1, _2, Some _4) )}

block:
  _1 = LC _2 = list_block_statement_ _3 = RC
    {                                 ( Block (_1, List.flatten _2, _3) )}

block_statement:
  _1 = local_variable_declaration_statement
    {                                         ( _1 )}
| _1 = statement
    {                      ( [_1] )}
| _1 = class_declaration
    {                      ( [DeclStmt (Class _1)] )}

local_variable_declaration_statement:
  _1 = local_variable_declaration _2 = SM
    {  ( List.map (fun x -> LocalVar x) _1 )}

local_variable_declaration:
  _2 = type_ _3 = listc_variable_declarator_
    {let _1 =               ( [] ) in
     ( decls (fun x -> x) _1 _2 _3 )}
| _1 = modifiers _2 = type_ _3 = listc_variable_declarator_
    {let _1 =               ( List.rev _1 ) in
     ( decls (fun x -> x) _1 _2 _3 )}

empty_statement:
  _1 = SM
    {                                                ( EmptyStmt _1 )}

labeled_statement:
  _1 = identifier _2 = COLON _3 = statement
    {                                                ( Label (_1, _3) )}

expression_statement:
  _1 = statement_expression _2 = SM
    {                                                ( Expr (_1, _2) )}

statement_expression:
  _1 = assignment
    {               ( _1 )}
| _1 = pre_increment_expression
    {                             ( _1 )}
| _1 = pre_decrement_expression
    {                             ( _1 )}
| _1 = post_increment_expression
    {                              ( _1 )}
| _1 = post_decrement_expression
    {                              ( _1 )}
| _1 = method_invocation
    {                      ( _1 )}
| _1 = class_instance_creation_expression
    {                                       ( _1 )}
| _1 = IDENTIFIER
    {                 ( Flag_parsing.sgrep_guard (((name [Id _1])))  )}
| _1 = typed_metavar
    {                 ( _1 )}

if_then_statement:
  _1 = IF _2 = LP _3 = expression _4 = RP _5 = statement
    {                                                     ( If (_1, _3, _5, None) )}

if_then_else_statement:
  _1 = IF _2 = LP _3 = expression _4 = RP _5 = statement_no_short_if _6 = ELSE _7 = statement
    {   ( If (_1, _3, _5, Some _7) )}

switch_statement:
  _1 = SWITCH _2 = LP _3 = expression _4 = RP _5 = switch_block
    {                                                         ( Switch(_1, _3, _5))}

switch_block:
  _1 = LC _2 = RC
    {                                                        ( [] )}
| _1 = LC _2 = nonempty_list_switch_label_ _3 = RC
    {                                                        ( [_2, []] )}
| _1 = LC _2 = switch_block_statement_groups _3 = RC
    {                                                        ( _2 )}
| _1 = LC _2 = switch_block_statement_groups _3 = nonempty_list_switch_label_ _4 = RC
    {     ( List.rev ((_3, []) :: _2) )}

switch_block_statement_group:
  _1 = nonempty_list_switch_label_ _2 = nonempty_list_block_statement_
    {  (_1, List.flatten _2)}

switch_label:
  _1 = CASE _2 = constant_expression _3 = COLON
    {                                       ( Case (_1, _2) )}
| _1 = DEFAULT_COLON _2 = COLON
    {                                       ( Default _1 )}

while_statement:
  _1 = WHILE _2 = LP _3 = expression _4 = RP _5 = statement
    {                                                        ( While (_1, _3, _5) )}

do_statement:
  _1 = DO _2 = statement _3 = WHILE _4 = LP _5 = expression _6 = RP _7 = SM
    {                                                        ( Do (_1, _2, _5) )}

for_statement:
  _1 = FOR _2 = LP _3 = for_control _4 = RP _5 = statement
    {                                                 ( For (_1, _3, _5) )}

for_control:
  _1 = for_init_opt _2 = SM _3 = option_expression_ _4 = SM _5 = optl_for_update_
    {     ( ForClassic (_1, Common2.option_to_list _3, _5) )}
| _1 = for_var_control
    {     ( let (a, b) = _1 in Foreach (a, b) )}
| _1 = DOTS
    {         ( Flag_parsing.sgrep_guard (ForEllipsis _1) )}

for_init_opt:
  
    {              ( ForInitExprs [] )}
| _1 = for_init
    {              ( _1 )}

for_init:
  _1 = listc_statement_expression_
    {                                ( ForInitExprs _1 )}
| _1 = local_variable_declaration
    {                                ( ForInitVars _1 )}

for_update:
  _1 = listc_statement_expression_
    {                                         ( _1 )}

for_var_control:
  _2 = type_ _3 = variable_declarator_id _4 = for_var_control_rest
    {let _1 =               ( [] ) in
     ( canon_var _1 (Some _2) _3, _4 )}
| _1 = modifiers _2 = type_ _3 = variable_declarator_id _4 = for_var_control_rest
    {let _1 =               ( List.rev _1 ) in
     ( canon_var _1 (Some _2) _3, _4 )}

for_var_control_rest:
  _1 = COLON _2 = expression
    {                                     ( _2 )}

break_statement:
  _1 = BREAK _2 = option_identifier_ _3 = SM
    {                                              ( Break (_1, _2) )}

continue_statement:
  _1 = CONTINUE _2 = option_identifier_ _3 = SM
    {                                              ( Continue (_1, _2) )}

return_statement:
  _1 = RETURN _2 = option_expression_ _3 = SM
    {                                            ( Return (_1, _2) )}

synchronized_statement:
  _1 = SYNCHRONIZED _2 = LP _3 = expression _4 = RP _5 = block
    {                                                              ( Sync (_3, _5) )}

throw_statement:
  _1 = THROW _2 = expression _3 = SM
    {                                       ( Throw (_1, _2) )}

try_statement:
  _1 = TRY _2 = block _3 = nonempty_list_catch_clause_
    {                                    ( Try (_1, None, _2, _3, None) )}
| _1 = TRY _2 = block _3 = list_catch_clause_ _4 = finally
    {                                    ( Try (_1, None, _2, _3, Some _4) )}
| _1 = TRY _2 = resource_specification _3 = block _4 = list_catch_clause_ _5 = option_finally_
    {    ( Try (_1, Some _2, _3, _4, _5) )}

finally:
  _1 = FINALLY _2 = block
    {                        ( _1, _2 )}

catch_clause:
  _1 = CATCH _2 = LP _3 = catch_formal_parameter _4 = RP _5 = block
    {                                                         ( _1, _3, _5 )}
| _1 = CATCH _2 = LP _3 = catch_formal_parameter _4 = RP _5 = empty_statement
    {                                                         ( _1, _3, _5 )}

catch_formal_parameter:
  _1 = nonempty_list_variable_modifier_ _2 = catch_type _3 = variable_declarator_id
    {      ( canon_var _1 (Some (fst _2)) _3, snd _2 )}
| _1 = catch_type _2 = variable_declarator_id
    {      ( canon_var [] (Some (fst _1)) _2, snd _1 )}

catch_type:
  _1 = list_sep_type__OR_
    {                                ( List.hd _1, List.tl _1 )}

resource_specification:
  _1 = LP _2 = list_sep_resource_SM_ _3 = option_SM_ _4 = RP
    {  ( _1, _2, _4 )}

resource:
  _1 = nonempty_list_variable_modifier_ _2 = local_variable_type _3 = identifier _4 = EQ _5 = expression
    {    ( let var = canon_var _1 (Some _2) (IdentDecl _3) in
      Left { f_var = var; f_init = Some (ExprInit _5) }
    )}
| _1 = local_variable_type _2 = identifier _3 = EQ _4 = expression
    {    ( let var = canon_var [] (Some _1) (IdentDecl _2) in
      Left { f_var = var; f_init = Some (ExprInit _4) }
    )}
| _1 = variable_access
    {    ( Right _1 )}

local_variable_type:
  _1 = unann_type
    {                                ( _1 )}

variable_access:
  _1 = field_access
    {                ( _1 )}
| _1 = name
    {                ( fix_name _1 )}

statement_no_short_if:
  _1 = statement_without_trailing_substatement
    {                                            ( _1 )}
| _1 = labeled_statement_no_short_if
    {                                            ( _1 )}
| _1 = if_then_else_statement_no_short_if
    {                                            ( _1 )}
| _1 = while_statement_no_short_if
    {                                            ( _1 )}
| _1 = for_statement_no_short_if
    {                                            ( _1 )}

labeled_statement_no_short_if:
  _1 = identifier _2 = COLON _3 = statement_no_short_if
    {   ( Label (_1, _3) )}

if_then_else_statement_no_short_if:
  _1 = IF _2 = LP _3 = expression _4 = RP _5 = statement_no_short_if _6 = ELSE _7 = statement_no_short_if
    {   ( If (_1, _3, _5, Some _7) )}

while_statement_no_short_if:
  _1 = WHILE _2 = LP _3 = expression _4 = RP _5 = statement_no_short_if
    {     ( While (_1, _3, _5) )}

for_statement_no_short_if:
  _1 = FOR _2 = LP _3 = for_control _4 = RP _5 = statement_no_short_if
    { ( For (_1, _3, _5) )}

modifier:
  _1 = PUBLIC
    {                ( Public, _1 )}
| _1 = PROTECTED
    {                ( Protected, _1 )}
| _1 = PRIVATE
    {                ( Private, _1 )}
| _1 = ABSTRACT
    {                ( Abstract, _1 )}
| _1 = STATIC
    {                ( Static, _1 )}
| _1 = FINAL
    {                ( Final, _1 )}
| _1 = STRICTFP
    {                ( StrictFP, _1 )}
| _1 = TRANSIENT
    {                ( Transient, _1 )}
| _1 = VOLATILE
    {                ( Volatile, _1 )}
| _1 = SYNCHRONIZED
    {                ( Synchronized, _1 )}
| _1 = NATIVE
    {                ( Native, _1 )}
| _1 = DEFAULT
    {                ( DefaultModifier, _1 )}
| _1 = annotation
    {              ( Annotation _1, (Common2.fst3 _1) )}

annotation:
  _1 = AT _2 = qualified_ident
    {                       ( (_1, _2, None) )}
| _1 = AT _2 = qualified_ident _3 = LP _4 = annotation_element _5 = RP
    {                                                  ( (_1, _2, Some (_3, _4, _5)) )}

annotation_element:
  
    {               ( EmptyAnnotArg )}
| _1 = element_value
    {                 ( AnnotArgValue _1 )}
| _1 = listc_element_value_pair_
    {                             ( AnnotArgPairInit _1 )}

element_value:
  _1 = expr1
    {              ( AnnotExprInit _1 )}
| _1 = annotation
    {              ( AnnotNestedAnnot _1 )}
| _1 = element_value_array_initializer
    {                                   ( AnnotArrayInit _1 )}

element_value_pair:
  _1 = identifier _2 = EQ _3 = element_value
    {                                ( AnnotPair (_1, _3) )}
| _1 = DOTS
    {         ( Flag_parsing.sgrep_guard (AnnotPairEllipsis _1) )}

element_value_array_initializer:
  _1 = LC _2 = RC
    {           ( (_1, [], _2) )}
| _1 = LC _2 = listc_element_value_ _3 = option_CM_ _4 = RC
    {                                     ( _1, _2, _4 )}

expr1:
  _1 = conditional_expression
    {                              ( _1 )}

class_declaration:
  _1 = class_header _2 = class_body
    {  ( { _1 with cl_body = _2 }  )}

class_header:
  _2 = CLASS _3 = identifier _4 = optl_type_parameters_ _5 = option_super_ _6 = optl_interfaces_
    {let _1 =               ( [] ) in
  ( { cl_name = _3; cl_kind = (ClassRegular, _2);
      cl_mods = _1; cl_tparams = _4;
      cl_extends = _5;  cl_impls = _6; cl_formals = [];
      cl_body = empty_body ;
     } )}
| _1 = modifiers _2 = CLASS _3 = identifier _4 = optl_type_parameters_ _5 = option_super_ _6 = optl_interfaces_
    {let _1 =               ( List.rev _1 ) in
  ( { cl_name = _3; cl_kind = (ClassRegular, _2);
      cl_mods = _1; cl_tparams = _4;
      cl_extends = _5;  cl_impls = _6; cl_formals = [];
      cl_body = empty_body ;
     } )}

super:
  _1 = EXTENDS _2 = type_
    {                                           ( _2 )}

interfaces:
  _1 = IMPLEMENTS _2 = listc_reference_type_
    {                                               ( _2 )}

class_body:
  _1 = LC _2 = list_class_body_declaration_ _3 = RC
    {                                             ( _1, List.flatten _2, _3 )}

class_body_declaration:
  _1 = class_member_declaration
    {                             ( _1 )}
| _1 = constructor_declaration
    {                            ( [_1] )}
| _1 = static_initializer
    {                       ( [_1] )}
| _1 = instance_initializer
    {                         ( [_1] )}

class_member_declaration:
  _1 = field_declaration
    {                      ( _1 )}
| _1 = method_declaration
    {                       ( [Method _1] )}
| _1 = generic_method_or_constructor_decl
    {                                      ( [Method _1] )}
| _1 = class_declaration
    {                      ( [Class _1] )}
| _1 = interface_declaration
    {                          ( [Class _1] )}
| _1 = enum_declaration
    {                    ( [Enum _1] )}
| _1 = annotation_type_declaration
    {                               ( [Class _1] )}
| _1 = SM
    {        ( [] )}
| _1 = DOTS
    {         ( [DeclEllipsis _1] )}

static_initializer:
  _1 = STATIC _2 = block
    {                                  ( Init (Some _1, _2) )}

instance_initializer:
  _1 = block
    {                                  ( Init (None, _1) )}

field_declaration:
  _2 = type_ _3 = listc_variable_declarator_ _4 = SM
    {let _1 =               ( [] ) in
   ( decls (fun x -> Field x) _1 _2 _3 )}
| _1 = modifiers _2 = type_ _3 = listc_variable_declarator_ _4 = SM
    {let _1 =               ( List.rev _1 ) in
   ( decls (fun x -> Field x) _1 _2 _3 )}

variable_declarator:
  _1 = variable_declarator_id
    {                           ( _1, None )}
| _1 = variable_declarator_id _2 = EQ _3 = variable_initializer
    {                                                    ( _1, Some _3 )}

variable_declarator_id:
  _1 = identifier
    {                                 ( IdentDecl _1 )}
| _1 = variable_declarator_id _2 = LB_RB
    {                                 ( ArrayDecl _1 )}

variable_initializer:
  _1 = expression
    {                      ( ExprInit _1 )}
| _1 = array_initializer
    {                      ( _1 )}

array_initializer:
  _1 = LC _2 = option_CM_ _3 = RC
    {                                       ( ArrayInit (_1, [], _3) )}
| _1 = LC _2 = listc_variable_initializer_ _3 = option_CM_ _4 = RC
    {                                             ( ArrayInit (_1, _2, _4) )}

method_declaration:
  _1 = method_header _2 = method_body
    {                                               ( { _1 with m_body = _2 } )}

method_header:
  _2 = type_ _3 = method_declarator _4 = optl_throws_
    {let _1 =               ( [] ) in
     ( method_header _1 _2 _3 _4 )}
| _1 = modifiers _2 = type_ _3 = method_declarator _4 = optl_throws_
    {let _1 =               ( List.rev _1 ) in
     ( method_header _1 _2 _3 _4 )}
| _2 = VOID _3 = method_declarator _4 = optl_throws_
    {let _1 =               ( [] ) in
     ( method_header _1 (void_type _2) _3 _4 )}
| _1 = modifiers _2 = VOID _3 = method_declarator _4 = optl_throws_
    {let _1 =               ( List.rev _1 ) in
     ( method_header _1 (void_type _2) _3 _4 )}

method_declarator:
  _1 = identifier _2 = LP _3 = listc0_formal_parameter_ _4 = RP
    {                                                ( (IdentDecl _1), _3 )}
| _1 = method_declarator _2 = LB_RB
    {                                                ( (ArrayDecl (fst _1)), snd _1)}

method_body:
  _1 = block
    {           ( _1 )}
| _1 = SM
    {           ( EmptyStmt _1 )}

throws:
  _1 = THROWS _2 = listc_name_
    {  ( List.map (fun x -> typ_of_qualified_id (qualified_ident x)) _2 )}

generic_method_or_constructor_decl:
  _2 = type_parameters _3 = type_ _4 = identifier _5 = formal_parameters _6 = optl_throws_ _7 = method_body
    {let _1 =               ( [] ) in
    ( let (t, mdecl, throws, body) = _3, (IdentDecl _4, _5), _6, _7 in
      let header = method_header _1 (* TODO $2 *) t mdecl throws in
      { header with m_body = body }
    )}
| _1 = modifiers _2 = type_parameters _3 = type_ _4 = identifier _5 = formal_parameters _6 = optl_throws_ _7 = method_body
    {let _1 =               ( List.rev _1 ) in
    ( let (t, mdecl, throws, body) = _3, (IdentDecl _4, _5), _6, _7 in
      let header = method_header _1 (* TODO $2 *) t mdecl throws in
      { header with m_body = body }
    )}
| _2 = type_parameters _3 = VOID _4 = identifier _5 = formal_parameters _6 = optl_throws_ _7 = method_body
    {let _1 =               ( [] ) in
   ( let (t, mdecl, throws, body) = void_type _3, (IdentDecl _4, _5), _6, _7 in
      let header = method_header _1 (* TODO $2 *) t mdecl throws in
      { header with m_body = body }
    )}
| _1 = modifiers _2 = type_parameters _3 = VOID _4 = identifier _5 = formal_parameters _6 = optl_throws_ _7 = method_body
    {let _1 =               ( List.rev _1 ) in
   ( let (t, mdecl, throws, body) = void_type _3, (IdentDecl _4, _5), _6, _7 in
      let header = method_header _1 (* TODO $2 *) t mdecl throws in
      { header with m_body = body }
    )}

constructor_declaration:
  _2 = constructor_declarator _3 = optl_throws_ _4 = constructor_body
    {let _1 =               ( [] ) in
  ( let (id, formals) = _2 in
    let var = { mods = _1; type_ = None; name = id } in
    Method { m_var = var; m_formals = formals; m_throws = _3;
	     m_body = _4 }
  )}
| _1 = modifiers _2 = constructor_declarator _3 = optl_throws_ _4 = constructor_body
    {let _1 =               ( List.rev _1 ) in
  ( let (id, formals) = _2 in
    let var = { mods = _1; type_ = None; name = id } in
    Method { m_var = var; m_formals = formals; m_throws = _3;
	     m_body = _4 }
  )}

constructor_declarator:
  _1 = identifier _2 = LP _3 = listc0_formal_parameter_ _4 = RP
    {                                                                    ( _1, _3)}

constructor_body:
  _1 = LC _2 = list_block_statement_ _3 = RC
    {    ( Block (_1, List.flatten _2, _3) )}
| _1 = LC _2 = explicit_constructor_invocation _3 = list_block_statement_ _4 = RC
    {    ( Block (_1, _2::(List.flatten _3), _4) )}

explicit_constructor_invocation:
  _1 = THIS _2 = LP _3 = listc0_argument_ _4 = RP _5 = SM
    {      ( Expr (Call (This _1, (_2,_3,_4)), _5) )}
| _1 = SUPER _2 = LP _3 = listc0_argument_ _4 = RP _5 = SM
    {      ( constructor_invocation (NameId (super_ident _1)) (_2,_3,_4) _5 )}
| _1 = primary _2 = DOT _3 = SUPER _4 = LP _5 = listc0_argument_ _6 = RP _7 = SM
    {      ( Expr (Call ((Dot (_1, _2, super_ident _3)), (_4,_5,_6)), _7) )}
| _1 = name _2 = DOT _3 = SUPER _4 = LP _5 = listc0_argument_ _6 = RP _7 = SM
    {      ( constructor_invocation (Dot (name _1, _2, super_ident _3)) (_4,_5,_6) _7 )}

formal_parameters:
  _1 = LP _2 = listc0_formal_parameter_ _3 = RP
    {                                                    ( _2 )}

formal_parameter:
  _1 = list_variable_modifier_ _2 = type_ _3 = variable_declarator_id_bis
    {  ( ParamClassic (canon_var _1 (Some _2) _3) )}
| _1 = DOTS
    {         ( ParamEllipsis _1 )}

variable_declarator_id_bis:
  _1 = variable_declarator_id
    {                               ( _1 )}
| _1 = DOTS _2 = variable_declarator_id
    {                                ( _2 (* todo_ast *) )}

variable_modifier:
  _1 = FINAL
    {              ( Final, _1 )}
| _1 = annotation
    {              ( (Annotation _1), Common2.fst3 _1 )}

interface_declaration:
  _2 = INTERFACE _3 = identifier _4 = optl_type_parameters_ _5 = optl_extends_interfaces_ _6 = interface_body
    {let _1 =               ( [] ) in
  ( { cl_name = _3; cl_kind = (Interface, _2);
      cl_mods = _1; cl_tparams = _4;
      cl_extends = None; cl_impls = _5; cl_formals = [];
      cl_body = _6;
    } )}
| _1 = modifiers _2 = INTERFACE _3 = identifier _4 = optl_type_parameters_ _5 = optl_extends_interfaces_ _6 = interface_body
    {let _1 =               ( List.rev _1 ) in
  ( { cl_name = _3; cl_kind = (Interface, _2);
      cl_mods = _1; cl_tparams = _4;
      cl_extends = None; cl_impls = _5; cl_formals = [];
      cl_body = _6;
    } )}

extends_interfaces:
  _1 = EXTENDS _2 = reference_type
    {                                                   ( [_2] )}
| _1 = extends_interfaces _2 = CM _3 = reference_type
    {                                                   ( _1 @ [_3] )}

interface_body:
  _1 = LC _2 = list_interface_member_declaration_ _3 = RC
    {                                                      ( _1, List.flatten _2,_3)}

interface_member_declaration:
  _1 = constant_declaration
    {                         ( _1 )}
| _1 = interface_method_declaration
    {                                 ( [Method _1] )}
| _1 = interface_generic_method_decl
    {                                 ( [Method _1] )}
| _1 = class_declaration
    {                          ( [Class _1] )}
| _1 = interface_declaration
    {                          ( [Class _1] )}
| _1 = enum_declaration
    {                          ( [Enum _1] )}
| _1 = annotation_type_declaration
    {                               ( [Class _1] )}
| _1 = SM
    {        ( [] )}
| _1 = DOTS
    {         ( [DeclEllipsis _1] )}

constant_declaration:
  _2 = type_ _3 = listc_variable_declarator_ _4 = SM
    {let _1 =               ( [] ) in
    ( decls (fun x -> Field x) _1 _2 _3 )}
| _1 = modifiers _2 = type_ _3 = listc_variable_declarator_ _4 = SM
    {let _1 =               ( List.rev _1 ) in
    ( decls (fun x -> Field x) _1 _2 _3 )}

interface_method_declaration:
  _1 = method_declaration
    {                                                 ( _1 )}

interface_generic_method_decl:
  _2 = type_parameters _3 = type_ _4 = identifier _5 = formal_parameters _6 = optl_throws_ _7 = SM
    {let _1 =               ( [] ) in
    ( let (t, mdecl, throws) = _3, (IdentDecl _4, _5), _6 in
      method_header _1 (* TODO $2 *) t mdecl throws
    )}
| _1 = modifiers _2 = type_parameters _3 = type_ _4 = identifier _5 = formal_parameters _6 = optl_throws_ _7 = SM
    {let _1 =               ( List.rev _1 ) in
    ( let (t, mdecl, throws) = _3, (IdentDecl _4, _5), _6 in
      method_header _1 (* TODO $2 *) t mdecl throws
    )}
| _2 = type_parameters _3 = VOID _4 = identifier _5 = formal_parameters _6 = optl_throws_ _7 = SM
    {let _1 =               ( [] ) in
    ( let (t, mdecl, throws) = void_type _3, (IdentDecl _4, _5), _6 in
      method_header _1 (* TODO $2 *) t mdecl throws
    )}
| _1 = modifiers _2 = type_parameters _3 = VOID _4 = identifier _5 = formal_parameters _6 = optl_throws_ _7 = SM
    {let _1 =               ( List.rev _1 ) in
    ( let (t, mdecl, throws) = void_type _3, (IdentDecl _4, _5), _6 in
      method_header _1 (* TODO $2 *) t mdecl throws
    )}

enum_declaration:
  _2 = ENUM _3 = identifier _4 = optl_interfaces_ _5 = enum_body
    {let _1 =               ( [] ) in
   ( { en_name = _3; en_mods = _1; en_impls = _4; en_body = _5; } )}
| _1 = modifiers _2 = ENUM _3 = identifier _4 = optl_interfaces_ _5 = enum_body
    {let _1 =               ( List.rev _1 ) in
   ( { en_name = _3; en_mods = _1; en_impls = _4; en_body = _5; } )}

enum_body:
  _1 = LC _2 = optl_enum_body_declarations_ _3 = RC
    {                                                          ( [], _2 )}
| _1 = LC _2 = listc_enum_constant_ _3 = optl_enum_body_declarations_ _4 = RC
    {                                                                ( _2, _3 )}
| _1 = LC _2 = listc_enum_constant_ _3 = CM _4 = optl_enum_body_declarations_ _5 = RC
    {                                                                 ( _2, _4 )}

enum_constant:
  _2 = enum_constant_bis
    {let _1 =               ( [] ) in
                                               ( _2 )}
| _1 = modifiers _2 = enum_constant_bis
    {let _1 =               ( List.rev _1 ) in
                                               ( _2 )}

enum_constant_bis:
  _1 = identifier
    {                                      ( _1, None, None )}
| _1 = identifier _2 = LP _3 = listc0_argument_ _4 = RP
    {                                       ( _1, Some (_2,_3,_4), None )}
| _1 = identifier _2 = LC _3 = list_method_declaration_ _4 = RC
    {    ( _1, None, Some (_2, _3 |> List.map (fun x -> Method x) , _4) )}

enum_body_declarations:
  _1 = SM _2 = list_class_body_declaration_
    {                               ( List.flatten _2 )}
| _1 = DOTS
    {         ( [DeclEllipsis _1] )}

annotation_type_declaration:
  _2 = AT _3 = INTERFACE _4 = identifier _5 = annotation_type_body
    {let _1 =               ( [] ) in
     ( { cl_name = _4; cl_kind = (AtInterface, _2); cl_mods = _1; cl_tparams = [];
         cl_extends = None; cl_impls = []; cl_formals = [];
         cl_body = _5
       } )}
| _1 = modifiers _2 = AT _3 = INTERFACE _4 = identifier _5 = annotation_type_body
    {let _1 =               ( List.rev _1 ) in
     ( { cl_name = _4; cl_kind = (AtInterface, _2); cl_mods = _1; cl_tparams = [];
         cl_extends = None; cl_impls = []; cl_formals = [];
         cl_body = _5
       } )}

annotation_type_body:
  _1 = LC _2 = list_annotation_type_element_declaration_ _3 = RC
    {  ( _1, _2, _3 )}

annotation_type_element_declaration:
  _1 = annotation_type_element_rest
    {                                                                  ( _1 )}

annotation_type_element_rest:
  _2 = type_ _3 = identifier _4 = annotation_method_or_constant_rest _5 = SM
    {let _1 =               ( [] ) in
   ( AnnotationTypeElementTodo (snd _3) )}
| _1 = modifiers _2 = type_ _3 = identifier _4 = annotation_method_or_constant_rest _5 = SM
    {let _1 =               ( List.rev _1 ) in
   ( AnnotationTypeElementTodo (snd _3) )}
| _1 = class_declaration
    {                               ( Class _1 )}
| _1 = enum_declaration
    {                               ( Enum _1 )}
| _1 = interface_declaration
    {                               ( Class _1 )}
| _1 = annotation_type_declaration
    {                               ( Class _1 )}

annotation_method_or_constant_rest:
  _1 = LP _2 = RP
    {                                 ( None )}
| _1 = LP _2 = RP _3 = DEFAULT _4 = element_value
    {                                 ( Some (_3) )}

modifiers:
  _1 = modifier
    {             ( [_1] )}
| _1 = modifiers _2 = modifier
    {                       ( _2 :: _1 )}

switch_block_statement_groups:
  _1 = switch_block_statement_group
    {                                 ( [_1] )}
| _1 = switch_block_statement_groups _2 = switch_block_statement_group
    {                                                               ( _2 :: _1 )}

dims_opt:
  
    {              ( 0 )}
| _1 = dims
    {         ( _1 )}

%%
