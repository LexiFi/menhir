File "pfff_php.mly", line 128, characters 22-32:
Warning: the token TCommentPP is unused.
File "pfff_php.mly", line 122, characters 30-38:
Warning: the token TNewline is unused.
File "pfff_php.mly", line 122, characters 22-29:
Warning: the token TSpaces is unused.
File "pfff_php.mly", line 115, characters 22-30:
Warning: the token TUnknown is unused.
File "pfff_php.mly", line 197, characters 30-44:
Warning: the token T_BOOLEAN_PIPE is unused.
File "pfff_php.mly", line 181, characters 13-24:
Warning: the token T_CLOSE_TAG is unused.
File "pfff_php.mly", line 125, characters 22-31:
Warning: the token T_COMMENT is unused.
File "pfff_php.mly", line 125, characters 32-45:
Warning: the token T_DOC_COMMENT is unused.
File "pfff_php.mly", line 181, characters 1-11:
Warning: the token T_OPEN_TAG is unused.
%{
(* src: originally ocamlyaccified from zend_language_parser.y in Zend PHP.
 * updates:
 *  - extended to deal with XHP based on the XHP bison grammar
 *  - added support for a few PHP 5.3 extensions (e.g. lambda, const)
 *  - added support for yield (facebook extension)
 *  - added support for a few PHP 5.4 extensions (e.g. traits, short array)
 *  - added support for generics (another facebook extension)
 *  - added support for attributes (a.k.a annotations)
 *  - factorized some rules (e.g. parameters, arguments)
 *  - added support for trailing comma in function calls and definitions
 *  - added support for (new Foo)->method() (id() not needed anymore)
 *  - heavy rewrite of expr and lvalue rules, to avoid the many conflicts
 *    regarding f()[] sugar and also to allow more forms of expressions
 *    such as (<whatever expr>)->method()
 *  - added support for typedefs (another facebook extension)
 *  - added support for implicit fields via constructor parameters
 *    (facebook extension)
 *  - added support for namespace (a PHP 5.3 extension)
 *
 * updates after 2020:
 *  - removed XHP, to simplify (I'm not working at Facebook anymore)
 *  - removed facebook-ext class abstract constants, newtype, shape, etc.
 (*
  * +----------------------------------------------------------------------+
  * | Zend Engine                                                          |
  * +----------------------------------------------------------------------+
  * | Copyright (c) 1998-2006 Zend Technologies Ltd. (http://www.zend.com) |
  * +----------------------------------------------------------------------+
  * | This source file is subject to version 2.00 of the Zend license,     |
  * | that is bundled with this package in the file LICENSE, and is        |
  * | available through the world-wide-web at the following url:           |
  * | http://www.zend.com/license/2_00.txt.                                |
  * | If you did not receive a copy of the Zend license and are unable to  |
  * | obtain it through the world-wide-web, please send a note to          |
  * | license@zend.com so we can mail you a copy immediately.              |
  * +----------------------------------------------------------------------+
  * | Authors: Andi Gutmans <andi@zend.com>                                |
  * |          Zeev Suraski <zeev@zend.com>                                |
  * +----------------------------------------------------------------------+
  *)
 *)
open Common
module Flag = Flag_parsing

open Cst_php
module PI = Parse_info

let mk_param s =
  { p_type = None;
    p_attrs = None;
    p_ref = None;
    p_name = DName s;
    p_default = None;
    p_modifier = None;
    p_variadic = None;
  }

let mk_var (s, tok) =
  match s with
  | "this" -> This tok
  | _ -> IdVar (DName(s, tok))

let rec validate_parameter_list = function
  | [] -> ()
  | Middle3 _ :: params  -> validate_parameter_list_empty params
  | Left3 param :: params ->
      if param.p_variadic <> None
      then validate_parameter_list_empty params
      else validate_parameter_list params
  | Right3 _ :: params -> validate_parameter_list params

and validate_parameter_list_empty = function
  | [] -> ()
  | Right3 _ :: params -> validate_parameter_list_empty params
  | _ ->
      if !Flag.sgrep_mode
      then ()
      else raise Parsing.Parse_error

let o2l = Common.opt_to_list

let qiopt a b =
  match a with
  | None -> b
  | Some t -> QITok t::b

let mk_Toplevel x =
  match x with
  | [] -> raise Impossible
  | [x] -> Toplevel x
  | xs -> Toplevels xs
%}
%start main
%start sgrep_spatch_pattern
%token <Parse_info.t> EOF
%token <Parse_info.t> LDots
%token <Parse_info.t> RDots
%token <Parse_info.t> TAND
%token <Parse_info.t> TANTISLASH
%token <Parse_info.t> TBACKQUOTE
%token <Parse_info.t> TBANG
%token <Parse_info.t> TCBRA
%token <Parse_info.t> TCBRACE
%token <Parse_info.t> TCOLCOL
%token <Parse_info.t> TCOLON
%token <Parse_info.t> TCOMMA
%token <Parse_info.t> TCPAR
%token <Parse_info.t> TCommentPP
%token <Parse_info.t> TDIV
%token <Parse_info.t> TDOLLAR
%token <Parse_info.t> TDOLLARDOLLAR
%token <Parse_info.t> TDOT
%token <Parse_info.t> TEQ
%token <Parse_info.t> TGREATER
%token <Parse_info.t> TGUIL
%token <Parse_info.t> TMINUS
%token <Parse_info.t> TMOD
%token <Parse_info.t> TMUL
%token <Parse_info.t> TNewline
%token <Parse_info.t> TOBRA
%token <Parse_info.t> TOBRACE
%token <Parse_info.t> TOPAR
%token <Parse_info.t> TOR
%token <Parse_info.t> TPLUS
%token <Parse_info.t> TPOW
%token <Parse_info.t> TQUESTION
%token <Parse_info.t> TSEMICOLON
%token <Parse_info.t> TSMALLER
%token <Parse_info.t> TSpaces
%token <Parse_info.t> TTILDE
%token <Parse_info.t> TUnknown
%token <Parse_info.t> TXOR
%token <Parse_info.t> T_ABSTRACT
%token <Parse_info.t> T_AND_EQUAL
%token <Parse_info.t> T_ARRAY
%token <Parse_info.t> T_ARRAY_CAST
%token <Parse_info.t> T_ARROW
%token <Parse_info.t> T_AS
%token <Parse_info.t> T_ASYNC
%token <Parse_info.t> T_AWAIT
%token <Parse_info.t> T_BOOLEAN_AND
%token <Parse_info.t> T_BOOLEAN_OR
%token <Parse_info.t> T_BOOLEAN_PIPE
%token <Parse_info.t> T_BOOL_CAST
%token <Parse_info.t> T_BREAK
%token <Parse_info.t> T_CASE
%token <Parse_info.t> T_CATCH
%token <Parse_info.t> T_CLASS
%token <Parse_info.t> T_CLASS_C
%token <Parse_info.t> T_CLONE
%token <Parse_info.t> T_CLOSE_TAG
%token <Parse_info.t> T_CLOSE_TAG_OF_ECHO
%token <Parse_info.t> T_COMMENT
%token <Parse_info.t> T_CONCAT_EQUAL
%token <Parse_info.t> T_CONST
%token <string * Parse_info.t> T_CONSTANT_ENCAPSED_STRING
%token <Parse_info.t> T_CONTINUE
%token <Parse_info.t> T_CURLY_OPEN
%token <Parse_info.t> T_DEC
%token <Parse_info.t> T_DECLARE
%token <Parse_info.t> T_DEFAULT
%token <Parse_info.t> T_DIR
%token <Parse_info.t> T_DIV_EQUAL
%token <float option * Parse_info.t> T_DNUMBER
%token <Parse_info.t> T_DO
%token <Parse_info.t> T_DOC_COMMENT
%token <Parse_info.t> T_DOLLAR_OPEN_CURLY_BRACES
%token <Parse_info.t> T_DOUBLE_ARROW
%token <Parse_info.t> T_DOUBLE_CAST
%token <Parse_info.t> T_ECHO
%token <Parse_info.t> T_ELLIPSIS
%token <Parse_info.t> T_ELSE
%token <Parse_info.t> T_ELSEIF
%token <Parse_info.t> T_EMPTY
%token <string * Parse_info.t> T_ENCAPSED_AND_WHITESPACE
%token <Parse_info.t> T_ENDDECLARE
%token <Parse_info.t> T_ENDFOR
%token <Parse_info.t> T_ENDFOREACH
%token <Parse_info.t> T_ENDIF
%token <Parse_info.t> T_ENDSWITCH
%token <Parse_info.t> T_ENDWHILE
%token <Parse_info.t> T_END_HEREDOC
%token <Parse_info.t> T_ENUM
%token <Parse_info.t> T_EVAL
%token <Parse_info.t> T_EXIT
%token <Parse_info.t> T_EXTENDS
%token <Parse_info.t> T_FILE
%token <Parse_info.t> T_FINAL
%token <Parse_info.t> T_FINALLY
%token <Parse_info.t> T_FOR
%token <Parse_info.t> T_FOREACH
%token <Parse_info.t> T_FROM
%token <Parse_info.t> T_FUNCTION
%token <Parse_info.t> T_FUNC_C
%token <Parse_info.t> T_GLOBAL
%token <string * Parse_info.t> T_IDENT
%token <Parse_info.t> T_IF
%token <Parse_info.t> T_IMPLEMENTS
%token <Parse_info.t> T_INC
%token <Parse_info.t> T_INCLUDE
%token <Parse_info.t> T_INCLUDE_ONCE
%token <string * Parse_info.t> T_INLINE_HTML
%token <Parse_info.t> T_INSTANCEOF
%token <Parse_info.t> T_INSTEADOF
%token <Parse_info.t> T_INTERFACE
%token <Parse_info.t> T_INT_CAST
%token <Parse_info.t> T_ISSET
%token <Parse_info.t> T_IS_EQUAL
%token <Parse_info.t> T_IS_GREATER_OR_EQUAL
%token <Parse_info.t> T_IS_IDENTICAL
%token <Parse_info.t> T_IS_NOT_EQUAL
%token <Parse_info.t> T_IS_NOT_IDENTICAL
%token <Parse_info.t> T_IS_SMALLER_OR_EQUAL
%token <Parse_info.t> T_LAMBDA_CPAR
%token <Parse_info.t> T_LAMBDA_OPAR
%token <Parse_info.t> T_LINE
%token <Parse_info.t> T_LIST
%token <int option * Parse_info.t> T_LNUMBER
%token <Parse_info.t> T_LOGICAL_AND
%token <Parse_info.t> T_LOGICAL_OR
%token <Parse_info.t> T_LOGICAL_XOR
%token <string * Parse_info.t> T_METAVAR
%token <Parse_info.t> T_METHOD_C
%token <Parse_info.t> T_MINUS_EQUAL
%token <Parse_info.t> T_MOD_EQUAL
%token <Parse_info.t> T_MUL_EQUAL
%token <Parse_info.t> T_NAMESPACE
%token <Parse_info.t> T_NAMESPACE_C
%token <Parse_info.t> T_NEW
%token <string * Parse_info.t> T_NUM_STRING
%token <Parse_info.t> T_OBJECT_CAST
%token <Parse_info.t> T_OBJECT_OPERATOR
%token <Parse_info.t> T_OPEN_TAG
%token <Parse_info.t> T_OPEN_TAG_WITH_ECHO
%token <Parse_info.t> T_OR_EQUAL
%token <Parse_info.t> T_PARENT
%token <Parse_info.t> T_PLUS_EQUAL
%token <Parse_info.t> T_PRINT
%token <Parse_info.t> T_PRIVATE
%token <Parse_info.t> T_PROTECTED
%token <Parse_info.t> T_PUBLIC
%token <Parse_info.t> T_REQUIRE
%token <Parse_info.t> T_REQUIRE_ONCE
%token <Parse_info.t> T_RETURN
%token <Parse_info.t> T_ROCKET
%token <Parse_info.t> T_SELF
%token <Parse_info.t> T_SL
%token <Parse_info.t> T_SL_EQUAL
%token <Parse_info.t> T_SR
%token <Parse_info.t> T_SR_EQUAL
%token <Parse_info.t> T_START_HEREDOC
%token <Parse_info.t> T_STATIC
%token <Parse_info.t> T_STRING_CAST
%token <string * Parse_info.t> T_STRING_VARNAME
%token <Parse_info.t> T_SUPER
%token <Parse_info.t> T_SWITCH
%token <Parse_info.t> T_THROW
%token <Parse_info.t> T_TRAIT
%token <Parse_info.t> T_TRAIT_C
%token <Parse_info.t> T_TRY
%token <Parse_info.t> T_TYPE
%token <Parse_info.t> T_UNSET
%token <Parse_info.t> T_UNSET_CAST
%token <Parse_info.t> T_USE
%token <Parse_info.t> T_VAR
%token <string * Parse_info.t> T_VARIABLE
%token <Parse_info.t> T_WHILE
%token <Parse_info.t> T_XOR_EQUAL
%token <Parse_info.t> T_YIELD
%token <Parse_info.t> T__AT
%nonassoc LOW_PRIORITY_RULE
%nonassoc T_YIELD
%nonassoc T_FROM
%nonassoc T_AWAIT
%left T_ARROW
%left T_INCLUDE T_INCLUDE_ONCE T_REQUIRE T_REQUIRE_ONCE
%right T_DOUBLE_ARROW
%left T_LOGICAL_OR
%left T_LOGICAL_XOR
%left T_LOGICAL_AND
%right T_PRINT
%left TEQ T_AND_EQUAL T_CONCAT_EQUAL T_DIV_EQUAL T_MINUS_EQUAL T_MOD_EQUAL T_MUL_EQUAL T_OR_EQUAL T_PLUS_EQUAL T_SL_EQUAL T_SR_EQUAL T_XOR_EQUAL
%left TCOLON TQUESTION
%left T_BOOLEAN_OR
%left T_BOOLEAN_AND
%left TOR
%left TXOR
%left TAND
%nonassoc T_IS_EQUAL T_IS_IDENTICAL T_IS_NOT_EQUAL T_IS_NOT_IDENTICAL T_ROCKET
%nonassoc TGREATER TSMALLER T_IS_GREATER_OR_EQUAL T_IS_SMALLER_OR_EQUAL
%left T_SL T_SR
%left TDOT TMINUS TPLUS
%left TDIV TMOD TMUL
%right TPOW
%right TBANG
%nonassoc T_INSTANCEOF
%right TTILDE T_ARRAY_CAST T_BOOL_CAST T_DEC T_DOUBLE_CAST T_INC T_INT_CAST T_OBJECT_CAST T_STRING_CAST T_UNSET_CAST
%right T__AT
%nonassoc T_CLONE
%left T_ELSEIF
%left T_ELSE
%left TCOLCOL
%type <Cst_php.toplevel list> main
%type <Cst_php.any> sgrep_spatch_pattern
%%

option_TAND_:
  
    {    ( None )}
| x = TAND
    {    ( Some x )}

option_TANTISLASH_:
  
    {    ( None )}
| x = TANTISLASH
    {    ( Some x )}

option_arguments_:
  
    {    ( None )}
| x = arguments
    {    ( Some x )}

option_attributes_:
  
    {    ( None )}
| x = attributes
    {    ( Some x )}

option_ctor_modifier_:
  
    {    ( None )}
| x = ctor_modifier
    {    ( Some x )}

option_expr_:
  
    {    ( None )}
| x = expr
    {    ( Some x )}

option_expr_or_dots_:
  
    {    ( None )}
| _1 = expr
    {let x =          ( _1 ) in
    ( Some x )}
| _1 = T_ELLIPSIS
    {let x =          ( Flag_parsing.sgrep_guard (Ellipsis _1) ) in
    ( Some x )}

option_finally_clause_:
  
    {    ( None )}
| x = finally_clause
    {    ( Some x )}

option_namespace_aliasing_clause_:
  
    {    ( None )}
| x = namespace_aliasing_clause
    {    ( Some x )}

option_return_type_:
  
    {    ( None )}
| x = return_type
    {    ( Some x )}

option_use_keyword_:
  
    {    ( None )}
| x = use_keyword
    {    ( Some x )}

option_visibility_modifier_:
  
    {    ( None )}
| x = visibility_modifier
    {    ( Some x )}

list_additional_catch_:
  
    {    ( [] )}
| x = additional_catch xs = list_additional_catch_
    {    ( x :: xs )}

list_encaps_:
  
    {    ( [] )}
| x = encaps xs = list_encaps_
    {    ( x :: xs )}

list_enum_statement_:
  
    {    ( [] )}
| x = enum_statement xs = list_enum_statement_
    {    ( x :: xs )}

list_inner_statement_:
  
    {    ( [] )}
| x = inner_statement xs = list_inner_statement_
    {    ( x :: xs )}

list_member_declaration_:
  
    {    ( [] )}
| x = member_declaration xs = list_member_declaration_
    {    ( x :: xs )}

list_member_modifier_:
  
    {    ( [] )}
| x = member_modifier xs = list_member_modifier_
    {    ( x :: xs )}

list_top_statement_:
  
    {    ( [] )}
| x = top_statement xs = list_top_statement_
    {    ( x :: xs )}

list_trait_rule_:
  
    {    ( [] )}
| x = trait_rule xs = list_trait_rule_
    {    ( x :: xs )}

nonempty_list_member_modifier_:
  x = member_modifier
    {    ( [ x ] )}
| x = member_modifier xs = nonempty_list_member_modifier_
    {    ( x :: xs )}

nonempty_list_top_statement_:
  x = top_statement
    {    ( [ x ] )}
| x = top_statement xs = nonempty_list_top_statement_
    {    ( x :: xs )}

list_sep_assignment_list_element_TCOMMA_:
  _1 = assignment_list_element
    {                          ( [Left _1] )}
| _1 = list_sep_assignment_list_element_TCOMMA_ _2 = TCOMMA _3 = assignment_list_element
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep_attribute_TCOMMA_:
  _1 = attribute
    {                          ( [Left _1] )}
| _1 = list_sep_attribute_TCOMMA_ _2 = TCOMMA _3 = attribute
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep_class_constant_declaration_TCOMMA_:
  _1 = class_constant_declaration
    {                          ( [Left _1] )}
| _1 = list_sep_class_constant_declaration_TCOMMA_ _2 = TCOMMA _3 = class_constant_declaration
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep_class_name_no_array_TCOMMA_:
  _1 = class_name_no_array
    {                          ( [Left _1] )}
| _1 = list_sep_class_name_no_array_TCOMMA_ _2 = TCOMMA _3 = class_name_no_array
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep_class_variable_TCOMMA_:
  _1 = class_variable
    {                          ( [Left _1] )}
| _1 = list_sep_class_variable_TCOMMA_ _2 = TCOMMA _3 = class_variable
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep_declare_TCOMMA_:
  _1 = declare
    {                          ( [Left _1] )}
| _1 = list_sep_declare_TCOMMA_ _2 = TCOMMA _3 = declare
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep_expr_TCOMMA_:
  _1 = expr
    {                          ( [Left _1] )}
| _1 = list_sep_expr_TCOMMA_ _2 = TCOMMA _3 = expr
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep_expr_or_dots_TCOMMA_:
  _1 = expr
    {let _1 =          ( _1 ) in
                          ( [Left _1] )}
| _1 = T_ELLIPSIS
    {let _1 =          ( Flag_parsing.sgrep_guard (Ellipsis _1) ) in
                          ( [Left _1] )}
| _1 = list_sep_expr_or_dots_TCOMMA_ _2 = TCOMMA _1_inlined1 = expr
    {let _3 =
  let _1 = _1_inlined1 in
           ( _1 )
in
                          ( _1 @ [Right _2; Left _3] )}
| _1 = list_sep_expr_or_dots_TCOMMA_ _2 = TCOMMA _1_inlined1 = T_ELLIPSIS
    {let _3 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
                          ( _1 @ [Right _2; Left _3] )}

list_sep_function_call_argument_TCOMMA_:
  _1 = function_call_argument
    {                          ( [Left _1] )}
| _1 = list_sep_function_call_argument_TCOMMA_ _2 = TCOMMA _3 = function_call_argument
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep_global_var_TCOMMA_:
  _1 = global_var
    {                          ( [Left _1] )}
| _1 = list_sep_global_var_TCOMMA_ _2 = TCOMMA _3 = global_var
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep_namespace_use_clause_TCOMMA_:
  _1 = namespace_use_clause
    {                          ( [Left _1] )}
| _1 = list_sep_namespace_use_clause_TCOMMA_ _2 = TCOMMA _3 = namespace_use_clause
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep_static_var_TCOMMA_:
  _1 = static_var
    {                          ( [Left _1] )}
| _1 = list_sep_static_var_TCOMMA_ _2 = TCOMMA _3 = static_var
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep_type_php_TCOMMA_:
  _1 = type_php
    {                          ( [Left _1] )}
| _1 = list_sep_type_php_TCOMMA_ _2 = TCOMMA _3 = type_php
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep_unset_variable_TCOMMA_:
  _1 = unset_variable
    {                          ( [Left _1] )}
| _1 = list_sep_unset_variable_TCOMMA_ _2 = TCOMMA _3 = unset_variable
    {                          ( _1 @ [Right _2; Left _3] )}

list_sep2_class_name_TOR_:
  _1 = class_name
    {                          ( [_1] )}
| _1 = list_sep2_class_name_TOR_ _2 = TOR _3 = class_name
    {                           ( _1 @ [_3] )}

list_sep2_namespace_use_group_clause_TCOMMA_:
  _1 = namespace_use_group_clause
    {                          ( [_1] )}
| _1 = list_sep2_namespace_use_group_clause_TCOMMA_ _2 = TCOMMA _3 = namespace_use_group_clause
    {                           ( _1 @ [_3] )}

main:
  _1 = list_top_statement_ _2 = EOF
    {                         ( List.flatten _1 @ [FinalDef _2] )}

top_statement:
  _1 = statement
    {                              ( [TopStmt _1] )}
| _1 = function_declaration
    {                              ( [FuncDef _1] )}
| _1 = class_declaration
    {                              ( [ClassDef _1] )}
| _1 = constant_declaration
    {                              ( [ConstantDef _1] )}
| _1 = type_declaration
    {                              ( [TypeDef _1] )}
| _1 = namespace_declaration
    {                              ( [_1] )}
| _1 = namespace_use_declaration
    {                              ( _1 )}

sgrep_spatch_pattern:
  _1 = expr _2 = EOF
    {                                    ( Expr _1 )}
| _1 = top_statement _2 = EOF
    {                                    ( mk_Toplevel _1 )}
| _1 = top_statement _2 = nonempty_list_top_statement_ _3 = EOF
    {                                    ( Toplevels (_1 @ List.flatten _2) )}
| _1 = TCOLON _2 = type_php _3 = EOF
    {                                    ( Hint2 _2 )}
| _1 = T_IF _2 = TOPAR _1_inlined1 = expr _4 = TCPAR _5 = EOF
    {let _3 =
  let _1 = _1_inlined1 in
           ( _1 )
in
                                    ( Partial (PartialIf (_1, _3)) )}
| _1 = T_IF _2 = TOPAR _1_inlined1 = T_ELLIPSIS _4 = TCPAR _5 = EOF
    {let _3 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
                                    ( Partial (PartialIf (_1, _3)) )}

statement:
  _1 = expr _2 = TSEMICOLON
    {                          ( ExprStmt(_1,_2) )}
| _1 = TSEMICOLON
    {                          ( EmptyStmt(_1) )}
| _1 = TOBRACE _2 = list_inner_statement_ _3 = TCBRACE
    {                              ( Block(_1,_2,_3) )}
| _1 = T_IF _2 = TOPAR _1_inlined1 = expr _4 = TCPAR _5 = statement _6 = elseif_list _7 = else_single
    {let _3 =
  let _1 = _1_inlined1 in
           ( _1 )
in
     ( If(_1,(_2,_3,_4),_5,_6,_7) )}
| _1 = T_IF _2 = TOPAR _1_inlined1 = T_ELLIPSIS _4 = TCPAR _5 = statement _6 = elseif_list _7 = else_single
    {let _3 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
     ( If(_1,(_2,_3,_4),_5,_6,_7) )}
| _1 = T_IF _2 = TOPAR _1_inlined1 = expr _4 = TCPAR _5 = TCOLON _6 = list_inner_statement_ _7 = new_elseif_list _8 = new_else_single _9 = T_ENDIF _10 = TSEMICOLON
    {let _3 =
  let _1 = _1_inlined1 in
           ( _1 )
in
     ( IfColon(_1,(_2,_3,_4),_5,_6,_7,_8,_9,_10)  )}
| _1 = T_IF _2 = TOPAR _1_inlined1 = T_ELLIPSIS _4 = TCPAR _5 = TCOLON _6 = list_inner_statement_ _7 = new_elseif_list _8 = new_else_single _9 = T_ENDIF _10 = TSEMICOLON
    {let _3 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
     ( IfColon(_1,(_2,_3,_4),_5,_6,_7,_8,_9,_10)  )}
| _1 = T_WHILE _2 = TOPAR _1_inlined1 = expr _4 = TCPAR _5 = while_statement
    {let _3 =
  let _1 = _1_inlined1 in
           ( _1 )
in
     ( While(_1,(_2,_3,_4),_5) )}
| _1 = T_WHILE _2 = TOPAR _1_inlined1 = T_ELLIPSIS _4 = TCPAR _5 = while_statement
    {let _3 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
     ( While(_1,(_2,_3,_4),_5) )}
| _1 = T_DO _2 = statement _3 = T_WHILE _4 = TOPAR _1_inlined1 = expr _6 = TCPAR _7 = TSEMICOLON
    {let _5 =
  let _1 = _1_inlined1 in
           ( _1 )
in
     ( Do(_1,_2,_3,(_4,_5,_6),_7) )}
| _1 = T_DO _2 = statement _3 = T_WHILE _4 = TOPAR _1_inlined1 = T_ELLIPSIS _6 = TCPAR _7 = TSEMICOLON
    {let _5 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
     ( Do(_1,_2,_3,(_4,_5,_6),_7) )}
| _1 = T_FOR _2 = TOPAR _3 = for_expr _4 = TSEMICOLON _5 = for_expr _6 = TSEMICOLON _7 = for_expr _8 = TCPAR _9 = for_statement
    {     ( For(_1,_2,_3,_4,_5,_6,_7,_8,_9) )}
| _1 = T_SWITCH _2 = TOPAR _1_inlined1 = expr _4 = TCPAR _5 = switch_case_list
    {let _3 =
  let _1 = _1_inlined1 in
           ( _1 )
in
     ( Switch(_1,(_2,_3,_4),_5) )}
| _1 = T_SWITCH _2 = TOPAR _1_inlined1 = T_ELLIPSIS _4 = TCPAR _5 = switch_case_list
    {let _3 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
     ( Switch(_1,(_2,_3,_4),_5) )}
| _1 = T_FOREACH _2 = TOPAR _3 = expr _4 = T_AS _5 = foreach_pattern _6 = TCPAR _7 = foreach_statement
    {     ( Foreach(_1,_2,_3,None, _4,_5,_6,_7) )}
| _1 = T_FOREACH _2 = TOPAR _3 = expr _4 = T_AWAIT _5 = T_AS _6 = foreach_pattern _7 = TCPAR _8 = foreach_statement
    {     ( Foreach(_1,_2,_3, Some _4, _5,_6,_7, _8) )}
| _1 = T_BREAK _2 = option_expr_ _3 = TSEMICOLON
    {                        ( Break(_1,_2, _3) )}
| _1 = T_CONTINUE _2 = option_expr_ _3 = TSEMICOLON
    {                        ( Continue(_1, _2, _3) )}
| _1 = T_RETURN _2 = option_expr_or_dots_ _3 = TSEMICOLON
    {                               ( Return (_1, _2, _3))}
| _1 = T_TRY _2 = TOBRACE _3 = list_inner_statement_ _4 = TCBRACE _5 = T_CATCH _6 = TOPAR _7 = list_sep2_class_name_TOR_ _1_inlined1 = T_VARIABLE _9 = TCPAR _10 = TOBRACE _11 = list_inner_statement_ _12 = TCBRACE _13 = list_additional_catch_ _14 = option_finally_clause_
    {let _8 =
  let _1 = _1_inlined1 in
                ( _1 )
in
     ( let try_block = (_2,_3,_4) in
       let catch_block = (_10, _11, _12) in
       let t = List.hd _7 in (* TODO: return a list of types *)
       let catch = (_5, (_6, (t, DName _8), _9), catch_block) in
       Try(_1, try_block, [catch] @ _13, o2l _14)
     )}
| _1 = T_TRY _2 = TOBRACE _3 = list_inner_statement_ _4 = TCBRACE _5 = T_CATCH _6 = TOPAR _7 = list_sep2_class_name_TOR_ _1_inlined1 = T_METAVAR _9 = TCPAR _10 = TOBRACE _11 = list_inner_statement_ _12 = TCBRACE _13 = list_additional_catch_ _14 = option_finally_clause_
    {let _8 =
  let _1 = _1_inlined1 in
               ( _1 )
in
     ( let try_block = (_2,_3,_4) in
       let catch_block = (_10, _11, _12) in
       let t = List.hd _7 in (* TODO: return a list of types *)
       let catch = (_5, (_6, (t, DName _8), _9), catch_block) in
       Try(_1, try_block, [catch] @ _13, o2l _14)
     )}
| _1 = T_TRY _2 = TOBRACE _3 = list_inner_statement_ _4 = TCBRACE _5 = finally_clause
    {     ( let try_block = (_2,_3,_4) in
       Try(_1, try_block, [], [_5])
     )}
| _1 = T_THROW _1_inlined1 = expr _3 = TSEMICOLON
    {let _2 =
  let _1 = _1_inlined1 in
           ( _1 )
in
                            ( Throw(_1,_2,_3) )}
| _1 = T_THROW _1_inlined1 = T_ELLIPSIS _3 = TSEMICOLON
    {let _2 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
                            ( Throw(_1,_2,_3) )}
| _1 = T_ECHO _1_inlined1 = list_sep_expr_or_dots_TCOMMA_ _3 = TSEMICOLON
    {let _2 =
  let _1 = _1_inlined1 in
                             ( _1 )
in
                                  ( Echo(_1,_2,_3) )}
| _1 = T_INLINE_HTML
    {                                  ( InlineHtml(_1) )}
| _1 = T_OPEN_TAG_WITH_ECHO _2 = expr _3 = T_CLOSE_TAG_OF_ECHO
    {                                                 (
     (* ugly: the 2 tokens will have a wrong string *)
     Echo (_1, [Left _2], _3)
   )}
| _1 = T_OPEN_TAG_WITH_ECHO _2 = expr _3 = TSEMICOLON _4 = T_CLOSE_TAG_OF_ECHO
    {                                                     (
     Echo (_1, [Left _2], _4)
   )}
| _1 = T_GLOBAL _1_inlined1 = list_sep_global_var_TCOMMA_ _3 = TSEMICOLON
    {let _2 =
  let _1 = _1_inlined1 in
                             ( _1 )
in
                                  ( Globals(_1,_2,_3) )}
| _1 = T_STATIC _1_inlined1 = list_sep_static_var_TCOMMA_ _3 = TSEMICOLON
    {let _2 =
  let _1 = _1_inlined1 in
                             ( _1 )
in
                                  ( StaticVars(_1,_2,_3) )}
| _1 = T_UNSET _2 = TOPAR _1_inlined1 = list_sep_unset_variable_TCOMMA_ _4 = TCPAR _5 = TSEMICOLON
    {let _3 =
  let _1 = _1_inlined1 in
                             ( _1 )
in
                                             ( Unset(_1,(_2,_3,_4),_5) )}
| _1 = T_USE _2 = use_filename _3 = TSEMICOLON
    {                                  ( Use(_1,_2,_3) )}
| _1 = T_DECLARE _2 = TOPAR _1_inlined1 = list_sep_declare_TCOMMA_ _4 = TCPAR _5 = declare_statement
    {let _3 =
  let _1 = _1_inlined1 in
                             ( _1 )
in
     ( Declare(_1,(_2,_3,_4),_5) )}
| _1 = T_ELLIPSIS
    {         ( Flag_parsing.sgrep_guard (ExprStmt (Ellipsis _1, fakeInfo ";")) )}

inner_statement:
  _1 = statement
    {                                    ( _1 )}
| _1 = function_declaration
    {                          ( FuncDefNested _1 )}
| _1 = class_declaration
    {                          ( ClassDefNested _1 )}

for_expr:
  
    {                 ( [] )}
| _1 = list_sep_expr_TCOMMA_
    {let _1 =                            ( _1 ) in
                 ( _1 )}

foreach_variable:
  _2 = expr
    {let _1 =     ( None ) in
                                      ( _1, _2 )}
| x = TAND _2 = expr
    {let _1 =     ( Some x ) in
                                      ( _1, _2 )}

foreach_pattern:
  _1 = foreach_variable
    {                                          ( ForeachVar _1 )}
| _1 = foreach_variable _2 = T_ARROW _3 = foreach_pattern
    {                                          ( ForeachArrow(ForeachVar _1,_2,_3) )}
| _1 = T_LIST _2 = TOPAR _3 = assignment_list _4 = TCPAR
    {                                          ( ForeachList(_1,(_2,_3,_4)) )}

switch_case_list:
  _1 = TOBRACE _2 = case_list _3 = TCBRACE
    {     ( CaseList(_1,None,_2,_3) )}
| _1 = TOBRACE _2 = TSEMICOLON _3 = case_list _4 = TCBRACE
    {     ( CaseList(_1, Some _2, _3, _4) )}
| _1 = TCOLON _2 = case_list _3 = T_ENDSWITCH _4 = TSEMICOLON
    {     ( CaseColonList(_1,None,_2, _3, _4) )}
| _1 = TCOLON _2 = TSEMICOLON _3 = case_list _4 = T_ENDSWITCH _5 = TSEMICOLON
    {     ( CaseColonList(_1, Some _2, _3, _4, _5) )}

case_list:
  _1 = case_list_rev
    {                         ( List.rev _1 )}

case_list_rev:
  
    {                ( [] )}
| _1 = case_list_rev _2 = T_CASE _3 = expr _4 = case_separator _5 = list_inner_statement_
    {     ( Case(_2,_3,_4,_5)::_1   )}
| _1 = case_list_rev _2 = T_DEFAULT _3 = case_separator _4 = list_inner_statement_
    {     ( Default(_2,_3,_4)::_1 )}

case_separator:
  _1 = TCOLON
    {           ( _1 )}
| _1 = TSEMICOLON
    {       ( _1 )}

while_statement:
  _1 = statement
    {                                       ( SingleStmt _1 )}
| _1 = TCOLON _2 = list_inner_statement_ _3 = T_ENDWHILE _4 = TSEMICOLON
    {                                       ( ColonStmt(_1,_2,_3,_4) )}

for_statement:
  _1 = statement
    {                                     ( SingleStmt _1 )}
| _1 = TCOLON _2 = list_inner_statement_ _3 = T_ENDFOR _4 = TSEMICOLON
    {                                     ( ColonStmt(_1,_2,_3,_4) )}

foreach_statement:
  _1 = statement
    {                                         ( SingleStmt _1 )}
| _1 = TCOLON _2 = list_inner_statement_ _3 = T_ENDFOREACH _4 = TSEMICOLON
    {                                         ( ColonStmt(_1,_2,_3,_4))}

declare_statement:
  _1 = statement
    {                                         ( SingleStmt _1 )}
| _1 = TCOLON _2 = list_inner_statement_ _3 = T_ENDDECLARE _4 = TSEMICOLON
    {                                         ( ColonStmt(_1,_2,_3,_4))}

elseif_list:
  
    {             ( [] )}
| _1 = elseif_list _2 = T_ELSEIF _3 = TOPAR _1_inlined1 = expr _5 = TCPAR _6 = statement
    {let _4 =
  let _1 = _1_inlined1 in
           ( _1 )
in
                                                        ( _1 @ [_2,(_3,_4,_5),_6])}
| _1 = elseif_list _2 = T_ELSEIF _3 = TOPAR _1_inlined1 = T_ELLIPSIS _5 = TCPAR _6 = statement
    {let _4 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
                                                        ( _1 @ [_2,(_3,_4,_5),_6])}

new_elseif_list:
  
    {             ( [] )}
| _1 = new_elseif_list _2 = T_ELSEIF _3 = TOPAR _1_inlined1 = expr _5 = TCPAR _6 = TCOLON _7 = list_inner_statement_
    {let _4 =
  let _1 = _1_inlined1 in
           ( _1 )
in
     ( _1 @ [_2,(_3,_4,_5),_6,_7] )}
| _1 = new_elseif_list _2 = T_ELSEIF _3 = TOPAR _1_inlined1 = T_ELLIPSIS _5 = TCPAR _6 = TCOLON _7 = list_inner_statement_
    {let _4 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
     ( _1 @ [_2,(_3,_4,_5),_6,_7] )}

else_single:
  _1 = T_ELSE _2 = statement
    {                                       ( Some(_1,_2) )}
|  %prec LOW_PRIORITY_RULE
    {                                       ( None )}

new_else_single:
  
    {                               ( None )}
| _1 = T_ELSE _2 = TCOLON _3 = list_inner_statement_
    {                               ( Some(_1,_2,_3) )}

additional_catch:
  _1 = T_CATCH _2 = TOPAR _3 = class_name _1_inlined1 = T_VARIABLE _5 = TCPAR _6 = TOBRACE _7 = list_inner_statement_ _8 = TCBRACE
    {let _4 =
  let _1 = _1_inlined1 in
                ( _1 )
in
     ( let catch_block = (_6, _7, _8) in
       let catch = (_1, (_2, (_3, DName _4), _5), catch_block) in
       catch
     )}
| _1 = T_CATCH _2 = TOPAR _3 = class_name _1_inlined1 = T_METAVAR _5 = TCPAR _6 = TOBRACE _7 = list_inner_statement_ _8 = TCBRACE
    {let _4 =
  let _1 = _1_inlined1 in
               ( _1 )
in
     ( let catch_block = (_6, _7, _8) in
       let catch = (_1, (_2, (_3, DName _4), _5), catch_block) in
       catch
     )}

finally_clause:
  _1 = T_FINALLY _2 = TOBRACE _3 = list_inner_statement_ _4 = TCBRACE
    {                                                    ( (_1, (_2, _3, _4)) )}

declare:
  _1 = ident _2 = TEQ _3 = static_scalar
    {                                   ( Name _1, (_2, _3) )}

global_var:
  _1 = T_VARIABLE
    {let _1 =               ( _1 ) in
                  ( GlobalVar (DName _1) )}
| _1 = T_METAVAR
    {let _1 =              ( _1 ) in
                  ( GlobalVar (DName _1) )}
| _1 = TDOLLAR _2 = expr
    {                    ( GlobalDollar (_1, _2) )}
| _1 = TDOLLAR _2 = TOBRACE _3 = expr _4 = TCBRACE
    {                    ( GlobalDollarExpr (_1, (_2, _3, _4)) )}

static_var:
  _1 = T_VARIABLE
    {let _1 =               ( _1 ) in
                              ( (DName _1, None) )}
| _1 = T_METAVAR
    {let _1 =              ( _1 ) in
                              ( (DName _1, None) )}
| _1 = T_VARIABLE _2 = TEQ _3 = static_scalar
    {let _1 =               ( _1 ) in
                              ( (DName _1, Some (_2, _3)) )}
| _1 = T_METAVAR _2 = TEQ _3 = static_scalar
    {let _1 =              ( _1 ) in
                              ( (DName _1, Some (_2, _3)) )}

unset_variable:
  _1 = expr
    {let _1 =          ( _1 ) in
                                ( _1 )}
| _1 = T_ELLIPSIS
    {let _1 =          ( Flag_parsing.sgrep_guard (Ellipsis _1) ) in
                                ( _1 )}

use_filename:
  _1 = T_CONSTANT_ENCAPSED_STRING
    {                                        ( UseDirect _1 )}
| _1 = TOPAR _2 = T_CONSTANT_ENCAPSED_STRING _3 = TCPAR
    {                                        ( UseParen (_1, _2, _3) )}

constant_declaration:
  _1 = T_CONST _3 = ident_constant_name _4 = TEQ _5 = static_scalar _6 = TSEMICOLON
    {let _2 =     ( None ) in
   ( { cst_toks = (_1,_4,_6); cst_name = Name _3; cst_val = _5; cst_type = _2})}
| _1 = T_CONST x = type_php _3 = ident_constant_name _4 = TEQ _5 = static_scalar _6 = TSEMICOLON
    {let _2 =     ( Some x ) in
   ( { cst_toks = (_1,_4,_6); cst_name = Name _3; cst_val = _5; cst_type = _2})}

function_declaration:
  _2 = unticked_function_declaration
    {let _1 =     ( None ) in
   ( { _2 with f_attrs = _1 } )}
| x = attributes _2 = unticked_function_declaration
    {let _1 =     ( Some x ) in
   ( { _2 with f_attrs = _1 } )}

unticked_function_declaration:
  _2 = T_FUNCTION _3 = is_reference _4 = ident _5 = type_params_opt _6 = TOPAR _7 = parameter_list _8 = TCPAR _9 = option_return_type_ _10 = function_body
    {let _1 =              ( [] ) in
   (  validate_parameter_list _7;
      { f_tok = _2; f_ref = _3; f_name = Name _4; f_params = (_6, _7, _8);
       f_tparams = _5;
       f_return_type = _9; f_body = _10;
       f_attrs = None;
       f_type = FunctionRegular; f_modifiers = _1;
    } )}
| _1 = T_ASYNC _2 = T_FUNCTION _3 = is_reference _4 = ident _5 = type_params_opt _6 = TOPAR _7 = parameter_list _8 = TCPAR _9 = option_return_type_ _10 = function_body
    {let _1 =            ( [Async,(_1)] ) in
   (  validate_parameter_list _7;
      { f_tok = _2; f_ref = _3; f_name = Name _4; f_params = (_6, _7, _8);
       f_tparams = _5;
       f_return_type = _9; f_body = _10;
       f_attrs = None;
       f_type = FunctionRegular; f_modifiers = _1;
    } )}
| _1 = T_STATIC _2 = T_FUNCTION _3 = is_reference _4 = ident _5 = type_params_opt _6 = TOPAR _7 = parameter_list _8 = TCPAR _9 = option_return_type_ _10 = function_body
    {let _1 =             ( [Static,(_1)] ) in
   (  validate_parameter_list _7;
      { f_tok = _2; f_ref = _3; f_name = Name _4; f_params = (_6, _7, _8);
       f_tparams = _5;
       f_return_type = _9; f_body = _10;
       f_attrs = None;
       f_type = FunctionRegular; f_modifiers = _1;
    } )}

function_body:
  _1 = TOBRACE _2 = list_inner_statement_ _3 = TCBRACE
    {                                ( (_1, _2, _3)  )}
| _1 = TSEMICOLON
    {       ( (* ugly: *) (fakeInfo"", [], _1) )}

parameter_list:
  
    {                                 ( [] )}
| _1 = parameter
    {                                     ( [_1] )}
| _1 = parameter _2 = TCOMMA _3 = parameter_list
    {                                  ( _1 :: (Right3 _2) :: _3 )}

parameter:
  _1 = option_attributes_ _2 = option_ctor_modifier_ _4 = parameter_bis
    {let _3 =     ( None ) in
   ( match _4 with
     | Left3 param ->
         let hint = match param.p_type with
              | Some(HintVariadic (tok, _)) -> Some(HintVariadic (tok, _3))
              | _ -> _3
         in
         Left3 { param with p_modifier = _2; p_attrs = _1; p_type = hint; }
      | _ -> match (_1, _2, _3) with
             | (None, None, None) -> _4
             | _ -> raise Parsing.Parse_error
      )}
| _1 = option_attributes_ _2 = option_ctor_modifier_ x = type_php _4 = parameter_bis
    {let _3 =     ( Some x ) in
   ( match _4 with
     | Left3 param ->
         let hint = match param.p_type with
              | Some(HintVariadic (tok, _)) -> Some(HintVariadic (tok, _3))
              | _ -> _3
         in
         Left3 { param with p_modifier = _2; p_attrs = _1; p_type = hint; }
      | _ -> match (_1, _2, _3) with
             | (None, None, None) -> _4
             | _ -> raise Parsing.Parse_error
      )}

parameter_bis:
  _1 = T_VARIABLE
    {let _1 =               ( _1 ) in
     ( Left3 (mk_param _1) )}
| _1 = T_METAVAR
    {let _1 =              ( _1 ) in
     ( Left3 (mk_param _1) )}
| _1 = TAND _1_inlined1 = T_VARIABLE
    {let _2 =
  let _1 = _1_inlined1 in
                ( _1 )
in
     ( let p = mk_param _2 in Left3 {p with p_ref=Some _1} )}
| _1 = TAND _1_inlined1 = T_METAVAR
    {let _2 =
  let _1 = _1_inlined1 in
               ( _1 )
in
     ( let p = mk_param _2 in Left3 {p with p_ref=Some _1} )}
| _1 = T_VARIABLE _2 = TEQ _3 = static_scalar
    {let _1 =               ( _1 ) in
     ( let p = mk_param _1 in Left3 {p with p_default=Some(_2,_3)} )}
| _1 = T_METAVAR _2 = TEQ _3 = static_scalar
    {let _1 =              ( _1 ) in
     ( let p = mk_param _1 in Left3 {p with p_default=Some(_2,_3)} )}
| _1 = TAND _1_inlined1 = T_VARIABLE _3 = TEQ _4 = static_scalar
    {let _2 =
  let _1 = _1_inlined1 in
                ( _1 )
in
     ( let p = mk_param _2 in Left3 {p with p_ref=Some _1; p_default=Some(_3,_4)} )}
| _1 = TAND _1_inlined1 = T_METAVAR _3 = TEQ _4 = static_scalar
    {let _2 =
  let _1 = _1_inlined1 in
               ( _1 )
in
     ( let p = mk_param _2 in Left3 {p with p_ref=Some _1; p_default=Some(_3,_4)} )}
| _1 = T_ELLIPSIS _2 = T_VARIABLE
    {     ( let p = mk_param _2 in Left3 {p with p_variadic=Some _1; p_type=Some(HintVariadic (_1, None))} )}
| _1 = TAND _2 = T_ELLIPSIS _3 = T_VARIABLE
    {     ( let p = mk_param _3 in Left3 {p with p_ref=Some _1; p_variadic=Some _2; p_type=Some(HintVariadic (_2, None))} )}
| _1 = T_ELLIPSIS
    {     ( Middle3 _1 )}

ctor_modifier:
  _1 = visibility_modifier
    {                                   ( _1 )}

is_reference:
  _1 = option_TAND_
    {                     ( _1 )}

lexical_vars:
  
    {              ( None )}
| _1 = T_USE _2 = TOPAR _3 = non_empty_lexical_var_list _4 = TCPAR
    {                                            (
     Some (_1, (_2, (_3 |> List.map (function
     | Right info -> Right info
     | Left (a,b) -> Left (LexicalVar (a,b)))), _4))
   )}

non_empty_lexical_var_list:
  _1 = non_empty_lexical_var_list_bis
    {                                  ( _1 )}
| _1 = non_empty_lexical_var_list_bis _2 = TCOMMA
    {                                      ( _1 @ [Right _2] )}

non_empty_lexical_var_list_bis:
  _1 = lexical_var
    {     ( [Left _1] )}
| _1 = non_empty_lexical_var_list_bis _2 = TCOMMA _3 = lexical_var
    {     ( _1 @ [Right _2; Left _3] )}

lexical_var:
  _1 = option_TAND_ _1_inlined1 = T_VARIABLE
    {let _2 =
  let _1 = _1_inlined1 in
                ( _1 )
in
                             ( (_1, DName _2) )}
| _1 = option_TAND_ _1_inlined1 = T_METAVAR
    {let _2 =
  let _1 = _1_inlined1 in
               ( _1 )
in
                             ( (_1, DName _2) )}

class_declaration:
  _2 = unticked_class_declaration
    {let _1 =     ( None ) in
     ( { _2 with c_attrs = _1 } )}
| x = attributes _2 = unticked_class_declaration
    {let _1 =     ( Some x ) in
     ( { _2 with c_attrs = _1 } )}

unticked_class_declaration:
  _1 = class_entry_type _2 = ident_class_name _3 = type_params_opt _4 = extends_from _5 = implements_list _6 = TOBRACE _7 = list_member_declaration_ _8 = TCBRACE
    {     (
       { c_type = _1; c_name = _2; c_extends = _4; c_tparams = _3;
         c_implements = _5; c_body = _6, _7, _8;
         c_attrs = None;
         c_enum_type = None;
       }
     )}
| _1 = T_INTERFACE _2 = ident_class_name _3 = type_params_opt _4 = interface_extends_list _5 = TOBRACE _6 = list_member_declaration_ _7 = TCBRACE
    {     ( { c_type = Interface _1; c_name = _2; c_extends = None; c_tparams = _3;
         (* we use c_implements for interface extension because
          * it can be a list. ugly?
          *)
         c_implements = _4; c_body = _5, _6, _7;
         c_attrs = None;
         c_enum_type = None;
     } )}
| _1 = T_TRAIT _2 = ident_class_name _3 = type_params_opt _4 = implements_list _5 = TOBRACE _6 = list_member_declaration_ _7 = TCBRACE
    {     ( { c_type = Trait _1; c_name = _2; c_extends = None; c_tparams = _3;
         c_implements = _4; c_body = (_5, _6, _7);
         c_attrs = None;
         c_enum_type = None;
       }
     )}
| _1 = T_ENUM _2 = ident_class_name _3 = TCOLON _4 = type_php _5 = type_constr_opt _6 = TOBRACE _7 = list_enum_statement_ _8 = TCBRACE
    {     ( { c_type = Enum _1; c_name = _2; c_extends = None; c_tparams = None;
         c_implements = None; c_body = (_6, _7, _8);
         c_attrs = None;
         c_enum_type = Some { e_tok = _3; e_base = _4; e_constraint = _5; }
       }
     )}

class_entry_type:
  _1 = T_CLASS
    {                              ( ClassRegular _1 )}
| _1 = T_ABSTRACT _2 = T_CLASS
    {                              ( ClassAbstract (_1, _2) )}
| _1 = T_FINAL _2 = T_CLASS
    {                              ( ClassFinal (_1, _2) )}

visibility_modifier:
  _1 = T_PUBLIC
    {               ( Public,(_1) )}
| _1 = T_PROTECTED
    {               ( Protected,(_1) )}
| _1 = T_PRIVATE
    {               ( Private,(_1) )}

class_modifier:
  _1 = T_ABSTRACT
    {              ( Abstract, _1 )}
| _1 = T_FINAL
    {              ( Final, _1 )}

variable_modifiers:
  _1 = T_VAR
    {                          ( NoModifiers _1 )}
| _1 = nonempty_list_member_modifier_
    {                          ( VModifiers _1 )}

member_modifier:
  _1 = class_modifier
    {                  ( _1 )}
| _1 = visibility_modifier
    {                       ( _1 )}
| _1 = T_STATIC
    {               ( Static,(_1) )}
| _1 = T_ASYNC
    {               ( Async,(_1) )}

extends_from:
  
    {                                 ( None )}
| _1 = T_EXTENDS _2 = class_name_no_array
    {                                 ( Some (_1, _2)  )}

interface_extends_list:
  
    {                             ( None )}
| _1 = T_EXTENDS _2 = class_name_list
    {                             ( Some(_1,_2) )}

implements_list:
  
    {                                ( None )}
| _1 = T_IMPLEMENTS _2 = class_name_list
    {                                ( Some(_1, _2) )}

member_declaration:
  _1 = option_visibility_modifier_ _2 = T_CONST _1_inlined1 = list_sep_class_constant_declaration_TCOMMA_ _5 = TSEMICOLON
    {let _4 =
  let _1 = _1_inlined1 in
                             ( _1 )
in
let _3 =     ( None ) in
     ( ClassConstants(o2l _1, _2, _3, _4, _5) )}
| _1 = option_visibility_modifier_ _2 = T_CONST x = type_php _1_inlined1 = list_sep_class_constant_declaration_TCOMMA_ _5 = TSEMICOLON
    {let _4 =
  let _1 = _1_inlined1 in
                             ( _1 )
in
let _3 =     ( Some x ) in
     ( ClassConstants(o2l _1, _2, _3, _4, _5) )}
| _1 = variable_modifiers _1_inlined1 = list_sep_class_variable_TCOMMA_ _4 = TSEMICOLON
    {let _3 =
  let _1 = _1_inlined1 in
                             ( _1 )
in
let _2 =     ( None ) in
     ( ClassVariables(_1, _2, _3, _4)  )}
| _1 = variable_modifiers x = type_php _1_inlined1 = list_sep_class_variable_TCOMMA_ _4 = TSEMICOLON
    {let _3 =
  let _1 = _1_inlined1 in
                             ( _1 )
in
let _2 =     ( Some x ) in
     ( ClassVariables(_1, _2, _3, _4)  )}
| _2 = method_declaration
    {let _1 =     ( None ) in
                                          ( Method { _2 with f_attrs = _1 } )}
| x = attributes _2 = method_declaration
    {let _1 =     ( Some x ) in
                                          ( Method { _2 with f_attrs = _1 } )}
| _1 = T_USE _2 = class_name_list _3 = TSEMICOLON
    {     ( UseTrait (_1, _2, Left _3) )}
| _1 = T_USE _2 = class_name_list _3 = TOBRACE _4 = list_trait_rule_ _5 = TCBRACE
    {     ( UseTrait (_1, _2, Right (_3, _4, _5)) )}
| _1 = T_ELLIPSIS
    {         ( Flag_parsing.sgrep_guard (DeclEllipsis _1) )}

enum_statement:
  _1 = class_constant_declaration _2 = TSEMICOLON
    {     ( ClassConstants([], _2, None, [Left _1], _2) )}

method_declaration:
  _1 = list_member_modifier_ _2 = T_FUNCTION _3 = is_reference _4 = ident_method_name _5 = type_params_opt _6 = TOPAR _7 = parameter_list _8 = TCPAR _9 = option_return_type_ _10 = method_body
    {     ( validate_parameter_list _7;
       let body, function_type = _10 in
       ({ f_tok = _2; f_ref = _3; f_name = Name _4; f_tparams = _5;
          f_params = (_6, _7, _8); f_return_type = _9;
          f_body = body; f_type = function_type; f_modifiers = _1;
          f_attrs = None;
        })
     )}

class_constant_declaration:
  _1 = ident_constant_name _2 = TEQ _3 = static_scalar
    {                                        ( ((Name _1), (_2,_3)))}

class_variable:
  _1 = T_VARIABLE
    {let _1 =               ( _1 ) in
                      ( (DName _1, None) )}
| _1 = T_METAVAR
    {let _1 =              ( _1 ) in
                      ( (DName _1, None) )}
| _1 = T_VARIABLE _2 = TEQ _3 = static_scalar
    {let _1 =               ( _1 ) in
                              ( (DName _1, Some (_2, _3)) )}
| _1 = T_METAVAR _2 = TEQ _3 = static_scalar
    {let _1 =              ( _1 ) in
                              ( (DName _1, Some (_2, _3)) )}

method_body:
  _1 = TOBRACE _2 = list_inner_statement_ _3 = TCBRACE
    {                            ( (_1, _2, _3), MethodRegular )}
| _1 = TSEMICOLON
    {                            ( (* ugly: *) (fakeInfo"",[], _1), MethodAbstract )}

trait_rule:
  _1 = trait_precedence_rule
    {                          ( _1 )}
| _1 = trait_alias_rule
    {                          ( _1 )}

trait_precedence_rule:
  _1 = qualified_name_for_traits _2 = TCOLCOL _3 = T_IDENT _4 = T_INSTEADOF _5 = class_name_list _6 = TSEMICOLON
    {   ( InsteadOf (_1, _2, Name _3, _4, _5, _6) )}

trait_alias_rule:
  _1 = trait_alias_rule_method _2 = T_AS _3 = list_member_modifier_ _4 = T_IDENT _5 = TSEMICOLON
    {   ( As (_1, _2, _3, Some (Name _4), _5) )}
| _1 = trait_alias_rule_method _2 = T_AS _3 = nonempty_list_member_modifier_ _4 = TSEMICOLON
    {   ( As (_1, _2, _3, None, _4) )}

trait_alias_rule_method:
  _1 = qualified_name_for_traits _2 = TCOLCOL _3 = T_IDENT
    {                                          ( Right (_1, _2, Name _3) )}
| _1 = T_IDENT
    {           ( Left (Name _1) )}

type_declaration:
  _1 = T_TYPE _2 = ident _3 = type_params_opt _4 = type_constr_opt _5 = TEQ _6 = type_php _7 = TSEMICOLON
    {     ( { t_tok = _1; t_name = Name _2; t_tparams = _3; t_tconstraint = _4;
         t_tokeq = _5; t_kind = Alias _6; t_sc = _7; }
     )}

type_constr_opt:
  _1 = T_AS _2 = type_php
    {                  ( Some (_1, _2) )}
| 
    {                  ( None )}

type_params_opt:
  
    {                             ( None )}
| _1 = TSMALLER _2 = type_params_list _3 = TGREATER
    {                             ( Some (_1, _2, _3) )}

type_params_list:
  _1 = type_param
    {                                       ( [Left _1] )}
| _1 = type_param _2 = TCOMMA _3 = type_params_list
    {                                    ( [Left _1; Right _2] @ _3 )}

type_param:
  _1 = variance_opt _2 = ident
    {                                       ( TParam (Name _2) )}
| _1 = variance_opt _2 = ident _3 = T_AS _4 = TQUESTION _5 = class_name
    {                                           ( TParamConstraint (Name _2, _3, HintQuestion (_4, _5)) )}
| _1 = variance_opt _2 = ident _3 = T_AS _4 = class_name
    {                                       ( TParamConstraint (Name _2, _3, _4) )}
| _1 = variance_opt _2 = ident _3 = T_SUPER _4 = TQUESTION _5 = class_name
    {                                              ( TParamConstraint (Name _2, _3, HintQuestion (_4, _5)) )}
| _1 = variance_opt _2 = ident _3 = T_SUPER _4 = class_name
    {                                          ( TParamConstraint (Name _2, _3, _4) )}

variance_opt:
  
    {                ( None)}
| _1 = TMINUS
    {                ( Some _1 )}
| _1 = TPLUS
    {                ( Some _1 )}

type_php:
  _1 = primary_type_php
    {                    ( _1 )}
| _1 = type_php _2 = TCOLCOL _3 = primary_type_php
    {                                  ( HintTypeConst (_1, _2, _3) )}

primary_type_php:
  _1 = class_name
    {              ( _1 )}
| _1 = T_SELF
    {              ( Hint (Self _1, None) )}
| _1 = T_PARENT
    {              ( Hint (Parent _1, None) )}
| _1 = TQUESTION _2 = type_php
    {     ( HintQuestion (_1, _2)  )}
| _1 = TOPAR _2 = non_empty_type_php_list _3 = TCPAR
    {     ( HintTuple (_1, _2, _3) )}
| _1 = TOPAR _2 = T_FUNCTION _3 = TOPAR _4 = type_php_or_dots_list _5 = TCPAR _6 = return_type _7 = TCPAR
    {     ( HintCallback (_1, (_2, (_3, _4, _5), Some _6), _7))}

type_php_or_dots_list:
  
    {                                 ( [] )}
| _1 = non_empty_type_php_or_dots_list
    {                                     ( _1 )}
| _1 = non_empty_type_php_or_dots_list _2 = TCOMMA
    {                                       ( _1 @ [Right3 _2] )}

type_php_or_dots:
  _1 = type_php
    {            ( Left3 _1 )}
| _1 = T_ELLIPSIS
    {            ( Middle3 _1 )}

type_arguments:
  
    {                          ( None )}
| _1 = TSMALLER _2 = type_arg_list _3 = TGREATER
    {                          ( Some (_1, _2, _3) )}

type_arg_list:
  _1 = type_php
    {                                   ( [Left _1])}
| _1 = type_php _2 = TCOMMA _3 = type_arg_list
    {                                   ( (Left _1)::(Right _2):: _3 )}

return_type:
  _1 = TCOLON _2 = type_php
    {                                          ( _1, _2 )}

attributes:
  _1 = T_SL _1_inlined1 = list_sep_attribute_TCOMMA_ _3 = T_SR
    {let _2 =
  let _1 = _1_inlined1 in
                             ( _1 )
in
                                       ( (_1, _2, _3) )}

attribute:
  _1 = ident
    {                                          ( Attribute _1 )}
| _1 = ident _2 = TOPAR _3 = attribute_argument_list _4 = TCPAR
    {                                          ( AttributeWithArgs (_1,(_2,_3,_4)) )}

attribute_argument:
  _1 = static_scalar
    {                                  ( _1 )}

expr:
  _1 = simple_expr
    {               ( _1 )}
| _1 = simple_expr _2 = TEQ _3 = expr
    {                        ( Assign(_1,_2, _3) )}
| _1 = simple_expr _2 = TEQ _3 = TAND _4 = expr
    {                               ( AssignRef(_1,_2,_3, _4) )}
| _1 = simple_expr _2 = T_PLUS_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Plus,_2),_3) )}
| _1 = simple_expr _2 = T_MINUS_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Minus,_2),_3) )}
| _1 = simple_expr _2 = T_MUL_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Mul,_2),_3) )}
| _1 = simple_expr _2 = T_DIV_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Div,_2),_3) )}
| _1 = simple_expr _2 = T_MOD_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Mod,_2),_3) )}
| _1 = simple_expr _2 = T_AND_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith And,_2),_3) )}
| _1 = simple_expr _2 = T_OR_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Or,_2),_3) )}
| _1 = simple_expr _2 = T_XOR_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Xor,_2),_3) )}
| _1 = simple_expr _2 = T_SL_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith DecLeft,_2),_3) )}
| _1 = simple_expr _2 = T_SR_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith DecRight,_2),_3) )}
| _1 = simple_expr _2 = T_CONCAT_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignConcat,_2),_3) )}
| _1 = expr _2 = T_INC
    {              ( Postfix(_1, (AST_generic_.Incr, _2)) )}
| _1 = expr _2 = T_DEC
    {              ( Postfix(_1, (AST_generic_.Decr, _2)) )}
| _1 = T_INC _2 = expr
    {              ( Infix((AST_generic_.Incr, _1), _2) )}
| _1 = T_DEC _2 = expr
    {              ( Infix((AST_generic_.Decr, _1), _2) )}
| _1 = expr _2 = T_BOOLEAN_OR _3 = expr
    {                            ( Binary(_1,(Logical OrBool ,_2),_3) )}
| _1 = expr _2 = T_BOOLEAN_AND _3 = expr
    {                            ( Binary(_1,(Logical AndBool,_2),_3) )}
| _1 = expr _2 = T_LOGICAL_OR _3 = expr
    {                            ( Binary(_1,(Logical OrLog,  _2),_3) )}
| _1 = expr _2 = T_LOGICAL_AND _3 = expr
    {                            ( Binary(_1,(Logical AndLog, _2),_3) )}
| _1 = expr _2 = T_LOGICAL_XOR _3 = expr
    {                            ( Binary(_1,(Logical XorLog, _2),_3) )}
| _1 = expr _2 = TPLUS _3 = expr
    {                    ( Binary(_1,(Arith Plus ,_2),_3) )}
| _1 = expr _2 = TMINUS _3 = expr
    {                        ( Binary(_1,(Arith Minus,_2),_3) )}
| _1 = expr _2 = TMUL _3 = expr
    {                    ( Binary(_1,(Arith Mul,_2),_3) )}
| _1 = expr _2 = TDIV _3 = expr
    {                    ( Binary(_1,(Arith Div,_2),_3) )}
| _1 = expr _2 = TMOD _3 = expr
    {                    ( Binary(_1,(Arith Mod,_2),_3) )}
| _1 = expr _2 = TPOW _3 = expr
    {                    ( Binary(_1,(Arith Pow,_2),_3) )}
| _1 = expr _2 = TAND _3 = expr
    {                    ( Binary(_1,(Arith And,_2),_3) )}
| _1 = expr _2 = TOR _3 = expr
    {                    ( Binary(_1,(Arith Or,_2),_3) )}
| _1 = expr _2 = TXOR _3 = expr
    {                    ( Binary(_1,(Arith Xor,_2),_3) )}
| _1 = expr _2 = T_SL _3 = expr
    {                    ( Binary(_1,(Arith DecLeft,_2),_3) )}
| _1 = expr _2 = T_SR _3 = expr
    {                    ( Binary(_1,(Arith DecRight,_2),_3) )}
| _1 = expr _2 = TDOT _3 = expr
    {                    ( Binary(_1,(BinaryConcat,_2),_3) )}
| _1 = expr _2 = T_IS_IDENTICAL _3 = expr
    {                                   ( Binary(_1,(Logical Identical,_2),_3) )}
| _1 = expr _2 = T_IS_NOT_IDENTICAL _3 = expr
    {                                   ( Binary(_1,(Logical NotIdentical,_2),_3) )}
| _1 = expr _2 = T_IS_EQUAL _3 = expr
    {                                   ( Binary(_1,(Logical Eq,_2),_3) )}
| _1 = expr _2 = T_IS_NOT_EQUAL _3 = expr
    {                                   ( Binary(_1,(Logical NotEq,_2),_3) )}
| _1 = expr _2 = TSMALLER _3 = expr
    {                              ( Binary(_1,(Logical Inf,_2),_3) )}
| _1 = expr _2 = T_IS_SMALLER_OR_EQUAL _3 = expr
    {                                   ( Binary(_1,(Logical InfEq,_2),_3) )}
| _1 = expr _2 = TGREATER _3 = expr
    {                              ( Binary(_1,(Logical Sup,_2),_3) )}
| _1 = expr _2 = T_IS_GREATER_OR_EQUAL _3 = expr
    {                                   ( Binary(_1,(Logical SupEq,_2),_3) )}
| _1 = expr _2 = T_ROCKET _3 = expr
    {                                   ( Binary(_1,(CombinedComparison,_2),_3) )}
| _1 = TPLUS _2 = expr %prec T_INC
    {                                        ( Unary((UnPlus,_1),_2) )}
| _1 = TMINUS _2 = expr %prec T_INC
    {                                        ( Unary((UnMinus,_1),_2) )}
| _1 = TBANG _2 = expr
    {                                        ( Unary((UnBang,_1),_2) )}
| _1 = TTILDE _2 = expr
    {                                        ( Unary((UnTilde,_1),_2) )}
| _1 = expr _2 = TQUESTION _3 = expr _4 = TCOLON _5 = expr
    {                             ( CondExpr(_1,_2,Some _3,_4,_5) )}
| _1 = expr _2 = TQUESTION _3 = TCOLON _4 = expr
    {                         ( CondExpr(_1,_2,None,_3,_4) )}
| _1 = expr _2 = TQUESTION _3 = TQUESTION _4 = expr
    {                     ( CondExpr(_1,_2,None,_3,_4) )}
| _1 = expr _2 = T_INSTANCEOF _3 = expr
    {                           ( InstanceOf(_1, _2, _3) )}
| _1 = T_BOOL_CAST _2 = expr
    {                        ( Cast((BoolTy,_1),_2) )}
| _1 = T_INT_CAST _2 = expr
    {                        ( Cast((IntTy,_1),_2) )}
| _1 = T_DOUBLE_CAST _2 = expr
    {                        ( Cast((DoubleTy,_1),_2) )}
| _1 = T_STRING_CAST _2 = expr
    {                        ( Cast((StringTy,_1),_2) )}
| _1 = T_ARRAY_CAST _2 = expr
    {                        ( Cast((ArrayTy,_1),_2) )}
| _1 = T_OBJECT_CAST _2 = expr
    {                        ( Cast((ObjectTy,_1),_2) )}
| _1 = T_UNSET_CAST _2 = expr
    {                        ( CastUnset(_1,_2) )}
| _1 = T_EXIT _2 = exit_expr
    {                    ( Exit(_1,_2) )}
| _1 = T__AT _2 = expr
    {                      ( At(_1,_2) )}
| _1 = T_PRINT _2 = expr
    {                 ( Print(_1,_2) )}
| _1 = T_CLONE _2 = expr
    {                ( Clone(_1,_2) )}
| _2 = T_FUNCTION _3 = is_reference _4 = TOPAR _5 = parameter_list _6 = TCPAR _7 = lexical_vars _8 = option_return_type_ _9 = TOBRACE _10 = list_inner_statement_ _11 = TCBRACE
    {let _1 =              ( [] ) in
   ( validate_parameter_list _5;
     let params = (_4, _5, _6) in
       let body = (_9, _10, _11) in
       Lambda (_7, { f_tok = _2;f_ref = _3;f_params = params; f_body = body;
                     f_tparams = None;
                     f_name = Name("__lambda__", _2);
                     f_return_type = _8; f_type = FunctionLambda;
                     f_modifiers = _1;
                     f_attrs = None;
       })
   )}
| _1 = T_ASYNC _2 = T_FUNCTION _3 = is_reference _4 = TOPAR _5 = parameter_list _6 = TCPAR _7 = lexical_vars _8 = option_return_type_ _9 = TOBRACE _10 = list_inner_statement_ _11 = TCBRACE
    {let _1 =            ( [Async,(_1)] ) in
   ( validate_parameter_list _5;
     let params = (_4, _5, _6) in
       let body = (_9, _10, _11) in
       Lambda (_7, { f_tok = _2;f_ref = _3;f_params = params; f_body = body;
                     f_tparams = None;
                     f_name = Name("__lambda__", _2);
                     f_return_type = _8; f_type = FunctionLambda;
                     f_modifiers = _1;
                     f_attrs = None;
       })
   )}
| _1 = T_STATIC _2 = T_FUNCTION _3 = is_reference _4 = TOPAR _5 = parameter_list _6 = TCPAR _7 = lexical_vars _8 = option_return_type_ _9 = TOBRACE _10 = list_inner_statement_ _11 = TCBRACE
    {let _1 =             ( [Static,(_1)] ) in
   ( validate_parameter_list _5;
     let params = (_4, _5, _6) in
       let body = (_9, _10, _11) in
       Lambda (_7, { f_tok = _2;f_ref = _3;f_params = params; f_body = body;
                     f_tparams = None;
                     f_name = Name("__lambda__", _2);
                     f_return_type = _8; f_type = FunctionLambda;
                     f_modifiers = _1;
                     f_attrs = None;
       })
   )}
| _1 = lambda_expr
    {               ( _1 )}
| _1 = T_YIELD _2 = expr
    {                             ( Yield (_1, ArrayExpr _2) )}
| _1 = T_YIELD _2 = expr _3 = T_ARROW _4 = expr
    {                          ( Yield (_1, ArrayArrowExpr (_2, _3, _4)) )}
| _1 = T_YIELD _2 = T_FROM _3 = expr
    {                                    ( Yield (_1, ArrayExpr _3) )}
| _1 = T_YIELD _2 = T_BREAK
    {                   ( YieldBreak (_1, _2) )}
| _1 = T_AWAIT _2 = expr
    {                ( Await (_1, _2) )}
| _1 = T_INCLUDE _1_inlined1 = expr
    {let _2 =
  let _1 = _1_inlined1 in
           ( _1 )
in
                                   ( Include(_1,_2) )}
| _1 = T_INCLUDE _1_inlined1 = T_ELLIPSIS
    {let _2 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
                                   ( Include(_1,_2) )}
| _1 = T_INCLUDE_ONCE _1_inlined1 = expr
    {let _2 =
  let _1 = _1_inlined1 in
           ( _1 )
in
                                   ( IncludeOnce(_1,_2) )}
| _1 = T_INCLUDE_ONCE _1_inlined1 = T_ELLIPSIS
    {let _2 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
                                   ( IncludeOnce(_1,_2) )}
| _1 = T_REQUIRE _1_inlined1 = expr
    {let _2 =
  let _1 = _1_inlined1 in
           ( _1 )
in
                                   ( Require(_1,_2) )}
| _1 = T_REQUIRE _1_inlined1 = T_ELLIPSIS
    {let _2 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
                                   ( Require(_1,_2) )}
| _1 = T_REQUIRE_ONCE _1_inlined1 = expr
    {let _2 =
  let _1 = _1_inlined1 in
           ( _1 )
in
                                   ( RequireOnce(_1,_2) )}
| _1 = T_REQUIRE_ONCE _1_inlined1 = T_ELLIPSIS
    {let _2 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
                                   ( RequireOnce(_1,_2) )}
| _1 = T_EMPTY _2 = TOPAR _1_inlined1 = expr _4 = TCPAR
    {let _3 =
  let _1 = _1_inlined1 in
           ( _1 )
in
                                       ( Empty(_1,(_2,_3,_4)) )}
| _1 = T_EMPTY _2 = TOPAR _1_inlined1 = T_ELLIPSIS _4 = TCPAR
    {let _3 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
                                       ( Empty(_1,(_2,_3,_4)) )}
| _1 = T_EVAL _2 = TOPAR _1_inlined1 = expr _4 = TCPAR
    {let _3 =
  let _1 = _1_inlined1 in
           ( _1 )
in
                                       ( Eval(_1,(_2,_3,_4)) )}
| _1 = T_EVAL _2 = TOPAR _1_inlined1 = T_ELLIPSIS _4 = TCPAR
    {let _3 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
                                       ( Eval(_1,(_2,_3,_4)) )}
| _1 = T_ISSET _2 = TOPAR _1_inlined1 = list_sep_expr_or_dots_TCOMMA_ _4 = TCPAR
    {let _3 =
  let _1 = _1_inlined1 in
                             ( _1 )
in
                                       ( Isset(_1, (_2, _3, _4)) )}
| _1 = T_LIST _2 = TOPAR _3 = assignment_list _4 = TCPAR _5 = TEQ _6 = expr
    {     ( AssignList(_1,(_2,_3,_4),_5,_6) )}

simple_expr:
  _1 = new_expr
    {            ( _1 )}
| _1 = call_expr
    {             ( _1 )}

new_expr:
  _1 = member_expr
    {               ( _1 )}
| _1 = T_NEW _2 = member_expr _3 = option_arguments_
    {                                ( New (_1, _2, _3) )}
| _1 = T_NEW _2 = T_CLASS _3 = option_arguments_ _4 = extends_from _5 = implements_list _6 = TOBRACE _7 = list_member_declaration_ _8 = TCBRACE
    {     ( let class_ =
         { c_type = ClassRegular _2; c_name = Name ("!ANON!", _2);
           c_extends = _4; c_tparams = None;
           c_implements = _5; c_body = _6, _7, _8;
           c_attrs = None; c_enum_type = None; }
       in
       NewAnonClass (_1, _3, class_)
     )}

call_expr:
  _1 = member_expr _2 = arguments
    {                         ( Call (_1, _2) )}
| _1 = call_expr _2 = arguments
    {                       ( Call (_1, _2) )}
| _1 = call_expr _2 = TOBRA _3 = dim_offset _4 = TCBRA
    {                                ( ArrayGet(_1, (_2, _3, _4)) )}
| _1 = call_expr _2 = TOBRACE _3 = expr _4 = TCBRACE
    {                            ( HashGet(_1, (_2, _3, _4)) )}
| _1 = call_expr _2 = T_OBJECT_OPERATOR _3 = primary_expr
    {                               ( ObjGet(_1, _2, _3) )}
| _1 = call_expr _2 = T_OBJECT_OPERATOR _3 = TOBRACE _4 = expr _5 = TCBRACE
    {                               ( ObjGet(_1,_2, (BraceIdent (_3, _4, _5))) )}

member_expr:
  _1 = primary_expr
    {                ( _1 )}
| _1 = member_expr _2 = TOBRA _3 = dim_offset _4 = TCBRA
    {                                  ( ArrayGet(_1, (_2, _3, _4)) )}
| _1 = member_expr _2 = TOBRACE _3 = expr _4 = TCBRACE
    {                              ( HashGet(_1, (_2, _3, _4)) )}
| _1 = member_expr _2 = T_OBJECT_OPERATOR _3 = primary_expr
    {                                 (  ObjGet(_1, _2, _3) )}
| _1 = member_expr _2 = T_OBJECT_OPERATOR _3 = TOBRACE _4 = expr _5 = TCBRACE
    {     ( ObjGet(_1,_2, (BraceIdent (_3, _4, _5))) )}
| _1 = member_expr _2 = TCOLCOL _3 = primary_expr
    {                                 ( ClassGet(_1, _2, _3) )}
| _1 = member_expr _2 = TCOLCOL _3 = T_CLASS
    {     ( ClassGet(_1, _2, Id (XName [QI (Name("class", _3))])) )}

primary_expr:
  _1 = constant
    {            ( Sc (C _1) )}
| _1 = qualified_class_name
    {                        ( Id _1  )}
| _1 = T_SELF
    {                        ( Id (Self _1) )}
| _1 = T_PARENT
    {                        ( Id (Parent _1) )}
| _1 = T_STATIC
    {                        ( Id (LateStatic _1) )}
| _1 = T_VARIABLE
    {              ( mk_var _1 )}
| _1 = TDOLLARDOLLAR
    {        ( mk_var ("$$", _1) )}
| _1 = TDOLLAR _2 = primary_expr
    {                            ( Deref(_1, _2) )}
| _1 = TDOLLAR _2 = TOBRACE _3 = expr _4 = TCBRACE
    {                    ( Deref(_1, BraceIdent(_2, _3, _4)) )}
| _1 = T_ARRAY _2 = TOPAR _3 = array_pair_list _4 = TCPAR
    {                                      ( ArrayLong(_1,(_2,_3,_4)) )}
| _1 = TOBRA _2 = array_pair_list _3 = TCBRA
    {                                      ( ArrayShort(_1, _2, _3) )}
| _1 = TGUIL _2 = list_encaps_ _3 = TGUIL
    {                                      ( Sc (Guil (_1, _2, _3)) )}
| _1 = TBACKQUOTE _2 = list_encaps_ _3 = TBACKQUOTE
    {                                      ( BackQuote(_1,_2,_3) )}
| _1 = T_START_HEREDOC _2 = list_encaps_ _3 = T_END_HEREDOC
    {                                          ( Sc (HereDoc (_1, _2, _3)) )}
| _1 = TOPAR _1_inlined1 = expr _3 = TCPAR
    {let _2 =
  let _1 = _1_inlined1 in
           ( _1 )
in
                        ( ParenExpr(_1,_2,_3) )}
| _1 = TOPAR _1_inlined1 = T_ELLIPSIS _3 = TCPAR
    {let _2 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
                        ( ParenExpr(_1,_2,_3) )}
| _1 = LDots _2 = expr _3 = RDots
    {                      ( Flag_parsing.sgrep_guard (DeepEllipsis (_1, _2, _3)) )}

constant:
  _1 = T_LNUMBER
    {                        ( Int(_1) )}
| _1 = T_DNUMBER
    {                        ( Double(_1) )}
| _1 = T_CONSTANT_ENCAPSED_STRING
    {                                ( String(_1) )}
| _1 = T_LINE
    {          ( PreProcess(Line, _1) )}
| _1 = T_FILE
    {          ( PreProcess(File, _1) )}
| _1 = T_DIR
    {                                           ( PreProcess(Dir, _1) )}
| _1 = T_CLASS_C
    {             ( PreProcess(ClassC, _1) )}
| _1 = T_TRAIT_C
    {                                                    ( PreProcess(TraitC, _1))}
| _1 = T_FUNC_C
    {            ( PreProcess(FunctionC, _1) )}
| _1 = T_METHOD_C
    {                                                     ( PreProcess(MethodC, _1))}
| _1 = T_NAMESPACE_C
    {                 ( PreProcess(NamespaceC, _1) )}

static_scalar:
  _1 = expr
    {                    ( _1 )}

assignment_list_element:
  _1 = expr
    {                    ( ListVar _1 )}
| _1 = T_LIST _2 = TOPAR _3 = assignment_list _4 = TCPAR
    {                                    ( ListList (_1, (_2, _3, _4)) )}
| 
    {                        ( ListEmpty )}

array_pair_list:
  _1 = array_pair_list_rev
    {                                     ( List.rev _1 )}

array_pair:
  _1 = expr
    {let _1 =          ( _1 ) in
                                   ( (ArrayExpr _1) )}
| _1 = T_ELLIPSIS
    {let _1 =          ( Flag_parsing.sgrep_guard (Ellipsis _1) ) in
                                   ( (ArrayExpr _1) )}
| _1 = TAND _2 = expr
    {                           ( (ArrayRef (_1,_2)) )}
| _1 = expr _2 = T_ARROW _3 = expr
    {                           ( (ArrayArrowExpr(_1,_2,_3)) )}
| _1 = expr _2 = T_ARROW _3 = TAND _4 = expr
    {                       ( (ArrayArrowRef(_1,_2,_3,_4)) )}

arguments:
  _1 = TOPAR _2 = function_call_argument_list _3 = TCPAR
    {                                               ( (_1, _2, _3) )}

function_call_argument:
  _1 = expr
    {let _1 =          ( _1 ) in
                            ( (Arg (_1)) )}
| _1 = T_ELLIPSIS
    {let _1 =          ( Flag_parsing.sgrep_guard (Ellipsis _1) ) in
                            ( (Arg (_1)) )}
| _1 = TAND _2 = expr
    {                    ( (ArgRef(_1, _2)) )}
| _1 = T_ELLIPSIS _2 = expr
    {                    ( (ArgUnpack(_1, _2)) )}

encaps:
  _1 = T_ENCAPSED_AND_WHITESPACE
    {     ( EncapsString _1 )}
| _1 = T_VARIABLE
    {     ( EncapsVar (mk_var _1)  )}
| _1 = T_VARIABLE _2 = TOBRA _3 = encaps_var_offset _4 = TCBRA
    {     ( EncapsVar (ArrayGet (mk_var _1,(_2,Some _3,_4))))}
| _1 = T_VARIABLE _2 = T_OBJECT_OPERATOR _3 = ident_encaps
    {     ( EncapsVar (ObjGet(mk_var _1, _2, Id (XName [QI (Name _3)]))))}
| _1 = T_DOLLAR_OPEN_CURLY_BRACES _2 = T_STRING_VARNAME _3 = TCBRACE
    {     (
       (* this is not really a T_VARIABLE, bit it's still conceptually
        * a variable so we build it almost like above
        *)
       let var = mk_var _2 in
       EncapsDollarCurly (_1, var, _3)
     )}
| _1 = T_DOLLAR_OPEN_CURLY_BRACES _2 = T_STRING_VARNAME _3 = TOBRA _4 = expr _5 = TCBRA _6 = TCBRACE
    {     (
       let lval = ArrayGet(mk_var _2, (_3, Some _4, _5))
       in
       EncapsDollarCurly (_1,  lval, _6)
     )}
| _1 = T_CURLY_OPEN _2 = expr _3 = TCBRACE
    {                                   ( EncapsCurly(_1, _2, _3) )}
| _1 = T_DOLLAR_OPEN_CURLY_BRACES _2 = expr _3 = TCBRACE
    {                                       ( EncapsExpr (_1, _2, _3) )}

encaps_var_offset:
  _1 = ident_encaps
    {                 (
     (* It looks like an ident but as we are in encaps_var_offset,
      * PHP allows array access inside strings to omit the quote
      * around fieldname, so it's actually really a Constant (String)
      * rather than an ident, as we usually do for other T_IDENT
      * cases.
      *)
     let cst = String _1 in (* will not have enclosing "'"  as usual *)
     Sc (C cst)
   )}
| _1 = T_VARIABLE
    {                ( mk_var _1 )}
| _1 = T_NUM_STRING
    {                (
     (* the original php lexer does not return some numbers for
      * offset of array access inside strings. Not sure why ...
      *)
     let cst = String _1 in (* will not have enclosing "'"  as usual *)
     Sc (C cst)
   )}

lambda_expr:
  _1 = T_VARIABLE _2 = lambda_body
    {     (
       let sl_tok, sl_body = _2 in
       let sl_params = SLSingleParam (mk_param _1) in
       ShortLambda { sl_params; sl_tok; sl_body; sl_modifiers = [] }
     )}
| _1 = T_ASYNC _2 = T_VARIABLE _3 = lambda_body
    {     (
       let sl_tok, sl_body = _3 in
       let sl_params = SLSingleParam (mk_param _2) in
       ShortLambda { sl_params; sl_tok; sl_body; sl_modifiers = [Async,(_1)] }
     )}
| _1 = T_LAMBDA_OPAR _2 = parameter_list _3 = T_LAMBDA_CPAR _4 = option_return_type_ _5 = lambda_body
    {     (
       validate_parameter_list _2;
       let sl_tok, sl_body = _5 in
       let sl_params = SLParams (_1, _2, _3) in
       ShortLambda { sl_params; sl_tok; sl_body; sl_modifiers = []; }
     )}
| _1 = T_ASYNC _2 = T_LAMBDA_OPAR _3 = parameter_list _4 = T_LAMBDA_CPAR _5 = option_return_type_ _6 = lambda_body
    {     (
       validate_parameter_list _3;
       let sl_tok, sl_body = _6 in
       let sl_params = SLParams (_2, _3, _4) in
       ShortLambda { sl_params; sl_tok; sl_body; sl_modifiers = [Async,(_1)]; }
     )}
| _1 = T_ASYNC _2 = TOBRACE _3 = list_inner_statement_ _4 = TCBRACE
    {     (
       let sl_body = SLBody (_2, _3, _4) in
       ShortLambda { sl_params = SLParamsOmitted;
                     sl_tok = None;
                     sl_body;
                     sl_modifiers = [Async,(_1)];
                   }
     )}

lambda_body:
  _1 = T_DOUBLE_ARROW _2 = TOBRACE _3 = list_inner_statement_ _4 = TCBRACE
    {                                  ( (Some _1, SLBody (_2, _3, _4)) )}
| _1 = T_DOUBLE_ARROW _2 = expr
    {              ( (Some _1, SLExpr _2) )}

dim_offset:
  _1 = option_expr_
    {         ( _1 )}
| _1 = T_ELLIPSIS
    {         ( Some (Ellipsis _1) )}

exit_expr:
  
    {                ( None )}
| _1 = TOPAR _2 = TCPAR
    {                ( Some(_1, None, _2) )}
| _1 = TOPAR _1_inlined1 = expr _3 = TCPAR
    {let _2 =
  let _1 = _1_inlined1 in
           ( _1 )
in
                        ( Some(_1, Some _2, _3) )}
| _1 = TOPAR _1_inlined1 = T_ELLIPSIS _3 = TCPAR
    {let _2 =
  let _1 = _1_inlined1 in
           ( Flag_parsing.sgrep_guard (Ellipsis _1) )
in
                        ( Some(_1, Some _2, _3) )}

ident:
  _1 = T_IDENT
    {           ( _1 )}
| _1 = T_ENUM
    {               ( PI.str_of_info _1, _1 )}
| _1 = T_TYPE
    {               ( PI.str_of_info _1, _1 )}
| _1 = T_SUPER
    {               ( PI.str_of_info _1, _1 )}
| _1 = T_METAVAR
    {               ( _1 )}

ident_encaps:
  _1 = T_IDENT
    {           ( _1 )}

ident_in_name:
  _1 = ident
    {         ( _1 )}
| _1 = T_INSTANCEOF
    {                ( PI.str_of_info _1, _1 )}

ident_constant_name:
  _1 = ident
    {         ( _1 )}
| _1 = T_LIST
    {                 ( PI.str_of_info _1, _1 )}
| _1 = T_LOGICAL_AND
    {                 ( PI.str_of_info _1, _1 )}
| _1 = T_NEW
    {                 ( PI.str_of_info _1, _1 )}
| _1 = T_FROM
    {              ( PI.str_of_info _1, _1 )}

ident_class_name:
  _1 = ident
    {                 ( Name _1 )}

ident_method_name:
  _1 = ident
    {         ( _1 )}
| _1 = T_PARENT
    {            ( "parent", _1 )}
| _1 = T_SELF
    {            ( "self", _1 )}
| _1 = T_ASYNC
    {            ( "async", _1 )}
| _1 = T_INCLUDE
    {             ( "include", _1 )}
| _1 = T_PUBLIC
    {            ( "public", _1 )}
| _1 = T_DEFAULT
    {             ( "default", _1 )}
| _1 = T_INSTANCEOF
    {                ( "instanceof", _1 )}
| _1 = T_FROM
    {              ( PI.str_of_info _1, _1 )}

namespace_declaration:
  _1 = T_NAMESPACE _2 = namespace_name _3 = TSEMICOLON
    {     ( NamespaceDef (_1, _2, _3) )}
| _1 = T_NAMESPACE _2 = namespace_name _3 = TOBRACE _4 = list_top_statement_ _5 = TCBRACE
    {     ( NamespaceBracketDef (_1, Some _2, (_3, List.flatten _4, _5)) )}
| _1 = T_NAMESPACE _2 = TOBRACE _3 = list_top_statement_ _4 = TCBRACE
    {     ( NamespaceBracketDef (_1, None, (_2, List.flatten _3, _4)) )}

namespace_use_declaration:
  _1 = T_USE _2 = option_use_keyword_ _1_inlined1 = list_sep_namespace_use_clause_TCOMMA_ _4 = TSEMICOLON
    {let _3 =
  let _1 = _1_inlined1 in
                             ( _1 )
in
   ( [NamespaceUse (_1, _2, _3, _4)] )}
| _1 = T_USE _2 = option_use_keyword_ _3 = option_TANTISLASH_ _4 = namespace_name _5 = TANTISLASH _6 = TOBRACE _1_inlined1 = list_sep2_namespace_use_group_clause_TCOMMA_ _8 = TCBRACE _9 = TSEMICOLON
    {let _7 =
  let _1 = _1_inlined1 in
                               ( _1 )
in
   ( _7 |> List.map (fun (_use_kwd_opt_TODO, name, alias_opt) ->
       let full_name = (qiopt _3 _4) @ name in
       NamespaceUse (_1, _2, [Left (full_name, alias_opt)], _9)
      )
   )}

use_keyword:
  _1 = T_CONST
    {            ( _1 )}
| _1 = T_FUNCTION
    {               ( _1 )}

namespace_name:
  _1 = ident_in_name
    {                                           ( [QI (Name _1)] )}
| _1 = namespace_name _2 = TANTISLASH _3 = ident_in_name
    {                                           ( _1 @ [QITok _2; QI (Name _3)] )}

namespace_use_clause:
  _1 = option_TANTISLASH_ _2 = namespace_name _3 = option_namespace_aliasing_clause_
    {    ( (qiopt _1 _2, _3) )}

namespace_use_group_clause:
  _1 = option_use_keyword_ _2 = namespace_name _3 = option_namespace_aliasing_clause_
    { ( _1, _2, _3 )}

namespace_aliasing_clause:
  _1 = T_AS _2 = ident
    {                                      ( _1, Name _2 )}

qualified_name:
  _1 = namespace_name
    {                                         ( XName _1 )}
| _1 = TANTISLASH _2 = namespace_name
    {                                         ( XName (QITok _1::_2) )}
| _1 = T_NAMESPACE _2 = TANTISLASH _3 = namespace_name
    {     ( XName (QI (Name ("namespace", _1))::QITok _2::_3) )}

qualified_class_name:
  _1 = qualified_name
    {                                     ( _1 )}

qualified_class_name_or_array:
  _1 = qualified_class_name
    {                        ( _1 )}
| _1 = T_ARRAY
    {           ( XName [QI (Name ("array", _1))] )}

qualified_name_for_traits:
  _1 = qualified_class_name
    {                                                ( _1 )}

class_name:
  _1 = qualified_class_name_or_array _2 = type_arguments
    {                                                         ( Hint (_1, _2) )}

class_name_no_array:
  _1 = qualified_class_name _2 = type_arguments
    {                                                         ( Hint (_1, _2) )}

attribute_argument_list:
  
    {             ( [] )}
| _1 = attribute_argument
    {                      ( [Left _1] )}
| _1 = attribute_argument_list _2 = TCOMMA _3 = attribute_argument
    {                                                  ( _1@[Right _2; Left _3])}

non_empty_type_php_or_dots_list:
  _1 = type_php_or_dots
    {                                                        ( [_1] )}
| _1 = non_empty_type_php_or_dots_list _2 = TCOMMA _3 = type_php_or_dots
    {                                                        ( _1 @ [Right3 _2; _3])}

non_empty_type_php_list:
  _1 = list_sep_type_php_TCOMMA_
    {let _1 =                            ( _1 ) in
                   ( _1 )}
| _1 = list_sep_type_php_TCOMMA_ _2 = TCOMMA
    {let _1 =                            ( _1 ) in
                       ( _1 @ [Right _2] )}

class_name_list:
  _1 = list_sep_class_name_no_array_TCOMMA_
    {let _1 =                            ( _1 ) in
                                            ( _1 )}

possible_comma:
  
    {             ( [] )}
| _1 = TCOMMA
    {              ( [Right _1] )}

function_call_argument_list:
  
    {                                          ( [] )}
| _1 = list_sep_function_call_argument_TCOMMA_
    {let _1 =
  let _1 =                            ( _1 ) in
                                                                       ( _1 )
in
                                              ( _1 )}
| _1 = list_sep_function_call_argument_TCOMMA_ _2 = TCOMMA
    {let _1 =
  let _1 =                            ( _1 ) in
                                                                       ( _1 )
in
                                              ( _1 @ [Right _2] )}

assignment_list:
  _1 = list_sep_assignment_list_element_TCOMMA_
    {let _1 =                            ( _1 ) in
                                                ( _1 )}

non_empty_array_pair_list_rev:
  _1 = array_pair
    {              ( [Left _1] )}
| _1 = non_empty_array_pair_list_rev _2 = TCOMMA _3 = array_pair
    {                                                 ( Left _3::Right _2::_1 )}

array_pair_list_rev:
  
    {             ( [] )}
| _1 = non_empty_array_pair_list_rev _2 = possible_comma
    {                                                ( _2@_1 )}

%%
