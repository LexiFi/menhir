State 0:
## Known stack suffix:
##
## LR(1) items:
main' -> . main [ # ]
## Transitions:
-- On YIELD shift to state 1
-- On WITH shift to state 293
-- On WHILE shift to state 328
-- On TRY shift to state 443
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 588
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On IF shift to state 475
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FOR shift to state 488
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On DEF shift to state 497
-- On CONTINUE shift to state 377
-- On CLASS shift to state 529
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On AT shift to state 538
-- On ASYNC shift to state 549
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On with_stmt shift to state 553
-- On while_stmt shift to state 554
-- On tuple(test_or_star_expr) shift to state 385
-- On try_stmt shift to state 555
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On string shift to state 34
-- On stmt shift to state 589
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 557
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On nonempty_list(decorator) shift to state 558
-- On nl_or_stmt shift to state 590
-- On main shift to state 592
-- On list(nl_or_stmt) shift to state 593
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On if_stmt shift to state 570
-- On global_stmt shift to state 433
-- On funcdef shift to state 571
-- On for_stmt shift to state 572
-- On flow_stmt shift to state 434
-- On file_input shift to state 594
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On decorator shift to state 573
-- On decorated shift to state 575
-- On continue_stmt shift to state 438
-- On compound_stmt shift to state 576
-- On comparison shift to state 112
-- On classdef shift to state 577
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On async_stmt shift to state 578
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On INDENT EOF
--   reduce production list(nl_or_stmt) ->

State 1:
## Known stack suffix:
## YIELD
## LR(1) items:
yield_expr -> YIELD . [ SEMICOL RPAREN NEWLINE EQ ]
yield_expr -> YIELD . FROM test [ SEMICOL RPAREN NEWLINE EQ ]
yield_expr -> YIELD . tuple(test) [ SEMICOL RPAREN NEWLINE EQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FROM shift to state 290
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(test) shift to state 292
-- On test shift to state 200
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On SEMICOL RPAREN NEWLINE EQ
--   reduce production yield_expr -> YIELD

State 2:
## Known stack suffix:
## TRUE
## LR(1) items:
atom -> TRUE . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> TRUE

State 3:
## Known stack suffix:
## SUB
## LR(1) items:
factor -> SUB . factor [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On string shift to state 34
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 289
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
## Reductions:

State 4:
## Known stack suffix:
## STR
## LR(1) items:
string -> STR . [ XOREQ SUBEQ SUB STR SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FSTRING_START FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB STR SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FSTRING_START FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production string -> STR

State 5:
## Known stack suffix:
## NONE
## LR(1) items:
atom -> NONE . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> NONE

State 6:
## Known stack suffix:
## NAME
## LR(1) items:
atom -> NAME . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> NAME

State 7:
## Known stack suffix:
## LPAREN
## LR(1) items:
atom_tuple -> LPAREN . RPAREN [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_tuple -> LPAREN . testlist_comp_or_expr RPAREN [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_tuple -> LPAREN . yield_expr RPAREN [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RPAREN shift to state 8
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On yield_expr shift to state 282
-- On xor_expr shift to state 53
-- On tuple(namedexpr_or_star_expr) shift to state 284
-- On testlist_comp_or_expr shift to state 285
-- On test shift to state 255
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 258
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On namedexpr_test shift to state 259
-- On namedexpr_or_star_expr shift to state 287
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 8:
## Known stack suffix:
## LPAREN RPAREN
## LR(1) items:
atom_tuple -> LPAREN RPAREN . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_tuple -> LPAREN RPAREN

State 9:
## Known stack suffix:
## NOT
## LR(1) items:
not_test -> NOT . not_test [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On not_test shift to state 281
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 10:
## Known stack suffix:
## LONGINT
## LR(1) items:
atom -> LONGINT . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> LONGINT

State 11:
## Known stack suffix:
## LDots
## LR(1) items:
atom -> LDots . test RDots [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 279
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 12:
## Known stack suffix:
## LBRACK
## LR(1) items:
atom_list -> LBRACK . RBRACK [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_list -> LBRACK . testlist_comp RBRACK [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RBRACK shift to state 13
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(namedexpr_or_star_expr) shift to state 252
-- On testlist_comp shift to state 253
-- On test shift to state 255
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 258
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On namedexpr_test shift to state 259
-- On namedexpr_or_star_expr shift to state 260
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 13:
## Known stack suffix:
## LBRACK RBRACK
## LR(1) items:
atom_list -> LBRACK RBRACK . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_list -> LBRACK RBRACK

State 14:
## Known stack suffix:
## MULT
## LR(1) items:
star_expr -> MULT . expr [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ IN FOR FDIVEQ EQ DIVEQ COMMA COLON ASYNC ANDEQ ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On expr shift to state 251
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 15:
## Known stack suffix:
## LBRACE
## LR(1) items:
atom_dict -> LBRACE . RBRACE [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_dict -> LBRACE . dictorsetmaker RBRACE [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RBRACE shift to state 16
-- On POW shift to state 17
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 238
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 241
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On list_sep_term(dictorset_elem,COMMA) shift to state 242
-- On list_comma(dictorset_elem) shift to state 243
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On dictorsetmaker shift to state 244
-- On dictorset_elem shift to state 246
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 16:
## Known stack suffix:
## LBRACE RBRACE
## LR(1) items:
atom_dict -> LBRACE RBRACE . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_dict -> LBRACE RBRACE

State 17:
## Known stack suffix:
## POW
## LR(1) items:
dictorset_elem -> POW . expr [ RBRACE FOR COMMA ASYNC ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On expr shift to state 237
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 18:
## Known stack suffix:
## INT
## LR(1) items:
atom -> INT . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> INT

State 19:
## Known stack suffix:
## IMAG
## LR(1) items:
atom -> IMAG . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> IMAG

State 20:
## Known stack suffix:
## FSTRING_START
## LR(1) items:
string -> FSTRING_START . list(interpolated) FSTRING_END [ XOREQ SUBEQ SUB STR SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FSTRING_START FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On FSTRING_STRING shift to state 21
-- On FSTRING_LBRACE shift to state 22
-- On list(interpolated) shift to state 233
-- On interpolated shift to state 235
## Reductions:
-- On FSTRING_END
--   reduce production list(interpolated) ->

State 21:
## Known stack suffix:
## FSTRING_STRING
## LR(1) items:
interpolated -> FSTRING_STRING . [ FSTRING_STRING FSTRING_LBRACE FSTRING_END ]
## Transitions:
## Reductions:
-- On FSTRING_STRING FSTRING_LBRACE FSTRING_END
--   reduce production interpolated -> FSTRING_STRING

State 22:
## Known stack suffix:
## FSTRING_LBRACE
## LR(1) items:
interpolated -> FSTRING_LBRACE . interpolant fstring_print_spec RBRACE [ FSTRING_STRING FSTRING_LBRACE FSTRING_END ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(test) shift to state 199
-- On test shift to state 200
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On interpolant shift to state 203
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 23:
## Known stack suffix:
## LAMBDA
## LR(1) items:
lambdadef -> LAMBDA . varargslist COLON test [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On POW shift to state 24
-- On NAME shift to state 26
-- On MULT shift to state 147
-- On LPAREN shift to state 149
-- On DIV shift to state 156
-- On varargslist shift to state 196
-- On parameter shift to state 162
-- On fpdef shift to state 165
## Reductions:
-- On COLON
--   reduce production varargslist ->

State 24:
## Known stack suffix:
## POW
## LR(1) items:
parameter -> POW . NAME [ COMMA COLON ]
## Transitions:
-- On NAME shift to state 25
## Reductions:

State 25:
## Known stack suffix:
## POW NAME
## LR(1) items:
parameter -> POW NAME . [ COMMA COLON ]
## Transitions:
## Reductions:
-- On COMMA COLON
--   reduce production parameter -> POW NAME

State 26:
## Known stack suffix:
## NAME
## LR(1) items:
fpdef -> NAME . [ COMMA COLON ]
parameter -> NAME . EQ test [ COMMA COLON ]
## Transitions:
-- On EQ shift to state 27
## Reductions:
-- On COMMA COLON
--   reduce production fpdef -> NAME

State 27:
## Known stack suffix:
## NAME EQ
## LR(1) items:
parameter -> NAME EQ . test [ COMMA COLON ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 195
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 28:
## Known stack suffix:
## FLOAT
## LR(1) items:
atom -> FLOAT . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> FLOAT

State 29:
## Known stack suffix:
## FALSE
## LR(1) items:
atom -> FALSE . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> FALSE

State 30:
## Known stack suffix:
## ELLIPSES
## LR(1) items:
atom -> ELLIPSES . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> ELLIPSES

State 31:
## Known stack suffix:
## BITNOT
## LR(1) items:
factor -> BITNOT . factor [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On string shift to state 34
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 194
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
## Reductions:

State 32:
## Known stack suffix:
## BACKQUOTE
## LR(1) items:
atom_repr -> BACKQUOTE . testlist1 BACKQUOTE [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On testlist1 shift to state 189
-- On test shift to state 191
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 33:
## Known stack suffix:
## AWAIT
## LR(1) items:
atom_expr -> AWAIT . atom_and_trailers [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BACKQUOTE shift to state 32
-- On string shift to state 34
-- On nonempty_list(string) shift to state 36
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 41
-- On atom shift to state 66
## Reductions:

State 34:
## Known stack suffix:
## string
## LR(1) items:
nonempty_list(string) -> string . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
nonempty_list(string) -> string . nonempty_list(string) [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On STR shift to state 4
-- On FSTRING_START shift to state 20
-- On string shift to state 34
-- On nonempty_list(string) shift to state 35
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production nonempty_list(string) -> string

State 35:
## Known stack suffix:
## string nonempty_list(string)
## LR(1) items:
nonempty_list(string) -> string nonempty_list(string) . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production nonempty_list(string) -> string nonempty_list(string)

State 36:
## Known stack suffix:
## nonempty_list(string)
## LR(1) items:
atom -> nonempty_list(string) . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> nonempty_list(string)

State 37:
## Known stack suffix:
## atom_tuple
## LR(1) items:
atom -> atom_tuple . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> atom_tuple

State 38:
## Known stack suffix:
## atom_repr
## LR(1) items:
atom -> atom_repr . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> atom_repr

State 39:
## Known stack suffix:
## atom_list
## LR(1) items:
atom -> atom_list . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> atom_list

State 40:
## Known stack suffix:
## atom_dict
## LR(1) items:
atom -> atom_dict . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> atom_dict

State 41:
## Known stack suffix:
## AWAIT atom_and_trailers
## LR(1) items:
atom_and_trailers -> atom_and_trailers . LPAREN RPAREN [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_and_trailers -> atom_and_trailers . LPAREN list_comma(argument) RPAREN [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_and_trailers -> atom_and_trailers . LBRACK list_comma(subscript) RBRACK [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_and_trailers -> atom_and_trailers . DOT NAME [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_expr -> AWAIT atom_and_trailers . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On LPAREN shift to state 42
-- On LBRACK shift to state 52
-- On DOT shift to state 130
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_expr -> AWAIT atom_and_trailers

State 42:
## Known stack suffix:
## atom_and_trailers LPAREN
## LR(1) items:
atom_and_trailers -> atom_and_trailers LPAREN . RPAREN [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_and_trailers -> atom_and_trailers LPAREN . list_comma(argument) RPAREN [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RPAREN shift to state 43
-- On POW shift to state 44
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 133
-- On MULT shift to state 136
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 138
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On list_sep_term(argument,COMMA) shift to state 183
-- On list_comma(argument) shift to state 184
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On argument shift to state 186
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 43:
## Known stack suffix:
## atom_and_trailers LPAREN RPAREN
## LR(1) items:
atom_and_trailers -> atom_and_trailers LPAREN RPAREN . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_and_trailers -> atom_and_trailers LPAREN RPAREN

State 44:
## Known stack suffix:
## POW
## LR(1) items:
argument -> POW . test [ RPAREN COMMA ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 132
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 45:
## Known stack suffix:
## ADD
## LR(1) items:
factor -> ADD . factor [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On string shift to state 34
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 47
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
## Reductions:

State 46:
## Known stack suffix:
## power
## LR(1) items:
factor -> power . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production factor -> power

State 47:
## Known stack suffix:
## ADD factor
## LR(1) items:
factor -> ADD factor . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production factor -> ADD factor

State 48:
## Known stack suffix:
## atom_expr
## LR(1) items:
power -> atom_expr . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
power -> atom_expr . POW factor [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On POW shift to state 49
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production power -> atom_expr

State 49:
## Known stack suffix:
## atom_expr POW
## LR(1) items:
power -> atom_expr POW . factor [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On string shift to state 34
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 50
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
## Reductions:

State 50:
## Known stack suffix:
## atom_expr POW factor
## LR(1) items:
power -> atom_expr POW factor . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production power -> atom_expr POW factor

State 51:
## Known stack suffix:
## atom_and_trailers
## LR(1) items:
atom_and_trailers -> atom_and_trailers . LPAREN RPAREN [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_and_trailers -> atom_and_trailers . LPAREN list_comma(argument) RPAREN [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_and_trailers -> atom_and_trailers . LBRACK list_comma(subscript) RBRACK [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_and_trailers -> atom_and_trailers . DOT NAME [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
atom_expr -> atom_and_trailers . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On LPAREN shift to state 42
-- On LBRACK shift to state 52
-- On DOT shift to state 130
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_expr -> atom_and_trailers

State 52:
## Known stack suffix:
## atom_and_trailers LBRACK
## LR(1) items:
atom_and_trailers -> atom_and_trailers LBRACK . list_comma(subscript) RBRACK [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 78
-- On term shift to state 55
-- On subscript shift to state 79
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On option(test) shift to state 120
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On list_sep_term(subscript,COMMA) shift to state 127
-- On list_comma(subscript) shift to state 128
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On COLON
--   reduce production option(test) ->

State 53:
## Known stack suffix:
## xor_expr
## LR(1) items:
expr -> xor_expr . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
xor_expr -> xor_expr . BITXOR and_expr [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On BITXOR shift to state 54
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production expr -> xor_expr

State 54:
## Known stack suffix:
## xor_expr BITXOR
## LR(1) items:
xor_expr -> xor_expr BITXOR . and_expr [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 77
## Reductions:

State 55:
## Known stack suffix:
## term
## LR(1) items:
arith_expr -> term . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production arith_expr -> term

State 56:
## Known stack suffix:
## shift_expr
## LR(1) items:
and_expr -> shift_expr . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
and_expr -> shift_expr . BITAND and_expr [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
shift_expr -> shift_expr . LSHIFT arith_expr [ XOREQ SUBEQ SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
shift_expr -> shift_expr . RSHIFT arith_expr [ XOREQ SUBEQ SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On RSHIFT shift to state 57
-- On LSHIFT shift to state 72
-- On BITAND shift to state 74
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production and_expr -> shift_expr

State 57:
## Known stack suffix:
## shift_expr RSHIFT
## LR(1) items:
shift_expr -> shift_expr RSHIFT . arith_expr [ XOREQ SUBEQ SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On term shift to state 55
-- On string shift to state 34
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 67
## Reductions:

State 58:
## Known stack suffix:
## factor
## LR(1) items:
term -> factor . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
term -> factor . term_op term [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On MULT shift to state 59
-- On MOD shift to state 60
-- On FDIV shift to state 61
-- On DIV shift to state 62
-- On AT shift to state 63
-- On term_op shift to state 64
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production term -> factor

State 59:
## Known stack suffix:
## MULT
## LR(1) items:
term_op -> MULT . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production term_op -> MULT

State 60:
## Known stack suffix:
## MOD
## LR(1) items:
term_op -> MOD . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production term_op -> MOD

State 61:
## Known stack suffix:
## FDIV
## LR(1) items:
term_op -> FDIV . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production term_op -> FDIV

State 62:
## Known stack suffix:
## DIV
## LR(1) items:
term_op -> DIV . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production term_op -> DIV

State 63:
## Known stack suffix:
## AT
## LR(1) items:
term_op -> AT . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production term_op -> AT

State 64:
## Known stack suffix:
## factor term_op
## LR(1) items:
term -> factor term_op . term [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On term shift to state 65
-- On string shift to state 34
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
## Reductions:

State 65:
## Known stack suffix:
## factor term_op term
## LR(1) items:
term -> factor term_op term . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production term -> factor term_op term

State 66:
## Known stack suffix:
## atom
## LR(1) items:
atom_and_trailers -> atom . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_and_trailers -> atom

State 67:
## Known stack suffix:
## shift_expr RSHIFT arith_expr
## LR(1) items:
arith_expr -> arith_expr . ADD term [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
arith_expr -> arith_expr . SUB term [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
shift_expr -> shift_expr RSHIFT arith_expr . [ XOREQ SUBEQ SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On SUB shift to state 68
-- On ADD shift to state 70
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production shift_expr -> shift_expr RSHIFT arith_expr

State 68:
## Known stack suffix:
## arith_expr SUB
## LR(1) items:
arith_expr -> arith_expr SUB . term [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On term shift to state 69
-- On string shift to state 34
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
## Reductions:

State 69:
## Known stack suffix:
## arith_expr SUB term
## LR(1) items:
arith_expr -> arith_expr SUB term . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production arith_expr -> arith_expr SUB term

State 70:
## Known stack suffix:
## arith_expr ADD
## LR(1) items:
arith_expr -> arith_expr ADD . term [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On term shift to state 71
-- On string shift to state 34
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
## Reductions:

State 71:
## Known stack suffix:
## arith_expr ADD term
## LR(1) items:
arith_expr -> arith_expr ADD term . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production arith_expr -> arith_expr ADD term

State 72:
## Known stack suffix:
## shift_expr LSHIFT
## LR(1) items:
shift_expr -> shift_expr LSHIFT . arith_expr [ XOREQ SUBEQ SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On term shift to state 55
-- On string shift to state 34
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 73
## Reductions:

State 73:
## Known stack suffix:
## shift_expr LSHIFT arith_expr
## LR(1) items:
arith_expr -> arith_expr . ADD term [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
arith_expr -> arith_expr . SUB term [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
shift_expr -> shift_expr LSHIFT arith_expr . [ XOREQ SUBEQ SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On SUB shift to state 68
-- On ADD shift to state 70
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production shift_expr -> shift_expr LSHIFT arith_expr

State 74:
## Known stack suffix:
## shift_expr BITAND
## LR(1) items:
and_expr -> shift_expr BITAND . and_expr [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 76
## Reductions:

State 75:
## Known stack suffix:
## arith_expr
## LR(1) items:
arith_expr -> arith_expr . ADD term [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
arith_expr -> arith_expr . SUB term [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD ]
shift_expr -> arith_expr . [ XOREQ SUBEQ SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On SUB shift to state 68
-- On ADD shift to state 70
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production shift_expr -> arith_expr

State 76:
## Known stack suffix:
## shift_expr BITAND and_expr
## LR(1) items:
and_expr -> shift_expr BITAND and_expr . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production and_expr -> shift_expr BITAND and_expr

State 77:
## Known stack suffix:
## xor_expr BITXOR and_expr
## LR(1) items:
xor_expr -> xor_expr BITXOR and_expr . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production xor_expr -> xor_expr BITXOR and_expr

State 78:
## Known stack suffix:
## test
## LR(1) items:
option(test) -> test . [ COLON ]
subscript -> test . [ RBRACK COMMA ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production option(test) -> test
-- On RBRACK COMMA
--   reduce production subscript -> test

State 79:
## Known stack suffix:
## subscript
## LR(1) items:
list_sep_term(subscript,COMMA) -> subscript . [ RBRACK ]
list_sep_term(subscript,COMMA) -> subscript . COMMA [ RBRACK ]
list_sep_term(subscript,COMMA) -> subscript . COMMA list_sep_term(subscript,COMMA) [ RBRACK ]
## Transitions:
-- On COMMA shift to state 80
## Reductions:
-- On RBRACK
--   reduce production list_sep_term(subscript,COMMA) -> subscript

State 80:
## Known stack suffix:
## subscript COMMA
## LR(1) items:
list_sep_term(subscript,COMMA) -> subscript COMMA . [ RBRACK ]
list_sep_term(subscript,COMMA) -> subscript COMMA . list_sep_term(subscript,COMMA) [ RBRACK ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 78
-- On term shift to state 55
-- On subscript shift to state 79
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On option(test) shift to state 120
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On list_sep_term(subscript,COMMA) shift to state 126
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On RBRACK
--   reduce production list_sep_term(subscript,COMMA) -> subscript COMMA
-- On COLON
--   reduce production option(test) ->

State 81:
## Known stack suffix:
## or_test
## LR(1) items:
test -> or_test . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
test -> or_test . IF or_test ELSE test [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On IF shift to state 82
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
--   reduce production test -> or_test

State 82:
## Known stack suffix:
## or_test IF
## LR(1) items:
test -> or_test IF . or_test ELSE test [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 83
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 83:
## Known stack suffix:
## or_test IF or_test
## LR(1) items:
test -> or_test IF or_test . ELSE test [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On ELSE shift to state 84
## Reductions:

State 84:
## Known stack suffix:
## or_test IF or_test ELSE
## LR(1) items:
test -> or_test IF or_test ELSE . test [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 85
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 85:
## Known stack suffix:
## or_test IF or_test ELSE test
## LR(1) items:
test -> or_test IF or_test ELSE test . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
--   reduce production test -> or_test IF or_test ELSE test

State 86:
## Known stack suffix:
## not_test
## LR(1) items:
and_test -> not_test . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
and_test -> not_test . AND list_sep(not_test,AND) [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On AND shift to state 87
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
--   reduce production and_test -> not_test

State 87:
## Known stack suffix:
## not_test AND
## LR(1) items:
and_test -> not_test AND . list_sep(not_test,AND) [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On not_test shift to state 88
-- On nonempty_list(string) shift to state 36
-- On list_sep(not_test,AND) shift to state 89
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 88:
## Known stack suffix:
## not_test
## LR(1) items:
list_sep(not_test,AND) -> not_test . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production list_sep(not_test,AND) -> not_test

State 89:
## Known stack suffix:
## not_test AND list_sep(not_test,AND)
## LR(1) items:
and_test -> not_test AND list_sep(not_test,AND) . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
list_sep(not_test,AND) -> list_sep(not_test,AND) . AND not_test [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On AND shift to state 90
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
--   reduce production and_test -> not_test AND list_sep(not_test,AND)

State 90:
## Known stack suffix:
## list_sep(not_test,AND) AND
## LR(1) items:
list_sep(not_test,AND) -> list_sep(not_test,AND) AND . not_test [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On not_test shift to state 91
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 91:
## Known stack suffix:
## list_sep(not_test,AND) AND not_test
## LR(1) items:
list_sep(not_test,AND) -> list_sep(not_test,AND) AND not_test . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production list_sep(not_test,AND) -> list_sep(not_test,AND) AND not_test

State 92:
## Known stack suffix:
## expr
## LR(1) items:
comparison -> expr . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
comparison -> expr . comp_op comparison_list [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
expr -> expr . BITOR xor_expr [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On NOTEQ shift to state 93
-- On NOT shift to state 94
-- On LT shift to state 96
-- On LEQ shift to state 97
-- On IS shift to state 98
-- On IN shift to state 100
-- On GT shift to state 101
-- On GEQ shift to state 102
-- On EQUAL shift to state 103
-- On BITOR shift to state 104
-- On comp_op shift to state 107
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production comparison -> expr

State 93:
## Known stack suffix:
## NOTEQ
## LR(1) items:
comp_op -> NOTEQ . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production comp_op -> NOTEQ

State 94:
## Known stack suffix:
## NOT
## LR(1) items:
comp_op -> NOT . IN [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
-- On IN shift to state 95
## Reductions:

State 95:
## Known stack suffix:
## NOT IN
## LR(1) items:
comp_op -> NOT IN . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production comp_op -> NOT IN

State 96:
## Known stack suffix:
## LT
## LR(1) items:
comp_op -> LT . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production comp_op -> LT

State 97:
## Known stack suffix:
## LEQ
## LR(1) items:
comp_op -> LEQ . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production comp_op -> LEQ

State 98:
## Known stack suffix:
## IS
## LR(1) items:
comp_op -> IS . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
comp_op -> IS . NOT [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
-- On NOT shift to state 99
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production comp_op -> IS

State 99:
## Known stack suffix:
## IS NOT
## LR(1) items:
comp_op -> IS NOT . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production comp_op -> IS NOT

State 100:
## Known stack suffix:
## IN
## LR(1) items:
comp_op -> IN . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production comp_op -> IN

State 101:
## Known stack suffix:
## GT
## LR(1) items:
comp_op -> GT . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production comp_op -> GT

State 102:
## Known stack suffix:
## GEQ
## LR(1) items:
comp_op -> GEQ . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production comp_op -> GEQ

State 103:
## Known stack suffix:
## EQUAL
## LR(1) items:
comp_op -> EQUAL . [ TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production comp_op -> EQUAL

State 104:
## Known stack suffix:
## expr BITOR
## LR(1) items:
expr -> expr BITOR . xor_expr [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 105
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 105:
## Known stack suffix:
## expr BITOR xor_expr
## LR(1) items:
expr -> expr BITOR xor_expr . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
xor_expr -> xor_expr . BITXOR and_expr [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On BITXOR shift to state 54
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production expr -> expr BITOR xor_expr

State 106:
## Known stack suffix:
## and_expr
## LR(1) items:
xor_expr -> and_expr . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production xor_expr -> and_expr

State 107:
## Known stack suffix:
## expr comp_op
## LR(1) items:
comparison -> expr comp_op . comparison_list [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On expr shift to state 108
-- On comparison_list shift to state 111
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 108:
## Known stack suffix:
## expr
## LR(1) items:
comparison_list -> expr . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
comparison_list -> expr . comp_op comparison_list [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
expr -> expr . BITOR xor_expr [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On NOTEQ shift to state 93
-- On NOT shift to state 94
-- On LT shift to state 96
-- On LEQ shift to state 97
-- On IS shift to state 98
-- On IN shift to state 100
-- On GT shift to state 101
-- On GEQ shift to state 102
-- On EQUAL shift to state 103
-- On BITOR shift to state 104
-- On comp_op shift to state 109
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production comparison_list -> expr

State 109:
## Known stack suffix:
## expr comp_op
## LR(1) items:
comparison_list -> expr comp_op . comparison_list [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On expr shift to state 108
-- On comparison_list shift to state 110
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 110:
## Known stack suffix:
## expr comp_op comparison_list
## LR(1) items:
comparison_list -> expr comp_op comparison_list . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production comparison_list -> expr comp_op comparison_list

State 111:
## Known stack suffix:
## expr comp_op comparison_list
## LR(1) items:
comparison -> expr comp_op comparison_list . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production comparison -> expr comp_op comparison_list

State 112:
## Known stack suffix:
## comparison
## LR(1) items:
not_test -> comparison . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production not_test -> comparison

State 113:
## Known stack suffix:
## lambdadef
## LR(1) items:
test -> lambdadef . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
--   reduce production test -> lambdadef

State 114:
## Known stack suffix:
## and_test
## LR(1) items:
or_test -> and_test . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
or_test -> and_test . OR list_sep(and_test,OR) [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On OR shift to state 115
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
--   reduce production or_test -> and_test

State 115:
## Known stack suffix:
## and_test OR
## LR(1) items:
or_test -> and_test OR . list_sep(and_test,OR) [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On list_sep(and_test,OR) shift to state 116
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 119
-- On and_expr shift to state 106
## Reductions:

State 116:
## Known stack suffix:
## and_test OR list_sep(and_test,OR)
## LR(1) items:
list_sep(and_test,OR) -> list_sep(and_test,OR) . OR and_test [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
or_test -> and_test OR list_sep(and_test,OR) . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On OR shift to state 117
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
--   reduce production or_test -> and_test OR list_sep(and_test,OR)

State 117:
## Known stack suffix:
## list_sep(and_test,OR) OR
## LR(1) items:
list_sep(and_test,OR) -> list_sep(and_test,OR) OR . and_test [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 118
-- On and_expr shift to state 106
## Reductions:

State 118:
## Known stack suffix:
## list_sep(and_test,OR) OR and_test
## LR(1) items:
list_sep(and_test,OR) -> list_sep(and_test,OR) OR and_test . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
--   reduce production list_sep(and_test,OR) -> list_sep(and_test,OR) OR and_test

State 119:
## Known stack suffix:
## and_test
## LR(1) items:
list_sep(and_test,OR) -> and_test . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
--   reduce production list_sep(and_test,OR) -> and_test

State 120:
## Known stack suffix:
## option(test)
## LR(1) items:
subscript -> option(test) . COLON option(test) [ RBRACK COMMA ]
subscript -> option(test) . COLON option(test) COLON option(test) [ RBRACK COMMA ]
## Transitions:
-- On COLON shift to state 121
## Reductions:

State 121:
## Known stack suffix:
## option(test) COLON
## LR(1) items:
subscript -> option(test) COLON . option(test) [ RBRACK COMMA ]
subscript -> option(test) COLON . option(test) COLON option(test) [ RBRACK COMMA ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 122
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On option(test) shift to state 123
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On RBRACK COMMA COLON
--   reduce production option(test) ->

State 122:
## Known stack suffix:
## test
## LR(1) items:
option(test) -> test . [ RBRACK COMMA COLON ]
## Transitions:
## Reductions:
-- On RBRACK COMMA COLON
--   reduce production option(test) -> test

State 123:
## Known stack suffix:
## option(test) COLON option(test)
## LR(1) items:
subscript -> option(test) COLON option(test) . [ RBRACK COMMA ]
subscript -> option(test) COLON option(test) . COLON option(test) [ RBRACK COMMA ]
## Transitions:
-- On COLON shift to state 124
## Reductions:
-- On RBRACK COMMA
--   reduce production subscript -> option(test) COLON option(test)

State 124:
## Known stack suffix:
## option(test) COLON option(test) COLON
## LR(1) items:
subscript -> option(test) COLON option(test) COLON . option(test) [ RBRACK COMMA ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 122
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On option(test) shift to state 125
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On RBRACK COMMA
--   reduce production option(test) ->

State 125:
## Known stack suffix:
## option(test) COLON option(test) COLON option(test)
## LR(1) items:
subscript -> option(test) COLON option(test) COLON option(test) . [ RBRACK COMMA ]
## Transitions:
## Reductions:
-- On RBRACK COMMA
--   reduce production subscript -> option(test) COLON option(test) COLON option(test)

State 126:
## Known stack suffix:
## subscript COMMA list_sep_term(subscript,COMMA)
## LR(1) items:
list_sep_term(subscript,COMMA) -> subscript COMMA list_sep_term(subscript,COMMA) . [ RBRACK ]
## Transitions:
## Reductions:
-- On RBRACK
--   reduce production list_sep_term(subscript,COMMA) -> subscript COMMA list_sep_term(subscript,COMMA)

State 127:
## Known stack suffix:
## list_sep_term(subscript,COMMA)
## LR(1) items:
list_comma(subscript) -> list_sep_term(subscript,COMMA) . [ RBRACK ]
## Transitions:
## Reductions:
-- On RBRACK
--   reduce production list_comma(subscript) -> list_sep_term(subscript,COMMA)

State 128:
## Known stack suffix:
## atom_and_trailers LBRACK list_comma(subscript)
## LR(1) items:
atom_and_trailers -> atom_and_trailers LBRACK list_comma(subscript) . RBRACK [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On RBRACK shift to state 129
## Reductions:

State 129:
## Known stack suffix:
## atom_and_trailers LBRACK list_comma(subscript) RBRACK
## LR(1) items:
atom_and_trailers -> atom_and_trailers LBRACK list_comma(subscript) RBRACK . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_and_trailers -> atom_and_trailers LBRACK list_comma(subscript) RBRACK

State 130:
## Known stack suffix:
## atom_and_trailers DOT
## LR(1) items:
atom_and_trailers -> atom_and_trailers DOT . NAME [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On NAME shift to state 131
## Reductions:

State 131:
## Known stack suffix:
## atom_and_trailers DOT NAME
## LR(1) items:
atom_and_trailers -> atom_and_trailers DOT NAME . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_and_trailers -> atom_and_trailers DOT NAME

State 132:
## Known stack suffix:
## POW test
## LR(1) items:
argument -> POW test . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production argument -> POW test

State 133:
## Known stack suffix:
## NAME
## LR(1) items:
argument -> NAME . COLON test [ RPAREN COMMA ]
atom -> NAME . [ SUB RSHIFT RPAREN POW OR NOTEQ NOT MULT MOD LT LSHIFT LPAREN LEQ LBRACK IS IN IF GT GEQ FOR FDIV EQUAL EQ DOT DIV COMMA COLONEQ BITXOR BITOR BITAND AT ASYNC AND ADD ]
## Transitions:
-- On COLON shift to state 134
## Reductions:
-- On SUB RSHIFT RPAREN POW OR NOTEQ NOT MULT MOD LT LSHIFT LPAREN LEQ LBRACK IS IN IF GT GEQ FOR FDIV EQUAL EQ DOT DIV COMMA COLONEQ BITXOR BITOR BITAND AT ASYNC AND ADD
--   reduce production atom -> NAME

State 134:
## Known stack suffix:
## NAME COLON
## LR(1) items:
argument -> NAME COLON . test [ RPAREN COMMA ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 135
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 135:
## Known stack suffix:
## NAME COLON test
## LR(1) items:
argument -> NAME COLON test . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production argument -> NAME COLON test

State 136:
## Known stack suffix:
## MULT
## LR(1) items:
argument -> MULT . test [ RPAREN COMMA ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 137
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 137:
## Known stack suffix:
## MULT test
## LR(1) items:
argument -> MULT test . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production argument -> MULT test

State 138:
## Known stack suffix:
## test
## LR(1) items:
argument -> test . [ RPAREN COMMA ]
argument -> test . comp_for [ RPAREN COMMA ]
argument -> test . COLONEQ test [ RPAREN COMMA ]
argument -> test . EQ test [ RPAREN COMMA ]
## Transitions:
-- On FOR shift to state 139
-- On EQ shift to state 178
-- On COLONEQ shift to state 180
-- On ASYNC shift to state 167
-- On sync_comp_for shift to state 169
-- On comp_for shift to state 182
## Reductions:
-- On RPAREN COMMA
--   reduce production argument -> test

State 139:
## Known stack suffix:
## FOR
## LR(1) items:
sync_comp_for -> FOR . exprlist IN or_test [ RPAREN RBRACK RBRACE COMMA ]
sync_comp_for -> FOR . exprlist IN or_test comp_iter [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(expr_or_star_expr) shift to state 140
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 141
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On exprlist shift to state 142
-- On expr_or_star_expr shift to state 174
-- On expr shift to state 177
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 140:
## Known stack suffix:
## tuple(expr_or_star_expr)
## LR(1) items:
exprlist -> tuple(expr_or_star_expr) . [ SEMICOL NEWLINE IN ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE IN
--   reduce production exprlist -> tuple(expr_or_star_expr)

State 141:
## Known stack suffix:
## star_expr
## LR(1) items:
expr_or_star_expr -> star_expr . [ SEMICOL NEWLINE IN COMMA ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE IN COMMA
--   reduce production expr_or_star_expr -> star_expr

State 142:
## Known stack suffix:
## FOR exprlist
## LR(1) items:
sync_comp_for -> FOR exprlist . IN or_test [ RPAREN RBRACK RBRACE COMMA ]
sync_comp_for -> FOR exprlist . IN or_test comp_iter [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
-- On IN shift to state 143
## Reductions:

State 143:
## Known stack suffix:
## FOR exprlist IN
## LR(1) items:
sync_comp_for -> FOR exprlist IN . or_test [ RPAREN RBRACK RBRACE COMMA ]
sync_comp_for -> FOR exprlist IN . or_test comp_iter [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 144
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 144:
## Known stack suffix:
## FOR exprlist IN or_test
## LR(1) items:
sync_comp_for -> FOR exprlist IN or_test . [ RPAREN RBRACK RBRACE COMMA ]
sync_comp_for -> FOR exprlist IN or_test . comp_iter [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
-- On IF shift to state 145
-- On FOR shift to state 139
-- On ASYNC shift to state 167
-- On sync_comp_for shift to state 169
-- On comp_iter shift to state 173
-- On comp_if shift to state 171
-- On comp_for shift to state 172
## Reductions:
-- On RPAREN RBRACK RBRACE COMMA
--   reduce production sync_comp_for -> FOR exprlist IN or_test

State 145:
## Known stack suffix:
## IF
## LR(1) items:
comp_if -> IF . test_nocond [ RPAREN RBRACK RBRACE COMMA ]
comp_if -> IF . test_nocond comp_iter [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 146
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test_nocond shift to state 166
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 160
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef_nocond shift to state 161
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 146:
## Known stack suffix:
## LAMBDA
## LR(1) items:
lambdadef_nocond -> LAMBDA . varargslist COLON test_nocond [ RPAREN RBRACK RBRACE IF FOR COMMA ASYNC ]
## Transitions:
-- On POW shift to state 24
-- On NAME shift to state 26
-- On MULT shift to state 147
-- On LPAREN shift to state 149
-- On DIV shift to state 156
-- On varargslist shift to state 157
-- On parameter shift to state 162
-- On fpdef shift to state 165
## Reductions:
-- On COLON
--   reduce production varargslist ->

State 147:
## Known stack suffix:
## MULT
## LR(1) items:
parameter -> MULT . NAME [ COMMA COLON ]
## Transitions:
-- On NAME shift to state 148
## Reductions:

State 148:
## Known stack suffix:
## MULT NAME
## LR(1) items:
parameter -> MULT NAME . [ COMMA COLON ]
## Transitions:
## Reductions:
-- On COMMA COLON
--   reduce production parameter -> MULT NAME

State 149:
## Known stack suffix:
## LPAREN
## LR(1) items:
fpdef -> LPAREN . fplist RPAREN [ RPAREN COMMA COLON ]
## Transitions:
-- On NAME shift to state 150
-- On LPAREN shift to state 149
-- On fplist shift to state 151
-- On fpdef shift to state 153
## Reductions:

State 150:
## Known stack suffix:
## NAME
## LR(1) items:
fpdef -> NAME . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production fpdef -> NAME

State 151:
## Known stack suffix:
## LPAREN fplist
## LR(1) items:
fpdef -> LPAREN fplist . RPAREN [ RPAREN COMMA COLON ]
## Transitions:
-- On RPAREN shift to state 152
## Reductions:

State 152:
## Known stack suffix:
## LPAREN fplist RPAREN
## LR(1) items:
fpdef -> LPAREN fplist RPAREN . [ RPAREN COMMA COLON ]
## Transitions:
## Reductions:
-- On RPAREN COMMA COLON
--   reduce production fpdef -> LPAREN fplist RPAREN

State 153:
## Known stack suffix:
## fpdef
## LR(1) items:
fplist -> fpdef . [ RPAREN ]
fplist -> fpdef . COMMA fplist [ RPAREN ]
## Transitions:
-- On COMMA shift to state 154
## Reductions:
-- On RPAREN
--   reduce production fplist -> fpdef

State 154:
## Known stack suffix:
## fpdef COMMA
## LR(1) items:
fplist -> fpdef COMMA . fplist [ RPAREN ]
## Transitions:
-- On NAME shift to state 150
-- On LPAREN shift to state 149
-- On fplist shift to state 155
-- On fpdef shift to state 153
## Reductions:

State 155:
## Known stack suffix:
## fpdef COMMA fplist
## LR(1) items:
fplist -> fpdef COMMA fplist . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN
--   reduce production fplist -> fpdef COMMA fplist

State 156:
## Known stack suffix:
## DIV
## LR(1) items:
parameter -> DIV . [ COMMA COLON ]
## Transitions:
## Reductions:
-- On COMMA COLON
--   reduce production parameter -> DIV

State 157:
## Known stack suffix:
## LAMBDA varargslist
## LR(1) items:
lambdadef_nocond -> LAMBDA varargslist . COLON test_nocond [ RPAREN RBRACK RBRACE IF FOR COMMA ASYNC ]
## Transitions:
-- On COLON shift to state 158
## Reductions:

State 158:
## Known stack suffix:
## LAMBDA varargslist COLON
## LR(1) items:
lambdadef_nocond -> LAMBDA varargslist COLON . test_nocond [ RPAREN RBRACK RBRACE IF FOR COMMA ASYNC ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 146
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test_nocond shift to state 159
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 160
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef_nocond shift to state 161
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 159:
## Known stack suffix:
## LAMBDA varargslist COLON test_nocond
## LR(1) items:
lambdadef_nocond -> LAMBDA varargslist COLON test_nocond . [ RPAREN RBRACK RBRACE IF FOR COMMA ASYNC ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK RBRACE IF FOR COMMA ASYNC
--   reduce production lambdadef_nocond -> LAMBDA varargslist COLON test_nocond

State 160:
## Known stack suffix:
## or_test
## LR(1) items:
test_nocond -> or_test . [ RPAREN RBRACK RBRACE IF FOR COMMA ASYNC ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK RBRACE IF FOR COMMA ASYNC
--   reduce production test_nocond -> or_test

State 161:
## Known stack suffix:
## lambdadef_nocond
## LR(1) items:
test_nocond -> lambdadef_nocond . [ RPAREN RBRACK RBRACE IF FOR COMMA ASYNC ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK RBRACE IF FOR COMMA ASYNC
--   reduce production test_nocond -> lambdadef_nocond

State 162:
## Known stack suffix:
## parameter
## LR(1) items:
varargslist -> parameter . [ COLON ]
varargslist -> parameter . COMMA varargslist [ COLON ]
## Transitions:
-- On COMMA shift to state 163
## Reductions:
-- On COLON
--   reduce production varargslist -> parameter

State 163:
## Known stack suffix:
## parameter COMMA
## LR(1) items:
varargslist -> parameter COMMA . varargslist [ COLON ]
## Transitions:
-- On POW shift to state 24
-- On NAME shift to state 26
-- On MULT shift to state 147
-- On LPAREN shift to state 149
-- On DIV shift to state 156
-- On varargslist shift to state 164
-- On parameter shift to state 162
-- On fpdef shift to state 165
## Reductions:
-- On COLON
--   reduce production varargslist ->

State 164:
## Known stack suffix:
## parameter COMMA varargslist
## LR(1) items:
varargslist -> parameter COMMA varargslist . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production varargslist -> parameter COMMA varargslist

State 165:
## Known stack suffix:
## fpdef
## LR(1) items:
parameter -> fpdef . [ COMMA COLON ]
## Transitions:
## Reductions:
-- On COMMA COLON
--   reduce production parameter -> fpdef

State 166:
## Known stack suffix:
## IF test_nocond
## LR(1) items:
comp_if -> IF test_nocond . [ RPAREN RBRACK RBRACE COMMA ]
comp_if -> IF test_nocond . comp_iter [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
-- On IF shift to state 145
-- On FOR shift to state 139
-- On ASYNC shift to state 167
-- On sync_comp_for shift to state 169
-- On comp_iter shift to state 170
-- On comp_if shift to state 171
-- On comp_for shift to state 172
## Reductions:
-- On RPAREN RBRACK RBRACE COMMA
--   reduce production comp_if -> IF test_nocond

State 167:
## Known stack suffix:
## ASYNC
## LR(1) items:
comp_for -> ASYNC . sync_comp_for [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
-- On FOR shift to state 139
-- On sync_comp_for shift to state 168
## Reductions:

State 168:
## Known stack suffix:
## ASYNC sync_comp_for
## LR(1) items:
comp_for -> ASYNC sync_comp_for . [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK RBRACE COMMA
--   reduce production comp_for -> ASYNC sync_comp_for

State 169:
## Known stack suffix:
## sync_comp_for
## LR(1) items:
comp_for -> sync_comp_for . [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK RBRACE COMMA
--   reduce production comp_for -> sync_comp_for

State 170:
## Known stack suffix:
## IF test_nocond comp_iter
## LR(1) items:
comp_if -> IF test_nocond comp_iter . [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK RBRACE COMMA
--   reduce production comp_if -> IF test_nocond comp_iter

State 171:
## Known stack suffix:
## comp_if
## LR(1) items:
comp_iter -> comp_if . [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK RBRACE COMMA
--   reduce production comp_iter -> comp_if

State 172:
## Known stack suffix:
## comp_for
## LR(1) items:
comp_iter -> comp_for . [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK RBRACE COMMA
--   reduce production comp_iter -> comp_for

State 173:
## Known stack suffix:
## FOR exprlist IN or_test comp_iter
## LR(1) items:
sync_comp_for -> FOR exprlist IN or_test comp_iter . [ RPAREN RBRACK RBRACE COMMA ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK RBRACE COMMA
--   reduce production sync_comp_for -> FOR exprlist IN or_test comp_iter

State 174:
## Known stack suffix:
## expr_or_star_expr
## LR(1) items:
tuple(expr_or_star_expr) -> expr_or_star_expr . [ SEMICOL NEWLINE IN ]
tuple(expr_or_star_expr) -> expr_or_star_expr . COMMA [ SEMICOL NEWLINE IN ]
tuple(expr_or_star_expr) -> expr_or_star_expr . COMMA tuple(expr_or_star_expr) [ SEMICOL NEWLINE IN ]
## Transitions:
-- On COMMA shift to state 175
## Reductions:
-- On SEMICOL NEWLINE IN
--   reduce production tuple(expr_or_star_expr) -> expr_or_star_expr

State 175:
## Known stack suffix:
## expr_or_star_expr COMMA
## LR(1) items:
tuple(expr_or_star_expr) -> expr_or_star_expr COMMA . [ SEMICOL NEWLINE IN ]
tuple(expr_or_star_expr) -> expr_or_star_expr COMMA . tuple(expr_or_star_expr) [ SEMICOL NEWLINE IN ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(expr_or_star_expr) shift to state 176
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 141
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On expr_or_star_expr shift to state 174
-- On expr shift to state 177
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:
-- On SEMICOL NEWLINE IN
--   reduce production tuple(expr_or_star_expr) -> expr_or_star_expr COMMA

State 176:
## Known stack suffix:
## expr_or_star_expr COMMA tuple(expr_or_star_expr)
## LR(1) items:
tuple(expr_or_star_expr) -> expr_or_star_expr COMMA tuple(expr_or_star_expr) . [ SEMICOL NEWLINE IN ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE IN
--   reduce production tuple(expr_or_star_expr) -> expr_or_star_expr COMMA tuple(expr_or_star_expr)

State 177:
## Known stack suffix:
## expr
## LR(1) items:
expr -> expr . BITOR xor_expr [ SEMICOL NEWLINE IN COMMA BITOR ]
expr_or_star_expr -> expr . [ SEMICOL NEWLINE IN COMMA ]
## Transitions:
-- On BITOR shift to state 104
## Reductions:
-- On SEMICOL NEWLINE IN COMMA
--   reduce production expr_or_star_expr -> expr

State 178:
## Known stack suffix:
## test EQ
## LR(1) items:
argument -> test EQ . test [ RPAREN COMMA ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 179
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 179:
## Known stack suffix:
## test EQ test
## LR(1) items:
argument -> test EQ test . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production argument -> test EQ test

State 180:
## Known stack suffix:
## test COLONEQ
## LR(1) items:
argument -> test COLONEQ . test [ RPAREN COMMA ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 181
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 181:
## Known stack suffix:
## test COLONEQ test
## LR(1) items:
argument -> test COLONEQ test . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production argument -> test COLONEQ test

State 182:
## Known stack suffix:
## test comp_for
## LR(1) items:
argument -> test comp_for . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production argument -> test comp_for

State 183:
## Known stack suffix:
## list_sep_term(argument,COMMA)
## LR(1) items:
list_comma(argument) -> list_sep_term(argument,COMMA) . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN
--   reduce production list_comma(argument) -> list_sep_term(argument,COMMA)

State 184:
## Known stack suffix:
## atom_and_trailers LPAREN list_comma(argument)
## LR(1) items:
atom_and_trailers -> atom_and_trailers LPAREN list_comma(argument) . RPAREN [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On RPAREN shift to state 185
## Reductions:

State 185:
## Known stack suffix:
## atom_and_trailers LPAREN list_comma(argument) RPAREN
## LR(1) items:
atom_and_trailers -> atom_and_trailers LPAREN list_comma(argument) RPAREN . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_and_trailers -> atom_and_trailers LPAREN list_comma(argument) RPAREN

State 186:
## Known stack suffix:
## argument
## LR(1) items:
list_sep_term(argument,COMMA) -> argument . [ RPAREN ]
list_sep_term(argument,COMMA) -> argument . COMMA [ RPAREN ]
list_sep_term(argument,COMMA) -> argument . COMMA list_sep_term(argument,COMMA) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 187
## Reductions:
-- On RPAREN
--   reduce production list_sep_term(argument,COMMA) -> argument

State 187:
## Known stack suffix:
## argument COMMA
## LR(1) items:
list_sep_term(argument,COMMA) -> argument COMMA . [ RPAREN ]
list_sep_term(argument,COMMA) -> argument COMMA . list_sep_term(argument,COMMA) [ RPAREN ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On POW shift to state 44
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 133
-- On MULT shift to state 136
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 138
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On list_sep_term(argument,COMMA) shift to state 188
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On argument shift to state 186
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On RPAREN
--   reduce production list_sep_term(argument,COMMA) -> argument COMMA

State 188:
## Known stack suffix:
## argument COMMA list_sep_term(argument,COMMA)
## LR(1) items:
list_sep_term(argument,COMMA) -> argument COMMA list_sep_term(argument,COMMA) . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN
--   reduce production list_sep_term(argument,COMMA) -> argument COMMA list_sep_term(argument,COMMA)

State 189:
## Known stack suffix:
## BACKQUOTE testlist1
## LR(1) items:
atom_repr -> BACKQUOTE testlist1 . BACKQUOTE [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On BACKQUOTE shift to state 190
## Reductions:

State 190:
## Known stack suffix:
## BACKQUOTE testlist1 BACKQUOTE
## LR(1) items:
atom_repr -> BACKQUOTE testlist1 BACKQUOTE . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_repr -> BACKQUOTE testlist1 BACKQUOTE

State 191:
## Known stack suffix:
## test
## LR(1) items:
testlist1 -> test . [ BACKQUOTE ]
testlist1 -> test . COMMA testlist1 [ BACKQUOTE ]
## Transitions:
-- On COMMA shift to state 192
## Reductions:
-- On BACKQUOTE
--   reduce production testlist1 -> test

State 192:
## Known stack suffix:
## test COMMA
## LR(1) items:
testlist1 -> test COMMA . testlist1 [ BACKQUOTE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On testlist1 shift to state 193
-- On test shift to state 191
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 193:
## Known stack suffix:
## test COMMA testlist1
## LR(1) items:
testlist1 -> test COMMA testlist1 . [ BACKQUOTE ]
## Transitions:
## Reductions:
-- On BACKQUOTE
--   reduce production testlist1 -> test COMMA testlist1

State 194:
## Known stack suffix:
## BITNOT factor
## LR(1) items:
factor -> BITNOT factor . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production factor -> BITNOT factor

State 195:
## Known stack suffix:
## NAME EQ test
## LR(1) items:
parameter -> NAME EQ test . [ COMMA COLON ]
## Transitions:
## Reductions:
-- On COMMA COLON
--   reduce production parameter -> NAME EQ test

State 196:
## Known stack suffix:
## LAMBDA varargslist
## LR(1) items:
lambdadef -> LAMBDA varargslist . COLON test [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On COLON shift to state 197
## Reductions:

State 197:
## Known stack suffix:
## LAMBDA varargslist COLON
## LR(1) items:
lambdadef -> LAMBDA varargslist COLON . test [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 198
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 198:
## Known stack suffix:
## LAMBDA varargslist COLON test
## LR(1) items:
lambdadef -> LAMBDA varargslist COLON test . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
--   reduce production lambdadef -> LAMBDA varargslist COLON test

State 199:
## Known stack suffix:
## tuple(test)
## LR(1) items:
interpolant -> tuple(test) . [ RBRACE EQ COLON BANG ]
## Transitions:
## Reductions:
-- On RBRACE EQ COLON BANG
--   reduce production interpolant -> tuple(test)

State 200:
## Known stack suffix:
## test
## LR(1) items:
tuple(test) -> test . [ SEMICOL RPAREN RBRACE NEWLINE EQ COLON BANG ]
tuple(test) -> test . COMMA [ SEMICOL RPAREN RBRACE NEWLINE EQ COLON BANG ]
tuple(test) -> test . COMMA tuple(test) [ SEMICOL RPAREN RBRACE NEWLINE EQ COLON BANG ]
## Transitions:
-- On COMMA shift to state 201
## Reductions:
-- On SEMICOL RPAREN RBRACE NEWLINE EQ COLON BANG
--   reduce production tuple(test) -> test

State 201:
## Known stack suffix:
## test COMMA
## LR(1) items:
tuple(test) -> test COMMA . [ SEMICOL RPAREN RBRACE NEWLINE EQ COLON BANG ]
tuple(test) -> test COMMA . tuple(test) [ SEMICOL RPAREN RBRACE NEWLINE EQ COLON BANG ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(test) shift to state 202
-- On test shift to state 200
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On SEMICOL RPAREN RBRACE NEWLINE EQ COLON BANG
--   reduce production tuple(test) -> test COMMA

State 202:
## Known stack suffix:
## test COMMA tuple(test)
## LR(1) items:
tuple(test) -> test COMMA tuple(test) . [ SEMICOL RPAREN RBRACE NEWLINE EQ COLON BANG ]
## Transitions:
## Reductions:
-- On SEMICOL RPAREN RBRACE NEWLINE EQ COLON BANG
--   reduce production tuple(test) -> test COMMA tuple(test)

State 203:
## Known stack suffix:
## FSTRING_LBRACE interpolant
## LR(1) items:
interpolated -> FSTRING_LBRACE interpolant . fstring_print_spec RBRACE [ FSTRING_STRING FSTRING_LBRACE FSTRING_END ]
## Transitions:
-- On EQ shift to state 204
-- On COLON shift to state 205
-- On BANG shift to state 206
-- On fstring_print_spec shift to state 230
-- On fstring_format_delimeter shift to state 207
-- On fstring_format_clause shift to state 232
## Reductions:
-- On RBRACE
--   reduce production fstring_format_clause ->

State 204:
## Known stack suffix:
## EQ
## LR(1) items:
fstring_print_spec -> EQ . fstring_format_clause [ RBRACE ]
## Transitions:
-- On COLON shift to state 205
-- On BANG shift to state 206
-- On fstring_format_delimeter shift to state 207
-- On fstring_format_clause shift to state 229
## Reductions:
-- On RBRACE
--   reduce production fstring_format_clause ->

State 205:
## Known stack suffix:
## COLON
## LR(1) items:
fstring_format_delimeter -> COLON . [ SUB NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production fstring_format_delimeter -> COLON

State 206:
## Known stack suffix:
## BANG
## LR(1) items:
fstring_format_delimeter -> BANG . [ SUB NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production fstring_format_delimeter -> BANG

State 207:
## Known stack suffix:
## fstring_format_delimeter
## LR(1) items:
fstring_format_clause -> fstring_format_delimeter . format_specifier [ RBRACE ]
## Transitions:
-- On SUB shift to state 208
-- On NAME shift to state 209
-- On MOD shift to state 210
-- On LT shift to state 211
-- On LBRACE shift to state 212
-- On INT shift to state 215
-- On GT shift to state 216
-- On FLOAT shift to state 217
-- On EQ shift to state 218
-- On DOT shift to state 219
-- On DIV shift to state 220
-- On COMMA shift to state 221
-- On COLON shift to state 222
-- On BITXOR shift to state 223
-- On ADD shift to state 224
-- On nonempty_list(format_token) shift to state 225
-- On format_token shift to state 226
-- On format_specifier shift to state 228
## Reductions:

State 208:
## Known stack suffix:
## SUB
## LR(1) items:
format_token -> SUB . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> SUB

State 209:
## Known stack suffix:
## NAME
## LR(1) items:
format_token -> NAME . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> NAME

State 210:
## Known stack suffix:
## MOD
## LR(1) items:
format_token -> MOD . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> MOD

State 211:
## Known stack suffix:
## LT
## LR(1) items:
format_token -> LT . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> LT

State 212:
## Known stack suffix:
## LBRACE
## LR(1) items:
format_token -> LBRACE . test RBRACE [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 213
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 213:
## Known stack suffix:
## LBRACE test
## LR(1) items:
format_token -> LBRACE test . RBRACE [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
-- On RBRACE shift to state 214
## Reductions:

State 214:
## Known stack suffix:
## LBRACE test RBRACE
## LR(1) items:
format_token -> LBRACE test RBRACE . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> LBRACE test RBRACE

State 215:
## Known stack suffix:
## INT
## LR(1) items:
format_token -> INT . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> INT

State 216:
## Known stack suffix:
## GT
## LR(1) items:
format_token -> GT . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> GT

State 217:
## Known stack suffix:
## FLOAT
## LR(1) items:
format_token -> FLOAT . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> FLOAT

State 218:
## Known stack suffix:
## EQ
## LR(1) items:
format_token -> EQ . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> EQ

State 219:
## Known stack suffix:
## DOT
## LR(1) items:
format_token -> DOT . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> DOT

State 220:
## Known stack suffix:
## DIV
## LR(1) items:
format_token -> DIV . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> DIV

State 221:
## Known stack suffix:
## COMMA
## LR(1) items:
format_token -> COMMA . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> COMMA

State 222:
## Known stack suffix:
## COLON
## LR(1) items:
format_token -> COLON . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> COLON

State 223:
## Known stack suffix:
## BITXOR
## LR(1) items:
format_token -> BITXOR . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> BITXOR

State 224:
## Known stack suffix:
## ADD
## LR(1) items:
format_token -> ADD . [ SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD ]
## Transitions:
## Reductions:
-- On SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
--   reduce production format_token -> ADD

State 225:
## Known stack suffix:
## nonempty_list(format_token)
## LR(1) items:
format_specifier -> nonempty_list(format_token) . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production format_specifier -> nonempty_list(format_token)

State 226:
## Known stack suffix:
## format_token
## LR(1) items:
nonempty_list(format_token) -> format_token . [ RBRACE ]
nonempty_list(format_token) -> format_token . nonempty_list(format_token) [ RBRACE ]
## Transitions:
-- On SUB shift to state 208
-- On NAME shift to state 209
-- On MOD shift to state 210
-- On LT shift to state 211
-- On LBRACE shift to state 212
-- On INT shift to state 215
-- On GT shift to state 216
-- On FLOAT shift to state 217
-- On EQ shift to state 218
-- On DOT shift to state 219
-- On DIV shift to state 220
-- On COMMA shift to state 221
-- On COLON shift to state 222
-- On BITXOR shift to state 223
-- On ADD shift to state 224
-- On nonempty_list(format_token) shift to state 227
-- On format_token shift to state 226
## Reductions:
-- On RBRACE
--   reduce production nonempty_list(format_token) -> format_token

State 227:
## Known stack suffix:
## format_token nonempty_list(format_token)
## LR(1) items:
nonempty_list(format_token) -> format_token nonempty_list(format_token) . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production nonempty_list(format_token) -> format_token nonempty_list(format_token)

State 228:
## Known stack suffix:
## fstring_format_delimeter format_specifier
## LR(1) items:
fstring_format_clause -> fstring_format_delimeter format_specifier . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production fstring_format_clause -> fstring_format_delimeter format_specifier

State 229:
## Known stack suffix:
## EQ fstring_format_clause
## LR(1) items:
fstring_print_spec -> EQ fstring_format_clause . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production fstring_print_spec -> EQ fstring_format_clause

State 230:
## Known stack suffix:
## FSTRING_LBRACE interpolant fstring_print_spec
## LR(1) items:
interpolated -> FSTRING_LBRACE interpolant fstring_print_spec . RBRACE [ FSTRING_STRING FSTRING_LBRACE FSTRING_END ]
## Transitions:
-- On RBRACE shift to state 231
## Reductions:

State 231:
## Known stack suffix:
## FSTRING_LBRACE interpolant fstring_print_spec RBRACE
## LR(1) items:
interpolated -> FSTRING_LBRACE interpolant fstring_print_spec RBRACE . [ FSTRING_STRING FSTRING_LBRACE FSTRING_END ]
## Transitions:
## Reductions:
-- On FSTRING_STRING FSTRING_LBRACE FSTRING_END
--   reduce production interpolated -> FSTRING_LBRACE interpolant fstring_print_spec RBRACE

State 232:
## Known stack suffix:
## fstring_format_clause
## LR(1) items:
fstring_print_spec -> fstring_format_clause . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production fstring_print_spec -> fstring_format_clause

State 233:
## Known stack suffix:
## FSTRING_START list(interpolated)
## LR(1) items:
string -> FSTRING_START list(interpolated) . FSTRING_END [ XOREQ SUBEQ SUB STR SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FSTRING_START FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On FSTRING_END shift to state 234
## Reductions:

State 234:
## Known stack suffix:
## FSTRING_START list(interpolated) FSTRING_END
## LR(1) items:
string -> FSTRING_START list(interpolated) FSTRING_END . [ XOREQ SUBEQ SUB STR SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FSTRING_START FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB STR SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FSTRING_START FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production string -> FSTRING_START list(interpolated) FSTRING_END

State 235:
## Known stack suffix:
## interpolated
## LR(1) items:
list(interpolated) -> interpolated . list(interpolated) [ FSTRING_END ]
## Transitions:
-- On FSTRING_STRING shift to state 21
-- On FSTRING_LBRACE shift to state 22
-- On list(interpolated) shift to state 236
-- On interpolated shift to state 235
## Reductions:
-- On FSTRING_END
--   reduce production list(interpolated) ->

State 236:
## Known stack suffix:
## interpolated list(interpolated)
## LR(1) items:
list(interpolated) -> interpolated list(interpolated) . [ FSTRING_END ]
## Transitions:
## Reductions:
-- On FSTRING_END
--   reduce production list(interpolated) -> interpolated list(interpolated)

State 237:
## Known stack suffix:
## POW expr
## LR(1) items:
dictorset_elem -> POW expr . [ RBRACE FOR COMMA ASYNC ]
expr -> expr . BITOR xor_expr [ RBRACE FOR COMMA BITOR ASYNC ]
## Transitions:
-- On BITOR shift to state 104
## Reductions:
-- On RBRACE FOR COMMA ASYNC
--   reduce production dictorset_elem -> POW expr

State 238:
## Known stack suffix:
## test
## LR(1) items:
dictorset_elem -> test . COLON test [ RBRACE FOR COMMA ASYNC ]
dictorset_elem -> test . [ RBRACE FOR COMMA ASYNC ]
## Transitions:
-- On COLON shift to state 239
## Reductions:
-- On RBRACE FOR COMMA ASYNC
--   reduce production dictorset_elem -> test

State 239:
## Known stack suffix:
## test COLON
## LR(1) items:
dictorset_elem -> test COLON . test [ RBRACE FOR COMMA ASYNC ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 240
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 240:
## Known stack suffix:
## test COLON test
## LR(1) items:
dictorset_elem -> test COLON test . [ RBRACE FOR COMMA ASYNC ]
## Transitions:
## Reductions:
-- On RBRACE FOR COMMA ASYNC
--   reduce production dictorset_elem -> test COLON test

State 241:
## Known stack suffix:
## star_expr
## LR(1) items:
dictorset_elem -> star_expr . [ RBRACE FOR COMMA ASYNC ]
## Transitions:
## Reductions:
-- On RBRACE FOR COMMA ASYNC
--   reduce production dictorset_elem -> star_expr

State 242:
## Known stack suffix:
## list_sep_term(dictorset_elem,COMMA)
## LR(1) items:
list_comma(dictorset_elem) -> list_sep_term(dictorset_elem,COMMA) . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production list_comma(dictorset_elem) -> list_sep_term(dictorset_elem,COMMA)

State 243:
## Known stack suffix:
## list_comma(dictorset_elem)
## LR(1) items:
dictorsetmaker -> list_comma(dictorset_elem) . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production dictorsetmaker -> list_comma(dictorset_elem)

State 244:
## Known stack suffix:
## LBRACE dictorsetmaker
## LR(1) items:
atom_dict -> LBRACE dictorsetmaker . RBRACE [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On RBRACE shift to state 245
## Reductions:

State 245:
## Known stack suffix:
## LBRACE dictorsetmaker RBRACE
## LR(1) items:
atom_dict -> LBRACE dictorsetmaker RBRACE . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_dict -> LBRACE dictorsetmaker RBRACE

State 246:
## Known stack suffix:
## dictorset_elem
## LR(1) items:
dictorsetmaker -> dictorset_elem . comp_for [ RBRACE ]
list_sep_term(dictorset_elem,COMMA) -> dictorset_elem . [ RBRACE ]
list_sep_term(dictorset_elem,COMMA) -> dictorset_elem . COMMA [ RBRACE ]
list_sep_term(dictorset_elem,COMMA) -> dictorset_elem . COMMA list_sep_term(dictorset_elem,COMMA) [ RBRACE ]
## Transitions:
-- On FOR shift to state 139
-- On COMMA shift to state 247
-- On ASYNC shift to state 167
-- On sync_comp_for shift to state 169
-- On comp_for shift to state 250
## Reductions:
-- On RBRACE
--   reduce production list_sep_term(dictorset_elem,COMMA) -> dictorset_elem

State 247:
## Known stack suffix:
## dictorset_elem COMMA
## LR(1) items:
list_sep_term(dictorset_elem,COMMA) -> dictorset_elem COMMA . [ RBRACE ]
list_sep_term(dictorset_elem,COMMA) -> dictorset_elem COMMA . list_sep_term(dictorset_elem,COMMA) [ RBRACE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On POW shift to state 17
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 238
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 241
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On list_sep_term(dictorset_elem,COMMA) shift to state 248
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On dictorset_elem shift to state 249
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On RBRACE
--   reduce production list_sep_term(dictorset_elem,COMMA) -> dictorset_elem COMMA

State 248:
## Known stack suffix:
## dictorset_elem COMMA list_sep_term(dictorset_elem,COMMA)
## LR(1) items:
list_sep_term(dictorset_elem,COMMA) -> dictorset_elem COMMA list_sep_term(dictorset_elem,COMMA) . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production list_sep_term(dictorset_elem,COMMA) -> dictorset_elem COMMA list_sep_term(dictorset_elem,COMMA)

State 249:
## Known stack suffix:
## dictorset_elem
## LR(1) items:
list_sep_term(dictorset_elem,COMMA) -> dictorset_elem . [ RBRACE ]
list_sep_term(dictorset_elem,COMMA) -> dictorset_elem . COMMA [ RBRACE ]
list_sep_term(dictorset_elem,COMMA) -> dictorset_elem . COMMA list_sep_term(dictorset_elem,COMMA) [ RBRACE ]
## Transitions:
-- On COMMA shift to state 247
## Reductions:
-- On RBRACE
--   reduce production list_sep_term(dictorset_elem,COMMA) -> dictorset_elem

State 250:
## Known stack suffix:
## dictorset_elem comp_for
## LR(1) items:
dictorsetmaker -> dictorset_elem comp_for . [ RBRACE ]
## Transitions:
## Reductions:
-- On RBRACE
--   reduce production dictorsetmaker -> dictorset_elem comp_for

State 251:
## Known stack suffix:
## MULT expr
## LR(1) items:
expr -> expr . BITOR xor_expr [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ IN FOR FDIVEQ EQ DIVEQ COMMA COLON BITOR ASYNC ANDEQ ADDEQ ]
star_expr -> MULT expr . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ IN FOR FDIVEQ EQ DIVEQ COMMA COLON ASYNC ANDEQ ADDEQ ]
## Transitions:
-- On BITOR shift to state 104
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ IN FOR FDIVEQ EQ DIVEQ COMMA COLON ASYNC ANDEQ ADDEQ
--   reduce production star_expr -> MULT expr

State 252:
## Known stack suffix:
## tuple(namedexpr_or_star_expr)
## LR(1) items:
testlist_comp -> tuple(namedexpr_or_star_expr) . [ RBRACK ]
## Transitions:
## Reductions:
-- On RBRACK
--   reduce production testlist_comp -> tuple(namedexpr_or_star_expr)

State 253:
## Known stack suffix:
## LBRACK testlist_comp
## LR(1) items:
atom_list -> LBRACK testlist_comp . RBRACK [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On RBRACK shift to state 254
## Reductions:

State 254:
## Known stack suffix:
## LBRACK testlist_comp RBRACK
## LR(1) items:
atom_list -> LBRACK testlist_comp RBRACK . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_list -> LBRACK testlist_comp RBRACK

State 255:
## Known stack suffix:
## test
## LR(1) items:
namedexpr_test -> test . [ RPAREN RBRACK FOR COMMA COLON ASYNC ]
namedexpr_test -> test . COLONEQ test [ RPAREN RBRACK FOR COMMA COLON ASYNC ]
## Transitions:
-- On COLONEQ shift to state 256
## Reductions:
-- On RPAREN RBRACK FOR COMMA COLON ASYNC
--   reduce production namedexpr_test -> test

State 256:
## Known stack suffix:
## test COLONEQ
## LR(1) items:
namedexpr_test -> test COLONEQ . test [ RPAREN RBRACK FOR COMMA COLON ASYNC ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 257
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 257:
## Known stack suffix:
## test COLONEQ test
## LR(1) items:
namedexpr_test -> test COLONEQ test . [ RPAREN RBRACK FOR COMMA COLON ASYNC ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK FOR COMMA COLON ASYNC
--   reduce production namedexpr_test -> test COLONEQ test

State 258:
## Known stack suffix:
## star_expr
## LR(1) items:
namedexpr_or_star_expr -> star_expr . [ RPAREN RBRACK FOR COMMA ASYNC ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK FOR COMMA ASYNC
--   reduce production namedexpr_or_star_expr -> star_expr

State 259:
## Known stack suffix:
## namedexpr_test
## LR(1) items:
namedexpr_or_star_expr -> namedexpr_test . [ RPAREN RBRACK FOR COMMA ASYNC ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK FOR COMMA ASYNC
--   reduce production namedexpr_or_star_expr -> namedexpr_test

State 260:
## Known stack suffix:
## namedexpr_or_star_expr
## LR(1) items:
testlist_comp -> namedexpr_or_star_expr . listcomp_for [ RBRACK ]
tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr . [ RBRACK ]
tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr . COMMA [ RBRACK ]
tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr . COMMA tuple(namedexpr_or_star_expr) [ RBRACK ]
## Transitions:
-- On FOR shift to state 261
-- On COMMA shift to state 271
-- On ASYNC shift to state 274
-- On sync_comp_for shift to state 275
-- On listsync_comp_for shift to state 277
-- On listcomp_for shift to state 278
## Reductions:
-- On RBRACK
--   reduce production tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr

State 261:
## Known stack suffix:
## FOR
## LR(1) items:
listsync_comp_for -> FOR . exprlist IN list_for [ RBRACK ]
sync_comp_for -> FOR . exprlist IN or_test [ RBRACK ]
sync_comp_for -> FOR . exprlist IN or_test comp_iter [ RBRACK ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(expr_or_star_expr) shift to state 140
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 141
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On exprlist shift to state 262
-- On expr_or_star_expr shift to state 174
-- On expr shift to state 177
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 262:
## Known stack suffix:
## FOR exprlist
## LR(1) items:
listsync_comp_for -> FOR exprlist . IN list_for [ RBRACK ]
sync_comp_for -> FOR exprlist . IN or_test [ RBRACK ]
sync_comp_for -> FOR exprlist . IN or_test comp_iter [ RBRACK ]
## Transitions:
-- On IN shift to state 263
## Reductions:

State 263:
## Known stack suffix:
## FOR exprlist IN
## LR(1) items:
listsync_comp_for -> FOR exprlist IN . list_for [ RBRACK ]
sync_comp_for -> FOR exprlist IN . or_test [ RBRACK ]
sync_comp_for -> FOR exprlist IN . or_test comp_iter [ RBRACK ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 264
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On list_for shift to state 270
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 264:
## Known stack suffix:
## FOR exprlist IN or_test
## LR(1) items:
list_for -> or_test . COMMA list_for_rest [ RBRACK ]
sync_comp_for -> FOR exprlist IN or_test . [ RBRACK ]
sync_comp_for -> FOR exprlist IN or_test . comp_iter [ RBRACK ]
## Transitions:
-- On IF shift to state 145
-- On FOR shift to state 139
-- On COMMA shift to state 265
-- On ASYNC shift to state 167
-- On sync_comp_for shift to state 169
-- On comp_iter shift to state 173
-- On comp_if shift to state 171
-- On comp_for shift to state 172
## Reductions:
-- On RBRACK
--   reduce production sync_comp_for -> FOR exprlist IN or_test

State 265:
## Known stack suffix:
## or_test COMMA
## LR(1) items:
list_for -> or_test COMMA . list_for_rest [ RBRACK ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 266
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On list_for_rest shift to state 269
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 266:
## Known stack suffix:
## or_test
## LR(1) items:
list_for_rest -> or_test . [ RBRACK ]
list_for_rest -> or_test . COMMA list_for_rest [ RBRACK ]
## Transitions:
-- On COMMA shift to state 267
## Reductions:
-- On RBRACK
--   reduce production list_for_rest -> or_test

State 267:
## Known stack suffix:
## or_test COMMA
## LR(1) items:
list_for_rest -> or_test COMMA . list_for_rest [ RBRACK ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 266
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On list_for_rest shift to state 268
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 268:
## Known stack suffix:
## or_test COMMA list_for_rest
## LR(1) items:
list_for_rest -> or_test COMMA list_for_rest . [ RBRACK ]
## Transitions:
## Reductions:
-- On RBRACK
--   reduce production list_for_rest -> or_test COMMA list_for_rest

State 269:
## Known stack suffix:
## or_test COMMA list_for_rest
## LR(1) items:
list_for -> or_test COMMA list_for_rest . [ RBRACK ]
## Transitions:
## Reductions:
-- On RBRACK
--   reduce production list_for -> or_test COMMA list_for_rest

State 270:
## Known stack suffix:
## FOR exprlist IN list_for
## LR(1) items:
listsync_comp_for -> FOR exprlist IN list_for . [ RBRACK ]
## Transitions:
## Reductions:
-- On RBRACK
--   reduce production listsync_comp_for -> FOR exprlist IN list_for

State 271:
## Known stack suffix:
## namedexpr_or_star_expr COMMA
## LR(1) items:
tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr COMMA . [ RPAREN RBRACK ]
tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr COMMA . tuple(namedexpr_or_star_expr) [ RPAREN RBRACK ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(namedexpr_or_star_expr) shift to state 272
-- On test shift to state 255
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 258
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On namedexpr_test shift to state 259
-- On namedexpr_or_star_expr shift to state 273
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On RPAREN RBRACK
--   reduce production tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr COMMA

State 272:
## Known stack suffix:
## namedexpr_or_star_expr COMMA tuple(namedexpr_or_star_expr)
## LR(1) items:
tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr COMMA tuple(namedexpr_or_star_expr) . [ RPAREN RBRACK ]
## Transitions:
## Reductions:
-- On RPAREN RBRACK
--   reduce production tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr COMMA tuple(namedexpr_or_star_expr)

State 273:
## Known stack suffix:
## namedexpr_or_star_expr
## LR(1) items:
tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr . [ RPAREN RBRACK ]
tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr . COMMA [ RPAREN RBRACK ]
tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr . COMMA tuple(namedexpr_or_star_expr) [ RPAREN RBRACK ]
## Transitions:
-- On COMMA shift to state 271
## Reductions:
-- On RPAREN RBRACK
--   reduce production tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr

State 274:
## Known stack suffix:
## ASYNC
## LR(1) items:
listcomp_for -> ASYNC . listsync_comp_for [ RBRACK ]
## Transitions:
-- On FOR shift to state 261
-- On sync_comp_for shift to state 275
-- On listsync_comp_for shift to state 276
## Reductions:

State 275:
## Known stack suffix:
## sync_comp_for
## LR(1) items:
listsync_comp_for -> sync_comp_for . [ RBRACK ]
## Transitions:
## Reductions:
-- On RBRACK
--   reduce production listsync_comp_for -> sync_comp_for

State 276:
## Known stack suffix:
## ASYNC listsync_comp_for
## LR(1) items:
listcomp_for -> ASYNC listsync_comp_for . [ RBRACK ]
## Transitions:
## Reductions:
-- On RBRACK
--   reduce production listcomp_for -> ASYNC listsync_comp_for

State 277:
## Known stack suffix:
## listsync_comp_for
## LR(1) items:
listcomp_for -> listsync_comp_for . [ RBRACK ]
## Transitions:
## Reductions:
-- On RBRACK
--   reduce production listcomp_for -> listsync_comp_for

State 278:
## Known stack suffix:
## namedexpr_or_star_expr listcomp_for
## LR(1) items:
testlist_comp -> namedexpr_or_star_expr listcomp_for . [ RBRACK ]
## Transitions:
## Reductions:
-- On RBRACK
--   reduce production testlist_comp -> namedexpr_or_star_expr listcomp_for

State 279:
## Known stack suffix:
## LDots test
## LR(1) items:
atom -> LDots test . RDots [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On RDots shift to state 280
## Reductions:

State 280:
## Known stack suffix:
## LDots test RDots
## LR(1) items:
atom -> LDots test RDots . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom -> LDots test RDots

State 281:
## Known stack suffix:
## NOT not_test
## LR(1) items:
not_test -> NOT not_test . [ XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
--   reduce production not_test -> NOT not_test

State 282:
## Known stack suffix:
## LPAREN yield_expr
## LR(1) items:
atom_tuple -> LPAREN yield_expr . RPAREN [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On RPAREN shift to state 283
## Reductions:

State 283:
## Known stack suffix:
## LPAREN yield_expr RPAREN
## LR(1) items:
atom_tuple -> LPAREN yield_expr RPAREN . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_tuple -> LPAREN yield_expr RPAREN

State 284:
## Known stack suffix:
## tuple(namedexpr_or_star_expr)
## LR(1) items:
testlist_comp_or_expr -> tuple(namedexpr_or_star_expr) . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN
--   reduce production testlist_comp_or_expr -> tuple(namedexpr_or_star_expr)

State 285:
## Known stack suffix:
## LPAREN testlist_comp_or_expr
## LR(1) items:
atom_tuple -> LPAREN testlist_comp_or_expr . RPAREN [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
-- On RPAREN shift to state 286
## Reductions:

State 286:
## Known stack suffix:
## LPAREN testlist_comp_or_expr RPAREN
## LR(1) items:
atom_tuple -> LPAREN testlist_comp_or_expr RPAREN . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production atom_tuple -> LPAREN testlist_comp_or_expr RPAREN

State 287:
## Known stack suffix:
## namedexpr_or_star_expr
## LR(1) items:
testlist_comp_or_expr -> namedexpr_or_star_expr . comp_for [ RPAREN ]
tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr . [ RPAREN ]
tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr . COMMA [ RPAREN ]
tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr . COMMA tuple(namedexpr_or_star_expr) [ RPAREN ]
## Transitions:
-- On FOR shift to state 139
-- On COMMA shift to state 271
-- On ASYNC shift to state 167
-- On sync_comp_for shift to state 169
-- On comp_for shift to state 288
## Reductions:
-- On RPAREN
--   reduce production tuple(namedexpr_or_star_expr) -> namedexpr_or_star_expr

State 288:
## Known stack suffix:
## namedexpr_or_star_expr comp_for
## LR(1) items:
testlist_comp_or_expr -> namedexpr_or_star_expr comp_for . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN
--   reduce production testlist_comp_or_expr -> namedexpr_or_star_expr comp_for

State 289:
## Known stack suffix:
## SUB factor
## LR(1) items:
factor -> SUB factor . [ XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
--   reduce production factor -> SUB factor

State 290:
## Known stack suffix:
## YIELD FROM
## LR(1) items:
yield_expr -> YIELD FROM . test [ SEMICOL RPAREN NEWLINE EQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 291
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 291:
## Known stack suffix:
## YIELD FROM test
## LR(1) items:
yield_expr -> YIELD FROM test . [ SEMICOL RPAREN NEWLINE EQ ]
## Transitions:
## Reductions:
-- On SEMICOL RPAREN NEWLINE EQ
--   reduce production yield_expr -> YIELD FROM test

State 292:
## Known stack suffix:
## YIELD tuple(test)
## LR(1) items:
yield_expr -> YIELD tuple(test) . [ SEMICOL RPAREN NEWLINE EQ ]
## Transitions:
## Reductions:
-- On SEMICOL RPAREN NEWLINE EQ
--   reduce production yield_expr -> YIELD tuple(test)

State 293:
## Known stack suffix:
## WITH
## LR(1) items:
with_stmt -> WITH . with_inner [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On with_inner shift to state 294
-- On test shift to state 295
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 294:
## Known stack suffix:
## WITH with_inner
## LR(1) items:
with_stmt -> WITH with_inner . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production with_stmt -> WITH with_inner

State 295:
## Known stack suffix:
## test
## LR(1) items:
with_inner -> test . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
with_inner -> test . AS expr COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
with_inner -> test . COMMA with_inner [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
with_inner -> test . AS expr COMMA with_inner [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COMMA shift to state 296
-- On COLON shift to state 298
-- On AS shift to state 582
## Reductions:

State 296:
## Known stack suffix:
## test COMMA
## LR(1) items:
with_inner -> test COMMA . with_inner [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On with_inner shift to state 297
-- On test shift to state 295
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 297:
## Known stack suffix:
## test COMMA with_inner
## LR(1) items:
with_inner -> test COMMA with_inner . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production with_inner -> test COMMA with_inner

State 298:
## Known stack suffix:
## test COLON
## LR(1) items:
with_inner -> test COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 581
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 299:
## Known stack suffix:
## RETURN
## LR(1) items:
return_stmt -> RETURN . [ SEMICOL NEWLINE ]
return_stmt -> RETURN . tuple(test) [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(test) shift to state 300
-- On test shift to state 200
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production return_stmt -> RETURN

State 300:
## Known stack suffix:
## RETURN tuple(test)
## LR(1) items:
return_stmt -> RETURN tuple(test) . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production return_stmt -> RETURN tuple(test)

State 301:
## Known stack suffix:
## RAISE
## LR(1) items:
raise_stmt -> RAISE . [ SEMICOL NEWLINE ]
raise_stmt -> RAISE . test [ SEMICOL NEWLINE ]
raise_stmt -> RAISE . test FROM test [ SEMICOL NEWLINE ]
raise_stmt -> RAISE . test COMMA test [ SEMICOL NEWLINE ]
raise_stmt -> RAISE . test COMMA test COMMA test [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 302
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production raise_stmt -> RAISE

State 302:
## Known stack suffix:
## RAISE test
## LR(1) items:
raise_stmt -> RAISE test . [ SEMICOL NEWLINE ]
raise_stmt -> RAISE test . FROM test [ SEMICOL NEWLINE ]
raise_stmt -> RAISE test . COMMA test [ SEMICOL NEWLINE ]
raise_stmt -> RAISE test . COMMA test COMMA test [ SEMICOL NEWLINE ]
## Transitions:
-- On FROM shift to state 303
-- On COMMA shift to state 305
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production raise_stmt -> RAISE test

State 303:
## Known stack suffix:
## RAISE test FROM
## LR(1) items:
raise_stmt -> RAISE test FROM . test [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 304
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 304:
## Known stack suffix:
## RAISE test FROM test
## LR(1) items:
raise_stmt -> RAISE test FROM test . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production raise_stmt -> RAISE test FROM test

State 305:
## Known stack suffix:
## RAISE test COMMA
## LR(1) items:
raise_stmt -> RAISE test COMMA . test [ SEMICOL NEWLINE ]
raise_stmt -> RAISE test COMMA . test COMMA test [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 306
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 306:
## Known stack suffix:
## RAISE test COMMA test
## LR(1) items:
raise_stmt -> RAISE test COMMA test . [ SEMICOL NEWLINE ]
raise_stmt -> RAISE test COMMA test . COMMA test [ SEMICOL NEWLINE ]
## Transitions:
-- On COMMA shift to state 307
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production raise_stmt -> RAISE test COMMA test

State 307:
## Known stack suffix:
## RAISE test COMMA test COMMA
## LR(1) items:
raise_stmt -> RAISE test COMMA test COMMA . test [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 308
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 308:
## Known stack suffix:
## RAISE test COMMA test COMMA test
## LR(1) items:
raise_stmt -> RAISE test COMMA test COMMA test . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production raise_stmt -> RAISE test COMMA test COMMA test

State 309:
## Known stack suffix:
## PRINT
## LR(1) items:
print_stmt -> PRINT . [ SEMICOL NEWLINE ]
print_stmt -> PRINT . test print_testlist [ SEMICOL NEWLINE ]
print_stmt -> PRINT . RSHIFT test [ SEMICOL NEWLINE ]
print_stmt -> PRINT . RSHIFT test COMMA test print_testlist [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RSHIFT shift to state 310
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 318
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production print_stmt -> PRINT

State 310:
## Known stack suffix:
## PRINT RSHIFT
## LR(1) items:
print_stmt -> PRINT RSHIFT . test [ SEMICOL NEWLINE ]
print_stmt -> PRINT RSHIFT . test COMMA test print_testlist [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 311
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 311:
## Known stack suffix:
## PRINT RSHIFT test
## LR(1) items:
print_stmt -> PRINT RSHIFT test . [ SEMICOL NEWLINE ]
print_stmt -> PRINT RSHIFT test . COMMA test print_testlist [ SEMICOL NEWLINE ]
## Transitions:
-- On COMMA shift to state 312
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production print_stmt -> PRINT RSHIFT test

State 312:
## Known stack suffix:
## PRINT RSHIFT test COMMA
## LR(1) items:
print_stmt -> PRINT RSHIFT test COMMA . test print_testlist [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 313
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 313:
## Known stack suffix:
## PRINT RSHIFT test COMMA test
## LR(1) items:
print_stmt -> PRINT RSHIFT test COMMA test . print_testlist [ SEMICOL NEWLINE ]
## Transitions:
-- On COMMA shift to state 314
-- On print_testlist shift to state 317
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production print_testlist ->

State 314:
## Known stack suffix:
## COMMA
## LR(1) items:
print_testlist -> COMMA . [ SEMICOL NEWLINE ]
print_testlist -> COMMA . test print_testlist [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 315
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production print_testlist -> COMMA

State 315:
## Known stack suffix:
## COMMA test
## LR(1) items:
print_testlist -> COMMA test . print_testlist [ SEMICOL NEWLINE ]
## Transitions:
-- On COMMA shift to state 314
-- On print_testlist shift to state 316
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production print_testlist ->

State 316:
## Known stack suffix:
## COMMA test print_testlist
## LR(1) items:
print_testlist -> COMMA test print_testlist . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production print_testlist -> COMMA test print_testlist

State 317:
## Known stack suffix:
## PRINT RSHIFT test COMMA test print_testlist
## LR(1) items:
print_stmt -> PRINT RSHIFT test COMMA test print_testlist . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production print_stmt -> PRINT RSHIFT test COMMA test print_testlist

State 318:
## Known stack suffix:
## PRINT test
## LR(1) items:
print_stmt -> PRINT test . print_testlist [ SEMICOL NEWLINE ]
## Transitions:
-- On COMMA shift to state 314
-- On print_testlist shift to state 319
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production print_testlist ->

State 319:
## Known stack suffix:
## PRINT test print_testlist
## LR(1) items:
print_stmt -> PRINT test print_testlist . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production print_stmt -> PRINT test print_testlist

State 320:
## Known stack suffix:
## PASS
## LR(1) items:
pass_stmt -> PASS . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production pass_stmt -> PASS

State 321:
## Known stack suffix:
## NONLOCAL
## LR(1) items:
nonlocal_stmt -> NONLOCAL . list_sep(NAME,COMMA) [ SEMICOL NEWLINE ]
## Transitions:
-- On NAME shift to state 322
-- On list_sep(NAME,COMMA) shift to state 323
## Reductions:

State 322:
## Known stack suffix:
## NAME
## LR(1) items:
list_sep(NAME,COMMA) -> NAME . [ SEMICOL NEWLINE COMMA ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE COMMA
--   reduce production list_sep(NAME,COMMA) -> NAME

State 323:
## Known stack suffix:
## NONLOCAL list_sep(NAME,COMMA)
## LR(1) items:
list_sep(NAME,COMMA) -> list_sep(NAME,COMMA) . COMMA NAME [ SEMICOL NEWLINE COMMA ]
nonlocal_stmt -> NONLOCAL list_sep(NAME,COMMA) . [ SEMICOL NEWLINE ]
## Transitions:
-- On COMMA shift to state 324
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production nonlocal_stmt -> NONLOCAL list_sep(NAME,COMMA)

State 324:
## Known stack suffix:
## list_sep(NAME,COMMA) COMMA
## LR(1) items:
list_sep(NAME,COMMA) -> list_sep(NAME,COMMA) COMMA . NAME [ SEMICOL NEWLINE COMMA ]
## Transitions:
-- On NAME shift to state 325
## Reductions:

State 325:
## Known stack suffix:
## list_sep(NAME,COMMA) COMMA NAME
## LR(1) items:
list_sep(NAME,COMMA) -> list_sep(NAME,COMMA) COMMA NAME . [ SEMICOL NEWLINE COMMA ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE COMMA
--   reduce production list_sep(NAME,COMMA) -> list_sep(NAME,COMMA) COMMA NAME

State 326:
## Known stack suffix:
## NEWLINE
## LR(1) items:
suite -> NEWLINE . INDENT list(stmt) DEDENT [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On INDENT shift to state 327
## Reductions:

State 327:
## Known stack suffix:
## NEWLINE INDENT
## LR(1) items:
suite -> NEWLINE INDENT . list(stmt) DEDENT [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On WITH shift to state 293
-- On WHILE shift to state 328
-- On TRY shift to state 443
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On IF shift to state 475
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FOR shift to state 488
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On DEF shift to state 497
-- On CONTINUE shift to state 377
-- On CLASS shift to state 529
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On AT shift to state 538
-- On ASYNC shift to state 549
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On with_stmt shift to state 553
-- On while_stmt shift to state 554
-- On tuple(test_or_star_expr) shift to state 385
-- On try_stmt shift to state 555
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On string shift to state 34
-- On stmt shift to state 556
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 557
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On nonempty_list(decorator) shift to state 558
-- On list(stmt) shift to state 579
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On if_stmt shift to state 570
-- On global_stmt shift to state 433
-- On funcdef shift to state 571
-- On for_stmt shift to state 572
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On decorator shift to state 573
-- On decorated shift to state 575
-- On continue_stmt shift to state 438
-- On compound_stmt shift to state 576
-- On comparison shift to state 112
-- On classdef shift to state 577
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On async_stmt shift to state 578
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On DEDENT
--   reduce production list(stmt) ->

State 328:
## Known stack suffix:
## WHILE
## LR(1) items:
while_stmt -> WHILE . namedexpr_test COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
while_stmt -> WHILE . namedexpr_test COLON suite ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 255
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On namedexpr_test shift to state 329
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 329:
## Known stack suffix:
## WHILE namedexpr_test
## LR(1) items:
while_stmt -> WHILE namedexpr_test . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
while_stmt -> WHILE namedexpr_test . COLON suite ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 330
## Reductions:

State 330:
## Known stack suffix:
## WHILE namedexpr_test COLON
## LR(1) items:
while_stmt -> WHILE namedexpr_test COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
while_stmt -> WHILE namedexpr_test COLON . suite ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 417
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 331:
## Known stack suffix:
## IMPORT
## LR(1) items:
import_name -> IMPORT . list_sep(dotted_as_name,COMMA) [ SEMICOL NEWLINE ]
## Transitions:
-- On NAME shift to state 332
-- On list_sep(dotted_as_name,COMMA) shift to state 335
-- On dotted_name shift to state 337
-- On dotted_as_name shift to state 341
## Reductions:

State 332:
## Known stack suffix:
## NAME
## LR(1) items:
dotted_name -> NAME . [ SEMICOL NEWLINE IMPORT COMMA AS ]
dotted_name -> NAME . DOT dotted_name [ SEMICOL NEWLINE IMPORT COMMA AS ]
## Transitions:
-- On DOT shift to state 333
## Reductions:
-- On SEMICOL NEWLINE IMPORT COMMA AS
--   reduce production dotted_name -> NAME

State 333:
## Known stack suffix:
## NAME DOT
## LR(1) items:
dotted_name -> NAME DOT . dotted_name [ SEMICOL NEWLINE IMPORT COMMA AS ]
## Transitions:
-- On NAME shift to state 332
-- On dotted_name shift to state 334
## Reductions:

State 334:
## Known stack suffix:
## NAME DOT dotted_name
## LR(1) items:
dotted_name -> NAME DOT dotted_name . [ SEMICOL NEWLINE IMPORT COMMA AS ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE IMPORT COMMA AS
--   reduce production dotted_name -> NAME DOT dotted_name

State 335:
## Known stack suffix:
## IMPORT list_sep(dotted_as_name,COMMA)
## LR(1) items:
import_name -> IMPORT list_sep(dotted_as_name,COMMA) . [ SEMICOL NEWLINE ]
list_sep(dotted_as_name,COMMA) -> list_sep(dotted_as_name,COMMA) . COMMA dotted_as_name [ SEMICOL NEWLINE COMMA ]
## Transitions:
-- On COMMA shift to state 336
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production import_name -> IMPORT list_sep(dotted_as_name,COMMA)

State 336:
## Known stack suffix:
## list_sep(dotted_as_name,COMMA) COMMA
## LR(1) items:
list_sep(dotted_as_name,COMMA) -> list_sep(dotted_as_name,COMMA) COMMA . dotted_as_name [ SEMICOL NEWLINE COMMA ]
## Transitions:
-- On NAME shift to state 332
-- On dotted_name shift to state 337
-- On dotted_as_name shift to state 340
## Reductions:

State 337:
## Known stack suffix:
## dotted_name
## LR(1) items:
dotted_as_name -> dotted_name . [ SEMICOL NEWLINE COMMA ]
dotted_as_name -> dotted_name . AS NAME [ SEMICOL NEWLINE COMMA ]
## Transitions:
-- On AS shift to state 338
## Reductions:
-- On SEMICOL NEWLINE COMMA
--   reduce production dotted_as_name -> dotted_name

State 338:
## Known stack suffix:
## dotted_name AS
## LR(1) items:
dotted_as_name -> dotted_name AS . NAME [ SEMICOL NEWLINE COMMA ]
## Transitions:
-- On NAME shift to state 339
## Reductions:

State 339:
## Known stack suffix:
## dotted_name AS NAME
## LR(1) items:
dotted_as_name -> dotted_name AS NAME . [ SEMICOL NEWLINE COMMA ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE COMMA
--   reduce production dotted_as_name -> dotted_name AS NAME

State 340:
## Known stack suffix:
## list_sep(dotted_as_name,COMMA) COMMA dotted_as_name
## LR(1) items:
list_sep(dotted_as_name,COMMA) -> list_sep(dotted_as_name,COMMA) COMMA dotted_as_name . [ SEMICOL NEWLINE COMMA ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE COMMA
--   reduce production list_sep(dotted_as_name,COMMA) -> list_sep(dotted_as_name,COMMA) COMMA dotted_as_name

State 341:
## Known stack suffix:
## dotted_as_name
## LR(1) items:
list_sep(dotted_as_name,COMMA) -> dotted_as_name . [ SEMICOL NEWLINE COMMA ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE COMMA
--   reduce production list_sep(dotted_as_name,COMMA) -> dotted_as_name

State 342:
## Known stack suffix:
## GLOBAL
## LR(1) items:
global_stmt -> GLOBAL . list_sep(NAME,COMMA) [ SEMICOL NEWLINE ]
## Transitions:
-- On NAME shift to state 322
-- On list_sep(NAME,COMMA) shift to state 343
## Reductions:

State 343:
## Known stack suffix:
## GLOBAL list_sep(NAME,COMMA)
## LR(1) items:
global_stmt -> GLOBAL list_sep(NAME,COMMA) . [ SEMICOL NEWLINE ]
list_sep(NAME,COMMA) -> list_sep(NAME,COMMA) . COMMA NAME [ SEMICOL NEWLINE COMMA ]
## Transitions:
-- On COMMA shift to state 324
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production global_stmt -> GLOBAL list_sep(NAME,COMMA)

State 344:
## Known stack suffix:
## FROM
## LR(1) items:
import_from -> FROM . name_and_level IMPORT MULT [ SEMICOL NEWLINE ]
import_from -> FROM . name_and_level IMPORT LPAREN list_comma(import_as_name) RPAREN [ SEMICOL NEWLINE ]
import_from -> FROM . name_and_level IMPORT list_comma(import_as_name) [ SEMICOL NEWLINE ]
## Transitions:
-- On ELLIPSES shift to state 345
-- On DOT shift to state 351
-- On name_and_level shift to state 353
-- On dot_level shift to state 367
## Reductions:
-- On NAME
--   reduce production dot_level ->

State 345:
## Known stack suffix:
## ELLIPSES
## LR(1) items:
dot_level -> ELLIPSES . dot_level [ NAME ]
name_and_level -> ELLIPSES . dot_level [ IMPORT ]
## Transitions:
-- On ELLIPSES shift to state 346
-- On DOT shift to state 347
-- On dot_level shift to state 350
## Reductions:
-- On NAME IMPORT
--   reduce production dot_level ->

State 346:
## Known stack suffix:
## ELLIPSES
## LR(1) items:
dot_level -> ELLIPSES . dot_level [ NAME IMPORT ]
## Transitions:
-- On ELLIPSES shift to state 346
-- On DOT shift to state 347
-- On dot_level shift to state 349
## Reductions:
-- On NAME IMPORT
--   reduce production dot_level ->

State 347:
## Known stack suffix:
## DOT
## LR(1) items:
dot_level -> DOT . dot_level [ NAME IMPORT ]
## Transitions:
-- On ELLIPSES shift to state 346
-- On DOT shift to state 347
-- On dot_level shift to state 348
## Reductions:
-- On NAME IMPORT
--   reduce production dot_level ->

State 348:
## Known stack suffix:
## DOT dot_level
## LR(1) items:
dot_level -> DOT dot_level . [ NAME IMPORT ]
## Transitions:
## Reductions:
-- On NAME IMPORT
--   reduce production dot_level -> DOT dot_level

State 349:
## Known stack suffix:
## ELLIPSES dot_level
## LR(1) items:
dot_level -> ELLIPSES dot_level . [ NAME IMPORT ]
## Transitions:
## Reductions:
-- On NAME IMPORT
--   reduce production dot_level -> ELLIPSES dot_level

State 350:
## Known stack suffix:
## ELLIPSES dot_level
## LR(1) items:
dot_level -> ELLIPSES dot_level . [ NAME ]
name_and_level -> ELLIPSES dot_level . [ IMPORT ]
## Transitions:
## Reductions:
-- On NAME
--   reduce production dot_level -> ELLIPSES dot_level
-- On IMPORT
--   reduce production name_and_level -> ELLIPSES dot_level

State 351:
## Known stack suffix:
## DOT
## LR(1) items:
dot_level -> DOT . dot_level [ NAME ]
name_and_level -> DOT . dot_level [ IMPORT ]
## Transitions:
-- On ELLIPSES shift to state 346
-- On DOT shift to state 347
-- On dot_level shift to state 352
## Reductions:
-- On NAME IMPORT
--   reduce production dot_level ->

State 352:
## Known stack suffix:
## DOT dot_level
## LR(1) items:
dot_level -> DOT dot_level . [ NAME ]
name_and_level -> DOT dot_level . [ IMPORT ]
## Transitions:
## Reductions:
-- On NAME
--   reduce production dot_level -> DOT dot_level
-- On IMPORT
--   reduce production name_and_level -> DOT dot_level

State 353:
## Known stack suffix:
## FROM name_and_level
## LR(1) items:
import_from -> FROM name_and_level . IMPORT MULT [ SEMICOL NEWLINE ]
import_from -> FROM name_and_level . IMPORT LPAREN list_comma(import_as_name) RPAREN [ SEMICOL NEWLINE ]
import_from -> FROM name_and_level . IMPORT list_comma(import_as_name) [ SEMICOL NEWLINE ]
## Transitions:
-- On IMPORT shift to state 354
## Reductions:

State 354:
## Known stack suffix:
## FROM name_and_level IMPORT
## LR(1) items:
import_from -> FROM name_and_level IMPORT . MULT [ SEMICOL NEWLINE ]
import_from -> FROM name_and_level IMPORT . LPAREN list_comma(import_as_name) RPAREN [ SEMICOL NEWLINE ]
import_from -> FROM name_and_level IMPORT . list_comma(import_as_name) [ SEMICOL NEWLINE ]
## Transitions:
-- On NAME shift to state 355
-- On MULT shift to state 358
-- On LPAREN shift to state 359
-- On list_sep_term(import_as_name,COMMA) shift to state 360
-- On list_comma(import_as_name) shift to state 366
-- On import_as_name shift to state 363
## Reductions:

State 355:
## Known stack suffix:
## NAME
## LR(1) items:
import_as_name -> NAME . [ SEMICOL RPAREN NEWLINE COMMA ]
import_as_name -> NAME . AS NAME [ SEMICOL RPAREN NEWLINE COMMA ]
## Transitions:
-- On AS shift to state 356
## Reductions:
-- On SEMICOL RPAREN NEWLINE COMMA
--   reduce production import_as_name -> NAME

State 356:
## Known stack suffix:
## NAME AS
## LR(1) items:
import_as_name -> NAME AS . NAME [ SEMICOL RPAREN NEWLINE COMMA ]
## Transitions:
-- On NAME shift to state 357
## Reductions:

State 357:
## Known stack suffix:
## NAME AS NAME
## LR(1) items:
import_as_name -> NAME AS NAME . [ SEMICOL RPAREN NEWLINE COMMA ]
## Transitions:
## Reductions:
-- On SEMICOL RPAREN NEWLINE COMMA
--   reduce production import_as_name -> NAME AS NAME

State 358:
## Known stack suffix:
## FROM name_and_level IMPORT MULT
## LR(1) items:
import_from -> FROM name_and_level IMPORT MULT . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production import_from -> FROM name_and_level IMPORT MULT

State 359:
## Known stack suffix:
## FROM name_and_level IMPORT LPAREN
## LR(1) items:
import_from -> FROM name_and_level IMPORT LPAREN . list_comma(import_as_name) RPAREN [ SEMICOL NEWLINE ]
## Transitions:
-- On NAME shift to state 355
-- On list_sep_term(import_as_name,COMMA) shift to state 360
-- On list_comma(import_as_name) shift to state 361
-- On import_as_name shift to state 363
## Reductions:

State 360:
## Known stack suffix:
## list_sep_term(import_as_name,COMMA)
## LR(1) items:
list_comma(import_as_name) -> list_sep_term(import_as_name,COMMA) . [ SEMICOL RPAREN NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL RPAREN NEWLINE
--   reduce production list_comma(import_as_name) -> list_sep_term(import_as_name,COMMA)

State 361:
## Known stack suffix:
## FROM name_and_level IMPORT LPAREN list_comma(import_as_name)
## LR(1) items:
import_from -> FROM name_and_level IMPORT LPAREN list_comma(import_as_name) . RPAREN [ SEMICOL NEWLINE ]
## Transitions:
-- On RPAREN shift to state 362
## Reductions:

State 362:
## Known stack suffix:
## FROM name_and_level IMPORT LPAREN list_comma(import_as_name) RPAREN
## LR(1) items:
import_from -> FROM name_and_level IMPORT LPAREN list_comma(import_as_name) RPAREN . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production import_from -> FROM name_and_level IMPORT LPAREN list_comma(import_as_name) RPAREN

State 363:
## Known stack suffix:
## import_as_name
## LR(1) items:
list_sep_term(import_as_name,COMMA) -> import_as_name . [ SEMICOL RPAREN NEWLINE ]
list_sep_term(import_as_name,COMMA) -> import_as_name . COMMA [ SEMICOL RPAREN NEWLINE ]
list_sep_term(import_as_name,COMMA) -> import_as_name . COMMA list_sep_term(import_as_name,COMMA) [ SEMICOL RPAREN NEWLINE ]
## Transitions:
-- On COMMA shift to state 364
## Reductions:
-- On SEMICOL RPAREN NEWLINE
--   reduce production list_sep_term(import_as_name,COMMA) -> import_as_name

State 364:
## Known stack suffix:
## import_as_name COMMA
## LR(1) items:
list_sep_term(import_as_name,COMMA) -> import_as_name COMMA . [ SEMICOL RPAREN NEWLINE ]
list_sep_term(import_as_name,COMMA) -> import_as_name COMMA . list_sep_term(import_as_name,COMMA) [ SEMICOL RPAREN NEWLINE ]
## Transitions:
-- On NAME shift to state 355
-- On list_sep_term(import_as_name,COMMA) shift to state 365
-- On import_as_name shift to state 363
## Reductions:
-- On SEMICOL RPAREN NEWLINE
--   reduce production list_sep_term(import_as_name,COMMA) -> import_as_name COMMA

State 365:
## Known stack suffix:
## import_as_name COMMA list_sep_term(import_as_name,COMMA)
## LR(1) items:
list_sep_term(import_as_name,COMMA) -> import_as_name COMMA list_sep_term(import_as_name,COMMA) . [ SEMICOL RPAREN NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL RPAREN NEWLINE
--   reduce production list_sep_term(import_as_name,COMMA) -> import_as_name COMMA list_sep_term(import_as_name,COMMA)

State 366:
## Known stack suffix:
## FROM name_and_level IMPORT list_comma(import_as_name)
## LR(1) items:
import_from -> FROM name_and_level IMPORT list_comma(import_as_name) . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production import_from -> FROM name_and_level IMPORT list_comma(import_as_name)

State 367:
## Known stack suffix:
## dot_level
## LR(1) items:
name_and_level -> dot_level . dotted_name [ IMPORT ]
## Transitions:
-- On NAME shift to state 332
-- On dotted_name shift to state 368
## Reductions:

State 368:
## Known stack suffix:
## dot_level dotted_name
## LR(1) items:
name_and_level -> dot_level dotted_name . [ IMPORT ]
## Transitions:
## Reductions:
-- On IMPORT
--   reduce production name_and_level -> dot_level dotted_name

State 369:
## Known stack suffix:
## EXEC
## LR(1) items:
exec_stmt -> EXEC . expr [ SEMICOL NEWLINE ]
exec_stmt -> EXEC . expr IN test [ SEMICOL NEWLINE ]
exec_stmt -> EXEC . expr IN test COMMA test [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On expr shift to state 370
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 370:
## Known stack suffix:
## EXEC expr
## LR(1) items:
exec_stmt -> EXEC expr . [ SEMICOL NEWLINE ]
exec_stmt -> EXEC expr . IN test [ SEMICOL NEWLINE ]
exec_stmt -> EXEC expr . IN test COMMA test [ SEMICOL NEWLINE ]
expr -> expr . BITOR xor_expr [ SEMICOL NEWLINE IN BITOR ]
## Transitions:
-- On IN shift to state 371
-- On BITOR shift to state 104
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production exec_stmt -> EXEC expr

State 371:
## Known stack suffix:
## EXEC expr IN
## LR(1) items:
exec_stmt -> EXEC expr IN . test [ SEMICOL NEWLINE ]
exec_stmt -> EXEC expr IN . test COMMA test [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 372
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 372:
## Known stack suffix:
## EXEC expr IN test
## LR(1) items:
exec_stmt -> EXEC expr IN test . [ SEMICOL NEWLINE ]
exec_stmt -> EXEC expr IN test . COMMA test [ SEMICOL NEWLINE ]
## Transitions:
-- On COMMA shift to state 373
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production exec_stmt -> EXEC expr IN test

State 373:
## Known stack suffix:
## EXEC expr IN test COMMA
## LR(1) items:
exec_stmt -> EXEC expr IN test COMMA . test [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 374
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 374:
## Known stack suffix:
## EXEC expr IN test COMMA test
## LR(1) items:
exec_stmt -> EXEC expr IN test COMMA test . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production exec_stmt -> EXEC expr IN test COMMA test

State 375:
## Known stack suffix:
## DEL
## LR(1) items:
del_stmt -> DEL . exprlist [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(expr_or_star_expr) shift to state 140
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 141
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On exprlist shift to state 376
-- On expr_or_star_expr shift to state 174
-- On expr shift to state 177
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 376:
## Known stack suffix:
## DEL exprlist
## LR(1) items:
del_stmt -> DEL exprlist . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production del_stmt -> DEL exprlist

State 377:
## Known stack suffix:
## CONTINUE
## LR(1) items:
continue_stmt -> CONTINUE . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production continue_stmt -> CONTINUE

State 378:
## Known stack suffix:
## BREAK
## LR(1) items:
break_stmt -> BREAK . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production break_stmt -> BREAK

State 379:
## Known stack suffix:
## ASSERT
## LR(1) items:
assert_stmt -> ASSERT . test [ SEMICOL NEWLINE ]
assert_stmt -> ASSERT . test COMMA test [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 380
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 380:
## Known stack suffix:
## ASSERT test
## LR(1) items:
assert_stmt -> ASSERT test . [ SEMICOL NEWLINE ]
assert_stmt -> ASSERT test . COMMA test [ SEMICOL NEWLINE ]
## Transitions:
-- On COMMA shift to state 381
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production assert_stmt -> ASSERT test

State 381:
## Known stack suffix:
## ASSERT test COMMA
## LR(1) items:
assert_stmt -> ASSERT test COMMA . test [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 382
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 382:
## Known stack suffix:
## ASSERT test COMMA test
## LR(1) items:
assert_stmt -> ASSERT test COMMA test . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production assert_stmt -> ASSERT test COMMA test

State 383:
## Known stack suffix:
## yield_stmt
## LR(1) items:
flow_stmt -> yield_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production flow_stmt -> yield_stmt

State 384:
## Known stack suffix:
## yield_expr
## LR(1) items:
yield_stmt -> yield_expr . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production yield_stmt -> yield_expr

State 385:
## Known stack suffix:
## tuple(test_or_star_expr)
## LR(1) items:
expr_stmt -> tuple(test_or_star_expr) . [ SEMICOL NEWLINE ]
expr_stmt -> tuple(test_or_star_expr) . COLON test [ SEMICOL NEWLINE ]
expr_stmt -> tuple(test_or_star_expr) . COLON test EQ test [ SEMICOL NEWLINE ]
expr_stmt -> tuple(test_or_star_expr) . augassign yield_expr [ SEMICOL NEWLINE ]
expr_stmt -> tuple(test_or_star_expr) . augassign tuple(test) [ SEMICOL NEWLINE ]
expr_stmt -> tuple(test_or_star_expr) . EQ expr_stmt_rhs_list [ SEMICOL NEWLINE ]
## Transitions:
-- On XOREQ shift to state 386
-- On SUBEQ shift to state 387
-- On RSHEQ shift to state 388
-- On POWEQ shift to state 389
-- On OREQ shift to state 390
-- On MULTEQ shift to state 391
-- On MODEQ shift to state 392
-- On LSHEQ shift to state 393
-- On FDIVEQ shift to state 394
-- On EQ shift to state 395
-- On DIVEQ shift to state 407
-- On COLON shift to state 408
-- On ANDEQ shift to state 412
-- On ADDEQ shift to state 413
-- On augassign shift to state 414
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production expr_stmt -> tuple(test_or_star_expr)

State 386:
## Known stack suffix:
## XOREQ
## LR(1) items:
augassign -> XOREQ . [ YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production augassign -> XOREQ

State 387:
## Known stack suffix:
## SUBEQ
## LR(1) items:
augassign -> SUBEQ . [ YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production augassign -> SUBEQ

State 388:
## Known stack suffix:
## RSHEQ
## LR(1) items:
augassign -> RSHEQ . [ YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production augassign -> RSHEQ

State 389:
## Known stack suffix:
## POWEQ
## LR(1) items:
augassign -> POWEQ . [ YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production augassign -> POWEQ

State 390:
## Known stack suffix:
## OREQ
## LR(1) items:
augassign -> OREQ . [ YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production augassign -> OREQ

State 391:
## Known stack suffix:
## MULTEQ
## LR(1) items:
augassign -> MULTEQ . [ YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production augassign -> MULTEQ

State 392:
## Known stack suffix:
## MODEQ
## LR(1) items:
augassign -> MODEQ . [ YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production augassign -> MODEQ

State 393:
## Known stack suffix:
## LSHEQ
## LR(1) items:
augassign -> LSHEQ . [ YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production augassign -> LSHEQ

State 394:
## Known stack suffix:
## FDIVEQ
## LR(1) items:
augassign -> FDIVEQ . [ YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production augassign -> FDIVEQ

State 395:
## Known stack suffix:
## tuple(test_or_star_expr) EQ
## LR(1) items:
expr_stmt -> tuple(test_or_star_expr) EQ . expr_stmt_rhs_list [ SEMICOL NEWLINE ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On yield_expr shift to state 396
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 397
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 402
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr_stmt_rhs_list shift to state 403
-- On expr_stmt_rhs shift to state 404
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 396:
## Known stack suffix:
## yield_expr
## LR(1) items:
expr_stmt_rhs -> yield_expr . [ SEMICOL NEWLINE EQ ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE EQ
--   reduce production expr_stmt_rhs -> yield_expr

State 397:
## Known stack suffix:
## tuple(test_or_star_expr)
## LR(1) items:
expr_stmt_rhs -> tuple(test_or_star_expr) . [ SEMICOL NEWLINE EQ ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE EQ
--   reduce production expr_stmt_rhs -> tuple(test_or_star_expr)

State 398:
## Known stack suffix:
## test_or_star_expr
## LR(1) items:
tuple(test_or_star_expr) -> test_or_star_expr . [ XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COLON ANDEQ ADDEQ ]
tuple(test_or_star_expr) -> test_or_star_expr . COMMA [ XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COLON ANDEQ ADDEQ ]
tuple(test_or_star_expr) -> test_or_star_expr . COMMA tuple(test_or_star_expr) [ XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COLON ANDEQ ADDEQ ]
## Transitions:
-- On COMMA shift to state 399
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COLON ANDEQ ADDEQ
--   reduce production tuple(test_or_star_expr) -> test_or_star_expr

State 399:
## Known stack suffix:
## test_or_star_expr COMMA
## LR(1) items:
tuple(test_or_star_expr) -> test_or_star_expr COMMA . [ XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COLON ANDEQ ADDEQ ]
tuple(test_or_star_expr) -> test_or_star_expr COMMA . tuple(test_or_star_expr) [ XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COLON ANDEQ ADDEQ ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 400
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 402
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COLON ANDEQ ADDEQ
--   reduce production tuple(test_or_star_expr) -> test_or_star_expr COMMA

State 400:
## Known stack suffix:
## test_or_star_expr COMMA tuple(test_or_star_expr)
## LR(1) items:
tuple(test_or_star_expr) -> test_or_star_expr COMMA tuple(test_or_star_expr) . [ XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COLON ANDEQ ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COLON ANDEQ ADDEQ
--   reduce production tuple(test_or_star_expr) -> test_or_star_expr COMMA tuple(test_or_star_expr)

State 401:
## Known stack suffix:
## test
## LR(1) items:
test_or_star_expr -> test . [ XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COMMA COLON ANDEQ ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COMMA COLON ANDEQ ADDEQ
--   reduce production test_or_star_expr -> test

State 402:
## Known stack suffix:
## star_expr
## LR(1) items:
test_or_star_expr -> star_expr . [ XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COMMA COLON ANDEQ ADDEQ ]
## Transitions:
## Reductions:
-- On XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COMMA COLON ANDEQ ADDEQ
--   reduce production test_or_star_expr -> star_expr

State 403:
## Known stack suffix:
## tuple(test_or_star_expr) EQ expr_stmt_rhs_list
## LR(1) items:
expr_stmt -> tuple(test_or_star_expr) EQ expr_stmt_rhs_list . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production expr_stmt -> tuple(test_or_star_expr) EQ expr_stmt_rhs_list

State 404:
## Known stack suffix:
## expr_stmt_rhs
## LR(1) items:
expr_stmt_rhs_list -> expr_stmt_rhs . [ SEMICOL NEWLINE ]
expr_stmt_rhs_list -> expr_stmt_rhs . EQ expr_stmt_rhs_list [ SEMICOL NEWLINE ]
## Transitions:
-- On EQ shift to state 405
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production expr_stmt_rhs_list -> expr_stmt_rhs

State 405:
## Known stack suffix:
## expr_stmt_rhs EQ
## LR(1) items:
expr_stmt_rhs_list -> expr_stmt_rhs EQ . expr_stmt_rhs_list [ SEMICOL NEWLINE ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On yield_expr shift to state 396
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 397
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 402
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr_stmt_rhs_list shift to state 406
-- On expr_stmt_rhs shift to state 404
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 406:
## Known stack suffix:
## expr_stmt_rhs EQ expr_stmt_rhs_list
## LR(1) items:
expr_stmt_rhs_list -> expr_stmt_rhs EQ expr_stmt_rhs_list . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production expr_stmt_rhs_list -> expr_stmt_rhs EQ expr_stmt_rhs_list

State 407:
## Known stack suffix:
## DIVEQ
## LR(1) items:
augassign -> DIVEQ . [ YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production augassign -> DIVEQ

State 408:
## Known stack suffix:
## tuple(test_or_star_expr) COLON
## LR(1) items:
expr_stmt -> tuple(test_or_star_expr) COLON . test [ SEMICOL NEWLINE ]
expr_stmt -> tuple(test_or_star_expr) COLON . test EQ test [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 409
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 409:
## Known stack suffix:
## tuple(test_or_star_expr) COLON test
## LR(1) items:
expr_stmt -> tuple(test_or_star_expr) COLON test . [ SEMICOL NEWLINE ]
expr_stmt -> tuple(test_or_star_expr) COLON test . EQ test [ SEMICOL NEWLINE ]
## Transitions:
-- On EQ shift to state 410
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production expr_stmt -> tuple(test_or_star_expr) COLON test

State 410:
## Known stack suffix:
## tuple(test_or_star_expr) COLON test EQ
## LR(1) items:
expr_stmt -> tuple(test_or_star_expr) COLON test EQ . test [ SEMICOL NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 411
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 411:
## Known stack suffix:
## tuple(test_or_star_expr) COLON test EQ test
## LR(1) items:
expr_stmt -> tuple(test_or_star_expr) COLON test EQ test . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production expr_stmt -> tuple(test_or_star_expr) COLON test EQ test

State 412:
## Known stack suffix:
## ANDEQ
## LR(1) items:
augassign -> ANDEQ . [ YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production augassign -> ANDEQ

State 413:
## Known stack suffix:
## ADDEQ
## LR(1) items:
augassign -> ADDEQ . [ YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD ]
## Transitions:
## Reductions:
-- On YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
--   reduce production augassign -> ADDEQ

State 414:
## Known stack suffix:
## tuple(test_or_star_expr) augassign
## LR(1) items:
expr_stmt -> tuple(test_or_star_expr) augassign . yield_expr [ SEMICOL NEWLINE ]
expr_stmt -> tuple(test_or_star_expr) augassign . tuple(test) [ SEMICOL NEWLINE ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On yield_expr shift to state 415
-- On xor_expr shift to state 53
-- On tuple(test) shift to state 416
-- On test shift to state 200
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 415:
## Known stack suffix:
## tuple(test_or_star_expr) augassign yield_expr
## LR(1) items:
expr_stmt -> tuple(test_or_star_expr) augassign yield_expr . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production expr_stmt -> tuple(test_or_star_expr) augassign yield_expr

State 416:
## Known stack suffix:
## tuple(test_or_star_expr) augassign tuple(test)
## LR(1) items:
expr_stmt -> tuple(test_or_star_expr) augassign tuple(test) . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production expr_stmt -> tuple(test_or_star_expr) augassign tuple(test)

State 417:
## Known stack suffix:
## WHILE namedexpr_test COLON suite
## LR(1) items:
while_stmt -> WHILE namedexpr_test COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
while_stmt -> WHILE namedexpr_test COLON suite . ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On ELSE shift to state 418
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production while_stmt -> WHILE namedexpr_test COLON suite

State 418:
## Known stack suffix:
## WHILE namedexpr_test COLON suite ELSE
## LR(1) items:
while_stmt -> WHILE namedexpr_test COLON suite ELSE . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 419
## Reductions:

State 419:
## Known stack suffix:
## WHILE namedexpr_test COLON suite ELSE COLON
## LR(1) items:
while_stmt -> WHILE namedexpr_test COLON suite ELSE COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 420
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 420:
## Known stack suffix:
## WHILE namedexpr_test COLON suite ELSE COLON suite
## LR(1) items:
while_stmt -> WHILE namedexpr_test COLON suite ELSE COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production while_stmt -> WHILE namedexpr_test COLON suite ELSE COLON suite

State 421:
## Known stack suffix:
## small_stmt
## LR(1) items:
simple_stmt -> small_stmt . NEWLINE [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
simple_stmt -> small_stmt . SEMICOL NEWLINE [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
simple_stmt -> small_stmt . SEMICOL simple_stmt [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On SEMICOL shift to state 422
-- On NEWLINE shift to state 441
## Reductions:

State 422:
## Known stack suffix:
## small_stmt SEMICOL
## LR(1) items:
simple_stmt -> small_stmt SEMICOL . NEWLINE [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
simple_stmt -> small_stmt SEMICOL . simple_stmt [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 423
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 424
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 423:
## Known stack suffix:
## small_stmt SEMICOL NEWLINE
## LR(1) items:
simple_stmt -> small_stmt SEMICOL NEWLINE . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production simple_stmt -> small_stmt SEMICOL NEWLINE

State 424:
## Known stack suffix:
## small_stmt SEMICOL simple_stmt
## LR(1) items:
simple_stmt -> small_stmt SEMICOL simple_stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production simple_stmt -> small_stmt SEMICOL simple_stmt

State 425:
## Known stack suffix:
## return_stmt
## LR(1) items:
flow_stmt -> return_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production flow_stmt -> return_stmt

State 426:
## Known stack suffix:
## raise_stmt
## LR(1) items:
flow_stmt -> raise_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production flow_stmt -> raise_stmt

State 427:
## Known stack suffix:
## print_stmt
## LR(1) items:
small_stmt -> print_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production small_stmt -> print_stmt

State 428:
## Known stack suffix:
## pass_stmt
## LR(1) items:
small_stmt -> pass_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production small_stmt -> pass_stmt

State 429:
## Known stack suffix:
## nonlocal_stmt
## LR(1) items:
small_stmt -> nonlocal_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production small_stmt -> nonlocal_stmt

State 430:
## Known stack suffix:
## import_stmt
## LR(1) items:
small_stmt -> import_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production small_stmt -> import_stmt

State 431:
## Known stack suffix:
## import_name
## LR(1) items:
import_stmt -> import_name . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production import_stmt -> import_name

State 432:
## Known stack suffix:
## import_from
## LR(1) items:
import_stmt -> import_from . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production import_stmt -> import_from

State 433:
## Known stack suffix:
## global_stmt
## LR(1) items:
small_stmt -> global_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production small_stmt -> global_stmt

State 434:
## Known stack suffix:
## flow_stmt
## LR(1) items:
small_stmt -> flow_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production small_stmt -> flow_stmt

State 435:
## Known stack suffix:
## expr_stmt
## LR(1) items:
small_stmt -> expr_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production small_stmt -> expr_stmt

State 436:
## Known stack suffix:
## exec_stmt
## LR(1) items:
small_stmt -> exec_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production small_stmt -> exec_stmt

State 437:
## Known stack suffix:
## del_stmt
## LR(1) items:
small_stmt -> del_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production small_stmt -> del_stmt

State 438:
## Known stack suffix:
## continue_stmt
## LR(1) items:
flow_stmt -> continue_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production flow_stmt -> continue_stmt

State 439:
## Known stack suffix:
## break_stmt
## LR(1) items:
flow_stmt -> break_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production flow_stmt -> break_stmt

State 440:
## Known stack suffix:
## assert_stmt
## LR(1) items:
small_stmt -> assert_stmt . [ SEMICOL NEWLINE ]
## Transitions:
## Reductions:
-- On SEMICOL NEWLINE
--   reduce production small_stmt -> assert_stmt

State 441:
## Known stack suffix:
## small_stmt NEWLINE
## LR(1) items:
simple_stmt -> small_stmt NEWLINE . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production simple_stmt -> small_stmt NEWLINE

State 442:
## Known stack suffix:
## simple_stmt
## LR(1) items:
suite -> simple_stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production suite -> simple_stmt

State 443:
## Known stack suffix:
## TRY
## LR(1) items:
try_stmt -> TRY . COLON suite nonempty_list(excepthandler) [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY . COLON suite nonempty_list(excepthandler) ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY . COLON suite nonempty_list(excepthandler) ELSE COLON suite FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY . COLON suite nonempty_list(excepthandler) FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY . COLON suite FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 444
## Reductions:

State 444:
## Known stack suffix:
## TRY COLON
## LR(1) items:
try_stmt -> TRY COLON . suite nonempty_list(excepthandler) [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON . suite nonempty_list(excepthandler) ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON . suite nonempty_list(excepthandler) ELSE COLON suite FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON . suite nonempty_list(excepthandler) FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON . suite FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 445
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 445:
## Known stack suffix:
## TRY COLON suite
## LR(1) items:
try_stmt -> TRY COLON suite . nonempty_list(excepthandler) [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON suite . nonempty_list(excepthandler) ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON suite . nonempty_list(excepthandler) ELSE COLON suite FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON suite . nonempty_list(excepthandler) FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON suite . FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On FINALLY shift to state 446
-- On EXCEPT shift to state 449
-- On nonempty_list(excepthandler) shift to state 463
-- On excepthandler shift to state 473
## Reductions:

State 446:
## Known stack suffix:
## TRY COLON suite FINALLY
## LR(1) items:
try_stmt -> TRY COLON suite FINALLY . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 447
## Reductions:

State 447:
## Known stack suffix:
## TRY COLON suite FINALLY COLON
## LR(1) items:
try_stmt -> TRY COLON suite FINALLY COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 448
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 448:
## Known stack suffix:
## TRY COLON suite FINALLY COLON suite
## LR(1) items:
try_stmt -> TRY COLON suite FINALLY COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production try_stmt -> TRY COLON suite FINALLY COLON suite

State 449:
## Known stack suffix:
## EXCEPT
## LR(1) items:
excepthandler -> EXCEPT . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
excepthandler -> EXCEPT . test COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
excepthandler -> EXCEPT . test AS NAME COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
excepthandler -> EXCEPT . test COMMA NAME COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On COLON shift to state 450
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 452
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 450:
## Known stack suffix:
## EXCEPT COLON
## LR(1) items:
excepthandler -> EXCEPT COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 451
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 451:
## Known stack suffix:
## EXCEPT COLON suite
## LR(1) items:
excepthandler -> EXCEPT COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production excepthandler -> EXCEPT COLON suite

State 452:
## Known stack suffix:
## EXCEPT test
## LR(1) items:
excepthandler -> EXCEPT test . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
excepthandler -> EXCEPT test . AS NAME COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
excepthandler -> EXCEPT test . COMMA NAME COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COMMA shift to state 453
-- On COLON shift to state 457
-- On AS shift to state 459
## Reductions:

State 453:
## Known stack suffix:
## EXCEPT test COMMA
## LR(1) items:
excepthandler -> EXCEPT test COMMA . NAME COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On NAME shift to state 454
## Reductions:

State 454:
## Known stack suffix:
## EXCEPT test COMMA NAME
## LR(1) items:
excepthandler -> EXCEPT test COMMA NAME . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 455
## Reductions:

State 455:
## Known stack suffix:
## EXCEPT test COMMA NAME COLON
## LR(1) items:
excepthandler -> EXCEPT test COMMA NAME COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 456
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 456:
## Known stack suffix:
## EXCEPT test COMMA NAME COLON suite
## LR(1) items:
excepthandler -> EXCEPT test COMMA NAME COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production excepthandler -> EXCEPT test COMMA NAME COLON suite

State 457:
## Known stack suffix:
## EXCEPT test COLON
## LR(1) items:
excepthandler -> EXCEPT test COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 458
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 458:
## Known stack suffix:
## EXCEPT test COLON suite
## LR(1) items:
excepthandler -> EXCEPT test COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production excepthandler -> EXCEPT test COLON suite

State 459:
## Known stack suffix:
## EXCEPT test AS
## LR(1) items:
excepthandler -> EXCEPT test AS . NAME COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On NAME shift to state 460
## Reductions:

State 460:
## Known stack suffix:
## EXCEPT test AS NAME
## LR(1) items:
excepthandler -> EXCEPT test AS NAME . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 461
## Reductions:

State 461:
## Known stack suffix:
## EXCEPT test AS NAME COLON
## LR(1) items:
excepthandler -> EXCEPT test AS NAME COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 462
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 462:
## Known stack suffix:
## EXCEPT test AS NAME COLON suite
## LR(1) items:
excepthandler -> EXCEPT test AS NAME COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production excepthandler -> EXCEPT test AS NAME COLON suite

State 463:
## Known stack suffix:
## TRY COLON suite nonempty_list(excepthandler)
## LR(1) items:
try_stmt -> TRY COLON suite nonempty_list(excepthandler) . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON suite nonempty_list(excepthandler) . ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON suite nonempty_list(excepthandler) . ELSE COLON suite FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON suite nonempty_list(excepthandler) . FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On FINALLY shift to state 464
-- On ELSE shift to state 467
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production try_stmt -> TRY COLON suite nonempty_list(excepthandler)

State 464:
## Known stack suffix:
## TRY COLON suite nonempty_list(excepthandler) FINALLY
## LR(1) items:
try_stmt -> TRY COLON suite nonempty_list(excepthandler) FINALLY . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 465
## Reductions:

State 465:
## Known stack suffix:
## TRY COLON suite nonempty_list(excepthandler) FINALLY COLON
## LR(1) items:
try_stmt -> TRY COLON suite nonempty_list(excepthandler) FINALLY COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 466
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 466:
## Known stack suffix:
## TRY COLON suite nonempty_list(excepthandler) FINALLY COLON suite
## LR(1) items:
try_stmt -> TRY COLON suite nonempty_list(excepthandler) FINALLY COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production try_stmt -> TRY COLON suite nonempty_list(excepthandler) FINALLY COLON suite

State 467:
## Known stack suffix:
## TRY COLON suite nonempty_list(excepthandler) ELSE
## LR(1) items:
try_stmt -> TRY COLON suite nonempty_list(excepthandler) ELSE . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON suite nonempty_list(excepthandler) ELSE . COLON suite FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 468
## Reductions:

State 468:
## Known stack suffix:
## TRY COLON suite nonempty_list(excepthandler) ELSE COLON
## LR(1) items:
try_stmt -> TRY COLON suite nonempty_list(excepthandler) ELSE COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON suite nonempty_list(excepthandler) ELSE COLON . suite FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 469
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 469:
## Known stack suffix:
## TRY COLON suite nonempty_list(excepthandler) ELSE COLON suite
## LR(1) items:
try_stmt -> TRY COLON suite nonempty_list(excepthandler) ELSE COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
try_stmt -> TRY COLON suite nonempty_list(excepthandler) ELSE COLON suite . FINALLY COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On FINALLY shift to state 470
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production try_stmt -> TRY COLON suite nonempty_list(excepthandler) ELSE COLON suite

State 470:
## Known stack suffix:
## TRY COLON suite nonempty_list(excepthandler) ELSE COLON suite FINALLY
## LR(1) items:
try_stmt -> TRY COLON suite nonempty_list(excepthandler) ELSE COLON suite FINALLY . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 471
## Reductions:

State 471:
## Known stack suffix:
## TRY COLON suite nonempty_list(excepthandler) ELSE COLON suite FINALLY COLON
## LR(1) items:
try_stmt -> TRY COLON suite nonempty_list(excepthandler) ELSE COLON suite FINALLY COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 472
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 472:
## Known stack suffix:
## TRY COLON suite nonempty_list(excepthandler) ELSE COLON suite FINALLY COLON suite
## LR(1) items:
try_stmt -> TRY COLON suite nonempty_list(excepthandler) ELSE COLON suite FINALLY COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production try_stmt -> TRY COLON suite nonempty_list(excepthandler) ELSE COLON suite FINALLY COLON suite

State 473:
## Known stack suffix:
## excepthandler
## LR(1) items:
nonempty_list(excepthandler) -> excepthandler . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
nonempty_list(excepthandler) -> excepthandler . nonempty_list(excepthandler) [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On EXCEPT shift to state 449
-- On nonempty_list(excepthandler) shift to state 474
-- On excepthandler shift to state 473
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production nonempty_list(excepthandler) -> excepthandler

State 474:
## Known stack suffix:
## excepthandler nonempty_list(excepthandler)
## LR(1) items:
nonempty_list(excepthandler) -> excepthandler nonempty_list(excepthandler) . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production nonempty_list(excepthandler) -> excepthandler nonempty_list(excepthandler)

State 475:
## Known stack suffix:
## IF
## LR(1) items:
if_stmt -> IF . namedexpr_test COLON suite elif_stmt_list [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 255
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On namedexpr_test shift to state 476
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 476:
## Known stack suffix:
## IF namedexpr_test
## LR(1) items:
if_stmt -> IF namedexpr_test . COLON suite elif_stmt_list [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 477
## Reductions:

State 477:
## Known stack suffix:
## IF namedexpr_test COLON
## LR(1) items:
if_stmt -> IF namedexpr_test COLON . suite elif_stmt_list [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 478
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 478:
## Known stack suffix:
## IF namedexpr_test COLON suite
## LR(1) items:
if_stmt -> IF namedexpr_test COLON suite . elif_stmt_list [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On ELSE shift to state 479
-- On ELIF shift to state 482
-- On elif_stmt_list shift to state 487
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production elif_stmt_list ->

State 479:
## Known stack suffix:
## ELSE
## LR(1) items:
elif_stmt_list -> ELSE . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 480
## Reductions:

State 480:
## Known stack suffix:
## ELSE COLON
## LR(1) items:
elif_stmt_list -> ELSE COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 481
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 481:
## Known stack suffix:
## ELSE COLON suite
## LR(1) items:
elif_stmt_list -> ELSE COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production elif_stmt_list -> ELSE COLON suite

State 482:
## Known stack suffix:
## ELIF
## LR(1) items:
elif_stmt_list -> ELIF . namedexpr_test COLON suite elif_stmt_list [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 255
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On namedexpr_test shift to state 483
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 483:
## Known stack suffix:
## ELIF namedexpr_test
## LR(1) items:
elif_stmt_list -> ELIF namedexpr_test . COLON suite elif_stmt_list [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 484
## Reductions:

State 484:
## Known stack suffix:
## ELIF namedexpr_test COLON
## LR(1) items:
elif_stmt_list -> ELIF namedexpr_test COLON . suite elif_stmt_list [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 485
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 485:
## Known stack suffix:
## ELIF namedexpr_test COLON suite
## LR(1) items:
elif_stmt_list -> ELIF namedexpr_test COLON suite . elif_stmt_list [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On ELSE shift to state 479
-- On ELIF shift to state 482
-- On elif_stmt_list shift to state 486
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production elif_stmt_list ->

State 486:
## Known stack suffix:
## ELIF namedexpr_test COLON suite elif_stmt_list
## LR(1) items:
elif_stmt_list -> ELIF namedexpr_test COLON suite elif_stmt_list . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production elif_stmt_list -> ELIF namedexpr_test COLON suite elif_stmt_list

State 487:
## Known stack suffix:
## IF namedexpr_test COLON suite elif_stmt_list
## LR(1) items:
if_stmt -> IF namedexpr_test COLON suite elif_stmt_list . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production if_stmt -> IF namedexpr_test COLON suite elif_stmt_list

State 488:
## Known stack suffix:
## FOR
## LR(1) items:
for_stmt -> FOR . exprlist IN tuple(test) COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
for_stmt -> FOR . exprlist IN tuple(test) COLON suite ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(expr_or_star_expr) shift to state 140
-- On term shift to state 55
-- On string shift to state 34
-- On star_expr shift to state 141
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On exprlist shift to state 489
-- On expr_or_star_expr shift to state 174
-- On expr shift to state 177
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 489:
## Known stack suffix:
## FOR exprlist
## LR(1) items:
for_stmt -> FOR exprlist . IN tuple(test) COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
for_stmt -> FOR exprlist . IN tuple(test) COLON suite ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On IN shift to state 490
## Reductions:

State 490:
## Known stack suffix:
## FOR exprlist IN
## LR(1) items:
for_stmt -> FOR exprlist IN . tuple(test) COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
for_stmt -> FOR exprlist IN . tuple(test) COLON suite ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On tuple(test) shift to state 491
-- On test shift to state 200
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 491:
## Known stack suffix:
## FOR exprlist IN tuple(test)
## LR(1) items:
for_stmt -> FOR exprlist IN tuple(test) . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
for_stmt -> FOR exprlist IN tuple(test) . COLON suite ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 492
## Reductions:

State 492:
## Known stack suffix:
## FOR exprlist IN tuple(test) COLON
## LR(1) items:
for_stmt -> FOR exprlist IN tuple(test) COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
for_stmt -> FOR exprlist IN tuple(test) COLON . suite ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 493
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 493:
## Known stack suffix:
## FOR exprlist IN tuple(test) COLON suite
## LR(1) items:
for_stmt -> FOR exprlist IN tuple(test) COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
for_stmt -> FOR exprlist IN tuple(test) COLON suite . ELSE COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On ELSE shift to state 494
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production for_stmt -> FOR exprlist IN tuple(test) COLON suite

State 494:
## Known stack suffix:
## FOR exprlist IN tuple(test) COLON suite ELSE
## LR(1) items:
for_stmt -> FOR exprlist IN tuple(test) COLON suite ELSE . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 495
## Reductions:

State 495:
## Known stack suffix:
## FOR exprlist IN tuple(test) COLON suite ELSE COLON
## LR(1) items:
for_stmt -> FOR exprlist IN tuple(test) COLON suite ELSE COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 496
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 496:
## Known stack suffix:
## FOR exprlist IN tuple(test) COLON suite ELSE COLON suite
## LR(1) items:
for_stmt -> FOR exprlist IN tuple(test) COLON suite ELSE COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production for_stmt -> FOR exprlist IN tuple(test) COLON suite ELSE COLON suite

State 497:
## Known stack suffix:
## DEF
## LR(1) items:
funcdef -> DEF . NAME parameters option(return_type) COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On NAME shift to state 498
## Reductions:

State 498:
## Known stack suffix:
## DEF NAME
## LR(1) items:
funcdef -> DEF NAME . parameters option(return_type) COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On LPAREN shift to state 499
-- On parameters shift to state 521
## Reductions:

State 499:
## Known stack suffix:
## LPAREN
## LR(1) items:
parameters -> LPAREN . typedargslist RPAREN [ SUB COLON ]
## Transitions:
-- On POW shift to state 500
-- On NAME shift to state 501
-- On MULT shift to state 505
-- On LPAREN shift to state 507
-- On ELLIPSES shift to state 510
-- On DIV shift to state 511
-- On typedargslist shift to state 512
-- On typed_parameter shift to state 514
-- On tfpdef_or_fpdef shift to state 517
-- On tfpdef shift to state 518
## Reductions:
-- On RPAREN
--   reduce production typedargslist ->

State 500:
## Known stack suffix:
## POW
## LR(1) items:
typed_parameter -> POW . tfpdef [ RPAREN COMMA ]
## Transitions:
-- On NAME shift to state 501
-- On tfpdef shift to state 504
## Reductions:

State 501:
## Known stack suffix:
## NAME
## LR(1) items:
tfpdef -> NAME . [ RPAREN EQ COMMA ]
tfpdef -> NAME . COLON test [ RPAREN EQ COMMA ]
## Transitions:
-- On COLON shift to state 502
## Reductions:
-- On RPAREN EQ COMMA
--   reduce production tfpdef -> NAME

State 502:
## Known stack suffix:
## NAME COLON
## LR(1) items:
tfpdef -> NAME COLON . test [ RPAREN EQ COMMA ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 503
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 503:
## Known stack suffix:
## NAME COLON test
## LR(1) items:
tfpdef -> NAME COLON test . [ RPAREN EQ COMMA ]
## Transitions:
## Reductions:
-- On RPAREN EQ COMMA
--   reduce production tfpdef -> NAME COLON test

State 504:
## Known stack suffix:
## POW tfpdef
## LR(1) items:
typed_parameter -> POW tfpdef . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production typed_parameter -> POW tfpdef

State 505:
## Known stack suffix:
## MULT
## LR(1) items:
typed_parameter -> MULT . tfpdef [ RPAREN COMMA ]
typed_parameter -> MULT . [ RPAREN COMMA ]
## Transitions:
-- On NAME shift to state 501
-- On tfpdef shift to state 506
## Reductions:
-- On RPAREN COMMA
--   reduce production typed_parameter -> MULT

State 506:
## Known stack suffix:
## MULT tfpdef
## LR(1) items:
typed_parameter -> MULT tfpdef . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production typed_parameter -> MULT tfpdef

State 507:
## Known stack suffix:
## LPAREN
## LR(1) items:
tfpdef_or_fpdef -> LPAREN . fplist RPAREN [ RPAREN COMMA ]
## Transitions:
-- On NAME shift to state 150
-- On LPAREN shift to state 149
-- On fplist shift to state 508
-- On fpdef shift to state 153
## Reductions:

State 508:
## Known stack suffix:
## LPAREN fplist
## LR(1) items:
tfpdef_or_fpdef -> LPAREN fplist . RPAREN [ RPAREN COMMA ]
## Transitions:
-- On RPAREN shift to state 509
## Reductions:

State 509:
## Known stack suffix:
## LPAREN fplist RPAREN
## LR(1) items:
tfpdef_or_fpdef -> LPAREN fplist RPAREN . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production tfpdef_or_fpdef -> LPAREN fplist RPAREN

State 510:
## Known stack suffix:
## ELLIPSES
## LR(1) items:
typed_parameter -> ELLIPSES . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production typed_parameter -> ELLIPSES

State 511:
## Known stack suffix:
## DIV
## LR(1) items:
typed_parameter -> DIV . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production typed_parameter -> DIV

State 512:
## Known stack suffix:
## LPAREN typedargslist
## LR(1) items:
parameters -> LPAREN typedargslist . RPAREN [ SUB COLON ]
## Transitions:
-- On RPAREN shift to state 513
## Reductions:

State 513:
## Known stack suffix:
## LPAREN typedargslist RPAREN
## LR(1) items:
parameters -> LPAREN typedargslist RPAREN . [ SUB COLON ]
## Transitions:
## Reductions:
-- On SUB COLON
--   reduce production parameters -> LPAREN typedargslist RPAREN

State 514:
## Known stack suffix:
## typed_parameter
## LR(1) items:
typedargslist -> typed_parameter . [ RPAREN ]
typedargslist -> typed_parameter . COMMA typedargslist [ RPAREN ]
## Transitions:
-- On COMMA shift to state 515
## Reductions:
-- On RPAREN
--   reduce production typedargslist -> typed_parameter

State 515:
## Known stack suffix:
## typed_parameter COMMA
## LR(1) items:
typedargslist -> typed_parameter COMMA . typedargslist [ RPAREN ]
## Transitions:
-- On POW shift to state 500
-- On NAME shift to state 501
-- On MULT shift to state 505
-- On LPAREN shift to state 507
-- On ELLIPSES shift to state 510
-- On DIV shift to state 511
-- On typedargslist shift to state 516
-- On typed_parameter shift to state 514
-- On tfpdef_or_fpdef shift to state 517
-- On tfpdef shift to state 518
## Reductions:
-- On RPAREN
--   reduce production typedargslist ->

State 516:
## Known stack suffix:
## typed_parameter COMMA typedargslist
## LR(1) items:
typedargslist -> typed_parameter COMMA typedargslist . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN
--   reduce production typedargslist -> typed_parameter COMMA typedargslist

State 517:
## Known stack suffix:
## tfpdef_or_fpdef
## LR(1) items:
typed_parameter -> tfpdef_or_fpdef . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production typed_parameter -> tfpdef_or_fpdef

State 518:
## Known stack suffix:
## tfpdef
## LR(1) items:
tfpdef_or_fpdef -> tfpdef . [ RPAREN COMMA ]
typed_parameter -> tfpdef . EQ test [ RPAREN COMMA ]
## Transitions:
-- On EQ shift to state 519
## Reductions:
-- On RPAREN COMMA
--   reduce production tfpdef_or_fpdef -> tfpdef

State 519:
## Known stack suffix:
## tfpdef EQ
## LR(1) items:
typed_parameter -> tfpdef EQ . test [ RPAREN COMMA ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 520
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 520:
## Known stack suffix:
## tfpdef EQ test
## LR(1) items:
typed_parameter -> tfpdef EQ test . [ RPAREN COMMA ]
## Transitions:
## Reductions:
-- On RPAREN COMMA
--   reduce production typed_parameter -> tfpdef EQ test

State 521:
## Known stack suffix:
## DEF NAME parameters
## LR(1) items:
funcdef -> DEF NAME parameters . option(return_type) COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On SUB shift to state 522
-- On return_type shift to state 525
-- On option(return_type) shift to state 526
## Reductions:
-- On COLON
--   reduce production option(return_type) ->

State 522:
## Known stack suffix:
## SUB
## LR(1) items:
return_type -> SUB . GT test [ COLON ]
## Transitions:
-- On GT shift to state 523
## Reductions:

State 523:
## Known stack suffix:
## SUB GT
## LR(1) items:
return_type -> SUB GT . test [ COLON ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 524
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 524:
## Known stack suffix:
## SUB GT test
## LR(1) items:
return_type -> SUB GT test . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production return_type -> SUB GT test

State 525:
## Known stack suffix:
## return_type
## LR(1) items:
option(return_type) -> return_type . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production option(return_type) -> return_type

State 526:
## Known stack suffix:
## DEF NAME parameters option(return_type)
## LR(1) items:
funcdef -> DEF NAME parameters option(return_type) . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 527
## Reductions:

State 527:
## Known stack suffix:
## DEF NAME parameters option(return_type) COLON
## LR(1) items:
funcdef -> DEF NAME parameters option(return_type) COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 528
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 528:
## Known stack suffix:
## DEF NAME parameters option(return_type) COLON suite
## LR(1) items:
funcdef -> DEF NAME parameters option(return_type) COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production funcdef -> DEF NAME parameters option(return_type) COLON suite

State 529:
## Known stack suffix:
## CLASS
## LR(1) items:
classdef -> CLASS . NAME arglist_paren_opt COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On NAME shift to state 530
## Reductions:

State 530:
## Known stack suffix:
## CLASS NAME
## LR(1) items:
classdef -> CLASS NAME . arglist_paren_opt COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On LPAREN shift to state 531
-- On arglist_paren_opt shift to state 535
## Reductions:
-- On COLON
--   reduce production arglist_paren_opt ->

State 531:
## Known stack suffix:
## LPAREN
## LR(1) items:
arglist_paren_opt -> LPAREN . RPAREN [ COLON ]
arglist_paren_opt -> LPAREN . list_comma(argument) RPAREN [ COLON ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RPAREN shift to state 532
-- On POW shift to state 44
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 133
-- On MULT shift to state 136
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 138
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On list_sep_term(argument,COMMA) shift to state 183
-- On list_comma(argument) shift to state 533
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On argument shift to state 186
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 532:
## Known stack suffix:
## LPAREN RPAREN
## LR(1) items:
arglist_paren_opt -> LPAREN RPAREN . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production arglist_paren_opt -> LPAREN RPAREN

State 533:
## Known stack suffix:
## LPAREN list_comma(argument)
## LR(1) items:
arglist_paren_opt -> LPAREN list_comma(argument) . RPAREN [ COLON ]
## Transitions:
-- On RPAREN shift to state 534
## Reductions:

State 534:
## Known stack suffix:
## LPAREN list_comma(argument) RPAREN
## LR(1) items:
arglist_paren_opt -> LPAREN list_comma(argument) RPAREN . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production arglist_paren_opt -> LPAREN list_comma(argument) RPAREN

State 535:
## Known stack suffix:
## CLASS NAME arglist_paren_opt
## LR(1) items:
classdef -> CLASS NAME arglist_paren_opt . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 536
## Reductions:

State 536:
## Known stack suffix:
## CLASS NAME arglist_paren_opt COLON
## LR(1) items:
classdef -> CLASS NAME arglist_paren_opt COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 537
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 537:
## Known stack suffix:
## CLASS NAME arglist_paren_opt COLON suite
## LR(1) items:
classdef -> CLASS NAME arglist_paren_opt COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production classdef -> CLASS NAME arglist_paren_opt COLON suite

State 538:
## Known stack suffix:
## AT
## LR(1) items:
decorator -> AT . decorator_name arglist_paren2_opt NEWLINE [ DEF CLASS AT ASYNC ]
## Transitions:
-- On NAME shift to state 539
-- On decorator_name shift to state 540
## Reductions:

State 539:
## Known stack suffix:
## NAME
## LR(1) items:
decorator_name -> NAME . [ NEWLINE LPAREN DOT ]
## Transitions:
## Reductions:
-- On NEWLINE LPAREN DOT
--   reduce production decorator_name -> NAME

State 540:
## Known stack suffix:
## AT decorator_name
## LR(1) items:
decorator -> AT decorator_name . arglist_paren2_opt NEWLINE [ DEF CLASS AT ASYNC ]
decorator_name -> decorator_name . DOT NAME [ NEWLINE LPAREN DOT ]
## Transitions:
-- On LPAREN shift to state 541
-- On DOT shift to state 545
-- On arglist_paren2_opt shift to state 547
## Reductions:
-- On NEWLINE
--   reduce production arglist_paren2_opt ->

State 541:
## Known stack suffix:
## LPAREN
## LR(1) items:
arglist_paren2_opt -> LPAREN . RPAREN [ NEWLINE ]
arglist_paren2_opt -> LPAREN . list_comma(argument) RPAREN [ NEWLINE ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RPAREN shift to state 542
-- On POW shift to state 44
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 133
-- On MULT shift to state 136
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On test shift to state 138
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On list_sep_term(argument,COMMA) shift to state 183
-- On list_comma(argument) shift to state 543
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On argument shift to state 186
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 542:
## Known stack suffix:
## LPAREN RPAREN
## LR(1) items:
arglist_paren2_opt -> LPAREN RPAREN . [ NEWLINE ]
## Transitions:
## Reductions:
-- On NEWLINE
--   reduce production arglist_paren2_opt -> LPAREN RPAREN

State 543:
## Known stack suffix:
## LPAREN list_comma(argument)
## LR(1) items:
arglist_paren2_opt -> LPAREN list_comma(argument) . RPAREN [ NEWLINE ]
## Transitions:
-- On RPAREN shift to state 544
## Reductions:

State 544:
## Known stack suffix:
## LPAREN list_comma(argument) RPAREN
## LR(1) items:
arglist_paren2_opt -> LPAREN list_comma(argument) RPAREN . [ NEWLINE ]
## Transitions:
## Reductions:
-- On NEWLINE
--   reduce production arglist_paren2_opt -> LPAREN list_comma(argument) RPAREN

State 545:
## Known stack suffix:
## decorator_name DOT
## LR(1) items:
decorator_name -> decorator_name DOT . NAME [ NEWLINE LPAREN DOT ]
## Transitions:
-- On NAME shift to state 546
## Reductions:

State 546:
## Known stack suffix:
## decorator_name DOT NAME
## LR(1) items:
decorator_name -> decorator_name DOT NAME . [ NEWLINE LPAREN DOT ]
## Transitions:
## Reductions:
-- On NEWLINE LPAREN DOT
--   reduce production decorator_name -> decorator_name DOT NAME

State 547:
## Known stack suffix:
## AT decorator_name arglist_paren2_opt
## LR(1) items:
decorator -> AT decorator_name arglist_paren2_opt . NEWLINE [ DEF CLASS AT ASYNC ]
## Transitions:
-- On NEWLINE shift to state 548
## Reductions:

State 548:
## Known stack suffix:
## AT decorator_name arglist_paren2_opt NEWLINE
## LR(1) items:
decorator -> AT decorator_name arglist_paren2_opt NEWLINE . [ DEF CLASS AT ASYNC ]
## Transitions:
## Reductions:
-- On DEF CLASS AT ASYNC
--   reduce production decorator -> AT decorator_name arglist_paren2_opt NEWLINE

State 549:
## Known stack suffix:
## ASYNC
## LR(1) items:
async_stmt -> ASYNC . funcdef [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
async_stmt -> ASYNC . with_stmt [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
async_stmt -> ASYNC . for_stmt [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On WITH shift to state 293
-- On FOR shift to state 488
-- On DEF shift to state 497
-- On with_stmt shift to state 550
-- On funcdef shift to state 551
-- On for_stmt shift to state 552
## Reductions:

State 550:
## Known stack suffix:
## ASYNC with_stmt
## LR(1) items:
async_stmt -> ASYNC with_stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production async_stmt -> ASYNC with_stmt

State 551:
## Known stack suffix:
## ASYNC funcdef
## LR(1) items:
async_stmt -> ASYNC funcdef . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production async_stmt -> ASYNC funcdef

State 552:
## Known stack suffix:
## ASYNC for_stmt
## LR(1) items:
async_stmt -> ASYNC for_stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production async_stmt -> ASYNC for_stmt

State 553:
## Known stack suffix:
## with_stmt
## LR(1) items:
compound_stmt -> with_stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production compound_stmt -> with_stmt

State 554:
## Known stack suffix:
## while_stmt
## LR(1) items:
compound_stmt -> while_stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production compound_stmt -> while_stmt

State 555:
## Known stack suffix:
## try_stmt
## LR(1) items:
compound_stmt -> try_stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production compound_stmt -> try_stmt

State 556:
## Known stack suffix:
## stmt
## LR(1) items:
list(stmt) -> stmt . list(stmt) [ DEDENT ]
## Transitions:
-- On YIELD shift to state 1
-- On WITH shift to state 293
-- On WHILE shift to state 328
-- On TRY shift to state 443
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On IF shift to state 475
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FOR shift to state 488
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On DEF shift to state 497
-- On CONTINUE shift to state 377
-- On CLASS shift to state 529
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On AT shift to state 538
-- On ASYNC shift to state 549
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On with_stmt shift to state 553
-- On while_stmt shift to state 554
-- On tuple(test_or_star_expr) shift to state 385
-- On try_stmt shift to state 555
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On string shift to state 34
-- On stmt shift to state 556
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 557
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On nonempty_list(decorator) shift to state 558
-- On list(stmt) shift to state 569
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On if_stmt shift to state 570
-- On global_stmt shift to state 433
-- On funcdef shift to state 571
-- On for_stmt shift to state 572
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On decorator shift to state 573
-- On decorated shift to state 575
-- On continue_stmt shift to state 438
-- On compound_stmt shift to state 576
-- On comparison shift to state 112
-- On classdef shift to state 577
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On async_stmt shift to state 578
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On DEDENT
--   reduce production list(stmt) ->

State 557:
## Known stack suffix:
## simple_stmt
## LR(1) items:
stmt -> simple_stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production stmt -> simple_stmt

State 558:
## Known stack suffix:
## nonempty_list(decorator)
## LR(1) items:
decorated -> nonempty_list(decorator) . classdef [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
decorated -> nonempty_list(decorator) . funcdef [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
decorated -> nonempty_list(decorator) . async_funcdef [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On DEF shift to state 497
-- On CLASS shift to state 529
-- On ASYNC shift to state 559
-- On funcdef shift to state 566
-- On classdef shift to state 567
-- On async_funcdef shift to state 568
## Reductions:

State 559:
## Known stack suffix:
## ASYNC
## LR(1) items:
async_funcdef -> ASYNC . DEF NAME parameters option(return_type) COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On DEF shift to state 560
## Reductions:

State 560:
## Known stack suffix:
## ASYNC DEF
## LR(1) items:
async_funcdef -> ASYNC DEF . NAME parameters option(return_type) COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On NAME shift to state 561
## Reductions:

State 561:
## Known stack suffix:
## ASYNC DEF NAME
## LR(1) items:
async_funcdef -> ASYNC DEF NAME . parameters option(return_type) COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On LPAREN shift to state 499
-- On parameters shift to state 562
## Reductions:

State 562:
## Known stack suffix:
## ASYNC DEF NAME parameters
## LR(1) items:
async_funcdef -> ASYNC DEF NAME parameters . option(return_type) COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On SUB shift to state 522
-- On return_type shift to state 525
-- On option(return_type) shift to state 563
## Reductions:
-- On COLON
--   reduce production option(return_type) ->

State 563:
## Known stack suffix:
## ASYNC DEF NAME parameters option(return_type)
## LR(1) items:
async_funcdef -> ASYNC DEF NAME parameters option(return_type) . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COLON shift to state 564
## Reductions:

State 564:
## Known stack suffix:
## ASYNC DEF NAME parameters option(return_type) COLON
## LR(1) items:
async_funcdef -> ASYNC DEF NAME parameters option(return_type) COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 565
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 565:
## Known stack suffix:
## ASYNC DEF NAME parameters option(return_type) COLON suite
## LR(1) items:
async_funcdef -> ASYNC DEF NAME parameters option(return_type) COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production async_funcdef -> ASYNC DEF NAME parameters option(return_type) COLON suite

State 566:
## Known stack suffix:
## nonempty_list(decorator) funcdef
## LR(1) items:
decorated -> nonempty_list(decorator) funcdef . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production decorated -> nonempty_list(decorator) funcdef

State 567:
## Known stack suffix:
## nonempty_list(decorator) classdef
## LR(1) items:
decorated -> nonempty_list(decorator) classdef . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production decorated -> nonempty_list(decorator) classdef

State 568:
## Known stack suffix:
## nonempty_list(decorator) async_funcdef
## LR(1) items:
decorated -> nonempty_list(decorator) async_funcdef . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production decorated -> nonempty_list(decorator) async_funcdef

State 569:
## Known stack suffix:
## stmt list(stmt)
## LR(1) items:
list(stmt) -> stmt list(stmt) . [ DEDENT ]
## Transitions:
## Reductions:
-- On DEDENT
--   reduce production list(stmt) -> stmt list(stmt)

State 570:
## Known stack suffix:
## if_stmt
## LR(1) items:
compound_stmt -> if_stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production compound_stmt -> if_stmt

State 571:
## Known stack suffix:
## funcdef
## LR(1) items:
compound_stmt -> funcdef . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production compound_stmt -> funcdef

State 572:
## Known stack suffix:
## for_stmt
## LR(1) items:
compound_stmt -> for_stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production compound_stmt -> for_stmt

State 573:
## Known stack suffix:
## decorator
## LR(1) items:
nonempty_list(decorator) -> decorator . [ DEF CLASS ASYNC ]
nonempty_list(decorator) -> decorator . nonempty_list(decorator) [ DEF CLASS ASYNC ]
## Transitions:
-- On AT shift to state 538
-- On nonempty_list(decorator) shift to state 574
-- On decorator shift to state 573
## Reductions:
-- On DEF CLASS ASYNC
--   reduce production nonempty_list(decorator) -> decorator

State 574:
## Known stack suffix:
## decorator nonempty_list(decorator)
## LR(1) items:
nonempty_list(decorator) -> decorator nonempty_list(decorator) . [ DEF CLASS ASYNC ]
## Transitions:
## Reductions:
-- On DEF CLASS ASYNC
--   reduce production nonempty_list(decorator) -> decorator nonempty_list(decorator)

State 575:
## Known stack suffix:
## decorated
## LR(1) items:
compound_stmt -> decorated . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production compound_stmt -> decorated

State 576:
## Known stack suffix:
## compound_stmt
## LR(1) items:
stmt -> compound_stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production stmt -> compound_stmt

State 577:
## Known stack suffix:
## classdef
## LR(1) items:
compound_stmt -> classdef . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production compound_stmt -> classdef

State 578:
## Known stack suffix:
## async_stmt
## LR(1) items:
compound_stmt -> async_stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production compound_stmt -> async_stmt

State 579:
## Known stack suffix:
## NEWLINE INDENT list(stmt)
## LR(1) items:
suite -> NEWLINE INDENT list(stmt) . DEDENT [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On DEDENT shift to state 580
## Reductions:

State 580:
## Known stack suffix:
## NEWLINE INDENT list(stmt) DEDENT
## LR(1) items:
suite -> NEWLINE INDENT list(stmt) DEDENT . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production suite -> NEWLINE INDENT list(stmt) DEDENT

State 581:
## Known stack suffix:
## test COLON suite
## LR(1) items:
with_inner -> test COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production with_inner -> test COLON suite

State 582:
## Known stack suffix:
## test AS
## LR(1) items:
with_inner -> test AS . expr COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
with_inner -> test AS . expr COMMA with_inner [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On nonempty_list(string) shift to state 36
-- On factor shift to state 58
-- On expr shift to state 583
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_expr shift to state 106
## Reductions:

State 583:
## Known stack suffix:
## test AS expr
## LR(1) items:
expr -> expr . BITOR xor_expr [ COMMA COLON BITOR ]
with_inner -> test AS expr . COLON suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
with_inner -> test AS expr . COMMA with_inner [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On COMMA shift to state 584
-- On COLON shift to state 586
-- On BITOR shift to state 104
## Reductions:

State 584:
## Known stack suffix:
## test AS expr COMMA
## LR(1) items:
with_inner -> test AS expr COMMA . with_inner [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On NOT shift to state 9
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMAG shift to state 19
-- On FSTRING_START shift to state 20
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On ELLIPSES shift to state 30
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ADD shift to state 45
-- On xor_expr shift to state 53
-- On with_inner shift to state 585
-- On test shift to state 295
-- On term shift to state 55
-- On string shift to state 34
-- On shift_expr shift to state 56
-- On power shift to state 46
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On factor shift to state 58
-- On expr shift to state 92
-- On comparison shift to state 112
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 585:
## Known stack suffix:
## test AS expr COMMA with_inner
## LR(1) items:
with_inner -> test AS expr COMMA with_inner . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production with_inner -> test AS expr COMMA with_inner

State 586:
## Known stack suffix:
## test AS expr COLON
## LR(1) items:
with_inner -> test AS expr COLON . suite [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
-- On YIELD shift to state 1
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 326
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On CONTINUE shift to state 377
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On tuple(test_or_star_expr) shift to state 385
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On suite shift to state 587
-- On string shift to state 34
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 442
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On global_stmt shift to state 433
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On continue_stmt shift to state 438
-- On comparison shift to state 112
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 587:
## Known stack suffix:
## test AS expr COLON suite
## LR(1) items:
with_inner -> test AS expr COLON suite . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production with_inner -> test AS expr COLON suite

State 588:
## Known stack suffix:
## NEWLINE
## LR(1) items:
nl_or_stmt -> NEWLINE . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production nl_or_stmt -> NEWLINE

State 589:
## Known stack suffix:
## stmt
## LR(1) items:
nl_or_stmt -> stmt . [ YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD ]
## Transitions:
## Reductions:
-- On YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
--   reduce production nl_or_stmt -> stmt

State 590:
## Known stack suffix:
## nl_or_stmt
## LR(1) items:
list(nl_or_stmt) -> nl_or_stmt . list(nl_or_stmt) [ INDENT EOF ]
## Transitions:
-- On YIELD shift to state 1
-- On WITH shift to state 293
-- On WHILE shift to state 328
-- On TRY shift to state 443
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 588
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On IF shift to state 475
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FOR shift to state 488
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On DEF shift to state 497
-- On CONTINUE shift to state 377
-- On CLASS shift to state 529
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On AT shift to state 538
-- On ASYNC shift to state 549
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On with_stmt shift to state 553
-- On while_stmt shift to state 554
-- On tuple(test_or_star_expr) shift to state 385
-- On try_stmt shift to state 555
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On string shift to state 34
-- On stmt shift to state 589
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 557
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On nonempty_list(decorator) shift to state 558
-- On nl_or_stmt shift to state 590
-- On list(nl_or_stmt) shift to state 591
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On if_stmt shift to state 570
-- On global_stmt shift to state 433
-- On funcdef shift to state 571
-- On for_stmt shift to state 572
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On decorator shift to state 573
-- On decorated shift to state 575
-- On continue_stmt shift to state 438
-- On compound_stmt shift to state 576
-- On comparison shift to state 112
-- On classdef shift to state 577
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On async_stmt shift to state 578
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On INDENT EOF
--   reduce production list(nl_or_stmt) ->

State 591:
## Known stack suffix:
## nl_or_stmt list(nl_or_stmt)
## LR(1) items:
list(nl_or_stmt) -> nl_or_stmt list(nl_or_stmt) . [ INDENT EOF ]
## Transitions:
## Reductions:
-- On INDENT EOF
--   reduce production list(nl_or_stmt) -> nl_or_stmt list(nl_or_stmt)

State 592:
## Known stack suffix:
## main
## LR(1) items:
main' -> main . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept main

State 593:
## Known stack suffix:
## list(nl_or_stmt)
## LR(1) items:
file_input -> list(nl_or_stmt) . [ INDENT EOF ]
## Transitions:
## Reductions:
-- On INDENT EOF
--   reduce production file_input -> list(nl_or_stmt)

State 594:
## Known stack suffix:
## file_input
## LR(1) items:
main -> file_input . EOF [ # ]
main -> file_input . INDENT NEWLINE DEDENT NEWLINE EOF [ # ]
## Transitions:
-- On INDENT shift to state 595
-- On EOF shift to state 600
## Reductions:

State 595:
## Known stack suffix:
## file_input INDENT
## LR(1) items:
main -> file_input INDENT . NEWLINE DEDENT NEWLINE EOF [ # ]
## Transitions:
-- On NEWLINE shift to state 596
## Reductions:

State 596:
## Known stack suffix:
## file_input INDENT NEWLINE
## LR(1) items:
main -> file_input INDENT NEWLINE . DEDENT NEWLINE EOF [ # ]
## Transitions:
-- On DEDENT shift to state 597
## Reductions:

State 597:
## Known stack suffix:
## file_input INDENT NEWLINE DEDENT
## LR(1) items:
main -> file_input INDENT NEWLINE DEDENT . NEWLINE EOF [ # ]
## Transitions:
-- On NEWLINE shift to state 598
## Reductions:

State 598:
## Known stack suffix:
## file_input INDENT NEWLINE DEDENT NEWLINE
## LR(1) items:
main -> file_input INDENT NEWLINE DEDENT NEWLINE . EOF [ # ]
## Transitions:
-- On EOF shift to state 599
## Reductions:

State 599:
## Known stack suffix:
## file_input INDENT NEWLINE DEDENT NEWLINE EOF
## LR(1) items:
main -> file_input INDENT NEWLINE DEDENT NEWLINE EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production main -> file_input INDENT NEWLINE DEDENT NEWLINE EOF

State 600:
## Known stack suffix:
## file_input EOF
## LR(1) items:
main -> file_input EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production main -> file_input EOF

State 601:
## Known stack suffix:
##
## LR(1) items:
sgrep_spatch_pattern' -> . sgrep_spatch_pattern [ # ]
## Transitions:
-- On YIELD shift to state 1
-- On WITH shift to state 293
-- On WHILE shift to state 328
-- On TRY shift to state 443
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On IF shift to state 475
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FOR shift to state 488
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On DEF shift to state 497
-- On CONTINUE shift to state 377
-- On CLASS shift to state 529
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On AT shift to state 538
-- On ASYNC shift to state 549
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On with_stmt shift to state 553
-- On while_stmt shift to state 554
-- On tuple(test_or_star_expr) shift to state 385
-- On try_stmt shift to state 555
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On string shift to state 34
-- On stmt shift to state 602
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 557
-- On shift_expr shift to state 56
-- On sgrep_spatch_pattern shift to state 611
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On nonempty_list(decorator) shift to state 558
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On if_stmt shift to state 570
-- On global_stmt shift to state 433
-- On funcdef shift to state 571
-- On for_stmt shift to state 572
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On decorator shift to state 573
-- On decorated shift to state 575
-- On continue_stmt shift to state 438
-- On compound_stmt shift to state 576
-- On comparison shift to state 112
-- On classdef shift to state 577
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On async_stmt shift to state 578
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:

State 602:
## Known stack suffix:
## stmt
## LR(1) items:
sgrep_spatch_pattern -> stmt . option(NEWLINE) EOF [ # ]
sgrep_spatch_pattern -> stmt . nonempty_list(stmt) option(NEWLINE) EOF [ # ]
## Transitions:
-- On YIELD shift to state 1
-- On WITH shift to state 293
-- On WHILE shift to state 328
-- On TRY shift to state 443
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NEWLINE shift to state 603
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On IF shift to state 475
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FOR shift to state 488
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On DEF shift to state 497
-- On CONTINUE shift to state 377
-- On CLASS shift to state 529
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On AT shift to state 538
-- On ASYNC shift to state 549
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On with_stmt shift to state 553
-- On while_stmt shift to state 554
-- On tuple(test_or_star_expr) shift to state 385
-- On try_stmt shift to state 555
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On string shift to state 34
-- On stmt shift to state 604
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 557
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On option(NEWLINE) shift to state 606
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On nonempty_list(stmt) shift to state 608
-- On nonempty_list(decorator) shift to state 558
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On if_stmt shift to state 570
-- On global_stmt shift to state 433
-- On funcdef shift to state 571
-- On for_stmt shift to state 572
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On decorator shift to state 573
-- On decorated shift to state 575
-- On continue_stmt shift to state 438
-- On compound_stmt shift to state 576
-- On comparison shift to state 112
-- On classdef shift to state 577
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On async_stmt shift to state 578
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On EOF
--   reduce production option(NEWLINE) ->

State 603:
## Known stack suffix:
## NEWLINE
## LR(1) items:
option(NEWLINE) -> NEWLINE . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production option(NEWLINE) -> NEWLINE

State 604:
## Known stack suffix:
## stmt
## LR(1) items:
nonempty_list(stmt) -> stmt . [ NEWLINE EOF ]
nonempty_list(stmt) -> stmt . nonempty_list(stmt) [ NEWLINE EOF ]
## Transitions:
-- On YIELD shift to state 1
-- On WITH shift to state 293
-- On WHILE shift to state 328
-- On TRY shift to state 443
-- On TRUE shift to state 2
-- On SUB shift to state 3
-- On STR shift to state 4
-- On RETURN shift to state 299
-- On RAISE shift to state 301
-- On PRINT shift to state 309
-- On PASS shift to state 320
-- On NOT shift to state 9
-- On NONLOCAL shift to state 321
-- On NONE shift to state 5
-- On NAME shift to state 6
-- On MULT shift to state 14
-- On LPAREN shift to state 7
-- On LONGINT shift to state 10
-- On LDots shift to state 11
-- On LBRACK shift to state 12
-- On LBRACE shift to state 15
-- On LAMBDA shift to state 23
-- On INT shift to state 18
-- On IMPORT shift to state 331
-- On IMAG shift to state 19
-- On IF shift to state 475
-- On GLOBAL shift to state 342
-- On FSTRING_START shift to state 20
-- On FROM shift to state 344
-- On FOR shift to state 488
-- On FLOAT shift to state 28
-- On FALSE shift to state 29
-- On EXEC shift to state 369
-- On ELLIPSES shift to state 30
-- On DEL shift to state 375
-- On DEF shift to state 497
-- On CONTINUE shift to state 377
-- On CLASS shift to state 529
-- On BREAK shift to state 378
-- On BITNOT shift to state 31
-- On BACKQUOTE shift to state 32
-- On AWAIT shift to state 33
-- On AT shift to state 538
-- On ASYNC shift to state 549
-- On ASSERT shift to state 379
-- On ADD shift to state 45
-- On yield_stmt shift to state 383
-- On yield_expr shift to state 384
-- On xor_expr shift to state 53
-- On with_stmt shift to state 553
-- On while_stmt shift to state 554
-- On tuple(test_or_star_expr) shift to state 385
-- On try_stmt shift to state 555
-- On test_or_star_expr shift to state 398
-- On test shift to state 401
-- On term shift to state 55
-- On string shift to state 34
-- On stmt shift to state 604
-- On star_expr shift to state 402
-- On small_stmt shift to state 421
-- On simple_stmt shift to state 557
-- On shift_expr shift to state 56
-- On return_stmt shift to state 425
-- On raise_stmt shift to state 426
-- On print_stmt shift to state 427
-- On power shift to state 46
-- On pass_stmt shift to state 428
-- On or_test shift to state 81
-- On not_test shift to state 86
-- On nonlocal_stmt shift to state 429
-- On nonempty_list(string) shift to state 36
-- On nonempty_list(stmt) shift to state 605
-- On nonempty_list(decorator) shift to state 558
-- On lambdadef shift to state 113
-- On import_stmt shift to state 430
-- On import_name shift to state 431
-- On import_from shift to state 432
-- On if_stmt shift to state 570
-- On global_stmt shift to state 433
-- On funcdef shift to state 571
-- On for_stmt shift to state 572
-- On flow_stmt shift to state 434
-- On factor shift to state 58
-- On expr_stmt shift to state 435
-- On expr shift to state 92
-- On exec_stmt shift to state 436
-- On del_stmt shift to state 437
-- On decorator shift to state 573
-- On decorated shift to state 575
-- On continue_stmt shift to state 438
-- On compound_stmt shift to state 576
-- On comparison shift to state 112
-- On classdef shift to state 577
-- On break_stmt shift to state 439
-- On atom_tuple shift to state 37
-- On atom_repr shift to state 38
-- On atom_list shift to state 39
-- On atom_expr shift to state 48
-- On atom_dict shift to state 40
-- On atom_and_trailers shift to state 51
-- On atom shift to state 66
-- On async_stmt shift to state 578
-- On assert_stmt shift to state 440
-- On arith_expr shift to state 75
-- On and_test shift to state 114
-- On and_expr shift to state 106
## Reductions:
-- On NEWLINE EOF
--   reduce production nonempty_list(stmt) -> stmt

State 605:
## Known stack suffix:
## stmt nonempty_list(stmt)
## LR(1) items:
nonempty_list(stmt) -> stmt nonempty_list(stmt) . [ NEWLINE EOF ]
## Transitions:
## Reductions:
-- On NEWLINE EOF
--   reduce production nonempty_list(stmt) -> stmt nonempty_list(stmt)

State 606:
## Known stack suffix:
## stmt option(NEWLINE)
## LR(1) items:
sgrep_spatch_pattern -> stmt option(NEWLINE) . EOF [ # ]
## Transitions:
-- On EOF shift to state 607
## Reductions:

State 607:
## Known stack suffix:
## stmt option(NEWLINE) EOF
## LR(1) items:
sgrep_spatch_pattern -> stmt option(NEWLINE) EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production sgrep_spatch_pattern -> stmt option(NEWLINE) EOF

State 608:
## Known stack suffix:
## stmt nonempty_list(stmt)
## LR(1) items:
sgrep_spatch_pattern -> stmt nonempty_list(stmt) . option(NEWLINE) EOF [ # ]
## Transitions:
-- On NEWLINE shift to state 603
-- On option(NEWLINE) shift to state 609
## Reductions:
-- On EOF
--   reduce production option(NEWLINE) ->

State 609:
## Known stack suffix:
## stmt nonempty_list(stmt) option(NEWLINE)
## LR(1) items:
sgrep_spatch_pattern -> stmt nonempty_list(stmt) option(NEWLINE) . EOF [ # ]
## Transitions:
-- On EOF shift to state 610
## Reductions:

State 610:
## Known stack suffix:
## stmt nonempty_list(stmt) option(NEWLINE) EOF
## LR(1) items:
sgrep_spatch_pattern -> stmt nonempty_list(stmt) option(NEWLINE) EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production sgrep_spatch_pattern -> stmt nonempty_list(stmt) option(NEWLINE) EOF

State 611:
## Known stack suffix:
## sgrep_spatch_pattern
## LR(1) items:
sgrep_spatch_pattern' -> sgrep_spatch_pattern . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept sgrep_spatch_pattern

