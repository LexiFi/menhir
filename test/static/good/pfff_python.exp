File "pfff_python.mly", line 95, characters 38-46:
Warning: the token TComment is unused.
File "pfff_python.mly", line 95, characters 24-37:
Warning: the token TCommentSpace is unused.
File "pfff_python.mly", line 88, characters 24-32:
Warning: the token TUnknown is unused.
Grammar has 145 nonterminal symbols, among which 2 start symbols.
Grammar has 103 terminal symbols.
Grammar has 389 productions.
nullable(yield_stmt) = false
nullable(yield_expr) = false
nullable(xor_expr) = false
nullable(with_stmt) = false
nullable(with_inner) = false
nullable(while_stmt) = false
nullable(varargslist) = true
nullable(typedargslist) = true
nullable(typed_parameter) = false
nullable(tuple(test_or_star_expr)) = false
nullable(tuple(test)) = false
nullable(tuple(namedexpr_or_star_expr)) = false
nullable(tuple(expr_or_star_expr)) = false
nullable(try_stmt) = false
nullable(tfpdef_or_fpdef) = false
nullable(tfpdef) = false
nullable(testlist_comp_or_expr) = false
nullable(testlist_comp) = false
nullable(testlist1) = false
nullable(test_or_star_expr) = false
nullable(test_nocond) = false
nullable(test) = false
nullable(term_op) = false
nullable(term) = false
nullable(sync_comp_for) = false
nullable(suite) = false
nullable(subscript) = false
nullable(string) = false
nullable(stmt) = false
nullable(star_expr) = false
nullable(small_stmt) = false
nullable(simple_stmt) = false
nullable(shift_expr) = false
nullable(sgrep_spatch_pattern) = false
nullable(return_type) = false
nullable(return_stmt) = false
nullable(raise_stmt) = false
nullable(print_testlist) = true
nullable(print_stmt) = false
nullable(power) = false
nullable(pass_stmt) = false
nullable(parameters) = false
nullable(parameter) = false
nullable(or_test) = false
nullable(option(test)) = true
nullable(option(return_type)) = true
nullable(option(NEWLINE)) = true
nullable(not_test) = false
nullable(nonlocal_stmt) = false
nullable(nonempty_list(string)) = false
nullable(nonempty_list(stmt)) = false
nullable(nonempty_list(format_token)) = false
nullable(nonempty_list(excepthandler)) = false
nullable(nonempty_list(decorator)) = false
nullable(nl_or_stmt) = false
nullable(namedexpr_test) = false
nullable(namedexpr_or_star_expr) = false
nullable(name_and_level) = false
nullable(main) = false
nullable(listsync_comp_for) = false
nullable(listcomp_for) = false
nullable(list_sep_term(subscript,COMMA)) = false
nullable(list_sep_term(import_as_name,COMMA)) = false
nullable(list_sep_term(dictorset_elem,COMMA)) = false
nullable(list_sep_term(argument,COMMA)) = false
nullable(list_sep(not_test,AND)) = false
nullable(list_sep(dotted_as_name,COMMA)) = false
nullable(list_sep(and_test,OR)) = false
nullable(list_sep(NAME,COMMA)) = false
nullable(list_for_rest) = false
nullable(list_for) = false
nullable(list_comma(subscript)) = false
nullable(list_comma(import_as_name)) = false
nullable(list_comma(dictorset_elem)) = false
nullable(list_comma(argument)) = false
nullable(list(stmt)) = true
nullable(list(nl_or_stmt)) = true
nullable(list(interpolated)) = true
nullable(lambdadef_nocond) = false
nullable(lambdadef) = false
nullable(interpolated) = false
nullable(interpolant) = false
nullable(import_stmt) = false
nullable(import_name) = false
nullable(import_from) = false
nullable(import_as_name) = false
nullable(if_stmt) = false
nullable(global_stmt) = false
nullable(funcdef) = false
nullable(fstring_print_spec) = true
nullable(fstring_format_delimeter) = false
nullable(fstring_format_clause) = true
nullable(fplist) = false
nullable(fpdef) = false
nullable(format_token) = false
nullable(format_specifier) = false
nullable(for_stmt) = false
nullable(flow_stmt) = false
nullable(file_input) = true
nullable(factor) = false
nullable(exprlist) = false
nullable(expr_stmt_rhs_list) = false
nullable(expr_stmt_rhs) = false
nullable(expr_stmt) = false
nullable(expr_or_star_expr) = false
nullable(expr) = false
nullable(exec_stmt) = false
nullable(excepthandler) = false
nullable(elif_stmt_list) = true
nullable(dotted_name) = false
nullable(dotted_as_name) = false
nullable(dot_level) = true
nullable(dictorsetmaker) = false
nullable(dictorset_elem) = false
nullable(del_stmt) = false
nullable(decorator_name) = false
nullable(decorator) = false
nullable(decorated) = false
nullable(continue_stmt) = false
nullable(compound_stmt) = false
nullable(comparison_list) = false
nullable(comparison) = false
nullable(comp_op) = false
nullable(comp_iter) = false
nullable(comp_if) = false
nullable(comp_for) = false
nullable(classdef) = false
nullable(break_stmt) = false
nullable(augassign) = false
nullable(atom_tuple) = false
nullable(atom_repr) = false
nullable(atom_list) = false
nullable(atom_expr) = false
nullable(atom_dict) = false
nullable(atom_and_trailers) = false
nullable(atom) = false
nullable(async_stmt) = false
nullable(async_funcdef) = false
nullable(assert_stmt) = false
nullable(arith_expr) = false
nullable(argument) = false
nullable(arglist_paren_opt) = true
nullable(arglist_paren2_opt) = true
nullable(and_test) = false
nullable(and_expr) = false
first(yield_stmt) = YIELD
first(yield_expr) = YIELD
first(xor_expr) = TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(with_stmt) = WITH
first(with_inner) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(while_stmt) = WHILE
first(varargslist) = POW NAME MULT LPAREN DIV
first(typedargslist) = POW NAME MULT LPAREN ELLIPSES DIV
first(typed_parameter) = POW NAME MULT LPAREN ELLIPSES DIV
first(tuple(test_or_star_expr)) = TRUE SUB STR NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(tuple(test)) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(tuple(namedexpr_or_star_expr)) = TRUE SUB STR NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(tuple(expr_or_star_expr)) = TRUE SUB STR NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(try_stmt) = TRY
first(tfpdef_or_fpdef) = NAME LPAREN
first(tfpdef) = NAME
first(testlist_comp_or_expr) = TRUE SUB STR NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(testlist_comp) = TRUE SUB STR NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(testlist1) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(test_or_star_expr) = TRUE SUB STR NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(test_nocond) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(test) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(term_op) = MULT MOD FDIV DIV AT
first(term) = TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(sync_comp_for) = FOR
first(suite) = YIELD TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMPORT IMAG GLOBAL FSTRING_START FROM FLOAT FALSE EXEC ELLIPSES DEL CONTINUE BREAK BITNOT BACKQUOTE AWAIT ASSERT ADD
first(subscript) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES COLON BITNOT BACKQUOTE AWAIT ADD
first(string) = STR FSTRING_START
first(stmt) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
first(star_expr) = MULT
first(small_stmt) = YIELD TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMPORT IMAG GLOBAL FSTRING_START FROM FLOAT FALSE EXEC ELLIPSES DEL CONTINUE BREAK BITNOT BACKQUOTE AWAIT ASSERT ADD
first(simple_stmt) = YIELD TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMPORT IMAG GLOBAL FSTRING_START FROM FLOAT FALSE EXEC ELLIPSES DEL CONTINUE BREAK BITNOT BACKQUOTE AWAIT ASSERT ADD
first(shift_expr) = TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(sgrep_spatch_pattern) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
first(return_type) = SUB
first(return_stmt) = RETURN
first(raise_stmt) = RAISE
first(print_testlist) = COMMA
first(print_stmt) = PRINT
first(power) = TRUE STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BACKQUOTE AWAIT
first(pass_stmt) = PASS
first(parameters) = LPAREN
first(parameter) = POW NAME MULT LPAREN DIV
first(or_test) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(option(test)) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(option(return_type)) = SUB
first(option(NEWLINE)) = NEWLINE
first(not_test) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(nonlocal_stmt) = NONLOCAL
first(nonempty_list(string)) = STR FSTRING_START
first(nonempty_list(stmt)) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
first(nonempty_list(format_token)) = SUB NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
first(nonempty_list(excepthandler)) = EXCEPT
first(nonempty_list(decorator)) = AT
first(nl_or_stmt) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
first(namedexpr_test) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(namedexpr_or_star_expr) = TRUE SUB STR NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(name_and_level) = NAME ELLIPSES DOT
first(main) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
first(listsync_comp_for) = FOR
first(listcomp_for) = FOR ASYNC
first(list_sep_term(subscript,COMMA)) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES COLON BITNOT BACKQUOTE AWAIT ADD
first(list_sep_term(import_as_name,COMMA)) = NAME
first(list_sep_term(dictorset_elem,COMMA)) = TRUE SUB STR POW NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(list_sep_term(argument,COMMA)) = TRUE SUB STR POW NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(list_sep(not_test,AND)) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(list_sep(dotted_as_name,COMMA)) = NAME
first(list_sep(and_test,OR)) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(list_sep(NAME,COMMA)) = NAME
first(list_for_rest) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(list_for) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(list_comma(subscript)) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES COLON BITNOT BACKQUOTE AWAIT ADD
first(list_comma(import_as_name)) = NAME
first(list_comma(dictorset_elem)) = TRUE SUB STR POW NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(list_comma(argument)) = TRUE SUB STR POW NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(list(stmt)) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
first(list(nl_or_stmt)) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
first(list(interpolated)) = FSTRING_STRING FSTRING_LBRACE
first(lambdadef_nocond) = LAMBDA
first(lambdadef) = LAMBDA
first(interpolated) = FSTRING_STRING FSTRING_LBRACE
first(interpolant) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(import_stmt) = IMPORT FROM
first(import_name) = IMPORT
first(import_from) = FROM
first(import_as_name) = NAME
first(if_stmt) = IF
first(global_stmt) = GLOBAL
first(funcdef) = DEF
first(fstring_print_spec) = EQ COLON BANG
first(fstring_format_delimeter) = COLON BANG
first(fstring_format_clause) = COLON BANG
first(fplist) = NAME LPAREN
first(fpdef) = NAME LPAREN
first(format_token) = SUB NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
first(format_specifier) = SUB NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
first(for_stmt) = FOR
first(flow_stmt) = YIELD RETURN RAISE CONTINUE BREAK
first(file_input) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
first(factor) = TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(exprlist) = TRUE SUB STR NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(expr_stmt_rhs_list) = YIELD TRUE SUB STR NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(expr_stmt_rhs) = YIELD TRUE SUB STR NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(expr_stmt) = TRUE SUB STR NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(expr_or_star_expr) = TRUE SUB STR NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(expr) = TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(exec_stmt) = EXEC
first(excepthandler) = EXCEPT
first(elif_stmt_list) = ELSE ELIF
first(dotted_name) = NAME
first(dotted_as_name) = NAME
first(dot_level) = ELLIPSES DOT
first(dictorsetmaker) = TRUE SUB STR POW NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(dictorset_elem) = TRUE SUB STR POW NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(del_stmt) = DEL
first(decorator_name) = NAME
first(decorator) = AT
first(decorated) = AT
first(continue_stmt) = CONTINUE
first(compound_stmt) = WITH WHILE TRY IF FOR DEF CLASS AT ASYNC
first(comparison_list) = TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(comparison) = TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(comp_op) = NOTEQ NOT LT LEQ IS IN GT GEQ EQUAL
first(comp_iter) = IF FOR ASYNC
first(comp_if) = IF
first(comp_for) = FOR ASYNC
first(classdef) = CLASS
first(break_stmt) = BREAK
first(augassign) = XOREQ SUBEQ RSHEQ POWEQ OREQ MULTEQ MODEQ LSHEQ FDIVEQ DIVEQ ANDEQ ADDEQ
first(atom_tuple) = LPAREN
first(atom_repr) = BACKQUOTE
first(atom_list) = LBRACK
first(atom_expr) = TRUE STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BACKQUOTE AWAIT
first(atom_dict) = LBRACE
first(atom_and_trailers) = TRUE STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BACKQUOTE
first(atom) = TRUE STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BACKQUOTE
first(async_stmt) = ASYNC
first(async_funcdef) = ASYNC
first(assert_stmt) = ASSERT
first(arith_expr) = TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(argument) = TRUE SUB STR POW NOT NONE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(arglist_paren_opt) = LPAREN
first(arglist_paren2_opt) = LPAREN
first(and_test) = TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
first(and_expr) = TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
minimal(yield_stmt) = (* 1 *) YIELD
minimal(yield_expr) = (* 1 *) YIELD
minimal(xor_expr) = (* 1 *) NAME
minimal(with_stmt) = (* 5 *) WITH NAME COLON NAME NEWLINE
minimal(with_inner) = (* 4 *) NAME COLON NAME NEWLINE
minimal(while_stmt) = (* 5 *) WHILE NAME COLON NAME NEWLINE
minimal(varargslist) = (* 0 *)
minimal(typedargslist) = (* 0 *)
minimal(typed_parameter) = (* 1 *) NAME
minimal(tuple(test_or_star_expr)) = (* 1 *) NAME
minimal(tuple(test)) = (* 1 *) NAME
minimal(tuple(namedexpr_or_star_expr)) = (* 1 *) NAME
minimal(tuple(expr_or_star_expr)) = (* 1 *) NAME
minimal(try_stmt) = (* 8 *) TRY COLON NAME NEWLINE EXCEPT COLON NAME NEWLINE
minimal(tfpdef_or_fpdef) = (* 1 *) NAME
minimal(tfpdef) = (* 1 *) NAME
minimal(testlist_comp_or_expr) = (* 1 *) NAME
minimal(testlist_comp) = (* 1 *) NAME
minimal(testlist1) = (* 1 *) NAME
minimal(test_or_star_expr) = (* 1 *) NAME
minimal(test_nocond) = (* 1 *) NAME
minimal(test) = (* 1 *) NAME
minimal(term_op) = (* 1 *) MULT
minimal(term) = (* 1 *) NAME
minimal(sync_comp_for) = (* 4 *) FOR NAME IN NAME
minimal(suite) = (* 2 *) NAME NEWLINE
minimal(subscript) = (* 1 *) NAME
minimal(string) = (* 1 *) STR
minimal(stmt) = (* 2 *) NAME NEWLINE
minimal(star_expr) = (* 2 *) MULT NAME
minimal(small_stmt) = (* 1 *) NAME
minimal(simple_stmt) = (* 2 *) NAME NEWLINE
minimal(shift_expr) = (* 1 *) NAME
minimal(sgrep_spatch_pattern) = (* 3 *) NAME NEWLINE EOF
minimal(return_type) = (* 3 *) SUB GT NAME
minimal(return_stmt) = (* 1 *) RETURN
minimal(raise_stmt) = (* 1 *) RAISE
minimal(print_testlist) = (* 0 *)
minimal(print_stmt) = (* 1 *) PRINT
minimal(power) = (* 1 *) NAME
minimal(pass_stmt) = (* 1 *) PASS
minimal(parameters) = (* 2 *) LPAREN RPAREN
minimal(parameter) = (* 1 *) NAME
minimal(or_test) = (* 1 *) NAME
minimal(option(test)) = (* 0 *)
minimal(option(return_type)) = (* 0 *)
minimal(option(NEWLINE)) = (* 0 *)
minimal(not_test) = (* 1 *) NAME
minimal(nonlocal_stmt) = (* 2 *) NONLOCAL NAME
minimal(nonempty_list(string)) = (* 1 *) STR
minimal(nonempty_list(stmt)) = (* 2 *) NAME NEWLINE
minimal(nonempty_list(format_token)) = (* 1 *) INT
minimal(nonempty_list(excepthandler)) = (* 4 *) EXCEPT COLON NAME NEWLINE
minimal(nonempty_list(decorator)) = (* 3 *) AT NAME NEWLINE
minimal(nl_or_stmt) = (* 1 *) NEWLINE
minimal(namedexpr_test) = (* 1 *) NAME
minimal(namedexpr_or_star_expr) = (* 1 *) NAME
minimal(name_and_level) = (* 1 *) NAME
minimal(main) = (* 1 *) EOF
minimal(listsync_comp_for) = (* 4 *) FOR NAME IN NAME
minimal(listcomp_for) = (* 4 *) FOR NAME IN NAME
minimal(list_sep_term(subscript,COMMA)) = (* 1 *) NAME
minimal(list_sep_term(import_as_name,COMMA)) = (* 1 *) NAME
minimal(list_sep_term(dictorset_elem,COMMA)) = (* 1 *) NAME
minimal(list_sep_term(argument,COMMA)) = (* 1 *) NAME
minimal(list_sep(not_test,AND)) = (* 1 *) NAME
minimal(list_sep(dotted_as_name,COMMA)) = (* 1 *) NAME
minimal(list_sep(and_test,OR)) = (* 1 *) NAME
minimal(list_sep(NAME,COMMA)) = (* 1 *) NAME
minimal(list_for_rest) = (* 1 *) NAME
minimal(list_for) = (* 3 *) NAME COMMA NAME
minimal(list_comma(subscript)) = (* 1 *) NAME
minimal(list_comma(import_as_name)) = (* 1 *) NAME
minimal(list_comma(dictorset_elem)) = (* 1 *) NAME
minimal(list_comma(argument)) = (* 1 *) NAME
minimal(list(stmt)) = (* 0 *)
minimal(list(nl_or_stmt)) = (* 0 *)
minimal(list(interpolated)) = (* 0 *)
minimal(lambdadef_nocond) = (* 3 *) LAMBDA COLON NAME
minimal(lambdadef) = (* 3 *) LAMBDA COLON NAME
minimal(interpolated) = (* 1 *) FSTRING_STRING
minimal(interpolant) = (* 1 *) NAME
minimal(import_stmt) = (* 2 *) IMPORT NAME
minimal(import_name) = (* 2 *) IMPORT NAME
minimal(import_from) = (* 4 *) FROM NAME IMPORT MULT
minimal(import_as_name) = (* 1 *) NAME
minimal(if_stmt) = (* 5 *) IF NAME COLON NAME NEWLINE
minimal(global_stmt) = (* 2 *) GLOBAL NAME
minimal(funcdef) = (* 7 *) DEF NAME LPAREN RPAREN COLON NAME NEWLINE
minimal(fstring_print_spec) = (* 0 *)
minimal(fstring_format_delimeter) = (* 1 *) COLON
minimal(fstring_format_clause) = (* 0 *)
minimal(fplist) = (* 1 *) NAME
minimal(fpdef) = (* 1 *) NAME
minimal(format_token) = (* 1 *) INT
minimal(format_specifier) = (* 1 *) INT
minimal(for_stmt) = (* 7 *) FOR NAME IN NAME COLON NAME NEWLINE
minimal(flow_stmt) = (* 1 *) BREAK
minimal(file_input) = (* 0 *)
minimal(factor) = (* 1 *) NAME
minimal(exprlist) = (* 1 *) NAME
minimal(expr_stmt_rhs_list) = (* 1 *) YIELD
minimal(expr_stmt_rhs) = (* 1 *) YIELD
minimal(expr_stmt) = (* 1 *) NAME
minimal(expr_or_star_expr) = (* 1 *) NAME
minimal(expr) = (* 1 *) NAME
minimal(exec_stmt) = (* 2 *) EXEC NAME
minimal(excepthandler) = (* 4 *) EXCEPT COLON NAME NEWLINE
minimal(elif_stmt_list) = (* 0 *)
minimal(dotted_name) = (* 1 *) NAME
minimal(dotted_as_name) = (* 1 *) NAME
minimal(dot_level) = (* 0 *)
minimal(dictorsetmaker) = (* 1 *) NAME
minimal(dictorset_elem) = (* 1 *) NAME
minimal(del_stmt) = (* 2 *) DEL NAME
minimal(decorator_name) = (* 1 *) NAME
minimal(decorator) = (* 3 *) AT NAME NEWLINE
minimal(decorated) = (* 8 *) AT NAME NEWLINE CLASS NAME COLON NAME NEWLINE
minimal(continue_stmt) = (* 1 *) CONTINUE
minimal(compound_stmt) = (* 5 *) IF NAME COLON NAME NEWLINE
minimal(comparison_list) = (* 1 *) NAME
minimal(comparison) = (* 1 *) NAME
minimal(comp_op) = (* 1 *) EQUAL
minimal(comp_iter) = (* 2 *) IF NAME
minimal(comp_if) = (* 2 *) IF NAME
minimal(comp_for) = (* 4 *) FOR NAME IN NAME
minimal(classdef) = (* 5 *) CLASS NAME COLON NAME NEWLINE
minimal(break_stmt) = (* 1 *) BREAK
minimal(augassign) = (* 1 *) ADDEQ
minimal(atom_tuple) = (* 2 *) LPAREN RPAREN
minimal(atom_repr) = (* 3 *) BACKQUOTE NAME BACKQUOTE
minimal(atom_list) = (* 2 *) LBRACK RBRACK
minimal(atom_expr) = (* 1 *) NAME
minimal(atom_dict) = (* 2 *) LBRACE RBRACE
minimal(atom_and_trailers) = (* 1 *) NAME
minimal(atom) = (* 1 *) NAME
minimal(async_stmt) = (* 6 *) ASYNC WITH NAME COLON NAME NEWLINE
minimal(async_funcdef) = (* 8 *) ASYNC DEF NAME LPAREN RPAREN COLON NAME NEWLINE
minimal(assert_stmt) = (* 2 *) ASSERT NAME
minimal(arith_expr) = (* 1 *) NAME
minimal(argument) = (* 1 *) NAME
minimal(arglist_paren_opt) = (* 0 *)
minimal(arglist_paren2_opt) = (* 0 *)
minimal(and_test) = (* 1 *) NAME
minimal(and_expr) = (* 1 *) NAME
maximal(yield_stmt) = infinity
maximal(yield_expr) = infinity
maximal(xor_expr) = infinity
maximal(with_stmt) = infinity
maximal(with_inner) = infinity
maximal(while_stmt) = infinity
maximal(varargslist) = infinity
maximal(typedargslist) = infinity
maximal(typed_parameter) = infinity
maximal(tuple(test_or_star_expr)) = infinity
maximal(tuple(test)) = infinity
maximal(tuple(namedexpr_or_star_expr)) = infinity
maximal(tuple(expr_or_star_expr)) = infinity
maximal(try_stmt) = infinity
maximal(tfpdef_or_fpdef) = infinity
maximal(tfpdef) = infinity
maximal(testlist_comp_or_expr) = infinity
maximal(testlist_comp) = infinity
maximal(testlist1) = infinity
maximal(test_or_star_expr) = infinity
maximal(test_nocond) = infinity
maximal(test) = infinity
maximal(term_op) = 1
maximal(term) = infinity
maximal(sync_comp_for) = infinity
maximal(suite) = infinity
maximal(subscript) = infinity
maximal(string) = infinity
maximal(stmt) = infinity
maximal(star_expr) = infinity
maximal(small_stmt) = infinity
maximal(simple_stmt) = infinity
maximal(shift_expr) = infinity
maximal(sgrep_spatch_pattern) = infinity
maximal(return_type) = infinity
maximal(return_stmt) = infinity
maximal(raise_stmt) = infinity
maximal(print_testlist) = infinity
maximal(print_stmt) = infinity
maximal(power) = infinity
maximal(pass_stmt) = 1
maximal(parameters) = infinity
maximal(parameter) = infinity
maximal(or_test) = infinity
maximal(option(test)) = infinity
maximal(option(return_type)) = infinity
maximal(option(NEWLINE)) = 1
maximal(not_test) = infinity
maximal(nonlocal_stmt) = infinity
maximal(nonempty_list(string)) = infinity
maximal(nonempty_list(stmt)) = infinity
maximal(nonempty_list(format_token)) = infinity
maximal(nonempty_list(excepthandler)) = infinity
maximal(nonempty_list(decorator)) = infinity
maximal(nl_or_stmt) = infinity
maximal(namedexpr_test) = infinity
maximal(namedexpr_or_star_expr) = infinity
maximal(name_and_level) = infinity
maximal(main) = infinity
maximal(listsync_comp_for) = infinity
maximal(listcomp_for) = infinity
maximal(list_sep_term(subscript,COMMA)) = infinity
maximal(list_sep_term(import_as_name,COMMA)) = infinity
maximal(list_sep_term(dictorset_elem,COMMA)) = infinity
maximal(list_sep_term(argument,COMMA)) = infinity
maximal(list_sep(not_test,AND)) = infinity
maximal(list_sep(dotted_as_name,COMMA)) = infinity
maximal(list_sep(and_test,OR)) = infinity
maximal(list_sep(NAME,COMMA)) = infinity
maximal(list_for_rest) = infinity
maximal(list_for) = infinity
maximal(list_comma(subscript)) = infinity
maximal(list_comma(import_as_name)) = infinity
maximal(list_comma(dictorset_elem)) = infinity
maximal(list_comma(argument)) = infinity
maximal(list(stmt)) = infinity
maximal(list(nl_or_stmt)) = infinity
maximal(list(interpolated)) = infinity
maximal(lambdadef_nocond) = infinity
maximal(lambdadef) = infinity
maximal(interpolated) = infinity
maximal(interpolant) = infinity
maximal(import_stmt) = infinity
maximal(import_name) = infinity
maximal(import_from) = infinity
maximal(import_as_name) = 3
maximal(if_stmt) = infinity
maximal(global_stmt) = infinity
maximal(funcdef) = infinity
maximal(fstring_print_spec) = infinity
maximal(fstring_format_delimeter) = 1
maximal(fstring_format_clause) = infinity
maximal(fplist) = infinity
maximal(fpdef) = infinity
maximal(format_token) = infinity
maximal(format_specifier) = infinity
maximal(for_stmt) = infinity
maximal(flow_stmt) = infinity
maximal(file_input) = infinity
maximal(factor) = infinity
maximal(exprlist) = infinity
maximal(expr_stmt_rhs_list) = infinity
maximal(expr_stmt_rhs) = infinity
maximal(expr_stmt) = infinity
maximal(expr_or_star_expr) = infinity
maximal(expr) = infinity
maximal(exec_stmt) = infinity
maximal(excepthandler) = infinity
maximal(elif_stmt_list) = infinity
maximal(dotted_name) = infinity
maximal(dotted_as_name) = infinity
maximal(dot_level) = infinity
maximal(dictorsetmaker) = infinity
maximal(dictorset_elem) = infinity
maximal(del_stmt) = infinity
maximal(decorator_name) = infinity
maximal(decorator) = infinity
maximal(decorated) = infinity
maximal(continue_stmt) = 1
maximal(compound_stmt) = infinity
maximal(comparison_list) = infinity
maximal(comparison) = infinity
maximal(comp_op) = 2
maximal(comp_iter) = infinity
maximal(comp_if) = infinity
maximal(comp_for) = infinity
maximal(classdef) = infinity
maximal(break_stmt) = 1
maximal(augassign) = 1
maximal(atom_tuple) = infinity
maximal(atom_repr) = infinity
maximal(atom_list) = infinity
maximal(atom_expr) = infinity
maximal(atom_dict) = infinity
maximal(atom_and_trailers) = infinity
maximal(atom) = infinity
maximal(async_stmt) = infinity
maximal(async_funcdef) = infinity
maximal(assert_stmt) = infinity
maximal(arith_expr) = infinity
maximal(argument) = infinity
maximal(arglist_paren_opt) = infinity
maximal(arglist_paren2_opt) = infinity
maximal(and_test) = infinity
maximal(and_expr) = infinity
follow(yield_stmt) = SEMICOL NEWLINE
follow(yield_expr) = SEMICOL RPAREN NEWLINE EQ
follow(xor_expr) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
follow(with_stmt) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(with_inner) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(while_stmt) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(varargslist) = COLON
follow(typedargslist) = RPAREN
follow(typed_parameter) = RPAREN COMMA
follow(tuple(test_or_star_expr)) = XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COLON ANDEQ ADDEQ
follow(tuple(test)) = SEMICOL RPAREN RBRACE NEWLINE EQ COLON BANG
follow(tuple(namedexpr_or_star_expr)) = RPAREN RBRACK
follow(tuple(expr_or_star_expr)) = SEMICOL NEWLINE IN
follow(try_stmt) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(tfpdef_or_fpdef) = RPAREN COMMA
follow(tfpdef) = RPAREN EQ COMMA
follow(testlist_comp_or_expr) = RPAREN
follow(testlist_comp) = RBRACK
follow(testlist1) = BACKQUOTE
follow(test_or_star_expr) = XOREQ SUBEQ SEMICOL RSHEQ POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FDIVEQ EQ DIVEQ COMMA COLON ANDEQ ADDEQ
follow(test_nocond) = RPAREN RBRACK RBRACE IF FOR COMMA ASYNC
follow(test) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
follow(term_op) = TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
follow(term) = XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD
follow(sync_comp_for) = RPAREN RBRACK RBRACE COMMA
follow(suite) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(subscript) = RBRACK COMMA
follow(string) = XOREQ SUBEQ SUB STR SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FSTRING_START FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
follow(stmt) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(star_expr) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ IN FOR FDIVEQ EQ DIVEQ COMMA COLON ASYNC ANDEQ ADDEQ
follow(small_stmt) = SEMICOL NEWLINE
follow(simple_stmt) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES ELIF DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(shift_expr) = XOREQ SUBEQ SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
follow(sgrep_spatch_pattern) = #
follow(return_type) = COLON
follow(return_stmt) = SEMICOL NEWLINE
follow(raise_stmt) = SEMICOL NEWLINE
follow(print_testlist) = SEMICOL NEWLINE
follow(print_stmt) = SEMICOL NEWLINE
follow(power) = XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
follow(pass_stmt) = SEMICOL NEWLINE
follow(parameters) = SUB COLON
follow(parameter) = COMMA COLON
follow(or_test) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
follow(option(test)) = RBRACK COMMA COLON
follow(option(return_type)) = COLON
follow(option(NEWLINE)) = EOF
follow(not_test) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
follow(nonlocal_stmt) = SEMICOL NEWLINE
follow(nonempty_list(string)) = XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
follow(nonempty_list(stmt)) = NEWLINE EOF
follow(nonempty_list(format_token)) = RBRACE
follow(nonempty_list(excepthandler)) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(nonempty_list(decorator)) = DEF CLASS ASYNC
follow(nl_or_stmt) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(namedexpr_test) = RPAREN RBRACK FOR COMMA COLON ASYNC
follow(namedexpr_or_star_expr) = RPAREN RBRACK FOR COMMA ASYNC
follow(name_and_level) = IMPORT
follow(main) = #
follow(listsync_comp_for) = RBRACK
follow(listcomp_for) = RBRACK
follow(list_sep_term(subscript,COMMA)) = RBRACK
follow(list_sep_term(import_as_name,COMMA)) = SEMICOL RPAREN NEWLINE
follow(list_sep_term(dictorset_elem,COMMA)) = RBRACE
follow(list_sep_term(argument,COMMA)) = RPAREN
follow(list_sep(not_test,AND)) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
follow(list_sep(dotted_as_name,COMMA)) = SEMICOL NEWLINE COMMA
follow(list_sep(and_test,OR)) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
follow(list_sep(NAME,COMMA)) = SEMICOL NEWLINE COMMA
follow(list_for_rest) = RBRACK
follow(list_for) = RBRACK
follow(list_comma(subscript)) = RBRACK
follow(list_comma(import_as_name)) = SEMICOL RPAREN NEWLINE
follow(list_comma(dictorset_elem)) = RBRACE
follow(list_comma(argument)) = RPAREN
follow(list(stmt)) = DEDENT
follow(list(nl_or_stmt)) = INDENT EOF
follow(list(interpolated)) = FSTRING_END
follow(lambdadef_nocond) = RPAREN RBRACK RBRACE IF FOR COMMA ASYNC
follow(lambdadef) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ NEWLINE MULTEQ MODEQ LSHEQ FROM FOR FDIVEQ EQ DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
follow(interpolated) = FSTRING_STRING FSTRING_LBRACE FSTRING_END
follow(interpolant) = RBRACE EQ COLON BANG
follow(import_stmt) = SEMICOL NEWLINE
follow(import_name) = SEMICOL NEWLINE
follow(import_from) = SEMICOL NEWLINE
follow(import_as_name) = SEMICOL RPAREN NEWLINE COMMA
follow(if_stmt) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(global_stmt) = SEMICOL NEWLINE
follow(funcdef) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(fstring_print_spec) = RBRACE
follow(fstring_format_delimeter) = SUB NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
follow(fstring_format_clause) = RBRACE
follow(fplist) = RPAREN
follow(fpdef) = RPAREN COMMA COLON
follow(format_token) = SUB RBRACE NAME MOD LT LBRACE INT GT FLOAT EQ DOT DIV COMMA COLON BITXOR ADD
follow(format_specifier) = RBRACE
follow(for_stmt) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(flow_stmt) = SEMICOL NEWLINE
follow(file_input) = INDENT EOF
follow(factor) = XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
follow(exprlist) = SEMICOL NEWLINE IN
follow(expr_stmt_rhs_list) = SEMICOL NEWLINE
follow(expr_stmt_rhs) = SEMICOL NEWLINE EQ
follow(expr_stmt) = SEMICOL NEWLINE
follow(expr_or_star_expr) = SEMICOL NEWLINE IN COMMA
follow(expr) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
follow(exec_stmt) = SEMICOL NEWLINE
follow(excepthandler) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FINALLY FALSE EXEC EXCEPT EOF ELSE ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(elif_stmt_list) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(dotted_name) = SEMICOL NEWLINE IMPORT COMMA AS
follow(dotted_as_name) = SEMICOL NEWLINE COMMA
follow(dot_level) = NAME IMPORT
follow(dictorsetmaker) = RBRACE
follow(dictorset_elem) = RBRACE FOR COMMA ASYNC
follow(del_stmt) = SEMICOL NEWLINE
follow(decorator_name) = NEWLINE LPAREN DOT
follow(decorator) = DEF CLASS AT ASYNC
follow(decorated) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(continue_stmt) = SEMICOL NEWLINE
follow(compound_stmt) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(comparison_list) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
follow(comparison) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
follow(comp_op) = TRUE SUB STR NONE NAME LPAREN LONGINT LDots LBRACK LBRACE INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
follow(comp_iter) = RPAREN RBRACK RBRACE COMMA
follow(comp_if) = RPAREN RBRACK RBRACE COMMA
follow(comp_for) = RPAREN RBRACK RBRACE COMMA
follow(classdef) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(break_stmt) = SEMICOL NEWLINE
follow(augassign) = YIELD TRUE SUB STR NOT NONE NAME LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT IMAG FSTRING_START FLOAT FALSE ELLIPSES BITNOT BACKQUOTE AWAIT ADD
follow(atom_tuple) = XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
follow(atom_repr) = XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
follow(atom_list) = XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
follow(atom_expr) = XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
follow(atom_dict) = XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
follow(atom_and_trailers) = XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
follow(atom) = XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ POW OREQ OR NOTEQ NOT NEWLINE MULTEQ MULT MODEQ MOD LT LSHIFT LSHEQ LPAREN LEQ LBRACK IS IN IF GT GEQ FROM FOR FDIVEQ FDIV EQUAL EQ ELSE DOT DIVEQ DIV COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE AT ASYNC AS ANDEQ AND ADDEQ ADD
follow(async_stmt) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(async_funcdef) = YIELD WITH WHILE TRY TRUE SUB STR RETURN RAISE PRINT PASS NOT NONLOCAL NONE NEWLINE NAME MULT LPAREN LONGINT LDots LBRACK LBRACE LAMBDA INT INDENT IMPORT IMAG IF GLOBAL FSTRING_START FROM FOR FLOAT FALSE EXEC EOF ELLIPSES DEL DEF DEDENT CONTINUE CLASS BREAK BITNOT BACKQUOTE AWAIT AT ASYNC ASSERT ADD
follow(assert_stmt) = SEMICOL NEWLINE
follow(arith_expr) = XOREQ SUBEQ SUB SEMICOL RSHIFT RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHIFT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BITAND BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ ADD
follow(argument) = RPAREN COMMA
follow(arglist_paren_opt) = COLON
follow(arglist_paren2_opt) = NEWLINE
follow(and_test) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NEWLINE MULTEQ MODEQ LSHEQ IF FROM FOR FDIVEQ EQ ELSE DIVEQ COMMA COLONEQ COLON BANG BACKQUOTE ASYNC AS ANDEQ ADDEQ
follow(and_expr) = XOREQ SUBEQ SEMICOL RSHEQ RPAREN RDots RBRACK RBRACE POWEQ OREQ OR NOTEQ NOT NEWLINE MULTEQ MODEQ LT LSHEQ LEQ IS IN IF GT GEQ FROM FOR FDIVEQ EQUAL EQ ELSE DIVEQ COMMA COLONEQ COLON BITXOR BITOR BANG BACKQUOTE ASYNC AS ANDEQ AND ADDEQ
Built an LR(0) automaton with 612 states.
The grammar is not SLR(1) -- 6 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 612 states.
294 out of 612 states have a default reduction.
The action table is 63648 entries; 4997 non-zero; 4469 compressed.
The action table occupies roughly 9032 bytes.
The goto table is 89964 entries; 3675 non-zero; 10161 compressed.
The goto table occupies roughly 20416 bytes.
The error table occupies roughly 7992 bytes.
The default_reduction table occupies roughly 1256 bytes.
The lhs table occupies roughly 424 bytes.
The trace table occupies roughly 8 bytes.
