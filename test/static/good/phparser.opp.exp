%{
%}
%start dummy
%start start
%token ABSTRACT
%token AND
%token AND_EQUAL
%token ANTISLASH
%token ARRAY
%token ARRAY_CAST
%token ARROW
%token AS
%token ASYNC
%token AT
%token AWAIT
%token BACKQUOTE
%token BANG
%token BOOLEAN_AND
%token BOOLEAN_OR
%token BOOL_CAST
%token BREAK
%token CALLABLE
%token CASE
%token CATCH
%token CLASS
%token CLASS_C
%token CLONE
%token CLOSE_TAG
%token CLOSE_TAG_OF_ECHO
%token COALESCE
%token COLON
%token COLONCOLON
%token COMMA
%token COMMENT
%token CONCAT
%token CONCAT_EQUAL
%token CONCURRENT
%token CONST
%token <string> CONSTANT_ENCAPSED_STRING
%token CONTINUE
%token COROUTINE
%token CURLY_OPEN
%token DEC
%token DECLARE
%token DEFAULT
%token DIR
%token DIV
%token DIV_EQUAL
%token <string> DNUMBER
%token DO
%token DOC_COMMENT
%token DOLLAR
%token DOLLARDOLLAR
%token DOLLAR_OPEN_CURLY_BRACES
%token DOUBLEQUOTE
%token DOUBLE_ARROW
%token DOUBLE_CAST
%token ECHO
%token ELLIPSIS
%token ELSE
%token ELSEIF
%token EMPTY
%token <string> ENCAPSED_AND_WHITESPACE
%token ENDIF
%token END_HEREDOC
%token ENUM
%token EOF
%token EQUAL
%token EVAL
%token EXIT
%token EXTENDS
%token FILE
%token FINAL
%token FINALLY
%token FOR
%token FOREACH
%token FOREACH_AS
%token FORK
%token <bool ref> FORK_LANGLE
%token FUNCTION
%token FUNC_C
%token GLOBAL
%token GOTO
%token HALT_COMPILER
%token <string> IDENT
%token IF
%token IMPLEMENTS
%token INC
%token INCLUDE
%token INCLUDE_ONCE
%token <string> INLINE_HTML
%token INOUT
%token INSTANCEOF
%token INSTEADOF
%token INTERFACE
%token INT_CAST
%token IS
%token ISSET
%token IS_EQUAL
%token IS_GREATER_OR_EQUAL
%token IS_IDENTICAL
%token IS_NOT_EQUAL
%token IS_NOT_IDENTICAL
%token IS_SMALLER_OR_EQUAL
%token LANGLE
%token LBRACE
%token LBRACKET
%token LINE
%token LIST
%token <string> LNUMBER
%token LOGICAL_AND
%token LOGICAL_OR
%token LOGICAL_XOR
%token LONG_DOUBLE_ARROW
%token LPAREN
%token METHOD_C
%token MINUS
%token MINUS_EQUAL
%token MOD
%token MOD_EQUAL
%token MUL
%token MUL_EQUAL
%token NAMESPACE
%token NAMESPACE_C
%token NEW
%token NEWLINE
%token NEWTYPE
%token <string> NUM_STRING
%token OBJECT_CAST
%token OPEN_TAG
%token OPEN_TAG_WITH_ECHO
%token OR
%token OR_EQUAL
%token PARENT
%token PIPE_ANGLE
%token PLUS
%token PLUS_EQUAL
%token POW
%token POW_EQUAL
%token PRINT
%token PRIVATE
%token PROTECTED
%token PUBLIC
%token QUESTION
%token QUESTION_ARROW
%token QUESTION_QUESTION
%token QUESTION_QUESTION_EQUAL
%token RANGLE
%token RBRACE
%token RBRACKET
%token REQUIRE
%token REQUIRE_ONCE
%token RETURN
%token RPAREN
%token SELF
%token SEMICOLON
%token SHAPE
%token SHL
%token SHL_EQUAL
%token SHR_EQUAL
%token SHR_PREFIX
%token SPACES
%token SPACESHIP
%token START_HEREDOC
%token STATIC
%token STRING_CAST
%token SUPER
%token SUSPEND
%token SWITCH
%token THROW
%token TILDE
%token TRAIT
%token TRAIT_C
%token TRY
%token TYPE
%token UNKNOWN
%token UNSET
%token UNSET_CAST
%token USE
%token USING
%token VAR
%token <string> VARIABLE
%token <string> VARNAME
%token WHERE
%token WHILE
%token XHP_ANY
%token <string> XHP_ATTR
%token XHP_ATTRIBUTE
%token XHP_CATEGORY
%token XHP_CHILDREN
%token <string list option> XHP_CLOSE_TAG
%token <string list> XHP_COLONID_DEF
%token XHP_GT
%token <string list> XHP_OPEN_TAG
%token XHP_PCDATA
%token <string list> XHP_PERCENTID_DEF
%token XHP_REQUIRED
%token XHP_SLASH_GT
%token <string> XHP_TEXT
%token XOR
%token XOR_EQUAL
%token YIELD
%token YIELD_FROM
%left INCLUDE INCLUDE_ONCE REQUIRE REQUIRE_ONCE
%left LOGICAL_OR
%left LOGICAL_XOR
%left LOGICAL_AND
%right PRINT SUSPEND
%right YIELD
%right DOUBLE_ARROW LONG_DOUBLE_ARROW PIPE_ANGLE
%left AND_EQUAL CONCAT_EQUAL DIV_EQUAL EQUAL MINUS_EQUAL MOD_EQUAL MUL_EQUAL OR_EQUAL PLUS_EQUAL POW_EQUAL QUESTION_QUESTION_EQUAL SHL_EQUAL SHR_EQUAL XOR_EQUAL
%nonassoc pre_COLONCOLON
%left COLONCOLON
%nonassoc ARROW LBRACKET QUESTION_ARROW
%nonassoc LBRACE LPAREN
%left AS COLON IS QUESTION QUESTION_QUESTION
%left BOOLEAN_OR
%left BOOLEAN_AND
%left OR
%left XOR
%left AND
%nonassoc IS_EQUAL IS_IDENTICAL IS_NOT_EQUAL SPACESHIP
%right IS_NOT_IDENTICAL
%right LANGLE
%right RANGLE
%nonassoc IS_GREATER_OR_EQUAL IS_SMALLER_OR_EQUAL
%left SHL SHR_PREFIX
%left CONCAT MINUS PLUS
%left DIV MOD MUL
%right BANG
%nonassoc INSTANCEOF
%right ARRAY_CAST AT AWAIT BOOL_CAST DEC DOUBLE_CAST INC INT_CAST OBJECT_CAST STRING_CAST TILDE UNSET_CAST
%right POW
%nonassoc CLONE
%left pre_ELSE
%left ELSEIF
%left ELSE
%type <unit> dummy
%type <unit> start
%%

option_AND_:
  
    {    ( None )}
| x = AND
    {    ( Some x )}

option_AWAIT_:
  
    {    ( None )}
| x = AWAIT
    {    ( Some x )}

option_COMMA_:
  
    {    ( None )}
| x = COMMA
    {    ( Some x )}

option_COROUTINE_:
  
    {    ( None )}
| x = COROUTINE
    {    ( Some x )}

option_ELLIPSIS_:
  
    {    ( None )}
| x = ELLIPSIS
    {    ( Some x )}

option_INOUT_:
  
    {    ( None )}
| x = INOUT
    {    ( Some x )}

option_NAMESPACE_:
  
    {    ( None )}
| x = NAMESPACE
    {    ( Some x )}

option_QUESTION_:
  
    {    ( None )}
| x = QUESTION
    {    ( Some x )}

option_SEMICOLON_:
  
    {    ( None )}
| x = SEMICOLON
    {    ( Some x )}

option_XHP_REQUIRED_:
  
    {    ( None )}
| x = XHP_REQUIRED
    {    ( Some x )}

option_attributes_:
  
    {    ( None )}
| x = attributes
    {    ( Some x )}

option_expr_:
  
    {    ( None )}
| x = expr
    {    ( Some x )}

option_expr_array_pair_:
  
    {    ( None )}
| x = expr_array_pair
    {    ( Some x )}

option_identifier_:
  
    {    ( None )}
| x = identifier
    {    ( Some x )}

option_lexical_vars_:
  
    {    ( None )}
| x = lexical_vars
    {    ( Some x )}

option_preceded_AS_type_expr__:
  
    {    ( None )}
| _1 = AS x = type_expr
    {let x =     ( x ) in
    ( Some x )}

option_preceded_EQUAL_expr__:
  
    {    ( None )}
| _1 = EQUAL x = expr
    {let x =     ( x ) in
    ( Some x )}

option_preceded_EQUAL_type_expr__:
  
    {    ( None )}
| _1 = EQUAL x = type_expr
    {let x =     ( x ) in
    ( Some x )}

option_preceded_EXTENDS_class_name__:
  
    {    ( None )}
| _1 = EXTENDS x = class_name
    {let x =     ( x ) in
    ( Some x )}

option_preceded_EXTENDS_comma_list_class_name___:
  
    {    ( None )}
| _1 = EXTENDS
    {let x =
  let x =
    let _1 =               ( [] ) in
                                ( _1 )
  in
      ( x )
in
    ( Some x )}
| _1 = EXTENDS _1_inlined1 = lseparated_nonempty_list_aux_COMMA_class_name_
    {let x =
  let x =
    let _1 = _1_inlined1 in
    let _1 =
      let _1 =                                        ( List.rev _1 ) in
                                         ( _1 )
    in
                                ( _1 )
  in
      ( x )
in
    ( Some x )}

option_preceded_IMPLEMENTS_comma_list_class_name___:
  
    {    ( None )}
| _1 = IMPLEMENTS
    {let x =
  let x =
    let _1 =               ( [] ) in
                                ( _1 )
  in
      ( x )
in
    ( Some x )}
| _1 = IMPLEMENTS _1_inlined1 = lseparated_nonempty_list_aux_COMMA_class_name_
    {let x =
  let x =
    let _1 = _1_inlined1 in
    let _1 =
      let _1 =                                        ( List.rev _1 ) in
                                         ( _1 )
    in
                                ( _1 )
  in
      ( x )
in
    ( Some x )}

option_return_type_:
  
    {    ( None )}
| x = return_type
    {    ( Some x )}

option_try_finally_:
  
    {    ( None )}
| x = try_finally
    {    ( Some x )}

option_type_arguments_:
  
    {    ( None )}
| x = type_arguments
    {    ( Some x )}

option_type_expr_:
  
    {    ( None )}
| x = type_expr
    {    ( Some x )}

option_type_parameters_:
  
    {    ( None )}
| x = type_parameters
    {    ( Some x )}

option_where_constraints_:
  
    {    ( None )}
| x = where_constraints
    {    ( Some x )}

loption_separated_nonempty_list_OR_name__:
  
    {    ( [] )}
| x = separated_nonempty_list_OR_name_
    {    ( x )}

list_class_member_modifier_:
  
    {    ( [] )}
| x = class_member_modifier xs = list_class_member_modifier_
    {    ( x :: xs )}

list_class_modifier_:
  
    {    ( [] )}
| x = class_modifier xs = list_class_modifier_
    {    ( x :: xs )}

list_encaps_:
  
    {    ( [] )}
| x = encaps xs = list_encaps_
    {    ( x :: xs )}

list_statement_class_:
  
    {    ( [] )}
| x = statement_class xs = list_statement_class_
    {    ( x :: xs )}

list_statement_inner_:
  
    {    ( [] )}
| x = statement_inner xs = list_statement_inner_
    {    ( x :: xs )}

list_switch_case_:
  
    {    ( [] )}
| x = switch_case xs = list_switch_case_
    {    ( x :: xs )}

list_top_statement_:
  
    {    ( [] )}
| x = top_statement xs = list_top_statement_
    {    ( x :: xs )}

list_trait_adaptation_:
  
    {    ( [] )}
| x = trait_adaptation xs = list_trait_adaptation_
    {    ( x :: xs )}

list_try_catch_:
  
    {    ( [] )}
| x = try_catch xs = list_try_catch_
    {    ( x :: xs )}

list_xhp_attribute_:
  
    {    ( [] )}
| x = xhp_attribute xs = list_xhp_attribute_
    {    ( x :: xs )}

list_xhp_child_:
  
    {    ( [] )}
| x = xhp_child xs = list_xhp_child_
    {    ( x :: xs )}

nonempty_list_class_member_modifier_:
  x = class_member_modifier
    {    ( [ x ] )}
| x = class_member_modifier xs = nonempty_list_class_member_modifier_
    {    ( x :: xs )}

separated_nonempty_list_OR_name_:
  x = name
    {    ( [ x ] )}
| x = name _2 = OR xs = separated_nonempty_list_OR_name_
    {    ( x :: xs )}

start:
  _1 = list_top_statement_ _2 = EOF
    {                     ( () )}

top_statement:
  _1 = statement
    {                                               ( () )}
| _1 = declaration
    {                                               ( () )}
| _1 = HALT_COMPILER _2 = LPAREN _3 = RPAREN _4 = SEMICOLON
    {                                               ( () )}
| _1 = NAMESPACE _2 = namespace_name _3 = SEMICOLON
    {                                               ( () )}
| _1 = NAMESPACE _2 = namespace_name _3 = LBRACE _4 = list_top_statement_ _5 = RBRACE
    {                                                        ( () )}
| _1 = NAMESPACE _2 = LBRACE _3 = list_top_statement_ _4 = RBRACE
    {                                               ( () )}
| _1 = USE _2 = option_NAMESPACE_ _3 = mixed_group_use_declaration _4 = SEMICOLON
    {                                                          ( () )}
| _1 = USE _2 = option_NAMESPACE_ _3 = use_modifier _4 = group_use_declaration _5 = SEMICOLON
    {                                                              ( () )}
| _1 = USE _2 = option_NAMESPACE_ _4 = SEMICOLON
    {let _3 =
  let _1 =               ( [] ) in
                              ( _1 )
in
                                                          ( () )}
| _1 = USE _2 = option_NAMESPACE_ _1_inlined1 = lseparated_nonempty_list_aux_COMMA_use_declaration_ _4 = SEMICOLON
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
                                                          ( () )}
| _1 = USE _2 = option_NAMESPACE_ _3 = use_modifier _5 = SEMICOLON
    {let _4 =
  let _1 =               ( [] ) in
                              ( _1 )
in
                                                                    ( () )}
| _1 = USE _2 = option_NAMESPACE_ _3 = use_modifier _1_inlined1 = lseparated_nonempty_list_aux_COMMA_use_declaration_ _5 = SEMICOLON
    {let _4 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
                                                                    ( () )}
| _1 = CONST _3 = SEMICOLON
    {let _2 =
  let _1 =               ( [] ) in
                              ( _1 )
in
                                                         ( () )}
| _1 = CONST _1_inlined1 = lseparated_nonempty_list_aux_COMMA_constant_declaration_ _3 = SEMICOLON
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
                                                         ( () )}

identifier:
  _1 = IDENT
    {                  ( () )}
| _1 = XHP_COLONID_DEF
    {                  ( () )}
| _1 = semi_reserved
    {                  ( () )}

name:
  _1 = namespace_name
    {                                     ( () )}
| _1 = NAMESPACE _2 = ANTISLASH _3 = namespace_name
    {                                     ( () )}
| _1 = ANTISLASH _2 = namespace_name
    {                                     ( () )}
| _1 = xhp_reserved
    {                                     ( () )}

namespace_name:
  _1 = IDENT
    {                                  ( () )}
| _1 = XHP_COLONID_DEF
    {                                  ( () )}
| _1 = namespace_name _2 = ANTISLASH _3 = IDENT
    {                                  ( () )}

class_special_name:
  _1 = STATIC
    {                      ( () )}
| _1 = SELF
    {                      ( () )}
| _1 = PARENT
    {                      ( () )}
| _1 = SHAPE
    {                      ( () )}
| _1 = ARRAY
    {                      ( () )}

unparametrized_class_name:
  _1 = STATIC
    {                      ( () )}
| _1 = SELF
    {                      ( () )}
| _1 = PARENT
    {                      ( () )}
| _1 = name
    {                      ( () )}

class_name:
  _1 = unparametrized_class_name
    {                            ( () )}
| _1 = unparametrized_class_name _2 = type_arguments
    {                                           ( () )}

type_name:
  _1 = CALLABLE
    {           ( () )}
| _1 = SELF
    {           ( () )}
| _1 = PARENT
    {           ( () )}
| _1 = ARRAY
    {           ( () )}
| _1 = name
    {           ( () )}

attribute:
  _1 = ANTISLASH _2 = attribute
    {                      ( () )}
| _1 = IDENT
    {        ( () )}
| _1 = IDENT _2 = COLON _3 = attribute
    {                        ( () )}
| _1 = IDENT _2 = LPAREN _4 = RPAREN
    {let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                                ( () )}
| _1 = IDENT _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _2_inlined1 = option_COMMA_ _4 = RPAREN
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                                ( () )}

attributes:
  _1 = SHL _1_inlined1 = lseparated_nonempty_list_aux_COMMA_attribute_ _2 = option_COMMA_ _3 = SHR_PREFIX _4 = RANGLE
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =                                        ( List.rev _1 ) in
                                              ( _1 )
in
                                                                ( () )}

declaration:
  _1 = attributes
    {                     ( () )}
| _1 = declare_function
    {                     ( () )}
| _1 = declare_class
    {                     ( () )}
| _1 = declare_trait
    {                     ( () )}
| _1 = declare_interface
    {                     ( () )}
| _1 = declare_enum
    {                     ( () )}
| _1 = declare_type
    {                     ( () )}

declare_function:
  _1 = ASYNC _2 = declare_function
    {                         ( () )}
| _1 = COROUTINE _2 = declare_function
    {                             ( () )}
| _1 = FUNCTION _2 = option_AND_ _3 = identifier [@doc_comment ] _4 = option_type_parameters_ _5 = LPAREN _7 = RPAREN _8 = option_return_type_ [@fn_flags ] _9 = option_where_constraints_ _10 = LBRACE _11 = list_statement_inner_ _12 = RBRACE [@fn_flags ]
    {let _6 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
  ( () )}
| _1 = FUNCTION _2 = option_AND_ _3 = identifier [@doc_comment ] _4 = option_type_parameters_ _5 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _7 = RPAREN _8 = option_return_type_ [@fn_flags ] _9 = option_where_constraints_ _10 = LBRACE _11 = list_statement_inner_ _12 = RBRACE [@fn_flags ]
    {let _6 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
  ( () )}

where_constraints:
  _1 = WHERE
    {let _2 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                              ( () )}
| _1 = WHERE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_where_constraint_ _2 = option_COMMA_
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                              ( () )}

where_constraint:
  _1 = type_expr _2 = EQUAL _3 = type_expr
    {                            ( () )}
| _1 = type_expr _2 = AS _3 = type_expr
    {                            ( () )}
| _1 = type_expr _2 = SUPER _3 = type_expr
    {                            ( () )}

declare_class:
  _1 = list_class_modifier_ _2 = CLASS _3 = identifier _4 = option_type_parameters_ _5 = option_preceded_EXTENDS_class_name__ _6 = option_preceded_IMPLEMENTS_comma_list_class_name___ [@doc_comment ] _7 = LBRACE _8 = list_statement_class_ _9 = RBRACE
    {  ( () )}

class_modifier:
  _1 = ABSTRACT
    {           ( () )}
| _1 = FINAL
    {           ( () )}

declare_trait:
  _1 = TRAIT _2 = identifier _3 = option_type_parameters_ _4 = option_preceded_IMPLEMENTS_comma_list_class_name___ [@doc_comment ] _5 = LBRACE _6 = list_statement_class_ _7 = RBRACE
    {  ( () )}

declare_interface:
  _1 = INTERFACE _2 = identifier _3 = option_type_parameters_ _4 = option_preceded_EXTENDS_comma_list_class_name___ [@doc_comment ] _5 = LBRACE _6 = list_statement_class_ _7 = RBRACE
    {  ( () )}

declare_enum:
  _1 = ENUM _2 = IDENT _3 = COLON _4 = type_expr _5 = option_preceded_AS_type_expr__ _6 = LBRACE _8 = RBRACE
    {let _7 =               ( [] ) in
  ( () )}
| _1 = ENUM _2 = IDENT _3 = COLON _4 = type_expr _5 = option_preceded_AS_type_expr__ _6 = LBRACE _1_inlined1 = lseparated_nonempty_list_aux_SEMICOLON_enum_member_ _2_inlined1 = option_SEMICOLON_ _8 = RBRACE
    {let _7 =
  let _1 = _1_inlined1 in
  let _1 =                                        ( List.rev _1 ) in
                                          ( _1 )
in
  ( () )}

enum_member:
  _1 = identifier _2 = EQUAL _3 = expr
    {                        ( () )}

declare_type:
  _1 = TYPE _2 = identifier _3 = option_type_parameters_ _4 = option_preceded_AS_type_expr__ _5 = EQUAL _6 = type_expr _7 = SEMICOLON
    {  ( () )}
| _1 = NEWTYPE _2 = identifier _3 = option_type_parameters_ _4 = option_preceded_AS_type_expr__ _5 = EQUAL _6 = type_expr _7 = SEMICOLON
    {  ( () )}

statement:
  _1 = LBRACE _2 = list_statement_inner_ _3 = RBRACE
    {                                 ( () )}
| _1 = statement_if
    {               ( () )}
| _1 = WHILE _2 = LPAREN _3 = expr _4 = RPAREN _5 = statement
    {  ( () )}
| _1 = DO _2 = statement _3 = WHILE _4 = LPAREN _5 = expr _6 = RPAREN _7 = SEMICOLON
    {  ( () )}
| _1 = FOR _2 = LPAREN _4 = SEMICOLON _6 = SEMICOLON _8 = RPAREN _9 = statement
    {let _7 =
  let _1 =               ( [] ) in
                              ( _1 )
in
let _5 =
  let _1 =               ( [] ) in
                              ( _1 )
in
let _3 =
  let _1 =               ( [] ) in
                              ( _1 )
in
  ( () )}
| _1 = FOR _2 = LPAREN _4 = SEMICOLON _6 = SEMICOLON _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _8 = RPAREN _9 = statement
    {let _7 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
let _5 =
  let _1 =               ( [] ) in
                              ( _1 )
in
let _3 =
  let _1 =               ( [] ) in
                              ( _1 )
in
  ( () )}
| _1 = FOR _2 = LPAREN _4 = SEMICOLON _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _6 = SEMICOLON _8 = RPAREN _9 = statement
    {let _7 =
  let _1 =               ( [] ) in
                              ( _1 )
in
let _5 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
let _3 =
  let _1 =               ( [] ) in
                              ( _1 )
in
  ( () )}
| _1 = FOR _2 = LPAREN _4 = SEMICOLON _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _6 = SEMICOLON _1_inlined2 = lseparated_nonempty_list_aux_COMMA_expr_ _8 = RPAREN _9 = statement
    {let _7 =
  let _1 = _1_inlined2 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
let _5 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
let _3 =
  let _1 =               ( [] ) in
                              ( _1 )
in
  ( () )}
| _1 = FOR _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _4 = SEMICOLON _6 = SEMICOLON _8 = RPAREN _9 = statement
    {let _7 =
  let _1 =               ( [] ) in
                              ( _1 )
in
let _5 =
  let _1 =               ( [] ) in
                              ( _1 )
in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
  ( () )}
| _1 = FOR _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _4 = SEMICOLON _6 = SEMICOLON _1_inlined2 = lseparated_nonempty_list_aux_COMMA_expr_ _8 = RPAREN _9 = statement
    {let _7 =
  let _1 = _1_inlined2 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
let _5 =
  let _1 =               ( [] ) in
                              ( _1 )
in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
  ( () )}
| _1 = FOR _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _4 = SEMICOLON _1_inlined2 = lseparated_nonempty_list_aux_COMMA_expr_ _6 = SEMICOLON _8 = RPAREN _9 = statement
    {let _7 =
  let _1 =               ( [] ) in
                              ( _1 )
in
let _5 =
  let _1 = _1_inlined2 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
  ( () )}
| _1 = FOR _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _4 = SEMICOLON _1_inlined2 = lseparated_nonempty_list_aux_COMMA_expr_ _6 = SEMICOLON _1_inlined3 = lseparated_nonempty_list_aux_COMMA_expr_ _8 = RPAREN _9 = statement
    {let _7 =
  let _1 = _1_inlined3 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
let _5 =
  let _1 = _1_inlined2 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
  ( () )}
| _1 = SWITCH _2 = LPAREN _3 = expr _4 = RPAREN _5 = switch_body
    {                                        ( () )}
| _1 = BREAK _2 = option_expr_ _3 = SEMICOLON
    {                           ( () )}
| _1 = CONTINUE _2 = option_expr_ _3 = SEMICOLON
    {                           ( () )}
| _1 = RETURN _2 = option_attributes_ _3 = option_expr_ _4 = SEMICOLON
    {                                       ( () )}
| _1 = GLOBAL _3 = SEMICOLON
    {let _2 =
  let _1 =               ( [] ) in
                              ( _1 )
in
                                              ( () )}
| _1 = GLOBAL _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_variable_ _3 = SEMICOLON
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
                                              ( () )}
| _1 = STATIC _3 = SEMICOLON
    {let _2 =
  let _1 =               ( [] ) in
                              ( _1 )
in
                                                       ( () )}
| _1 = STATIC _1_inlined1 = lseparated_nonempty_list_aux_COMMA_initializable_variable_ _3 = SEMICOLON
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
                                                       ( () )}
| _1 = ECHO _3 = SEMICOLON
    {let _2 =
  let _1 =               ( [] ) in
                              ( _1 )
in
                                     ( () )}
| _1 = ECHO _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _3 = SEMICOLON
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
                                     ( () )}
| _1 = INLINE_HTML
    {              ( () )}
| _1 = expr _2 = SEMICOLON
    {                 ( () )}
| _1 = UNSET _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = SEMICOLON
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =                                        ( List.rev _1 ) in
                                              ( _1 )
in
                                                                   ( () )}
| _1 = FOREACH _2 = LPAREN _3 = expr _5 = FOREACH_AS _6 = foreach_variable _7 = RPAREN _8 = statement
    {let _4 =     ( None ) in
    ( () )}
| _1 = FOREACH _2 = LPAREN _3 = expr x = AWAIT _5 = FOREACH_AS _6 = foreach_variable _7 = RPAREN _8 = statement
    {let _4 =     ( Some x ) in
    ( () )}
| _1 = FOREACH _2 = LPAREN _3 = expr _5 = FOREACH_AS _6 = foreach_variable _7 = DOUBLE_ARROW _8 = foreach_variable _9 = RPAREN _10 = statement
    {let _4 =     ( None ) in
    ( () )}
| _1 = FOREACH _2 = LPAREN _3 = expr x = AWAIT _5 = FOREACH_AS _6 = foreach_variable _7 = DOUBLE_ARROW _8 = foreach_variable _9 = RPAREN _10 = statement
    {let _4 =     ( Some x ) in
    ( () )}
| _1 = DECLARE _2 = LPAREN _4 = RPAREN _5 = statement
    {let _3 =
  let _1 =               ( [] ) in
                              ( _1 )
in
                                                                   ( () )}
| _1 = DECLARE _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_constant_declaration_ _4 = RPAREN _5 = statement
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
                                                                   ( () )}
| _1 = SEMICOLON
    {                                  ( () )}
| _1 = TRY _2 = LBRACE _3 = list_statement_inner_ _4 = RBRACE _5 = list_try_catch_ _6 = option_try_finally_
    {  ( () )}
| _1 = THROW _2 = expr _3 = SEMICOLON
    {                       ( () )}
| _1 = GOTO _2 = IDENT _3 = SEMICOLON
    {                       ( () )}
| _1 = IDENT _2 = COLON
    {              ( () )}
| _1 = option_AWAIT_ _2 = USING _3 = LPAREN _4 = expr_pair_list _5 = RPAREN _6 = SEMICOLON
    {                                                      ( () )}
| _1 = option_AWAIT_ _2 = USING _3 = LPAREN _4 = expr_pair_list _5 = RPAREN _6 = LBRACE _7 = list_statement_inner_ _8 = RBRACE
    {                                                                           ( () )}
| _1 = option_AWAIT_ _2 = USING _3 = expr_without_parenthesis _4 = SEMICOLON
    {                                                  ( () )}
| _1 = CONCURRENT _2 = LBRACE _3 = list_statement_inner_ _4 = RBRACE
    {                                            ( () )}

statement_inner:
  _1 = statement
    {                    ( () )}
| _1 = declare_function
    {                    ( () )}
| _1 = declare_class
    {                    ( () )}
| _1 = declare_trait
    {                    ( () )}
| _1 = declare_interface
    {                    ( () )}
| _1 = HALT_COMPILER _2 = LPAREN _3 = RPAREN _4 = SEMICOLON
    {                                        ( () )}

initializable_variable:
  _1 = VARIABLE _2 = option_preceded_EQUAL_expr__ [@doc_comment ]
    {                                                ( () )}

try_catch:
  _1 = CATCH _2 = LPAREN xs = loption_separated_nonempty_list_OR_name__ _4 = VARIABLE _5 = RPAREN _6 = LBRACE _7 = list_statement_inner_ _8 = RBRACE
    {let _3 =     ( xs ) in
  ( () )}

try_finally:
  _1 = FINALLY _2 = LBRACE _3 = list_statement_inner_ _4 = RBRACE
    {                                         ( () )}

foreach_variable:
  _1 = expr
    {                                     ( () )}
| _1 = AND _2 = expr_assignable
    {                                     ( () )}
| _1 = LIST _2 = LPAREN _3 = expr_pair_list _4 = RPAREN
    {                                     ( () )}

switch_body:
  _1 = LBRACE _2 = option_SEMICOLON_ _3 = list_switch_case_ _4 = RBRACE
    {                                             ( () )}

switch_case:
  _1 = CASE _2 = expr _3 = switch_case_separator _4 = list_statement_inner_
    {                                                   ( () )}
| _1 = DEFAULT _2 = switch_case_separator _3 = list_statement_inner_
    {                                                 ( () )}

switch_case_separator:
  _1 = COLON
    {            ( () )}
| _1 = SEMICOLON
    {            ( () )}

statement_if:
  _1 = if_without_else %prec pre_ELSE
    {                                 ( () )}
| _1 = if_without_else _2 = ELSE _3 = statement
    {                                 ( () )}

if_without_else:
  _1 = IF _2 = LPAREN _3 = expr _4 = RPAREN _5 = statement
    {                                  ( () )}
| _1 = if_without_else _2 = ELSEIF _3 = LPAREN _4 = expr _5 = RPAREN _6 = statement
    {                                                      ( () )}

parameter:
  _1 = option_attributes_ _2 = parameter_visibility _3 = option_INOUT_ _4 = option_type_expr_ _5 = option_AND_ _6 = parameter_core
    {                                                                         ( () )}

parameter_visibility:
  
    {              ( () )}
| _1 = PUBLIC
    {              ( () )}
| _1 = PRIVATE
    {              ( () )}
| _1 = PROTECTED
    {              ( () )}

parameter_core:
  _1 = VARIABLE _2 = option_preceded_EQUAL_expr__
    {                                   ( () )}
| _1 = ELLIPSIS _2 = VARIABLE
    {                    ( () )}
| _1 = ELLIPSIS
    {           ( () )}

statement_class:
  _1 = USE _3 = SEMICOLON
    {let _2 =
  let _1 =               ( [] ) in
                              ( _1 )
in
                                       ( () )}
| _1 = USE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_class_name_ _3 = SEMICOLON
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
                                       ( () )}
| _1 = USE _3 = LBRACE _4 = list_trait_adaptation_ _5 = RBRACE
    {let _2 =
  let _1 =               ( [] ) in
                              ( _1 )
in
                                                             ( () )}
| _1 = USE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_class_name_ _3 = LBRACE _4 = list_trait_adaptation_ _5 = RBRACE
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
                                                             ( () )}
| _1 = nonempty_list_class_member_modifier_ _2 = option_type_expr_ _4 = SEMICOLON
    {let _3 =
  let _1 =               ( [] ) in
                              ( _1 )
in
let _1 =                          ( () ) in
                                                 ( () )}
| _1 = nonempty_list_class_member_modifier_ _2 = option_type_expr_ _1_inlined1 = lseparated_nonempty_list_aux_COMMA_initializable_variable_ _4 = SEMICOLON
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
let _1 =                          ( () ) in
                                                 ( () )}
| _1 = VAR _2 = option_type_expr_ _4 = SEMICOLON
    {let _3 =
  let _1 =               ( [] ) in
                              ( _1 )
in
let _1 =       ( () ) in
                                                 ( () )}
| _1 = VAR _2 = option_type_expr_ _1_inlined1 = lseparated_nonempty_list_aux_COMMA_initializable_variable_ _4 = SEMICOLON
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
let _1 =       ( () ) in
                                                 ( () )}
| _1 = list_class_member_modifier_ _2 = CONST _4 = SEMICOLON
    {let _3 =
  let _1 =               ( [] ) in
                              ( _1 )
in
                                                                          ( () )}
| _1 = list_class_member_modifier_ _2 = CONST _1_inlined1 = lseparated_nonempty_list_aux_COMMA_constant_declaration_ _4 = SEMICOLON
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
                                                                          ( () )}
| _1 = list_class_member_modifier_ _2 = option_COROUTINE_ _3 = FUNCTION _4 = option_AND_ _5 = identifier [@doc_comment ] _6 = option_type_parameters_ _7 = LPAREN _9 = RPAREN _10 = option_return_type_ _11 = option_where_constraints_ [@fn_flags ] _12 = class_method_body [@fn_flags ]
    {let _8 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
  ( () )}
| _1 = list_class_member_modifier_ _2 = option_COROUTINE_ _3 = FUNCTION _4 = option_AND_ _5 = identifier [@doc_comment ] _6 = option_type_parameters_ _7 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _9 = RPAREN _10 = option_return_type_ _11 = option_where_constraints_ [@fn_flags ] _12 = class_method_body [@fn_flags ]
    {let _8 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
  ( () )}
| _1 = REQUIRE _2 = EXTENDS _3 = class_name _4 = SEMICOLON
    {                                       ( () )}
| _1 = REQUIRE _2 = IMPLEMENTS _3 = class_name _4 = SEMICOLON
    {                                          ( () )}
| _1 = list_class_member_modifier_ _2 = CONST _3 = TYPE _4 = name _5 = option_preceded_AS_type_expr__ _6 = option_preceded_EQUAL_type_expr__ _7 = SEMICOLON
    {  ( () )}
| _1 = XHP_ATTRIBUTE _3 = SEMICOLON
    {let _2 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                                                  ( () )}
| _1 = XHP_ATTRIBUTE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_xhp_attribute_decl_ _2 = option_COMMA_ _3 = SEMICOLON
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                                                  ( () )}
| _1 = XHP_CHILDREN _2 = xhp_children_decl _3 = SEMICOLON
    {                                           ( () )}
| _1 = XHP_CATEGORY _3 = SEMICOLON
    {let _2 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                                                ( () )}
| _1 = XHP_CATEGORY _1_inlined1 = lseparated_nonempty_list_aux_COMMA_XHP_PERCENTID_DEF_ _2 = option_COMMA_ _3 = SEMICOLON
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                                                ( () )}

class_method_body:
  _1 = SEMICOLON
    {                                  ( () )}
| _1 = LBRACE _2 = list_statement_inner_ _3 = RBRACE
    {                                 ( () )}

class_member_modifier:
  _1 = PUBLIC
    {            ( () )}
| _1 = PROTECTED
    {            ( () )}
| _1 = PRIVATE
    {            ( () )}
| _1 = STATIC
    {            ( () )}
| _1 = ABSTRACT
    {            ( () )}
| _1 = FINAL
    {            ( () )}
| _1 = ASYNC
    {            ( () )}
| _1 = attributes
    {             ( () )}

trait_adaptation:
  _1 = trait_precedence _2 = SEMICOLON
    {                             ( () )}
| _1 = trait_method_reference _2 = AS _3 = trait_alias _4 = SEMICOLON
    {                                                  ( () )}

trait_precedence:
  _1 = name _2 = COLONCOLON _3 = identifier _4 = INSTEADOF
    {let _5 =
  let _1 =               ( [] ) in
                              ( _1 )
in
                                                        ( () )}
| _1 = name _2 = COLONCOLON _3 = identifier _4 = INSTEADOF _1_inlined1 = lseparated_nonempty_list_aux_COMMA_name_
    {let _5 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
  in
                              ( _1 )
in
                                                        ( () )}

trait_alias:
  _1 = IDENT
    {        ( () )}
| _1 = reserved_non_modifiers
    {                         ( () )}
| _1 = class_member_modifier _2 = option_identifier_
    {                                    ( () )}

trait_method_reference:
  _1 = identifier
    {             ( () )}
| _1 = name _2 = COLONCOLON _3 = identifier
    {                             ( () )}

constant_declaration:
  _1 = type_expr _2 = identifier _3 = option_preceded_EQUAL_expr__ [@doc_comment ]
    {                                                            ( () )}
| _1 = identifier _2 = option_preceded_EQUAL_expr__ [@doc_comment ]
    {                                                  ( () )}

use_modifier:
  _1 = FUNCTION
    {           ( () )}
| _1 = CONST
    {           ( () )}
| _1 = TYPE
    {           ( () )}

group_use_declaration:
  _1 = namespace_name _2 = ANTISLASH _3 = LBRACE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_unprefixed_use_declaration_ _2_inlined1 = option_COMMA_ _5 = RBRACE
    {let _4 =
  let _1 = _1_inlined1 in
  let _1 =                                        ( List.rev _1 ) in
                                              ( _1 )
in
  ( () )}
| _1 = ANTISLASH _2 = namespace_name _3 = ANTISLASH _4 = LBRACE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_unprefixed_use_declaration_ _2_inlined1 = option_COMMA_ _6 = RBRACE
    {let _5 =
  let _1 = _1_inlined1 in
  let _1 =                                        ( List.rev _1 ) in
                                              ( _1 )
in
  ( () )}

mixed_group_use_declaration:
  _1 = namespace_name _2 = ANTISLASH _3 = LBRACE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_inline_use_declaration_ _2_inlined1 = option_COMMA_ _5 = RBRACE
    {let _4 =
  let _1 = _1_inlined1 in
  let _1 =                                        ( List.rev _1 ) in
                                              ( _1 )
in
  ( () )}
| _1 = ANTISLASH _2 = namespace_name _3 = ANTISLASH _4 = LBRACE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_inline_use_declaration_ _2_inlined1 = option_COMMA_ _6 = RBRACE
    {let _5 =
  let _1 = _1_inlined1 in
  let _1 =                                        ( List.rev _1 ) in
                                              ( _1 )
in
  ( () )}

inline_use_declaration:
  _1 = unprefixed_use_declaration
    {                                      ( () )}
| _1 = use_modifier _2 = unprefixed_use_declaration
    {                                          ( () )}

unprefixed_use_declaration:
  _1 = namespace_name
    {                          ( () )}
| _1 = namespace_name _2 = AS _3 = IDENT
    {                          ( () )}

use_declaration:
  _2 = unprefixed_use_declaration
    {let _1 =     ( None ) in
                                                ( () )}
| x = ANTISLASH _2 = unprefixed_use_declaration
    {let _1 =     ( Some x ) in
                                                ( () )}

type_expr:
  _1 = QUESTION _2 = type_expr
    {                     ( () )}
| _1 = AT _2 = type_expr
    {               ( () )}
| _1 = simple_type_expr %prec pre_COLONCOLON
    {                                        ( () )}

simple_type_expr:
  _1 = type_name
    {            ( () )}
| _1 = simple_type_expr _2 = type_arguments
    {                                  ( () )}
| _1 = simple_type_expr _2 = COLONCOLON _3 = type_name
    {                                        ( () )}
| _1 = SHAPE _2 = LPAREN _4 = RPAREN
    {let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                                       ( () )}
| _1 = SHAPE _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_shape_field_ _2_inlined1 = option_COMMA_ _4 = RPAREN
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                                       ( () )}
| _1 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_type_expr_ _2 = option_COMMA_ _3 = RPAREN
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =                                        ( List.rev _1 ) in
                                              ( _1 )
in
                                                        ( () )}
| _1 = LPAREN _2 = option_COROUTINE_ _3 = FUNCTION _4 = LPAREN _6 = RPAREN _7 = return_type _8 = RPAREN
    {let _5 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
  ( () )}
| _1 = LPAREN _2 = option_COROUTINE_ _3 = FUNCTION _4 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_type_expr_parameter_ _2_inlined1 = option_COMMA_ _6 = RPAREN _7 = return_type _8 = RPAREN
    {let _5 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
  ( () )}
| _1 = INT_CAST
    {              ( () )}
| _1 = DOUBLE_CAST
    {              ( () )}
| _1 = STRING_CAST
    {              ( () )}
| _1 = OBJECT_CAST
    {              ( () )}
| _1 = BOOL_CAST
    {              ( () )}
| _1 = ARRAY_CAST
    {              ( () )}

type_arguments:
  _1 = FORK_LANGLE _1_inlined1 = RANGLE
    {let _3 =          ( () ) in
let _2 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                                    ( _1 := true )}
| _1 = FORK_LANGLE _1_inlined1 = SHR_PREFIX
    {let _3 =              ( () ) in
let _2 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                                    ( _1 := true )}
| _1 = FORK_LANGLE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_type_expr_ _2 = option_COMMA_ _1_inlined2 = RANGLE
    {let _3 =          ( () ) in
let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                                    ( _1 := true )}
| _1 = FORK_LANGLE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_type_expr_ _2 = option_COMMA_ _1_inlined2 = SHR_PREFIX
    {let _3 =              ( () ) in
let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                                    ( _1 := true )}

type_parameters:
  _1 = FORK_LANGLE _1_inlined1 = RANGLE
    {let _3 =          ( () ) in
let _2 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                                         ( _1 := true )}
| _1 = FORK_LANGLE _1_inlined1 = SHR_PREFIX
    {let _3 =              ( () ) in
let _2 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                                         ( _1 := true )}
| _1 = FORK_LANGLE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_type_parameter_ _2 = option_COMMA_ _1_inlined2 = RANGLE
    {let _3 =          ( () ) in
let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                                         ( _1 := true )}
| _1 = FORK_LANGLE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_type_parameter_ _2 = option_COMMA_ _1_inlined2 = SHR_PREFIX
    {let _3 =              ( () ) in
let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                                         ( _1 := true )}

type_variance:
  
    {              ( () )}
| _1 = PLUS
    {              ( () )}
| _1 = MINUS
    {              ( () )}

type_parameter:
  _1 = type_variance _2 = type_name _3 = type_constraint
    {                                          ( () )}

type_constraint:
  
    {              ( () )}
| _1 = type_constraint _2 = AS _3 = type_expr
    {                               ( () )}
| _1 = type_constraint _2 = SUPER _3 = type_expr
    {                                  ( () )}

type_expr_parameter:
  _1 = type_expr
    {            ( () )}
| _1 = INOUT _2 = type_expr
    {                  ( () )}
| _1 = ELLIPSIS
    {            ( () )}
| _1 = type_expr _2 = ELLIPSIS
    {                     ( () )}

return_type:
  _1 = COLON _2 = type_expr
    {                  ( () )}

expr:
  _1 = open_expr_expr_
    {                  ( () )}
| _1 = LPAREN _2 = expr _3 = RPAREN
    {                     ( () )}
| _1 = LPAREN _2 = attributes _3 = expr _4 = RPAREN
    {                                ( () )}

expr_without_parenthesis:
  _1 = open_expr_expr_without_parenthesis_
    {                                      ( () )}

open_expr_expr_:
  _1 = LNUMBER
    {              ( () )}
| _1 = DNUMBER
    {              ( () )}
| _1 = LINE
    {              ( () )}
| _1 = FILE
    {              ( () )}
| _1 = DIR
    {              ( () )}
| _1 = TRAIT_C
    {              ( () )}
| _1 = METHOD_C
    {              ( () )}
| _1 = FUNC_C
    {              ( () )}
| _1 = NAMESPACE_C
    {              ( () )}
| _1 = CLASS_C
    {              ( () )}
| _1 = BANG _2 = expr
    {              ( () )}
| _1 = AWAIT _2 = expr
    {              ( () )}
| _1 = TILDE _2 = expr
    {              ( () )}
| _1 = CLONE _2 = expr
    {              ( () )}
| _1 = AT _2 = expr
    {              ( () )}
| _1 = PRINT _2 = expr
    {              ( () )}
| _1 = EXIT
    {              ( () )}
| _1 = SUSPEND _2 = expr
    {               ( () )}
| _1 = INCLUDE _2 = expr
    {               ( () )}
| _1 = INCLUDE_ONCE _2 = expr
    {                    ( () )}
| _1 = REQUIRE _2 = expr
    {               ( () )}
| _1 = REQUIRE_ONCE _2 = expr
    {                    ( () )}
| _1 = EMPTY _2 = LPAREN _3 = expr _4 = RPAREN
    {                           ( () )}
| _1 = EVAL _2 = LPAREN _3 = expr _4 = RPAREN
    {                          ( () )}
| _1 = ISSET _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _2_inlined1 = option_COMMA_ _4 = RPAREN
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =                                        ( List.rev _1 ) in
                                              ( _1 )
in
                                                         ( () )}
| _1 = name _2 = option_type_arguments_
    {                       ( () )}
| _1 = expr _2 = COLONCOLON _3 = property_name _4 = option_type_arguments_
    {                                                ( () )}
| _1 = class_special_name _2 = COLONCOLON _3 = property_name _4 = option_type_arguments_
    {                                                              ( () )}
| _1 = expr _1_inlined1 = ARROW _3 = property_name _4 = option_type_arguments_
    {let _2 =                  ( () ) in
                                           ( () )}
| _1 = expr _1_inlined1 = QUESTION_ARROW _3 = property_name _4 = option_type_arguments_
    {let _2 =                  ( () ) in
                                           ( () )}
| _1 = expr_assignable
    {                   ( () )}
| _1 = DOUBLEQUOTE _2 = list_encaps_ _3 = DOUBLEQUOTE
    {                                  ( () )}
| _1 = START_HEREDOC _2 = list_encaps_ _3 = END_HEREDOC
    {                                    ( () )}
| _1 = PLUS _2 = expr %prec INC
    {                      ( () )}
| _1 = MINUS _2 = expr %prec INC
    {                       ( () )}
| _1 = expr _2 = expr_argument_list
    {                          ( () )}
| _1 = expr _2 = BOOLEAN_AND _3 = expr
    {                        ( () )}
| _1 = expr _2 = IS_IDENTICAL _3 = expr
    {                         ( () )}
| _1 = expr _2 = IS_NOT_IDENTICAL _3 = expr
    {                             ( () )}
| _1 = expr _2 = SPACESHIP _3 = expr
    {                      ( () )}
| _1 = expr _2 = EQUAL _3 = option_attributes_ _4 = expr
    {                              ( () )}
| _1 = expr _2 = EQUAL _3 = AND _4 = expr
    {                      ( () )}
| _1 = expr _2 = IS_EQUAL _3 = expr
    {                     ( () )}
| _1 = expr _2 = IS_NOT_EQUAL _3 = expr
    {                         ( () )}
| _1 = expr _2 = LANGLE _3 = expr
    {                   ( () )}
| _1 = expr _2 = RANGLE _3 = expr
    {                   ( () )}
| _1 = expr _2 = IS_SMALLER_OR_EQUAL _3 = expr
    {                                ( () )}
| _1 = expr _2 = IS_GREATER_OR_EQUAL _3 = expr
    {                                ( () )}
| _1 = NEW _2 = expr_class_reference
    {                           ( () )}
| _1 = structured_literal
    {                     ( () )}
| _1 = INT_CAST _2 = expr
    {                    ( () )}
| _1 = DOUBLE_CAST _2 = expr
    {                    ( () )}
| _1 = STRING_CAST _2 = expr
    {                    ( () )}
| _1 = ARRAY_CAST _2 = expr
    {                    ( () )}
| _1 = OBJECT_CAST _2 = expr
    {                    ( () )}
| _1 = BOOL_CAST _2 = expr
    {                    ( () )}
| _1 = UNSET_CAST _2 = expr
    {                    ( () )}
| _1 = expr _2 = BOOLEAN_OR _3 = expr
    {                        ( () )}
| _1 = expr _2 = LOGICAL_OR _3 = expr
    {                        ( () )}
| _1 = expr _2 = LOGICAL_AND _3 = expr
    {                        ( () )}
| _1 = expr _2 = LOGICAL_XOR _3 = expr
    {                        ( () )}
| _1 = expr _2 = OR _3 = expr
    {                   ( () )}
| _1 = expr _2 = AND _3 = expr
    {                   ( () )}
| _1 = expr _2 = XOR _3 = expr
    {                   ( () )}
| _1 = expr _2 = CONCAT _3 = expr
    {                   ( () )}
| _1 = expr _2 = PLUS _3 = expr
    {                   ( () )}
| _1 = expr _2 = MINUS _3 = expr
    {                   ( () )}
| _1 = expr _2 = MUL _3 = expr
    {                   ( () )}
| _1 = expr _2 = POW _3 = expr
    {                   ( () )}
| _1 = expr _2 = DIV _3 = expr
    {                   ( () )}
| _1 = expr _2 = MOD _3 = expr
    {                   ( () )}
| _1 = expr _2 = SHL _3 = expr
    {                   ( () )}
| _1 = expr _2 = PIPE_ANGLE _3 = expr
    {                       ( () )}
| _1 = VARIABLE _2 = LONG_DOUBLE_ARROW _1_inlined1 = expr
    {let _3 =        ( () ) in
                                         ( () )}
| _1 = VARIABLE _2 = LONG_DOUBLE_ARROW _1_inlined1 = LBRACE _2_inlined1 = list_statement_inner_ _3 = RBRACE
    {let _3 =                                  ( () ) in
                                         ( () )}
| _1 = FORK _2 = LPAREN _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined1 = expr
    {let _7 =        ( () ) in
let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                  ( () )}
| _1 = FORK _2 = LPAREN _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined1 = LBRACE _2_inlined1 = list_statement_inner_ _3 = RBRACE
    {let _7 =                                  ( () ) in
let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                  ( () )}
| _1 = FORK _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined2 = expr
    {let _7 =        ( () ) in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                  ( () )}
| _1 = FORK _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined2 = LBRACE _2_inlined2 = list_statement_inner_ _3 = RBRACE
    {let _7 =                                  ( () ) in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                  ( () )}
| _1 = ASYNC _2 = LPAREN _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined1 = expr
    {let _7 =        ( () ) in
let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                  ( () )}
| _1 = ASYNC _2 = LPAREN _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined1 = LBRACE _2_inlined1 = list_statement_inner_ _3 = RBRACE
    {let _7 =                                  ( () ) in
let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                  ( () )}
| _1 = ASYNC _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined2 = expr
    {let _7 =        ( () ) in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                  ( () )}
| _1 = ASYNC _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined2 = LBRACE _2_inlined2 = list_statement_inner_ _3 = RBRACE
    {let _7 =                                  ( () ) in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                  ( () )}
| _1 = ASYNC _2 = VARIABLE _3 = LONG_DOUBLE_ARROW _1_inlined1 = expr
    {let _4 =        ( () ) in
                                               ( () )}
| _1 = ASYNC _2 = VARIABLE _3 = LONG_DOUBLE_ARROW _1_inlined1 = LBRACE _2_inlined1 = list_statement_inner_ _3_inlined1 = RBRACE
    {let _4 =                                  ( () ) in
                                               ( () )}
| _1 = ASYNC _2 = LBRACE _3 = list_statement_inner_ _4 = RBRACE
    {                                       ( () )}
| _1 = COROUTINE _2 = LPAREN _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined1 = expr
    {let _7 =        ( () ) in
let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                  ( () )}
| _1 = COROUTINE _2 = LPAREN _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined1 = LBRACE _2_inlined1 = list_statement_inner_ _3 = RBRACE
    {let _7 =                                  ( () ) in
let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                  ( () )}
| _1 = COROUTINE _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined2 = expr
    {let _7 =        ( () ) in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                  ( () )}
| _1 = COROUTINE _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined2 = LBRACE _2_inlined2 = list_statement_inner_ _3 = RBRACE
    {let _7 =                                  ( () ) in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                  ( () )}
| _1 = COROUTINE _2 = VARIABLE _3 = LONG_DOUBLE_ARROW _1_inlined1 = expr
    {let _4 =        ( () ) in
                                                   ( () )}
| _1 = COROUTINE _2 = VARIABLE _3 = LONG_DOUBLE_ARROW _1_inlined1 = LBRACE _2_inlined1 = list_statement_inner_ _3_inlined1 = RBRACE
    {let _4 =                                  ( () ) in
                                                   ( () )}
| _1 = COROUTINE _2 = LBRACE _3 = list_statement_inner_ _4 = RBRACE
    {                                           ( () )}
| _1 = expr _2 = LBRACKET _3 = expr_pair_list _4 = RBRACKET
    {                                        ( () )}
| _1 = expr _2 = INC
    {           ( () )}
| _1 = INC _2 = expr
    {           ( () )}
| _1 = expr _2 = DEC
    {           ( () )}
| _1 = DEC _2 = expr
    {           ( () )}
| _1 = expr _2 = PLUS_EQUAL _3 = expr
    {                       ( () )}
| _1 = expr _2 = MINUS_EQUAL _3 = expr
    {                        ( () )}
| _1 = expr _2 = MUL_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr _2 = POW_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr _2 = DIV_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr _2 = CONCAT_EQUAL _3 = expr
    {                         ( () )}
| _1 = expr _2 = MOD_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr _2 = AND_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr _2 = OR_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr _2 = XOR_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr _2 = SHL_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr _2 = SHR_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr _2 = QUESTION_QUESTION_EQUAL _3 = expr
    {                                    ( () )}
| _1 = expr _2 = SHR_PREFIX _3 = RANGLE _4 = expr
    {                               ( () )}
| _1 = expr _2 = IS _3 = type_expr
    {                    ( () )}
| _1 = expr _2 = AS _3 = type_expr
    {                    ( () )}
| _1 = expr _2 = INSTANCEOF _3 = expr_class_reference
    {                                       ( () )}
| _1 = expr _2 = QUESTION _3 = AS _4 = type_expr
    {                             ( () )}
| _1 = expr _2 = QUESTION _3 = COLON _4 = expr
    {                           ( () )}
| _1 = expr _2 = QUESTION _3 = expr _4 = COLON _5 = expr
    {                                ( () )}
| _1 = expr _2 = QUESTION_QUESTION _3 = expr
    {                              ( () )}
| _1 = LIST _2 = LPAREN _3 = expr_pair_list _4 = RPAREN _5 = EQUAL _6 = expr
    {                                               ( () )}
| _1 = xhp_html
    {           ( () )}
| _1 = function_expr
    {                ( () )}
| _1 = YIELD
    {        ( () )}
| _1 = YIELD _2 = expr
    {             ( () )}
| _1 = YIELD _2 = expr _3 = DOUBLE_ARROW _4 = expr
    {                               ( () )}
| _1 = YIELD _2 = BREAK
    {              ( () )}

open_expr_expr_without_parenthesis_:
  _1 = LNUMBER
    {              ( () )}
| _1 = DNUMBER
    {              ( () )}
| _1 = LINE
    {              ( () )}
| _1 = FILE
    {              ( () )}
| _1 = DIR
    {              ( () )}
| _1 = TRAIT_C
    {              ( () )}
| _1 = METHOD_C
    {              ( () )}
| _1 = FUNC_C
    {              ( () )}
| _1 = NAMESPACE_C
    {              ( () )}
| _1 = CLASS_C
    {              ( () )}
| _1 = BANG _2 = expr
    {              ( () )}
| _1 = AWAIT _2 = expr
    {              ( () )}
| _1 = TILDE _2 = expr
    {              ( () )}
| _1 = CLONE _2 = expr
    {              ( () )}
| _1 = AT _2 = expr
    {              ( () )}
| _1 = PRINT _2 = expr
    {              ( () )}
| _1 = EXIT
    {              ( () )}
| _1 = SUSPEND _2 = expr
    {               ( () )}
| _1 = INCLUDE _2 = expr
    {               ( () )}
| _1 = INCLUDE_ONCE _2 = expr
    {                    ( () )}
| _1 = REQUIRE _2 = expr
    {               ( () )}
| _1 = REQUIRE_ONCE _2 = expr
    {                    ( () )}
| _1 = EMPTY _2 = LPAREN _3 = expr _4 = RPAREN
    {                           ( () )}
| _1 = EVAL _2 = LPAREN _3 = expr _4 = RPAREN
    {                          ( () )}
| _1 = ISSET _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _2_inlined1 = option_COMMA_ _4 = RPAREN
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =                                        ( List.rev _1 ) in
                                              ( _1 )
in
                                                         ( () )}
| _1 = name _2 = option_type_arguments_
    {                       ( () )}
| _1 = expr_without_parenthesis _2 = COLONCOLON _3 = property_name _4 = option_type_arguments_
    {                                                ( () )}
| _1 = class_special_name _2 = COLONCOLON _3 = property_name _4 = option_type_arguments_
    {                                                              ( () )}
| _1 = expr_without_parenthesis _1_inlined1 = ARROW _3 = property_name _4 = option_type_arguments_
    {let _2 =                  ( () ) in
                                           ( () )}
| _1 = expr_without_parenthesis _1_inlined1 = QUESTION_ARROW _3 = property_name _4 = option_type_arguments_
    {let _2 =                  ( () ) in
                                           ( () )}
| _1 = expr_assignable
    {                   ( () )}
| _1 = DOUBLEQUOTE _2 = list_encaps_ _3 = DOUBLEQUOTE
    {                                  ( () )}
| _1 = START_HEREDOC _2 = list_encaps_ _3 = END_HEREDOC
    {                                    ( () )}
| _1 = PLUS _2 = expr %prec INC
    {                      ( () )}
| _1 = MINUS _2 = expr %prec INC
    {                       ( () )}
| _1 = expr_without_parenthesis _2 = expr_argument_list
    {                          ( () )}
| _1 = expr_without_parenthesis _2 = BOOLEAN_AND _3 = expr
    {                        ( () )}
| _1 = expr_without_parenthesis _2 = IS_IDENTICAL _3 = expr
    {                         ( () )}
| _1 = expr_without_parenthesis _2 = IS_NOT_IDENTICAL _3 = expr
    {                             ( () )}
| _1 = expr_without_parenthesis _2 = SPACESHIP _3 = expr
    {                      ( () )}
| _1 = expr_without_parenthesis _2 = EQUAL _3 = option_attributes_ _4 = expr
    {                              ( () )}
| _1 = expr_without_parenthesis _2 = EQUAL _3 = AND _4 = expr
    {                      ( () )}
| _1 = expr_without_parenthesis _2 = IS_EQUAL _3 = expr
    {                     ( () )}
| _1 = expr_without_parenthesis _2 = IS_NOT_EQUAL _3 = expr
    {                         ( () )}
| _1 = expr_without_parenthesis _2 = LANGLE _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = RANGLE _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = IS_SMALLER_OR_EQUAL _3 = expr
    {                                ( () )}
| _1 = expr_without_parenthesis _2 = IS_GREATER_OR_EQUAL _3 = expr
    {                                ( () )}
| _1 = NEW _2 = expr_class_reference
    {                           ( () )}
| _1 = structured_literal
    {                     ( () )}
| _1 = INT_CAST _2 = expr
    {                    ( () )}
| _1 = DOUBLE_CAST _2 = expr
    {                    ( () )}
| _1 = STRING_CAST _2 = expr
    {                    ( () )}
| _1 = ARRAY_CAST _2 = expr
    {                    ( () )}
| _1 = OBJECT_CAST _2 = expr
    {                    ( () )}
| _1 = BOOL_CAST _2 = expr
    {                    ( () )}
| _1 = UNSET_CAST _2 = expr
    {                    ( () )}
| _1 = expr_without_parenthesis _2 = BOOLEAN_OR _3 = expr
    {                        ( () )}
| _1 = expr_without_parenthesis _2 = LOGICAL_OR _3 = expr
    {                        ( () )}
| _1 = expr_without_parenthesis _2 = LOGICAL_AND _3 = expr
    {                        ( () )}
| _1 = expr_without_parenthesis _2 = LOGICAL_XOR _3 = expr
    {                        ( () )}
| _1 = expr_without_parenthesis _2 = OR _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = AND _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = XOR _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = CONCAT _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = PLUS _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = MINUS _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = MUL _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = POW _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = DIV _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = MOD _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = SHL _3 = expr
    {                   ( () )}
| _1 = expr_without_parenthesis _2 = PIPE_ANGLE _3 = expr
    {                       ( () )}
| _1 = VARIABLE _2 = LONG_DOUBLE_ARROW _1_inlined1 = expr
    {let _3 =        ( () ) in
                                         ( () )}
| _1 = VARIABLE _2 = LONG_DOUBLE_ARROW _1_inlined1 = LBRACE _2_inlined1 = list_statement_inner_ _3 = RBRACE
    {let _3 =                                  ( () ) in
                                         ( () )}
| _1 = FORK _2 = LPAREN _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined1 = expr
    {let _7 =        ( () ) in
let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                  ( () )}
| _1 = FORK _2 = LPAREN _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined1 = LBRACE _2_inlined1 = list_statement_inner_ _3 = RBRACE
    {let _7 =                                  ( () ) in
let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                  ( () )}
| _1 = FORK _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined2 = expr
    {let _7 =        ( () ) in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                  ( () )}
| _1 = FORK _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined2 = LBRACE _2_inlined2 = list_statement_inner_ _3 = RBRACE
    {let _7 =                                  ( () ) in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                  ( () )}
| _1 = ASYNC _2 = LPAREN _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined1 = expr
    {let _7 =        ( () ) in
let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                  ( () )}
| _1 = ASYNC _2 = LPAREN _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined1 = LBRACE _2_inlined1 = list_statement_inner_ _3 = RBRACE
    {let _7 =                                  ( () ) in
let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                  ( () )}
| _1 = ASYNC _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined2 = expr
    {let _7 =        ( () ) in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                  ( () )}
| _1 = ASYNC _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined2 = LBRACE _2_inlined2 = list_statement_inner_ _3 = RBRACE
    {let _7 =                                  ( () ) in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                  ( () )}
| _1 = ASYNC _2 = VARIABLE _3 = LONG_DOUBLE_ARROW _1_inlined1 = expr
    {let _4 =        ( () ) in
                                               ( () )}
| _1 = ASYNC _2 = VARIABLE _3 = LONG_DOUBLE_ARROW _1_inlined1 = LBRACE _2_inlined1 = list_statement_inner_ _3_inlined1 = RBRACE
    {let _4 =                                  ( () ) in
                                               ( () )}
| _1 = ASYNC _2 = LBRACE _3 = list_statement_inner_ _4 = RBRACE
    {                                       ( () )}
| _1 = COROUTINE _2 = LPAREN _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined1 = expr
    {let _7 =        ( () ) in
let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                  ( () )}
| _1 = COROUTINE _2 = LPAREN _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined1 = LBRACE _2_inlined1 = list_statement_inner_ _3 = RBRACE
    {let _7 =                                  ( () ) in
let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                  ( () )}
| _1 = COROUTINE _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined2 = expr
    {let _7 =        ( () ) in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                  ( () )}
| _1 = COROUTINE _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = option_return_type_ _6 = LONG_DOUBLE_ARROW _1_inlined2 = LBRACE _2_inlined2 = list_statement_inner_ _3 = RBRACE
    {let _7 =                                  ( () ) in
let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                  ( () )}
| _1 = COROUTINE _2 = VARIABLE _3 = LONG_DOUBLE_ARROW _1_inlined1 = expr
    {let _4 =        ( () ) in
                                                   ( () )}
| _1 = COROUTINE _2 = VARIABLE _3 = LONG_DOUBLE_ARROW _1_inlined1 = LBRACE _2_inlined1 = list_statement_inner_ _3_inlined1 = RBRACE
    {let _4 =                                  ( () ) in
                                                   ( () )}
| _1 = COROUTINE _2 = LBRACE _3 = list_statement_inner_ _4 = RBRACE
    {                                           ( () )}
| _1 = expr_without_parenthesis _2 = LBRACKET _3 = expr_pair_list _4 = RBRACKET
    {                                        ( () )}
| _1 = expr_without_parenthesis _2 = INC
    {           ( () )}
| _1 = INC _2 = expr
    {           ( () )}
| _1 = expr_without_parenthesis _2 = DEC
    {           ( () )}
| _1 = DEC _2 = expr
    {           ( () )}
| _1 = expr_without_parenthesis _2 = PLUS_EQUAL _3 = expr
    {                       ( () )}
| _1 = expr_without_parenthesis _2 = MINUS_EQUAL _3 = expr
    {                        ( () )}
| _1 = expr_without_parenthesis _2 = MUL_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr_without_parenthesis _2 = POW_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr_without_parenthesis _2 = DIV_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr_without_parenthesis _2 = CONCAT_EQUAL _3 = expr
    {                         ( () )}
| _1 = expr_without_parenthesis _2 = MOD_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr_without_parenthesis _2 = AND_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr_without_parenthesis _2 = OR_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr_without_parenthesis _2 = XOR_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr_without_parenthesis _2 = SHL_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr_without_parenthesis _2 = SHR_EQUAL _3 = expr
    {                      ( () )}
| _1 = expr_without_parenthesis _2 = QUESTION_QUESTION_EQUAL _3 = expr
    {                                    ( () )}
| _1 = expr_without_parenthesis _2 = SHR_PREFIX _3 = RANGLE _4 = expr
    {                               ( () )}
| _1 = expr_without_parenthesis _2 = IS _3 = type_expr
    {                    ( () )}
| _1 = expr_without_parenthesis _2 = AS _3 = type_expr
    {                    ( () )}
| _1 = expr_without_parenthesis _2 = INSTANCEOF _3 = expr_class_reference
    {                                       ( () )}
| _1 = expr_without_parenthesis _2 = QUESTION _3 = AS _4 = type_expr
    {                             ( () )}
| _1 = expr_without_parenthesis _2 = QUESTION _3 = COLON _4 = expr
    {                           ( () )}
| _1 = expr_without_parenthesis _2 = QUESTION _3 = expr _4 = COLON _5 = expr
    {                                ( () )}
| _1 = expr_without_parenthesis _2 = QUESTION_QUESTION _3 = expr
    {                              ( () )}
| _1 = LIST _2 = LPAREN _3 = expr_pair_list _4 = RPAREN _5 = EQUAL _6 = expr
    {                                               ( () )}
| _1 = xhp_html
    {           ( () )}
| _1 = function_expr
    {                ( () )}
| _1 = YIELD
    {        ( () )}
| _1 = YIELD _2 = expr
    {             ( () )}
| _1 = YIELD _2 = expr _3 = DOUBLE_ARROW _4 = expr
    {                               ( () )}
| _1 = YIELD _2 = BREAK
    {              ( () )}

function_expr:
  _1 = STATIC _2 = function_expr
    {  ( () )}
| _1 = ASYNC _2 = function_expr
    {  ( () )}
| _1 = COROUTINE _2 = function_expr
    {  ( () )}
| _1 = FUNCTION _2 = option_AND_ [@doc_comment ] _3 = LPAREN _5 = RPAREN _6 = option_return_type_ _7 = option_lexical_vars_ [@fn_flags ] _8 = LBRACE _9 = list_statement_inner_ _10 = RBRACE [@fn_flags ]
    {let _4 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
  ( () )}
| _1 = FUNCTION _2 = option_AND_ [@doc_comment ] _3 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2_inlined1 = option_COMMA_ _5 = RPAREN _6 = option_return_type_ _7 = option_lexical_vars_ [@fn_flags ] _8 = LBRACE _9 = list_statement_inner_ _10 = RBRACE [@fn_flags ]
    {let _4 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
  ( () )}

lexical_vars:
  _1 = USE _2 = LPAREN _4 = RPAREN
    {let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                                                 ( () )}
| _1 = USE _2 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_preceded_option_AND__VARIABLE__ _2_inlined1 = option_COMMA_ _4 = RPAREN
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                                                 ( () )}

expr_argument_list:
  _1 = LPAREN _3 = RPAREN
    {let _2 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
                                                   ( () )}
| _1 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_argument_ _2 = option_COMMA_ _3 = RPAREN
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
                                                   ( () )}
| _1 = LBRACE _2 = expr_pair_list _3 = RBRACE
    {                               ( () )}

expr_argument:
  _1 = expr
    {       ( () )}
| _1 = AND _2 = expr
    {           ( () )}
| _1 = INOUT _2 = expr
    {             ( () )}
| _1 = ELLIPSIS _2 = expr
    {                ( () )}
| _1 = attributes _2 = expr_argument
    {                           ( () )}

expr_pair_list:
  _1 = lseparated_nonempty_list_aux_COMMA_option_expr_array_pair__
    {let _1 =
  let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
in
                                        ( _1 )}

expr_array_pair:
  _1 = expr _2 = DOUBLE_ARROW _3 = expr
    {                         ( () )}
| _1 = expr
    {       ( () )}
| _1 = expr _2 = DOUBLE_ARROW _3 = AND _4 = expr_assignable
    {                                        ( () )}
| _1 = AND _2 = expr_assignable
    {                      ( () )}
| _1 = expr _2 = DOUBLE_ARROW _3 = LIST _4 = LPAREN _5 = expr_pair_list _6 = RPAREN
    {                                                      ( () )}
| _1 = LIST _2 = LPAREN _3 = expr_pair_list _4 = RPAREN
    {                                    ( () )}
| _1 = ELLIPSIS _2 = expr
    {                ( () )}

property_name:
  _1 = identifier
    {             ( () )}
| _1 = LBRACE _2 = expr _3 = RBRACE
    {                     ( () )}
| _1 = expr_variable
    {                ( () )}

expr_class_reference:
  _1 = class_name
    {             ( () )}
| _1 = expr_variable
    {                ( () )}
| _1 = LPAREN _2 = expr _3 = RPAREN
    {                     ( () )}

structured_literal:
  _1 = ARRAY _3 = LPAREN _4 = expr_pair_list _5 = RPAREN
    {let _2 =     ( None ) in
                                                             ( () )}
| _1 = ARRAY x = type_arguments _3 = LPAREN _4 = expr_pair_list _5 = RPAREN
    {let _2 =     ( Some x ) in
                                                             ( () )}
| _1 = SHAPE _3 = LPAREN _4 = expr_pair_list _5 = RPAREN
    {let _2 =     ( None ) in
                                                             ( () )}
| _1 = SHAPE x = type_arguments _3 = LPAREN _4 = expr_pair_list _5 = RPAREN
    {let _2 =     ( Some x ) in
                                                             ( () )}
| _1 = LBRACKET _2 = expr_pair_list _3 = RBRACKET
    {                                   ( () )}
| _1 = ARRAY _3 = LBRACKET _4 = expr_pair_list _5 = RBRACKET
    {let _2 =     ( None ) in
                                                                 ( () )}
| _1 = ARRAY x = type_arguments _3 = LBRACKET _4 = expr_pair_list _5 = RBRACKET
    {let _2 =     ( Some x ) in
                                                                 ( () )}
| _1 = CONSTANT_ENCAPSED_STRING
    {                           ( () )}

expr_assignable:
  _1 = expr_variable
    {                ( () )}

expr_variable:
  _1 = VARIABLE
    {           ( () )}
| _1 = DOLLAR _2 = LBRACE _3 = expr _4 = RBRACE
    {                            ( () )}
| _1 = DOLLAR _2 = expr_variable
    {                       ( () )}
| _1 = DOLLARDOLLAR
    {               ( () )}

encaps:
  _1 = ENCAPSED_AND_WHITESPACE
    {                          ( () )}
| _1 = encaps_var
    {             ( () )}

encaps_var:
  _1 = VARIABLE
    {           ( () )}
| _1 = VARIABLE _2 = LBRACKET _3 = encaps_var_offset _4 = RBRACKET
    {                                               ( () )}
| _1 = VARIABLE _1_inlined1 = ARROW _3 = IDENT
    {let _2 =                  ( () ) in
                       ( () )}
| _1 = VARIABLE _1_inlined1 = QUESTION_ARROW _3 = IDENT
    {let _2 =                  ( () ) in
                       ( () )}
| _1 = DOLLAR_OPEN_CURLY_BRACES _2 = expr _3 = RBRACE
    {                                       ( () )}
| _1 = DOLLAR_OPEN_CURLY_BRACES _2 = VARNAME _3 = RBRACE
    {                                          ( () )}
| _1 = DOLLAR_OPEN_CURLY_BRACES _2 = VARNAME _3 = LBRACKET _4 = expr _5 = RBRACKET _6 = RBRACE
    {  ( () )}
| _1 = CURLY_OPEN _2 = expr _3 = RBRACE
    {                         ( () )}

encaps_var_offset:
  _1 = IDENT
    {                   ( () )}
| _1 = NUM_STRING
    {                   ( () )}
| _1 = MINUS _2 = NUM_STRING
    {                   ( () )}
| _1 = VARIABLE
    {                   ( () )}

xhp_html:
  _1 = XHP_OPEN_TAG _2 = list_xhp_attribute_ _3 = XHP_GT _4 = list_xhp_child_ _5 = XHP_CLOSE_TAG
    {                                                              ( () )}
| _1 = XHP_OPEN_TAG _2 = list_xhp_attribute_ _3 = XHP_SLASH_GT
    {                                           ( () )}

xhp_child:
  _1 = XHP_TEXT
    {                     ( () )}
| _1 = xhp_html
    {                     ( () )}
| _1 = LBRACE _2 = expr _3 = RBRACE
    {                     ( () )}

xhp_attribute:
  _1 = XHP_ATTR _2 = EQUAL _3 = xhp_attribute_value
    {                                     ( () )}
| _1 = LBRACE _2 = option_ELLIPSIS_ _3 = expr _4 = RBRACE
    {                                     ( () )}

xhp_attribute_value:
  _1 = DOUBLEQUOTE _2 = list_encaps_ _3 = DOUBLEQUOTE
    {                                  ( () )}
| _1 = LBRACE _2 = expr _3 = RBRACE
    {                     ( () )}
| _1 = XHP_ATTR
    {                     ( () )}

xhp_attribute_decl:
  _1 = XHP_COLONID_DEF
    {                  ( () )}
| _1 = xhp_attribute_decl_type _2 = xhp_attr_name _3 = option_preceded_EQUAL_expr__ _4 = option_XHP_REQUIRED_
    {  ( () )}

xhp_attribute_decl_type:
  _1 = ENUM _2 = LBRACE _4 = RBRACE
    {let _3 =
  let _1 =               ( [] ) in
                                       ( _1 )
in
  ( () )}
| _1 = ENUM _2 = LBRACE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_ _2_inlined1 = option_COMMA_ _4 = RBRACE
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =
    let _1 =                                        ( List.rev _1 ) in
                                            ( _1 )
  in
                                       ( _1 )
in
  ( () )}
| _1 = VAR
    {  ( () )}
| _1 = type_expr
    {  ( () )}

xhp_attr_name:
  _1 = identifier
    {  ( () )}
| _1 = xhp_attr_name _2 = MINUS _3 = identifier
    {  ( () )}
| _1 = xhp_attr_name _2 = COLON _3 = identifier
    {  ( () )}

xhp_children_decl:
  _1 = XHP_ANY
    {  ( () )}
| _1 = EMPTY
    {  ( () )}
| _1 = xhp_children_paren_expr
    {  ( () )}

xhp_children_paren_expr:
  _1 = LPAREN _2 = xhp_children_decl_exprs _3 = RPAREN
    {  ( () )}
| _1 = LPAREN _2 = xhp_children_decl_exprs _3 = RPAREN _4 = MUL
    {  ( () )}
| _1 = LPAREN _2 = xhp_children_decl_exprs _3 = RPAREN _4 = QUESTION
    {  ( () )}
| _1 = LPAREN _2 = xhp_children_decl_exprs _3 = RPAREN _4 = PLUS
    {  ( () )}

xhp_children_decl_expr:
  _1 = xhp_children_paren_expr
    {                                 ( () )}
| _1 = xhp_children_decl_tag
    {                                 ( () )}
| _1 = xhp_children_decl_tag _2 = MUL
    {                                 ( () )}
| _1 = xhp_children_decl_tag _2 = QUESTION
    {                                 ( () )}
| _1 = xhp_children_decl_tag _2 = PLUS
    {                                 ( () )}

xhp_children_decl_exprs:
  _1 = xhp_children_decl_expr
    {                         ( () )}
| _1 = xhp_children_decl_exprs _2 = COMMA _3 = xhp_children_decl_expr
    {                                                       ( () )}
| _1 = xhp_children_decl_exprs _2 = OR _3 = xhp_children_decl_expr
    {                                                       ( () )}

xhp_children_decl_tag:
  _1 = XHP_ANY
    {                    ( () )}
| _1 = XHP_PCDATA
    {                    ( () )}
| _1 = XHP_COLONID_DEF
    {                    ( () )}
| _1 = XHP_PERCENTID_DEF
    {                    ( () )}
| _1 = IDENT
    {                    ( () )}

shape_field:
  _1 = option_QUESTION_ _2 = expr _3 = DOUBLE_ARROW _4 = type_expr
    {                                        ( () )}
| _1 = ELLIPSIS
    {           ( () )}

xhp_reserved:
  _1 = XHP_ATTRIBUTE
    {                ( "attribute" )}
| _1 = XHP_CATEGORY
    {                ( "category" )}
| _1 = XHP_CHILDREN
    {                ( "children" )}
| _1 = XHP_ANY
    {                ( "any" )}
| _1 = XHP_PCDATA
    {                ( "pcdata" )}

reserved_non_modifiers:
  _1 = xhp_reserved
    {               ( _1 )}
| _1 = INCLUDE
    {               ( "include" )}
| _1 = INCLUDE_ONCE
    {               ( "include_once" )}
| _1 = EVAL
    {               ( "eval" )}
| _1 = REQUIRE
    {               ( "require" )}
| _1 = REQUIRE_ONCE
    {               ( "require_once" )}
| _1 = LOGICAL_OR
    {               ( "or" )}
| _1 = LOGICAL_XOR
    {               ( "xor" )}
| _1 = LOGICAL_AND
    {               ( "and" )}
| _1 = INSTANCEOF
    {               ( "instanceof" )}
| _1 = INOUT
    {               ( "inout" )}
| _1 = IS
    {               ( "is" )}
| _1 = NEW
    {               ( "new" )}
| _1 = CLONE
    {               ( "clone" )}
| _1 = EXIT
    {               ( "exit" )}
| _1 = IF
    {               ( "if" )}
| _1 = ELSEIF
    {               ( "elseif" )}
| _1 = ELSE
    {               ( "else" )}
| _1 = ENDIF
    {               ( "endif" )}
| _1 = ECHO
    {               ( "echo" )}
| _1 = DO
    {               ( "do" )}
| _1 = WHILE
    {               ( "while" )}
| _1 = FOR
    {               ( "for" )}
| _1 = FOREACH
    {               ( "foreach" )}
| _1 = DECLARE
    {               ( "declare" )}
| _1 = AS
    {               ( "as" )}
| _1 = TRY
    {               ( "try" )}
| _1 = CATCH
    {               ( "catch" )}
| _1 = FINALLY
    {               ( "finally" )}
| _1 = THROW
    {               ( "throw" )}
| _1 = USE
    {               ( "use" )}
| _1 = INSTEADOF
    {               ( "insteadof" )}
| _1 = GLOBAL
    {               ( "global" )}
| _1 = VAR
    {               ( "var" )}
| _1 = UNSET
    {               ( "unset" )}
| _1 = ISSET
    {               ( "isset" )}
| _1 = EMPTY
    {               ( "empty" )}
| _1 = CONTINUE
    {               ( "continue" )}
| _1 = GOTO
    {               ( "goto" )}
| _1 = FUNCTION
    {               ( "function" )}
| _1 = CONST
    {               ( "const" )}
| _1 = RETURN
    {               ( "return" )}
| _1 = PRINT
    {               ( "print" )}
| _1 = YIELD
    {               ( "yield" )}
| _1 = LIST
    {               ( "list" )}
| _1 = SWITCH
    {               ( "switch" )}
| _1 = CASE
    {               ( "case" )}
| _1 = DEFAULT
    {               ( "default" )}
| _1 = BREAK
    {               ( "break" )}
| _1 = ARRAY
    {               ( "array" )}
| _1 = CALLABLE
    {               ( "callable" )}
| _1 = EXTENDS
    {               ( "extends" )}
| _1 = IMPLEMENTS
    {               ( "implements" )}
| _1 = NAMESPACE
    {               ( "namespace" )}
| _1 = TRAIT
    {               ( "trait" )}
| _1 = INTERFACE
    {               ( "interface" )}
| _1 = CLASS
    {               ( "class" )}
| _1 = TYPE
    {               ( "type" )}
| _1 = ENUM
    {               ( "enum" )}
| _1 = LINE
    {               ( "__LINE__" )}
| _1 = FILE
    {               ( "__FILE__" )}
| _1 = DIR
    {               ( "__DIR__" )}
| _1 = CLASS_C
    {               ( "__CLASS__" )}
| _1 = TRAIT_C
    {               ( "__TRAIT__" )}
| _1 = METHOD_C
    {               ( "__METHOD__" )}
| _1 = FUNC_C
    {               ( "__FUNCTION__" )}
| _1 = NAMESPACE_C
    {               ( "__NAMESPACE__" )}
| _1 = PARENT
    {               ( "parent" )}
| _1 = SELF
    {               ( "self" )}
| _1 = WHERE
    {               ( "where" )}
| _1 = SHAPE
    {               ( "shape" )}
| _1 = USING
    {               ( "using" )}
| _1 = COROUTINE
    {               ( "coroutine" )}
| _1 = SUSPEND
    {               ( "suspend" )}
| _1 = NEWTYPE
    {               ( "newtype" )}

semi_reserved:
  _1 = reserved_non_modifiers
    {                         ( _1 )}
| _1 = STATIC
    {            ( "STATIC" )}
| _1 = ABSTRACT
    {            ( "ABSTRACT" )}
| _1 = FINAL
    {            ( "FINAL" )}
| _1 = PRIVATE
    {            ( "PRIVATE" )}
| _1 = PROTECTED
    {            ( "PROTECTED" )}
| _1 = PUBLIC
    {            ( "PUBLIC" )}
| _1 = ASYNC
    {            ( "async" )}
| _1 = SUPER
    {            ( "super" )}

dummy:
  _1 = COMMENT _2 = DOC_COMMENT _3 = NEWLINE _4 = SPACES _5 = UNKNOWN _6 = OPEN_TAG _7 = OPEN_TAG_WITH_ECHO _8 = CLOSE_TAG _9 = CLOSE_TAG_OF_ECHO
    {  ( () )}
| _1 = AND_EQUAL _2 = BACKQUOTE _3 = BANG _4 = BOOLEAN_AND _5 = BOOLEAN_OR _6 = COALESCE _7 = CONCAT _8 = CONCAT_EQUAL _9 = CURLY_OPEN _10 = DEC _11 = DIV _12 = DIV_EQUAL _13 = DNUMBER _14 = DOLLAR_OPEN_CURLY_BRACES _15 = DOUBLEQUOTE _16 = ENCAPSED_AND_WHITESPACE _17 = END_HEREDOC _18 = FORK _19 = INC _20 = IS_EQUAL _21 = IS_GREATER_OR_EQUAL _22 = IS_IDENTICAL _23 = IS_NOT_EQUAL _24 = IS_SMALLER_OR_EQUAL _25 = LANGLE _26 = LONG_DOUBLE_ARROW _27 = MINUS_EQUAL _28 = MOD _29 = MOD_EQUAL _30 = MUL _31 = MUL_EQUAL _32 = NUM_STRING _33 = OR_EQUAL _34 = PIPE_ANGLE _35 = PLUS_EQUAL _36 = POW _37 = POW_EQUAL _38 = QUESTION_QUESTION _39 = QUESTION_QUESTION_EQUAL _40 = SHL_EQUAL _41 = SHR_EQUAL _42 = SPACESHIP _43 = START_HEREDOC _44 = TILDE _45 = UNSET_CAST _46 = VARNAME _47 = XHP_ATTR _48 = XHP_CLOSE_TAG _49 = XHP_GT _50 = XHP_OPEN_TAG _51 = XHP_PCDATA _52 = XHP_PERCENTID_DEF _53 = XHP_REQUIRED _54 = XHP_SLASH_GT _55 = XHP_TEXT _56 = XOR _57 = XOR_EQUAL _58 = YIELD_FROM
    {  ( () )}

lseparated_nonempty_list_aux_COMMA_XHP_PERCENTID_DEF_:
  _1 = XHP_PERCENTID_DEF
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_XHP_PERCENTID_DEF_ _2 = COMMA _3 = XHP_PERCENTID_DEF
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_attribute_:
  _1 = attribute
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_attribute_ _2 = COMMA _3 = attribute
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_class_name_:
  _1 = class_name
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_class_name_ _2 = COMMA _3 = class_name
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_constant_declaration_:
  _1 = constant_declaration
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_constant_declaration_ _2 = COMMA _3 = constant_declaration
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_expr_:
  _1 = expr
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_expr_ _2 = COMMA _3 = expr
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_expr_argument_:
  _1 = expr_argument
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_expr_argument_ _2 = COMMA _3 = expr_argument
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_expr_variable_:
  _1 = expr_variable
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_expr_variable_ _2 = COMMA _3 = expr_variable
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_initializable_variable_:
  _1 = initializable_variable
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_initializable_variable_ _2 = COMMA _3 = initializable_variable
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_inline_use_declaration_:
  _1 = inline_use_declaration
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_inline_use_declaration_ _2 = COMMA _3 = inline_use_declaration
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_name_:
  _1 = name
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_name_ _2 = COMMA _3 = name
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_option_expr_array_pair__:
  _1 = option_expr_array_pair_
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_option_expr_array_pair__ _2 = COMMA _3 = option_expr_array_pair_
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_parameter_:
  _1 = parameter
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_parameter_ _2 = COMMA _3 = parameter
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_preceded_option_AND__VARIABLE__:
  _1 = option_AND_ x = VARIABLE
    {let _1 =     ( x ) in
    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_preceded_option_AND__VARIABLE__ _2 = COMMA _1_inlined1 = option_AND_ x = VARIABLE
    {let _3 =     ( x ) in
                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_shape_field_:
  _1 = shape_field
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_shape_field_ _2 = COMMA _3 = shape_field
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_type_expr_:
  _1 = type_expr
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_type_expr_ _2 = COMMA _3 = type_expr
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_type_expr_parameter_:
  _1 = type_expr_parameter
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_type_expr_parameter_ _2 = COMMA _3 = type_expr_parameter
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_type_parameter_:
  _1 = type_parameter
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_type_parameter_ _2 = COMMA _3 = type_parameter
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_unprefixed_use_declaration_:
  _1 = unprefixed_use_declaration
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_unprefixed_use_declaration_ _2 = COMMA _3 = unprefixed_use_declaration
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_use_declaration_:
  _1 = use_declaration
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_use_declaration_ _2 = COMMA _3 = use_declaration
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_where_constraint_:
  _1 = where_constraint
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_where_constraint_ _2 = COMMA _3 = where_constraint
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_xhp_attribute_decl_:
  _1 = xhp_attribute_decl
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_xhp_attribute_decl_ _2 = COMMA _3 = xhp_attribute_decl
    {                                             ( _3 :: _1 )}

lseparated_nonempty_list_aux_SEMICOLON_enum_member_:
  _1 = enum_member
    {    ( [_1] )}
| _1 = lseparated_nonempty_list_aux_SEMICOLON_enum_member_ _2 = SEMICOLON _3 = enum_member
    {                                             ( _3 :: _1 )}

%%
