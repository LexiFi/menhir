Grammar has 89 nonterminal symbols, among which 1 start symbols.
Grammar has 92 terminal symbols.
Grammar has 299 productions.
nullable(yield) = false
nullable(with_item) = false
nullable(value) = false
nullable(test_with_generator) = false
nullable(test_list) = false
nullable(test) = false
nullable(targets) = false
nullable(subscript_key) = false
nullable(statements) = true
nullable(statement) = false
nullable(small_statement) = false
nullable(simple_statement) = false
nullable(set_or_dictionary_maker) = false
nullable(set_or_dictionary_entry) = false
nullable(set_or_dictionary) = false
nullable(separated_nonempty_list_indicator_tail(COMMA,test)) = true
nullable(separated_nonempty_list_indicator_tail(COMMA,expression)) = true
nullable(separated_nonempty_list_indicator(COMMA,test)) = false
nullable(separated_nonempty_list_indicator(COMMA,expression)) = false
nullable(reference) = false
nullable(raise_from) = false
nullable(parser_generator_separated_nonempty_list_of_lists(SEMICOLON,small_statement)) = false
nullable(parser_generator_separated_nonempty_list(DOT,identifier)) = false
nullable(parser_generator_separated_nonempty_list(COMMA,with_item)) = false
nullable(parser_generator_separated_nonempty_list(COMMA,subscript_key)) = false
nullable(parser_generator_separated_nonempty_list(COMMA,import)) = false
nullable(parser_generator_separated_nonempty_list(COMMA,identifier)) = false
nullable(parser_generator_separated_list_of_lists(SEMICOLON,small_statement)) = true
nullable(parser_generator_separated_list(DOT,identifier)) = true
nullable(parser_generator_separated_list(COMMA,with_item)) = true
nullable(parser_generator_separated_list(COMMA,test)) = true
nullable(parser_generator_separated_list(COMMA,subscript_key)) = true
nullable(parser_generator_separated_list(COMMA,lambda_parameter)) = true
nullable(parser_generator_separated_list(COMMA,import)) = true
nullable(parser_generator_separated_list(COMMA,identifier)) = true
nullable(parser_generator_separated_list(COMMA,argument)) = true
nullable(parse) = false
nullable(or_test) = false
nullable(option(test_list)) = true
nullable(option(test)) = true
nullable(option(return_annotation)) = true
nullable(option(raise_from)) = true
nullable(option(comment_annotation)) = true
nullable(option(annotation)) = true
nullable(option(SIGNATURE_COMMENT)) = true
nullable(option(FROM)) = true
nullable(option(COMMA)) = true
nullable(option(ANNOTATION_COMMENT)) = true
nullable(not_test) = false
nullable(nonempty_list(ellipsis_or_dot)) = false
nullable(nonempty_list(decorator)) = false
nullable(nonempty_list(comprehension)) = false
nullable(nonempty_list(comparison_operator)) = false
nullable(nonempty_list(NEWLINE)) = false
nullable(nonempty_list(BYTES)) = false
nullable(named_optional_block(FINALLY)) = true
nullable(named_optional_block(ELSE)) = true
nullable(mixed_string) = true
nullable(list(handler)) = true
nullable(list(condition)) = true
nullable(list(NEWLINE)) = true
nullable(imports) = false
nullable(import) = false
nullable(identifier) = false
nullable(handler) = false
nullable(generator) = false
nullable(from_string) = false
nullable(from) = false
nullable(expression_list) = false
nullable(expression) = false
nullable(ellipsis_or_dot) = false
nullable(define_parameters) = true
nullable(decorator_arguments) = true
nullable(decorator) = false
nullable(decorated_statement) = false
nullable(conditional) = false
nullable(condition) = false
nullable(comprehension) = false
nullable(compound_statement) = false
nullable(comparison_operator) = false
nullable(comparison) = false
nullable(block_or_stub_body) = false
nullable(block) = false
nullable(bases) = true
nullable(atom) = false
nullable(async_statement) = false
nullable(arguments) = true
nullable(argument) = false
nullable(and_test) = false
first(yield) = YIELD
first(with_item) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(value) = YIELD TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(test_with_generator) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(test_list) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(test) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(targets) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(subscript_key) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX COLON BYTES AWAIT ASYNC ASTERIKS
first(statements) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FALSE ELLIPSES DELETE DEFINE CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
first(statement) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FALSE ELLIPSES DELETE DEFINE CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
first(small_statement) = YIELD TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IDENTIFIER GLOBAL FROM FORMAT FLOAT FALSE ELLIPSES DELETE CONTINUE COMPLEX BYTES BREAK AWAIT ASYNC ASTERIKS ASSERT
first(simple_statement) = YIELD TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IDENTIFIER GLOBAL FROM FORMAT FLOAT FALSE ELLIPSES DELETE CONTINUE COMPLEX BYTES BREAK AWAIT ASYNC ASTERIKS ASSERT
first(set_or_dictionary_maker) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(set_or_dictionary_entry) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(set_or_dictionary) = LEFTCURLY
first(separated_nonempty_list_indicator_tail(COMMA,test)) = COMMA
first(separated_nonempty_list_indicator_tail(COMMA,expression)) = COMMA
first(separated_nonempty_list_indicator(COMMA,test)) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(separated_nonempty_list_indicator(COMMA,expression)) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(reference) = IDENTIFIER ASYNC
first(raise_from) = FROM
first(parser_generator_separated_nonempty_list_of_lists(SEMICOLON,small_statement)) = YIELD TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IDENTIFIER GLOBAL FROM FORMAT FLOAT FALSE ELLIPSES DELETE CONTINUE COMPLEX BYTES BREAK AWAIT ASYNC ASTERIKS ASSERT
first(parser_generator_separated_nonempty_list(DOT,identifier)) = IDENTIFIER ASYNC
first(parser_generator_separated_nonempty_list(COMMA,with_item)) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(parser_generator_separated_nonempty_list(COMMA,subscript_key)) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX COLON BYTES AWAIT ASYNC ASTERIKS
first(parser_generator_separated_nonempty_list(COMMA,import)) = IDENTIFIER ASYNC ASTERIKS
first(parser_generator_separated_nonempty_list(COMMA,identifier)) = IDENTIFIER ASYNC
first(parser_generator_separated_list_of_lists(SEMICOLON,small_statement)) = YIELD TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IDENTIFIER GLOBAL FROM FORMAT FLOAT FALSE ELLIPSES DELETE CONTINUE COMPLEX BYTES BREAK AWAIT ASYNC ASTERIKS ASSERT
first(parser_generator_separated_list(DOT,identifier)) = IDENTIFIER ASYNC
first(parser_generator_separated_list(COMMA,with_item)) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(parser_generator_separated_list(COMMA,test)) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(parser_generator_separated_list(COMMA,subscript_key)) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX COLON BYTES AWAIT ASYNC ASTERIKS
first(parser_generator_separated_list(COMMA,lambda_parameter)) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(parser_generator_separated_list(COMMA,import)) = IDENTIFIER ASYNC ASTERIKS
first(parser_generator_separated_list(COMMA,identifier)) = IDENTIFIER ASYNC
first(parser_generator_separated_list(COMMA,argument)) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(parse) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FALSE EOF ELLIPSES DELETE DEFINE CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
first(or_test) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(option(test_list)) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(option(test)) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(option(return_annotation)) = MINUS
first(option(raise_from)) = FROM
first(option(comment_annotation)) = ANNOTATION_COMMENT
first(option(annotation)) = COLON
first(option(SIGNATURE_COMMENT)) = SIGNATURE_COMMENT
first(option(FROM)) = FROM
first(option(COMMA)) = COMMA
first(option(ANNOTATION_COMMENT)) = ANNOTATION_COMMENT
first(not_test) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(nonempty_list(ellipsis_or_dot)) = ELLIPSES DOT
first(nonempty_list(decorator)) = AT
first(nonempty_list(comprehension)) = FOR ASYNC
first(nonempty_list(comparison_operator)) = RIGHTANGLEEQUALS RIGHTANGLE NOT LEFTANGLEEQUALS LEFTANGLE ISNOT IS IN EXCLAMATIONMARK DOUBLEEQUALS
first(nonempty_list(NEWLINE)) = NEWLINE
first(nonempty_list(BYTES)) = BYTES
first(named_optional_block(FINALLY)) = FINALLY
first(named_optional_block(ELSE)) = ELSE
first(mixed_string) = STRING FORMAT
first(list(handler)) = EXCEPT
first(list(condition)) = IF
first(list(NEWLINE)) = NEWLINE
first(imports) = LEFTPARENS IDENTIFIER ASYNC ASTERIKS
first(import) = IDENTIFIER ASYNC ASTERIKS
first(identifier) = IDENTIFIER ASYNC
first(handler) = EXCEPT
first(generator) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(from_string) = IDENTIFIER ELLIPSES DOT ASYNC
first(from) = IDENTIFIER ELLIPSES DOT ASYNC
first(expression_list) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(expression) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(ellipsis_or_dot) = ELLIPSES DOT
first(define_parameters) = TRUE TILDE STRING SLASH PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(decorator_arguments) = LEFTPARENS
first(decorator) = AT
first(decorated_statement) = AT
first(conditional) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(condition) = IF
first(comprehension) = FOR ASYNC
first(compound_statement) = WITH WHILE TRY IF FOR DEFINE CLASS
first(comparison_operator) = RIGHTANGLEEQUALS RIGHTANGLE NOT LEFTANGLEEQUALS LEFTANGLE ISNOT IS IN EXCLAMATIONMARK DOUBLEEQUALS
first(comparison) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(block_or_stub_body) = YIELD TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IDENTIFIER GLOBAL FROM FORMAT FLOAT FALSE ELLIPSES DELETE CONTINUE COMPLEX BYTES BREAK AWAIT ASYNC ASTERIKS ASSERT
first(block) = YIELD TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IDENTIFIER GLOBAL FROM FORMAT FLOAT FALSE ELLIPSES DELETE CONTINUE COMPLEX BYTES BREAK AWAIT ASYNC ASTERIKS ASSERT
first(bases) = LEFTPARENS
first(atom) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(async_statement) = ASYNC
first(arguments) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(argument) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
first(and_test) = TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
minimal(yield) = (* 1 *) YIELD
minimal(with_item) = (* 1 *) IDENTIFIER
minimal(value) = (* 1 *) IDENTIFIER
minimal(test_with_generator) = (* 1 *) IDENTIFIER
minimal(test_list) = (* 1 *) IDENTIFIER
minimal(test) = (* 1 *) IDENTIFIER
minimal(targets) = (* 2 *) IDENTIFIER EQUALS
minimal(subscript_key) = (* 1 *) IDENTIFIER
minimal(statements) = (* 0 *)
minimal(statement) = (* 2 *) BREAK NEWLINE
minimal(small_statement) = (* 1 *) BREAK
minimal(simple_statement) = (* 2 *) BREAK NEWLINE
minimal(set_or_dictionary_maker) = (* 1 *) IDENTIFIER
minimal(set_or_dictionary_entry) = (* 1 *) IDENTIFIER
minimal(set_or_dictionary) = (* 2 *) LEFTCURLY RIGHTCURLY
minimal(separated_nonempty_list_indicator_tail(COMMA,test)) = (* 0 *)
minimal(separated_nonempty_list_indicator_tail(COMMA,expression)) = (* 0 *)
minimal(separated_nonempty_list_indicator(COMMA,test)) = (* 1 *) IDENTIFIER
minimal(separated_nonempty_list_indicator(COMMA,expression)) = (* 1 *) IDENTIFIER
minimal(reference) = (* 1 *) IDENTIFIER
minimal(raise_from) = (* 2 *) FROM IDENTIFIER
minimal(parser_generator_separated_nonempty_list_of_lists(SEMICOLON,small_statement)) = (* 1 *) BREAK
minimal(parser_generator_separated_nonempty_list(DOT,identifier)) = (* 1 *) IDENTIFIER
minimal(parser_generator_separated_nonempty_list(COMMA,with_item)) = (* 1 *) IDENTIFIER
minimal(parser_generator_separated_nonempty_list(COMMA,subscript_key)) = (* 1 *) IDENTIFIER
minimal(parser_generator_separated_nonempty_list(COMMA,import)) = (* 1 *) ASTERIKS
minimal(parser_generator_separated_nonempty_list(COMMA,identifier)) = (* 1 *) IDENTIFIER
minimal(parser_generator_separated_list_of_lists(SEMICOLON,small_statement)) = (* 0 *)
minimal(parser_generator_separated_list(DOT,identifier)) = (* 0 *)
minimal(parser_generator_separated_list(COMMA,with_item)) = (* 0 *)
minimal(parser_generator_separated_list(COMMA,test)) = (* 0 *)
minimal(parser_generator_separated_list(COMMA,subscript_key)) = (* 0 *)
minimal(parser_generator_separated_list(COMMA,lambda_parameter)) = (* 0 *)
minimal(parser_generator_separated_list(COMMA,import)) = (* 0 *)
minimal(parser_generator_separated_list(COMMA,identifier)) = (* 0 *)
minimal(parser_generator_separated_list(COMMA,argument)) = (* 0 *)
minimal(parse) = (* 1 *) EOF
minimal(or_test) = (* 1 *) IDENTIFIER
minimal(option(test_list)) = (* 0 *)
minimal(option(test)) = (* 0 *)
minimal(option(return_annotation)) = (* 0 *)
minimal(option(raise_from)) = (* 0 *)
minimal(option(comment_annotation)) = (* 0 *)
minimal(option(annotation)) = (* 0 *)
minimal(option(SIGNATURE_COMMENT)) = (* 0 *)
minimal(option(FROM)) = (* 0 *)
minimal(option(COMMA)) = (* 0 *)
minimal(option(ANNOTATION_COMMENT)) = (* 0 *)
minimal(not_test) = (* 1 *) IDENTIFIER
minimal(nonempty_list(ellipsis_or_dot)) = (* 1 *) DOT
minimal(nonempty_list(decorator)) = (* 3 *) AT IDENTIFIER NEWLINE
minimal(nonempty_list(comprehension)) = (* 4 *) FOR IDENTIFIER IN IDENTIFIER
minimal(nonempty_list(comparison_operator)) = (* 2 *) DOUBLEEQUALS IDENTIFIER
minimal(nonempty_list(NEWLINE)) = (* 1 *) NEWLINE
minimal(nonempty_list(BYTES)) = (* 1 *) BYTES
minimal(named_optional_block(FINALLY)) = (* 0 *)
minimal(named_optional_block(ELSE)) = (* 0 *)
minimal(mixed_string) = (* 0 *)
minimal(list(handler)) = (* 0 *)
minimal(list(condition)) = (* 0 *)
minimal(list(NEWLINE)) = (* 0 *)
minimal(imports) = (* 1 *) ASTERIKS
minimal(import) = (* 1 *) ASTERIKS
minimal(identifier) = (* 1 *) IDENTIFIER
minimal(handler) = (* 4 *) EXCEPT COLON BREAK NEWLINE
minimal(generator) = (* 5 *) IDENTIFIER FOR IDENTIFIER IN IDENTIFIER
minimal(from_string) = (* 1 *) IDENTIFIER
minimal(from) = (* 1 *) IDENTIFIER
minimal(expression_list) = (* 1 *) IDENTIFIER
minimal(expression) = (* 1 *) IDENTIFIER
minimal(ellipsis_or_dot) = (* 1 *) DOT
minimal(define_parameters) = (* 0 *)
minimal(decorator_arguments) = (* 0 *)
minimal(decorator) = (* 3 *) AT IDENTIFIER NEWLINE
minimal(decorated_statement) = (* 7 *) AT IDENTIFIER NEWLINE TRY COLON BREAK NEWLINE
minimal(conditional) = (* 4 *) IDENTIFIER COLON BREAK NEWLINE
minimal(condition) = (* 2 *) IF IDENTIFIER
minimal(comprehension) = (* 4 *) FOR IDENTIFIER IN IDENTIFIER
minimal(compound_statement) = (* 4 *) TRY COLON BREAK NEWLINE
minimal(comparison_operator) = (* 2 *) DOUBLEEQUALS IDENTIFIER
minimal(comparison) = (* 1 *) IDENTIFIER
minimal(block_or_stub_body) = (* 2 *) ELLIPSES NEWLINE
minimal(block) = (* 2 *) BREAK NEWLINE
minimal(bases) = (* 0 *)
minimal(atom) = (* 1 *) IDENTIFIER
minimal(async_statement) = (* 5 *) ASYNC TRY COLON BREAK NEWLINE
minimal(arguments) = (* 0 *)
minimal(argument) = (* 1 *) IDENTIFIER
minimal(and_test) = (* 1 *) IDENTIFIER
maximal(yield) = infinity
maximal(with_item) = infinity
maximal(value) = infinity
maximal(test_with_generator) = infinity
maximal(test_list) = infinity
maximal(test) = infinity
maximal(targets) = infinity
maximal(subscript_key) = infinity
maximal(statements) = infinity
maximal(statement) = infinity
maximal(small_statement) = infinity
maximal(simple_statement) = infinity
maximal(set_or_dictionary_maker) = infinity
maximal(set_or_dictionary_entry) = infinity
maximal(set_or_dictionary) = infinity
maximal(separated_nonempty_list_indicator_tail(COMMA,test)) = infinity
maximal(separated_nonempty_list_indicator_tail(COMMA,expression)) = infinity
maximal(separated_nonempty_list_indicator(COMMA,test)) = infinity
maximal(separated_nonempty_list_indicator(COMMA,expression)) = infinity
maximal(reference) = infinity
maximal(raise_from) = infinity
maximal(parser_generator_separated_nonempty_list_of_lists(SEMICOLON,small_statement)) = infinity
maximal(parser_generator_separated_nonempty_list(DOT,identifier)) = infinity
maximal(parser_generator_separated_nonempty_list(COMMA,with_item)) = infinity
maximal(parser_generator_separated_nonempty_list(COMMA,subscript_key)) = infinity
maximal(parser_generator_separated_nonempty_list(COMMA,import)) = infinity
maximal(parser_generator_separated_nonempty_list(COMMA,identifier)) = infinity
maximal(parser_generator_separated_list_of_lists(SEMICOLON,small_statement)) = infinity
maximal(parser_generator_separated_list(DOT,identifier)) = infinity
maximal(parser_generator_separated_list(COMMA,with_item)) = infinity
maximal(parser_generator_separated_list(COMMA,test)) = infinity
maximal(parser_generator_separated_list(COMMA,subscript_key)) = infinity
maximal(parser_generator_separated_list(COMMA,lambda_parameter)) = infinity
maximal(parser_generator_separated_list(COMMA,import)) = infinity
maximal(parser_generator_separated_list(COMMA,identifier)) = infinity
maximal(parser_generator_separated_list(COMMA,argument)) = infinity
maximal(parse) = infinity
maximal(or_test) = infinity
maximal(option(test_list)) = infinity
maximal(option(test)) = infinity
maximal(option(return_annotation)) = infinity
maximal(option(raise_from)) = infinity
maximal(option(comment_annotation)) = 1
maximal(option(annotation)) = infinity
maximal(option(SIGNATURE_COMMENT)) = 1
maximal(option(FROM)) = 1
maximal(option(COMMA)) = 1
maximal(option(ANNOTATION_COMMENT)) = 1
maximal(not_test) = infinity
maximal(nonempty_list(ellipsis_or_dot)) = infinity
maximal(nonempty_list(decorator)) = infinity
maximal(nonempty_list(comprehension)) = infinity
maximal(nonempty_list(comparison_operator)) = infinity
maximal(nonempty_list(NEWLINE)) = infinity
maximal(nonempty_list(BYTES)) = infinity
maximal(named_optional_block(FINALLY)) = infinity
maximal(named_optional_block(ELSE)) = infinity
maximal(mixed_string) = infinity
maximal(list(handler)) = infinity
maximal(list(condition)) = infinity
maximal(list(NEWLINE)) = infinity
maximal(imports) = infinity
maximal(import) = infinity
maximal(identifier) = 1
maximal(handler) = infinity
maximal(generator) = infinity
maximal(from_string) = infinity
maximal(from) = infinity
maximal(expression_list) = infinity
maximal(expression) = infinity
maximal(ellipsis_or_dot) = 1
maximal(define_parameters) = infinity
maximal(decorator_arguments) = infinity
maximal(decorator) = infinity
maximal(decorated_statement) = infinity
maximal(conditional) = infinity
maximal(condition) = infinity
maximal(comprehension) = infinity
maximal(compound_statement) = infinity
maximal(comparison_operator) = infinity
maximal(comparison) = infinity
maximal(block_or_stub_body) = infinity
maximal(block) = infinity
maximal(bases) = infinity
maximal(atom) = infinity
maximal(async_statement) = infinity
maximal(arguments) = infinity
maximal(argument) = infinity
maximal(and_test) = infinity
follow(yield) = SEMICOLON RIGHTPARENS NEWLINE ANNOTATION_COMMENT
follow(with_item) = COMMA COLON
follow(value) = SEMICOLON NEWLINE ANNOTATION_COMMENT
follow(test_with_generator) = RIGHTPARENS
follow(test_list) = SLASHSLASHEQUALS SLASHEQUALS SEMICOLON RIGHTPARENS RIGHTANGLERIGHTANGLEEQUALS PLUSEQUALS PERCENTEQUALS NEWLINE MINUSEQUALS LEFTANGLELEFTANGLEEQUALS HATEQUALS FROM EQUALS ELSE COLON BAREQUALS ATEQUALS ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS ANNOTATION_COMMENT AMPERSANDEQUALS
follow(test) = SLASHSLASHEQUALS SLASHEQUALS SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS PLUSEQUALS PERCENTEQUALS NEWLINE MINUSEQUALS LEFTANGLELEFTANGLEEQUALS HATEQUALS FROM FOR EQUALS ELSE COMMA COLON BAREQUALS ATEQUALS ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS AS ANNOTATION_COMMENT AMPERSANDEQUALS
follow(targets) = YIELD TRUE TILDE STRING PLUS NOT MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
follow(subscript_key) = RIGHTBRACKET COMMA
follow(statements) = EOF DEDENT
follow(statement) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FALSE EOF ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(small_statement) = SEMICOLON NEWLINE
follow(simple_statement) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FINALLY FALSE EXCEPT EOF ELSEIF ELSE ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(set_or_dictionary_maker) = RIGHTCURLY FOR COMMA ASYNC
follow(set_or_dictionary_entry) = RIGHTCURLY FOR COMMA ASYNC
follow(set_or_dictionary) = SLASHSLASHEQUALS SLASHEQUALS SLASH SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS RIGHTANGLERIGHTANGLE RIGHTANGLEEQUALS RIGHTANGLE PLUSEQUALS PLUS PERCENTEQUALS PERCENT OR NOT NEWLINE MINUSEQUALS MINUS LEFTPARENS LEFTBRACKET LEFTANGLELEFTANGLEEQUALS LEFTANGLELEFTANGLE LEFTANGLEEQUALS LEFTANGLE ISNOT IS IN IF HATEQUALS HAT FROM FOR EXCLAMATIONMARK EQUALS ELSE DOUBLEEQUALS DOT COMMA COLON BAREQUALS BAR ATEQUALS AT ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS ASTERIKS AS ANNOTATION_COMMENT AND AMPERSANDEQUALS AMPERSAND
follow(separated_nonempty_list_indicator_tail(COMMA,test)) = SLASHSLASHEQUALS SLASHEQUALS SEMICOLON RIGHTPARENS RIGHTANGLERIGHTANGLEEQUALS PLUSEQUALS PERCENTEQUALS NEWLINE MINUSEQUALS LEFTANGLELEFTANGLEEQUALS HATEQUALS FROM EQUALS ELSE COLON BAREQUALS ATEQUALS ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS ANNOTATION_COMMENT AMPERSANDEQUALS
follow(separated_nonempty_list_indicator_tail(COMMA,expression)) = SEMICOLON NEWLINE IN
follow(separated_nonempty_list_indicator(COMMA,test)) = SLASHSLASHEQUALS SLASHEQUALS SEMICOLON RIGHTPARENS RIGHTANGLERIGHTANGLEEQUALS PLUSEQUALS PERCENTEQUALS NEWLINE MINUSEQUALS LEFTANGLELEFTANGLEEQUALS HATEQUALS FROM EQUALS ELSE COLON BAREQUALS ATEQUALS ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS ANNOTATION_COMMENT AMPERSANDEQUALS
follow(separated_nonempty_list_indicator(COMMA,expression)) = SEMICOLON NEWLINE IN
follow(reference) = SEMICOLON RIGHTPARENS NEWLINE LEFTPARENS COMMA COLON AS
follow(raise_from) = SEMICOLON NEWLINE
follow(parser_generator_separated_nonempty_list_of_lists(SEMICOLON,small_statement)) = NEWLINE
follow(parser_generator_separated_nonempty_list(DOT,identifier)) = SEMICOLON RIGHTPARENS NEWLINE LEFTPARENS COMMA COLON AS
follow(parser_generator_separated_nonempty_list(COMMA,with_item)) = COLON
follow(parser_generator_separated_nonempty_list(COMMA,subscript_key)) = RIGHTBRACKET
follow(parser_generator_separated_nonempty_list(COMMA,import)) = SEMICOLON RIGHTPARENS NEWLINE
follow(parser_generator_separated_nonempty_list(COMMA,identifier)) = SEMICOLON NEWLINE
follow(parser_generator_separated_list_of_lists(SEMICOLON,small_statement)) = NEWLINE
follow(parser_generator_separated_list(DOT,identifier)) = SEMICOLON RIGHTPARENS NEWLINE LEFTPARENS COMMA COLON AS
follow(parser_generator_separated_list(COMMA,with_item)) = COLON
follow(parser_generator_separated_list(COMMA,test)) = RIGHTBRACKET
follow(parser_generator_separated_list(COMMA,subscript_key)) = RIGHTBRACKET
follow(parser_generator_separated_list(COMMA,lambda_parameter)) = COLON
follow(parser_generator_separated_list(COMMA,import)) = SEMICOLON RIGHTPARENS NEWLINE
follow(parser_generator_separated_list(COMMA,identifier)) = SEMICOLON NEWLINE
follow(parser_generator_separated_list(COMMA,argument)) = RIGHTPARENS
follow(parse) = #
follow(or_test) = SLASHSLASHEQUALS SLASHEQUALS SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS PLUSEQUALS PERCENTEQUALS NEWLINE MINUSEQUALS LEFTANGLELEFTANGLEEQUALS IF HATEQUALS FROM FOR EQUALS ELSE COMMA COLON BAREQUALS ATEQUALS ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS AS ANNOTATION_COMMENT AMPERSANDEQUALS
follow(option(test_list)) = SEMICOLON RIGHTPARENS NEWLINE FROM ANNOTATION_COMMENT
follow(option(test)) = RIGHTBRACKET COMMA COLON
follow(option(return_annotation)) = COLON
follow(option(raise_from)) = SEMICOLON NEWLINE
follow(option(comment_annotation)) = TRUE TILDE STRING SLASH SEMICOLON RIGHTPARENS PLUS NOT NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS
follow(option(annotation)) = RIGHTPARENS EQUALS COMMA ANNOTATION_COMMENT
follow(option(SIGNATURE_COMMENT)) = YIELD TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IDENTIFIER GLOBAL FROM FORMAT FLOAT FALSE ELLIPSES DELETE CONTINUE COMPLEX BYTES BREAK AWAIT ASYNC ASTERIKS ASSERT
follow(option(FROM)) = TRUE TILDE STRING SEMICOLON RIGHTPARENS PLUS NOT NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IDENTIFIER FORMAT FLOAT FALSE ELLIPSES COMPLEX BYTES AWAIT ASYNC ASTERIKS ANNOTATION_COMMENT
follow(option(COMMA)) = RIGHTCURLY
follow(option(ANNOTATION_COMMENT)) = YIELD TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IDENTIFIER GLOBAL FROM FORMAT FLOAT FALSE ELLIPSES DELETE CONTINUE COMPLEX BYTES BREAK AWAIT ASYNC ASTERIKS ASSERT
follow(not_test) = SLASHSLASHEQUALS SLASHEQUALS SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS PLUSEQUALS PERCENTEQUALS OR NEWLINE MINUSEQUALS LEFTANGLELEFTANGLEEQUALS IF HATEQUALS FROM FOR EQUALS ELSE COMMA COLON BAREQUALS ATEQUALS ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS AS ANNOTATION_COMMENT AND AMPERSANDEQUALS
follow(nonempty_list(ellipsis_or_dot)) = IMPORT IDENTIFIER ELLIPSES DOT ASYNC
follow(nonempty_list(decorator)) = WITH WHILE TRY IF FOR DEFINE CLASS ASYNC
follow(nonempty_list(comprehension)) = RIGHTPARENS RIGHTCURLY RIGHTBRACKET COMMA
follow(nonempty_list(comparison_operator)) = SLASHSLASHEQUALS SLASHEQUALS SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS PLUSEQUALS PERCENTEQUALS OR NEWLINE MINUSEQUALS LEFTANGLELEFTANGLEEQUALS IF HATEQUALS FROM FOR EQUALS ELSE COMMA COLON BAREQUALS ATEQUALS ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS AS ANNOTATION_COMMENT AND AMPERSANDEQUALS
follow(nonempty_list(NEWLINE)) = WITH WHILE TRY INDENT IF FOR DEFINE CLASS AT ASYNC
follow(nonempty_list(BYTES)) = SLASHSLASHEQUALS SLASHEQUALS SLASH SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS RIGHTANGLERIGHTANGLE RIGHTANGLEEQUALS RIGHTANGLE PLUSEQUALS PLUS PERCENTEQUALS PERCENT OR NOT NEWLINE MINUSEQUALS MINUS LEFTPARENS LEFTBRACKET LEFTANGLELEFTANGLEEQUALS LEFTANGLELEFTANGLE LEFTANGLEEQUALS LEFTANGLE ISNOT IS IN IF HATEQUALS HAT FROM FOR EXCLAMATIONMARK EQUALS ELSE DOUBLEEQUALS DOT COMMA COLON BAREQUALS BAR ATEQUALS AT ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS ASTERIKS AS ANNOTATION_COMMENT AND AMPERSANDEQUALS AMPERSAND
follow(named_optional_block(FINALLY)) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FALSE EOF ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(named_optional_block(ELSE)) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FINALLY FALSE EOF ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(mixed_string) = SLASHSLASHEQUALS SLASHEQUALS SLASH SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS RIGHTANGLERIGHTANGLE RIGHTANGLEEQUALS RIGHTANGLE PLUSEQUALS PLUS PERCENTEQUALS PERCENT OR NOT NEWLINE MINUSEQUALS MINUS LEFTPARENS LEFTBRACKET LEFTANGLELEFTANGLEEQUALS LEFTANGLELEFTANGLE LEFTANGLEEQUALS LEFTANGLE ISNOT IS IN IF HATEQUALS HAT FROM FOR EXCLAMATIONMARK EQUALS ELSE DOUBLEEQUALS DOT COMMA COLON BAREQUALS BAR ATEQUALS AT ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS ASTERIKS AS ANNOTATION_COMMENT AND AMPERSANDEQUALS AMPERSAND
follow(list(handler)) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FINALLY FALSE EOF ELSE ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(list(condition)) = RIGHTPARENS RIGHTCURLY RIGHTBRACKET FOR COMMA ASYNC
follow(list(NEWLINE)) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FINALLY FALSE EXCEPT EOF ELSEIF ELSE ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(imports) = SEMICOLON NEWLINE
follow(import) = SEMICOLON RIGHTPARENS NEWLINE COMMA
follow(identifier) = SLASHSLASHEQUALS SLASHEQUALS SLASH SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS RIGHTANGLERIGHTANGLE RIGHTANGLEEQUALS RIGHTANGLE PLUSEQUALS PLUS PERCENTEQUALS PERCENT OR NOT NEWLINE MINUSEQUALS MINUS LEFTPARENS LEFTBRACKET LEFTANGLELEFTANGLEEQUALS LEFTANGLELEFTANGLE LEFTANGLEEQUALS LEFTANGLE ISNOT IS IN IMPORT IF IDENTIFIER HATEQUALS HAT FROM FOR EXCLAMATIONMARK EQUALS ELSE ELLIPSES DOUBLEEQUALS DOT COMMA COLONEQUALS COLON BAREQUALS BAR ATEQUALS AT ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS ASTERIKS AS ANNOTATION_COMMENT AND AMPERSANDEQUALS AMPERSAND
follow(handler) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FINALLY FALSE EXCEPT EOF ELSE ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(generator) = RIGHTPARENS COMMA
follow(from_string) = IMPORT
follow(from) = IMPORT
follow(expression_list) = SEMICOLON NEWLINE IN
follow(expression) = SLASHSLASHEQUALS SLASHEQUALS SLASH SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS RIGHTANGLERIGHTANGLE RIGHTANGLEEQUALS RIGHTANGLE PLUSEQUALS PLUS PERCENTEQUALS PERCENT OR NOT NEWLINE MINUSEQUALS MINUS LEFTPARENS LEFTBRACKET LEFTANGLELEFTANGLEEQUALS LEFTANGLELEFTANGLE LEFTANGLEEQUALS LEFTANGLE ISNOT IS IN IF HATEQUALS HAT FROM FOR EXCLAMATIONMARK EQUALS ELSE DOUBLEEQUALS DOT COMMA COLON BAREQUALS BAR ATEQUALS AT ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS ASTERIKS AS ANNOTATION_COMMENT AND AMPERSANDEQUALS AMPERSAND
follow(ellipsis_or_dot) = IMPORT IDENTIFIER ELLIPSES DOT ASYNC
follow(define_parameters) = RIGHTPARENS
follow(decorator_arguments) = NEWLINE
follow(decorator) = WITH WHILE TRY IF FOR DEFINE CLASS AT ASYNC
follow(decorated_statement) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FALSE EOF ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(conditional) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FALSE EOF ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(condition) = RIGHTPARENS RIGHTCURLY RIGHTBRACKET IF FOR COMMA ASYNC
follow(comprehension) = RIGHTPARENS RIGHTCURLY RIGHTBRACKET FOR COMMA ASYNC
follow(compound_statement) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FALSE EOF ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(comparison_operator) = SLASHSLASHEQUALS SLASHEQUALS SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS RIGHTANGLEEQUALS RIGHTANGLE PLUSEQUALS PERCENTEQUALS OR NOT NEWLINE MINUSEQUALS LEFTANGLELEFTANGLEEQUALS LEFTANGLEEQUALS LEFTANGLE ISNOT IS IN IF HATEQUALS FROM FOR EXCLAMATIONMARK EQUALS ELSE DOUBLEEQUALS COMMA COLON BAREQUALS ATEQUALS ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS AS ANNOTATION_COMMENT AND AMPERSANDEQUALS
follow(comparison) = SLASHSLASHEQUALS SLASHEQUALS SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS PLUSEQUALS PERCENTEQUALS OR NEWLINE MINUSEQUALS LEFTANGLELEFTANGLEEQUALS IF HATEQUALS FROM FOR EQUALS ELSE COMMA COLON BAREQUALS ATEQUALS ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS AS ANNOTATION_COMMENT AND AMPERSANDEQUALS
follow(block_or_stub_body) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FALSE EOF ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(block) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FINALLY FALSE EXCEPT EOF ELSEIF ELSE ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(bases) = COLON
follow(atom) = SLASHSLASHEQUALS SLASHEQUALS SLASH SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS RIGHTANGLERIGHTANGLE RIGHTANGLEEQUALS RIGHTANGLE PLUSEQUALS PLUS PERCENTEQUALS PERCENT OR NOT NEWLINE MINUSEQUALS MINUS LEFTPARENS LEFTBRACKET LEFTANGLELEFTANGLEEQUALS LEFTANGLELEFTANGLE LEFTANGLEEQUALS LEFTANGLE ISNOT IS IN IF HATEQUALS HAT FROM FOR EXCLAMATIONMARK EQUALS ELSE DOUBLEEQUALS DOT COMMA COLON BAREQUALS BAR ATEQUALS AT ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS ASTERIKS AS ANNOTATION_COMMENT AND AMPERSANDEQUALS AMPERSAND
follow(async_statement) = YIELD WITH WHILE TRY TRUE TILDE STRING RETURN RAISE PLUS PASS NOT NONLOCAL NEWLINE MINUS LEFTPARENS LEFTCURLY LEFTBRACKET LAMBDA INTEGER IMPORT IF IDENTIFIER GLOBAL FROM FORMAT FOR FLOAT FALSE EOF ELLIPSES DELETE DEFINE DEDENT CONTINUE COMPLEX CLASS BYTES BREAK AWAIT AT ASYNC ASTERIKS ASSERT
follow(arguments) = RIGHTPARENS
follow(argument) = RIGHTPARENS COMMA
follow(and_test) = SLASHSLASHEQUALS SLASHEQUALS SEMICOLON RIGHTPARENS RIGHTCURLY RIGHTBRACKET RIGHTANGLERIGHTANGLEEQUALS PLUSEQUALS PERCENTEQUALS OR NEWLINE MINUSEQUALS LEFTANGLELEFTANGLEEQUALS IF HATEQUALS FROM FOR EQUALS ELSE COMMA COLON BAREQUALS ATEQUALS ASYNC ASTERIKSEQUALS ASTERIKSASTERIKSEQUALS AS ANNOTATION_COMMENT AMPERSANDEQUALS
Built an LR(0) automaton with 532 states.
The grammar is not SLR(1) -- 39 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 532 states.
254 shift/reduce conflicts were silently solved.
Warning: 31 states have shift/reduce conflicts.
Warning: 5 states have reduce/reduce conflicts.
Warning: 77 shift/reduce conflicts were arbitrarily resolved.
Warning: 75 reduce/reduce conflicts were arbitrarily resolved.
193 out of 532 states have a default reduction.
The action table is 49476 entries; 7167 non-zero; 6508 compressed.
The action table occupies roughly 13104 bytes.
The goto table is 47880 entries; 1748 non-zero; 3116 compressed.
The goto table occupies roughly 6320 bytes.
The error table occupies roughly 6224 bytes.
The default_reduction table occupies roughly 1096 bytes.
The lhs table occupies roughly 336 bytes.
The trace table occupies roughly 8 bytes.
