%{
  open Core

  open Ast
  open Statement
  open Pyre
  open ParserExpression

  type decorator = { decorator_name : Reference.t Node.t; arguments : Call.Argument.t list option }

  let with_decorators decorators decoratee =
    let decorators =
      let convert ({ decorator_name; arguments } ) =
        { Decorator.name = decorator_name; arguments = arguments >>| List.map ~f:convert_argument }
      in
      List.map decorators ~f:convert
    in
    match decoratee with
    | { Node.location; value = Statement.Class value } ->
        let decorated = { value with Class.decorators; } in
        { Node.location; value = Statement.Class decorated }
    | { Node.location; value = Define value } ->
        let signature =
          { value.signature with Define.Signature.decorators }
        in
        let decorated = { value with signature } in
        { Node.location; value = Define decorated }
    | _ -> raise (ParserError "Cannot decorate statement")

  type entry =
    | Entry of Dictionary.Entry.t
    | Item of Expression.t
    | Keywords of Expression.t
    | Comprehension of Comprehension.Generator.t

  type entries = {
      entries: Dictionary.Entry.t list;
      items: Expression.t list;
      keywords: Expression.t list;
      comprehensions: Comprehension.Generator.t list;
    }


  let add_entry so_far = function
    | Entry entry ->
        { so_far with entries = entry :: so_far.entries }
    | Item item ->
        { so_far with items = item :: so_far.items }
    | Keywords keyword ->
        { so_far with keywords = keyword :: so_far.keywords }
    | Comprehension comprehension ->
        { so_far with comprehensions = comprehension :: so_far.comprehensions }

  (* Helper function to combine a start position of type Lexing.position and
   * stop position of type Location.position. *)
  let location_create_with_stop ~start ~stop =
    let position = Location.create ~start ~stop:start in
    { position with Location.stop = stop }

  type binary_operator =
    | Add
    | At
    | BitAnd
    | BitOr
    | BitXor
    | Divide
    | FloorDivide
    | LeftShift
    | Modulo
    | Multiply
    | Power
    | RightShift
    | Subtract

  let binary_operator
    ~compound
    ~left:({ Node.location; _ } as left)
    ~operator
    ~right:({ Node.location = { Location.stop; _ }; _ } as right) =
    let name =
      let name =
        match operator with
        | Add -> "add"
        | At -> "matmul"
        | BitAnd -> "and"
        | BitOr -> "or"
        | BitXor -> "xor"
        | Divide -> "truediv"
        | FloorDivide -> "floordiv"
        | LeftShift -> "lshift"
        | Modulo -> "mod"
        | Multiply -> "mul"
        | Power -> "pow"
        | RightShift -> "rshift"
        | Subtract -> "sub"
      in
      Format.asprintf "__%s%s__" (if compound then "i" else "") name
    in
    let callee =
      Expression.Name (Name.Attribute { base = left; attribute = name; special = true })
      |> Node.create ~location
    in
    Expression.Call { callee; arguments = [{ Call.Argument.name = None; value = right }] }
    |> Node.create ~location:{ location with stop }

  let slice ~lower ~upper ~step ~bound_colon ~step_colon =
    let increment ({ Location.start; stop; _ } as location) =
      let increment ({ Location.column; _ } as position) =
        { position with Location.column = column + 1 }
      in
      { location with Location.start = increment start; stop = increment stop }
    in
    let lower_location =
      match lower with
      | Some lower -> lower.Node.location
      | None -> Location.create ~start:bound_colon ~stop:bound_colon
    in
    let upper_location =
      match upper with
      | Some upper -> upper.Node.location
      | None -> Location.create ~start:bound_colon ~stop:bound_colon |> increment
    in
    let step_location =
      match step with
      | Some step -> step.Node.location
      | None ->
          begin
            match step_colon with
            | Some colon -> Location.create ~start:colon ~stop:colon |> increment
            | None ->
                begin
                  match upper with
                  | Some { Node.location = ({ stop; _ } as location); _ } ->
                      { location with start = stop }
                  | None -> Location.create ~start:bound_colon ~stop:bound_colon |> increment
                end
          end
    in
    let slice_location =
      { lower_location with Location.stop = step_location.Location.stop  }
    in
    let arguments =
      let argument argument location =
        let none =
          Expression.Name (Name.Identifier "None")
          |> Node.create ~location
        in
        Option.value argument ~default:none
      in
      [
        { Call.Argument.name = None; value = argument lower lower_location };
        { Call.Argument.name = None; value = argument upper upper_location };
        { Call.Argument.name = None; value = argument step step_location };
      ]
    in
    let callee =
      Expression.Name (Name.Identifier "slice")
      |> Node.create ~location:slice_location
    in
    Expression.Call { callee; arguments }
    |> Node.create ~location:slice_location


  let create_ellipsis (start, stop) =
    let location = Location.create ~start ~stop in
    Node.create Expression.Ellipsis ~location

  let create_ellipsis_after { Node.location; _ } =
    Node.create Expression.Ellipsis ~location:{ location with start = location.stop }

  let subscript_argument ~subscripts ~location =
    let value =
      match subscripts with
      | [subscript] -> subscript
      | subscripts -> { Node.location; value = Expression.Tuple subscripts }
    in
    { Call.Argument.name = None; value }

  let subscript_access subscript =
    let head, subscripts, subscript_location = subscript in
    let location = Node.location head in
    let callee =
      Expression.Name (Name.Attribute { base = head; attribute = "__getitem__"; special = true })
      |> Node.create ~location
    in
    Expression.Call { callee; arguments = [subscript_argument ~subscripts ~location] }
    |> Node.create ~location:{ subscript_location with start = location.start }

  let subscript_mutation ~subscript ~value ~annotation:_ =
    let head, subscripts, subscript_location = subscript in
    let callee =
      let location =
        { head.Node.location with Location.stop = subscript_location.Location.stop }
      in
      Expression.Name (Name.Attribute { base = head; attribute = "__setitem__"; special = true })
      |> Node.create ~location
    in
    let location =
      { head.Node.location with Location.stop = value.Node.location.Location.stop }
    in
    Expression.Call {
      callee;
      arguments = [subscript_argument ~subscripts ~location; { Call.Argument.name = None; value }];
    }
    |> Node.create ~location
    |> fun expression -> Statement.Expression (convert expression)
    |> Node.create ~location

  let with_annotation ~parameter ~annotation =
    let value =
      let { Node.value = { Parameter.annotation = existing; _ } as value; _ } = parameter in
      let annotation =
        match existing, annotation with
        | None, Some annotation -> Some annotation
        | _ -> existing
      in
      { value with Parameter.annotation }
    in
    { parameter with Node.value }

  let create_substring kind (string_position, (start, stop), value) =
    string_position,
    {
      Node.location = Location.create ~start ~stop;
      value = { AstExpression.Substring.kind; value };
    }

%}
%start parse
%token AMPERSAND
%token AMPERSANDEQUALS
%token AND
%token <(Lexing.position * Lexing.position) * string> ANNOTATION_COMMENT
%token AS
%token <Lexing.position> ASSERT
%token <Lexing.position * Lexing.position> ASTERIKS
%token ASTERIKSASTERIKSEQUALS
%token ASTERIKSEQUALS
%token <Lexing.position * Lexing.position> ASYNC
%token AT
%token ATEQUALS
%token <Lexing.position> AWAIT
%token BAR
%token BAREQUALS
%token <Lexing.position * Lexing.position> BREAK
%token <(Lexing.position * Lexing.position) * (Lexing.position * Lexing.position) * string> BYTES
%token <Lexing.position> CLASS
%token <Lexing.position> COLON
%token COLONEQUALS
%token COMMA
%token <(Lexing.position * Lexing.position) * float> COMPLEX
%token <Lexing.position * Lexing.position> CONTINUE
%token <Lexing.position> DEDENT
%token <Lexing.position> DEFINE
%token <Lexing.position> DELETE
%token <Lexing.position * Lexing.position> DOT
%token DOUBLEEQUALS
%token <(Lexing.position * Lexing.position)> ELLIPSES
%token ELSE
%token <Lexing.position> ELSEIF
%token EOF
%token EQUALS
%token <Lexing.position> EXCEPT
%token EXCLAMATIONMARK
%token <(Lexing.position * Lexing.position)> FALSE
%token FINALLY
%token <(Lexing.position * Lexing.position) * float> FLOAT
%token <Lexing.position> FOR
%token <(Lexing.position * Lexing.position) * (Lexing.position * Lexing.position) * string> FORMAT
%token <Lexing.position> FROM
%token <Lexing.position> GLOBAL
%token HAT
%token HATEQUALS
%token <(Lexing.position * Lexing.position) * string> IDENTIFIER
%token <Lexing.position> IF
%token <Lexing.position> IMPORT
%token IN
%token INDENT
%token <(Lexing.position * Lexing.position) * int> INTEGER
%token IS
%token ISNOT
%token <Lexing.position> LAMBDA
%token LEFTANGLE
%token LEFTANGLEEQUALS
%token LEFTANGLELEFTANGLE
%token LEFTANGLELEFTANGLEEQUALS
%token <Lexing.position> LEFTBRACKET
%token <Lexing.position> LEFTCURLY
%token <Lexing.position> LEFTPARENS
%token <Lexing.position> MINUS
%token MINUSEQUALS
%token <Lexing.position> NEWLINE
%token <Lexing.position> NONLOCAL
%token <Lexing.position> NOT
%token OR
%token <Lexing.position * Lexing.position> PASS
%token PERCENT
%token PERCENTEQUALS
%token <Lexing.position> PLUS
%token PLUSEQUALS
%token <Lexing.position * Lexing.position> RAISE
%token <Lexing.position * Lexing.position> RETURN
%token RIGHTANGLE
%token RIGHTANGLEEQUALS
%token RIGHTANGLERIGHTANGLE
%token RIGHTANGLERIGHTANGLEEQUALS
%token <Lexing.position> RIGHTBRACKET
%token <Lexing.position> RIGHTCURLY
%token <Lexing.position> RIGHTPARENS
%token SEMICOLON
%token <(Lexing.position * Lexing.position) * string list * string> SIGNATURE_COMMENT
%token <Lexing.position> SLASH
%token SLASHEQUALS
%token SLASHSLASHEQUALS
%token <(Lexing.position * Lexing.position) * (Lexing.position * Lexing.position) * string> STRING
%token <Lexing.position> TILDE
%token <(Lexing.position * Lexing.position)> TRUE
%token <Lexing.position> TRY
%token <Lexing.position> WHILE
%token <Lexing.position> WITH
%token <Lexing.position * Lexing.position> YIELD
%left LEFTANGLELEFTANGLE RIGHTANGLERIGHTANGLE
%left NOT
%left BAR
%left HAT
%left AMPERSAND
%left MINUS PLUS
%left ASTERIKS PERCENT SLASH
%left AWAIT
%left TILDE
%left AT
%left DOT
%nonassoc LEFTPARENS
%type <Ast.Statement.t list> parse
%%

option_ANNOTATION_COMMENT_:
  
    {    ( None )}
| x = ANNOTATION_COMMENT
    {    ( Some x )}

option_COMMA_:
  
    {    ( None )}
| x = COMMA
    {    ( Some x )}

option_FROM_:
  
    {    ( None )}
| x = FROM
    {    ( Some x )}

option_SIGNATURE_COMMENT_:
  
    {    ( None )}
| x = SIGNATURE_COMMENT
    {    ( Some x )}

option_annotation_:
  
    {    ( None )}
| _1 = COLON expression = expression
    {let x =                                    ( expression ) in
    ( Some x )}

option_comment_annotation_:
  
    {    ( None )}
| annotation = ANNOTATION_COMMENT
    {let x =                                     (
      let (start, stop), annotation = annotation in
      annotation
      |> String.strip ~drop:(function | '\'' | '"' -> true | _ -> false)
      |> StringLiteral.create
      |> fun string -> Expression.String string
      |> Node.create ~location:(Location.create ~start ~stop)
    ) in
    ( Some x )}

option_raise_from_:
  
    {    ( None )}
| x = raise_from
    {    ( Some x )}

option_return_annotation_:
  
    {    ( None )}
| _1 = MINUS _2 = RIGHTANGLE expression = expression
    {let x =                                                ( expression ) in
    ( Some x )}

option_test_:
  
    {    ( None )}
| x = test
    {    ( Some x )}

option_test_list_:
  
    {    ( None )}
| x = test_list
    {    ( Some x )}

list_NEWLINE_:
  
    {    ( [] )}
| x = NEWLINE xs = list_NEWLINE_
    {    ( x :: xs )}

list_condition_:
  
    {    ( [] )}
| x = condition xs = list_condition_
    {    ( x :: xs )}

list_handler_:
  
    {    ( [] )}
| x = handler xs = list_handler_
    {    ( x :: xs )}

nonempty_list_BYTES_:
  x = BYTES
    {    ( [ x ] )}
| x = BYTES xs = nonempty_list_BYTES_
    {    ( x :: xs )}

nonempty_list_NEWLINE_:
  x = NEWLINE
    {    ( [ x ] )}
| x = NEWLINE xs = nonempty_list_NEWLINE_
    {    ( x :: xs )}

nonempty_list_comparison_operator_:
  x = comparison_operator
    {    ( [ x ] )}
| x = comparison_operator xs = nonempty_list_comparison_operator_
    {    ( x :: xs )}

nonempty_list_comprehension_:
  x = comprehension
    {    ( [ x ] )}
| x = comprehension xs = nonempty_list_comprehension_
    {    ( x :: xs )}

nonempty_list_decorator_:
  x = decorator
    {    ( [ x ] )}
| x = decorator xs = nonempty_list_decorator_
    {    ( x :: xs )}

nonempty_list_ellipsis_or_dot_:
  x = ellipsis_or_dot
    {    ( [ x ] )}
| x = ellipsis_or_dot xs = nonempty_list_ellipsis_or_dot_
    {    ( x :: xs )}

parse:
  statements = statements _2 = EOF
    {                                 ( snd statements )}

statements:
  
    {    ( Location.any, [] )}
| _1 = NEWLINE statements = statements
    {                                     ( statements )}
| statement = statement statements = statements
    {                                                   (
      (* The recursion always terminates in the empty statement case. This logic avoids
       * propagating the end location information from there. *)
      let location =
        match (snd statements) with
        | [] -> fst statement
        | _ -> {(fst statement) with Location.stop = (fst statements).Location.stop;}
       in
      location, (snd statement)@(snd statements)
    )}

statement:
  statements = simple_statement
    {                                  ( statements )}
| statement = compound_statement
    {                                   ( statement.Node.location, [statement] )}
| statement = decorated_statement
    {                                    ( statement.Node.location, [statement] )}
| statement = async_statement
    {                                ( statement.Node.location, [statement] )}

simple_statement:
  statements = parser_generator_separated_nonempty_list_of_lists_SEMICOLON_small_statement_ _2 = NEWLINE
    {            (
      let flattened_statements = List.concat statements in
      let head = List.hd_exn flattened_statements in
      let last = List.last_exn flattened_statements in
      let location = {head.Node.location with Location.stop = Node.stop last} in
      location, flattened_statements
    )}

small_statement:
  head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = PLUSEQUALS value = value
    {let compound =                ( Add ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = ATEQUALS value = value
    {let compound =              ( At ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = AMPERSANDEQUALS value = value
    {let compound =                     ( BitAnd ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = BAREQUALS value = value
    {let compound =               ( BitOr ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = HATEQUALS value = value
    {let compound =               ( BitXor ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = SLASHSLASHEQUALS value = value
    {let compound =                      ( FloorDivide ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = SLASHEQUALS value = value
    {let compound =                 ( Divide ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = LEFTANGLELEFTANGLEEQUALS value = value
    {let compound =                              ( LeftShift ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = PERCENTEQUALS value = value
    {let compound =                   ( Modulo ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = ASTERIKSASTERIKSEQUALS value = value
    {let compound =                            ( Power ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = ASTERIKSEQUALS value = value
    {let compound =                    ( Multiply ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = RIGHTANGLERIGHTANGLEEQUALS value = value
    {let compound =                                ( RightShift ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _1 = MINUSEQUALS value = value
    {let compound =                 ( Subtract ) in
let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                                                                       (
      let value =
        binary_operator
          ~compound:true
          ~left:(subscript_access subscript)
          ~operator:compound
          ~right:value
      in
      [subscript_mutation ~subscript ~value ~annotation:None]
  )}
| target = test_list _1 = PLUSEQUALS value = value
    {let compound =                ( Add ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = ATEQUALS value = value
    {let compound =              ( At ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = AMPERSANDEQUALS value = value
    {let compound =                     ( BitAnd ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = BAREQUALS value = value
    {let compound =               ( BitOr ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = HATEQUALS value = value
    {let compound =               ( BitXor ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = SLASHSLASHEQUALS value = value
    {let compound =                      ( FloorDivide ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = SLASHEQUALS value = value
    {let compound =                 ( Divide ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = LEFTANGLELEFTANGLEEQUALS value = value
    {let compound =                              ( LeftShift ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = PERCENTEQUALS value = value
    {let compound =                   ( Modulo ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = ASTERIKSASTERIKSEQUALS value = value
    {let compound =                            ( Power ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = ASTERIKSEQUALS value = value
    {let compound =                    ( Multiply ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = RIGHTANGLERIGHTANGLEEQUALS value = value
    {let compound =                                ( RightShift ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = MINUSEQUALS value = value
    {let compound =                 ( Subtract ) in
                  (
      let value = binary_operator ~compound:true ~left:target ~operator:compound ~right:value in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = None;
          value = convert value;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = COLON expression = expression
    {let annotation =                                    ( expression ) in
                            (
      [{
        Node.location = {
          target.Node.location with Location.stop =
            annotation.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = Some annotation >>| convert;
          value = create_ellipsis_after annotation |> convert;
          parent = None;
        };
      }]
    )}
| target = test_list annotation = ANNOTATION_COMMENT
    {let annotation =                                     (
      let (start, stop), annotation = annotation in
      annotation
      |> String.strip ~drop:(function | '\'' | '"' -> true | _ -> false)
      |> StringLiteral.create
      |> fun string -> Expression.String string
      |> Node.create ~location:(Location.create ~start ~stop)
    ) in
                                    (
      [{
        Node.location = {
          target.Node.location with Location.stop =
            annotation.Node.location.Location.stop;
        };
        value = Statement.Assign {
          Assign.target = convert target;
          annotation = Some annotation >>| convert;
          value = create_ellipsis_after annotation |> convert;
          parent = None;
        };
      }]
    )}
| target = test_list _1 = COLON expression = expression _3 = EQUALS value = test_list
    {let annotation =                                    ( expression ) in
                      (
      [{
        Node.location = {
          target.Node.location with Location.stop =
            value.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = Some annotation >>| convert;
          value = convert value;
          parent = None;
        };
      }]
    )}
| targets = targets value = value annotation = option_comment_annotation_
    {                                                                       (
      List.map ~f:(fun target -> target ~value ~annotation) targets
  )}
| targets = targets ellipsis = ELLIPSES
    {                                           (
      let value = create_ellipsis ellipsis in
      List.map ~f:(fun target -> target ~value ~annotation:None) targets
    )}
| target = test_list _1 = COLON expression = expression _3 = EQUALS ellipsis = ELLIPSES
    {let annotation =                                    ( expression ) in
                        (
      let ellipsis = create_ellipsis ellipsis in
      [{
        Node.location = {
          target.Node.location with Location.stop =
            ellipsis.Node.location.Location.stop;
        };
        value = Assign {
          Assign.target = convert target;
          annotation = Some annotation >>| convert;
          value = convert ellipsis;
          parent = None;
        };
      }]
    )}
| start = ASSERT test = test
    {                                (
      [{
        Node.location = location_create_with_stop ~start ~stop:(Node.stop test);
        value = Assert { Assert.test = convert test; message = None; origin = Assert.Origin.Assertion }
      }]
    )}
| start = ASSERT test = test _3 = COMMA message = test
    {                          (
      [{
        Node.location = location_create_with_stop ~start ~stop:(Node.stop test);
        value = Assert {
          Assert.test = convert test;
          message = Some message >>| convert;
          origin = Assert.Origin.Assertion
        }
      }]
    )}
| position = BREAK
    {                     (
      let start, stop = position in
      [{ Node.location = Location.create ~start ~stop; value = Break }]
    )}
| position = CONTINUE
    {                        (
      let start, stop = position in
      [{ Node.location = Location.create ~start ~stop; value = Continue }]
    )}
| test = test_list
    {                     (
      [{ Node.location = test.Node.location; value = Expression (convert test) }]
    )}
| start = GLOBAL globals = parser_generator_separated_nonempty_list_COMMA_identifier_
    {                                                                                          (
      let last = List.last_exn globals in
      let stop = (fst last).Location.stop in
      [{
        Node.location = location_create_with_stop ~start ~stop;
        value = Global (List.map globals ~f:snd);
      }]
    )}
| start = IMPORT imports = imports
    {                                       (
      [{
        Node.location = location_create_with_stop ~start ~stop:((fst imports).Location.stop);
        value = Import { Import.from = None; imports = snd imports };
      }]
    )}
| start = FROM from = from _3 = IMPORT imports = imports
    {                                                         (
      [{
        Node.location = location_create_with_stop ~start ~stop:((fst imports).Location.stop);
        value = Import {
          Import.from;
          imports = snd imports;
        };
      }]
    )}
| start = NONLOCAL nonlocals = parser_generator_separated_nonempty_list_COMMA_identifier_
    {                                                                                              (
      let stop = (fst (List.last_exn nonlocals)).Location.stop in
      [{
        Node.location = location_create_with_stop ~start ~stop;
        value = Nonlocal (List.map nonlocals ~f:snd);
      }]
    )}
| position = PASS
    {                    (
      let start, stop = position in
      [{ Node.location = Location.create ~start ~stop; value = Pass }]
    )}
| position = RAISE test = option_test_list_ raise_from = option_raise_from_
    {                                                                  (
      let start, stop = position in
      let location =
        match (test, raise_from) with
        | None, None -> Location.create ~start ~stop
        | Some node, None ->
          location_create_with_stop ~start ~stop:(Node.stop node)
        | _, Some { Node.location; _ } ->
          location_create_with_stop ~start ~stop:(location.Location.stop)
      in
      [{
        Node.location;
        value = Raise { Raise.expression = test >>| convert; from = raise_from >>| convert };
      }]
    )}
| return = RETURN test = option_test_list_
    {                                       (
      let start, stop = return in
      let location =
        match test with
        | None -> Location.create ~start ~stop
        | Some node -> location_create_with_stop ~start ~stop:(Node.stop node)
      in
      [{
        Node.location;
        value = Return { Return.expression = test >>| convert; is_implicit = false };
      }]
    )}
| delete = DELETE expression = expression_list
    {                                 (
      let stop = Node.stop expression in
      [{
        Node.location = location_create_with_stop ~start:delete ~stop;
        value = Delete (convert expression);
      }]
    )}
| yield = yield
    {                  (
      let has_from, yield = yield in
      let location = Node.location yield in
      if has_from then
        let yield =
          match yield with
          | { Node.value = Yield (Some yield); _ } ->
              let callee =
                Expression.Name (
                  Name.Attribute {
                    base = yield;
                    attribute = "__iter__";
                    special = true
                  }
                ) |> Node.create ~location
              in
              Expression.Call { callee; arguments = [] }
              |> Node.create ~location
          | _ ->
              yield
        in
        [
          {
            Node.location;
            value = YieldFrom { Node.location; value = Yield (Some (convert yield)) }
          };
        ]
      else
        [{ Node.location; value = Yield (convert yield) }]
    )}

raise_from:
  _1 = FROM test_list = test_list
    {                                ( test_list )}

compound_statement:
  definition = CLASS name = reference bases = bases colon_position = COLON body = block_or_stub_body
    {                              (
      let location = Location.create ~start:definition ~stop:colon_position in
      let body_location, body = body in
      let location = { location with Location.stop = body_location.Location.stop } in
      let name_location, name = name in
      let body =
        let rec transform_toplevel_statements = function
          | { Node.location; value = Statement.Assign assign } ->
              {
                Node.location;
                value = Statement.Assign { assign with Assign.parent = Some name };
              }
          | { Node.location; value = Define define } ->
              let signature = { define.signature with Define.Signature.parent = Some name } in
              {
                Node.location;
                value = Define { define with signature };
              }
          | {
              Node.location;
              value = If {
                If.test;
                body;
                orelse;
              };
            } ->
              {
                Node.location;
                value = If {
                  If.test;
                  body = List.map ~f:transform_toplevel_statements body;
                  orelse = List.map ~f:transform_toplevel_statements orelse;
                };
              }
          | statement ->
              statement
        in
        List.map ~f:transform_toplevel_statements body in
      {
        Node.location;
        value = Class {
          Class.name = { Node.location = name_location; value = name };
          bases = List.map ~f:convert_argument bases;
          body;
          decorators = [];
          top_level_unbound_names = [];
        };
      }
    )}
| definition = DEFINE name = reference _3 = LEFTPARENS parameters = define_parameters _5 = RIGHTPARENS return_annotation = option_return_annotation_ _7 = COLON signature_comment = option_SIGNATURE_COMMENT_ body = block_or_stub_body
    {                              (
      let body_location, body = body in
      let location =
        location_create_with_stop ~start:definition ~stop:body_location.Location.stop
      in
      let annotation =
        match return_annotation with
        | Some return_annotation -> Some return_annotation
        | None ->
          signature_comment
          >>= (fun ((start, stop), _, return_annotation) ->
              Some {
                Node.location = Location.create ~start ~stop;
                value = Expression.String (StringLiteral.create return_annotation);
              }
            )
      in
      let parameters =
        match signature_comment with
        | Some ((start, stop), parameter_annotations, _)
          when not (List.is_empty parameter_annotations) ->
            let add_annotation ({ Node.value = parameter; _ } as parameter_node) annotation =
                match annotation with
                | None ->
                    parameter_node
                | Some annotation -> {
                    parameter_node with
                    Node.value = {
                      parameter with
                        Parameter.annotation = Some {
                          Node.location = Location.create ~start ~stop;
                          value = Expression.String (StringLiteral.create annotation);
                        };
                      }
                  }
            in
            (* We don't know whether a define is a method at this point, and mypy's documentation
               specifies that a method's self should NOT be annotated:
               `https://mypy.readthedocs.io/en/latest/python2.html`.

                Because we don't know whether we are parsing a method at this point or whether
                there's any decorators that mean a function doesn't have a self parameter, we make
                the angelic assumption that annotations lacking a single annotation knowingly elided
                the self annotation. *)
            let unannotated_parameter_count =
               List.length parameters - List.length parameter_annotations
            in
            if unannotated_parameter_count = 0 || unannotated_parameter_count = 1 then
              let parameter_annotations =
                List.init ~f:(fun _ -> None) unannotated_parameter_count @
                List.map ~f:Option.some parameter_annotations
              in
              List.map2_exn
                ~f:add_annotation
                parameters
                parameter_annotations
            else
              parameters
        | _ ->
            parameters
      in
      let name_location, name = name in
      {
        Node.location;
        value = Define {
          signature = {
            name = { Node.location = name_location; value = name };
            parameters = List.map ~f:convert_parameter parameters;
            decorators = [];
            return_annotation = annotation >>| convert;
            async = false;
            generator = Ast.Statement.is_generator body;
            parent = None;
            nesting_define = None;
          };
          captures = [];
          unbound_names = [];
          body
        };
      }
    )}
| start = FOR target = expression_list _3 = IN iterator = test_list _5 = COLON _6 = option_ANNOTATION_COMMENT_ body = block orelse = named_optional_block_ELSE_
    {                                                                           (
      let stop = begin match orelse with
      | _, [] -> (fst body).Location.stop
      | location, _ -> location.Location.stop
      end in
      {
        Node.location = location_create_with_stop ~start ~stop;
        value = For {
          For.target = convert target;
          iterator = convert iterator;
          body = snd body;
          orelse = snd orelse;
          async = false
        };
      }
    )}
| start = IF value = conditional
    {                                    (
      let value_location, value = value in
      {
        Node.location = location_create_with_stop ~start ~stop:value_location.Location.stop;
        value
      }
    )}
| start = TRY _2 = COLON body = block handlers = list_handler_ orelse = named_optional_block_ELSE_ finally = named_optional_block_FINALLY_
    {                                            (
      let stop =
        begin
          match handlers, snd orelse, snd finally with
          | _, _, (_::_) -> fst finally
          | _, (_::_), [] -> fst orelse
          | (_::_), [], [] -> (fst (List.last_exn handlers))
          | _ -> (fst body)
        end.Location.stop
      in
      {
        Node.location = location_create_with_stop ~start ~stop;
        value = Try {
          Try.body = snd body;
          handlers = List.map ~f:snd handlers;
          orelse = snd orelse;
          finally = snd finally
        };
      }
    )}
| start = WITH items = parser_generator_separated_nonempty_list_COMMA_with_item_ _3 = COLON _4 = option_ANNOTATION_COMMENT_ body = block
    {                 (
      let convert_item (expression, expression_option) =
        (convert expression, expression_option >>| convert)
      in
      {
        Node.location = location_create_with_stop ~start ~stop:(fst body).Location.stop;
        value = With {
          With.items = List.map ~f:convert_item items;
          body = snd body;
          async = false;
        };
      }
    )}
| start = WHILE test = test_list _3 = COLON body = block orelse = named_optional_block_ELSE_
    {                                                      (
      let stop =
        match orelse with
        | _, [] -> (fst body).Location.stop
        | location, _ -> location.Location.stop in
      {
        Node.location = location_create_with_stop ~start ~stop;
        value = While { While.test = convert test; body = snd body; orelse = snd orelse };
      }
    )}

decorated_statement:
  decorators = nonempty_list_decorator_ statement = compound_statement
    {                                                            (
      with_decorators decorators statement
    )}
| decorators = nonempty_list_decorator_ statement = async_statement
    {                                                         (
      with_decorators decorators statement
    )}

async_statement:
  position = ASYNC statement = compound_statement
    {                                                     (
      let location = location_create_with_stop ~start:(fst position) ~stop:(Node.stop statement) in
      match statement with
      | { Node.value = Statement.Define value; _ } ->
          let signature = { value.signature with Define.Signature.async = true } in
          let decorated = { value with signature } in
          {
            Node.location;
            value = Statement.Define decorated;
          }
      | { Node.value = For value; _ } ->
          let with_async = { value with For.async = true } in
          {
            Node.location;
            value = For with_async;
          }
      | { Node.value = With value; _ } ->
          let with_async = { value with With.async = true } in
          {
            Node.location;
            value = With with_async;
          }
      | _ -> raise (ParserError "Async not supported on statement.")
    )}

block_or_stub_body:
  ellipsis = ELLIPSES _2 = NEWLINE
    {                                                                     (
    let location = Location.create ~start:(fst ellipsis) ~stop:(snd ellipsis) in
    let body = [Node.create (Statement.Expression (Node.create AstExpression.Expression.Ellipsis ~location)) ~location] in
    location, body
   )}
| _1 = nonempty_list_NEWLINE_ _2 = INDENT ellipsis = ELLIPSES _4 = NEWLINE _5 = DEDENT _6 = list_NEWLINE_
    {                                                                     (
    let location = Location.create ~start:(fst ellipsis) ~stop:(snd ellipsis) in
    let body = [Node.create (Statement.Expression (Node.create AstExpression.Expression.Ellipsis ~location)) ~location] in
    location, body
   )}
| statements = block
    {                       ( statements )}

block:
  simple_statement = simple_statement
    {                                         ( simple_statement )}
| _1 = nonempty_list_NEWLINE_ _2 = INDENT statements = statements _4 = DEDENT _5 = list_NEWLINE_
    {                                                                (
      statements
    )}

named_optional_block_ELSE_:
  
    {    ( Location.any, [] )}
| _1 = ELSE _2 = COLON block = block
    {                               ( block )}

named_optional_block_FINALLY_:
  
    {    ( Location.any, [] )}
| _1 = FINALLY _2 = COLON block = block
    {                               ( block )}

conditional:
  test = test_list _2 = COLON body = block orelse = named_optional_block_ELSE_
    {                                                      (
      {
        test.Node.location with
        Location.stop =
          match orelse with
          | _, [] -> (fst body).Location.stop
          | location, _ -> location.Location.stop;
      },
      If { If.test = convert test; body = snd body; orelse = snd orelse }
    )}
| test = test_list _2 = COLON body = block else_start = ELSEIF value = conditional
    {                                             (
      let stop = (fst value).Location.stop in
      { test.Node.location with Location.stop },
      Statement.If {
        If.test = convert test;
        body = (snd body);
        orelse = [{
          Node.location =
            location_create_with_stop ~start:else_start ~stop;
          value = snd value
        }];
      }
    )}

bases:
  
    {    ( [] )}
| _1 = LEFTPARENS bases = parser_generator_separated_list_COMMA_argument_ _3 = RIGHTPARENS
    {                                                                                      (
      bases
    )}

decorator_arguments:
  
    {    ( None )}
| _1 = LEFTPARENS arguments = arguments _3 = RIGHTPARENS
    {                                                   ( Some arguments )}

decorator:
  _1 = AT name = reference arguments = decorator_arguments _4 = nonempty_list_NEWLINE_
    {                                                                    (
      { decorator_name = { Node.location = fst name; value = snd name }; arguments }
    )}

identifier:
  identifier = IDENTIFIER
    {                            (
      let start, stop = fst identifier in
      Location.create ~start ~stop, snd identifier
    )}
| position = ASYNC
    {                     (
      Location.create ~start:(fst position) ~stop:(snd position),
      "async"
    )}

reference:
  identifiers = parser_generator_separated_nonempty_list_DOT_identifier_
    {                                                                            (
      let location =
        let (start, _) = List.hd_exn identifiers in
        let (stop, _) = List.last_exn identifiers in
        { start with Location.stop = stop.Location.stop }
      in
      let reference =
        List.map ~f:snd identifiers
        |> Reference.create_from_list
      in
      location, reference
    )}

define_parameters:
  asteriks = ASTERIKS _2 = COMMA annotation = option_comment_annotation_ parameters = define_parameters
    {let parameter =                         (
      {
        Node.location = Location.create ~start:(fst asteriks) ~stop:(snd asteriks);
        value = {
            Parameter.name = "*";
            value = None;
            annotation = None;
        };
      }
    ) in
                                   ( (with_annotation ~parameter ~annotation) :: parameters )}
| slash = SLASH _2 = COMMA annotation = option_comment_annotation_ parameters = define_parameters
    {let parameter =                   (
    {
      Node.location = Location.create ~start:slash ~stop:slash;
      value = {
          Parameter.name = "/";
          value = None;
          annotation = None;
      };
    }
  ) in
                                   ( (with_annotation ~parameter ~annotation) :: parameters )}
| expression = expression annotation_inlined1 = option_annotation_ _2 = COMMA annotation = option_comment_annotation_ parameters = define_parameters
    {let parameter =
  let annotation = annotation_inlined1 in
  let name =                             (
      let rec identifier expression =
        match expression with
        | { Node.location; value = Expression.Name (Name.Identifier identifier) } ->
            (location, identifier)
        | { Node.location; value = Starred (Starred.Once expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "*" ^ identifier
        | { Node.location; value = Starred (Starred.Twice expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "**" ^ identifier
        | _ ->
            raise (ParserError "Unexpected parameters") in
      identifier expression
    ) in
                                            (
      {
        Node.location = fst name;
        value = { Parameter.name = snd name; value = None; annotation };
      }
    )
in
                                   ( (with_annotation ~parameter ~annotation) :: parameters )}
| expression = expression annotation_inlined1 = option_annotation_ _3 = EQUALS value = test _2 = COMMA annotation = option_comment_annotation_ parameters = define_parameters
    {let parameter =
  let annotation = annotation_inlined1 in
  let name =                             (
      let rec identifier expression =
        match expression with
        | { Node.location; value = Expression.Name (Name.Identifier identifier) } ->
            (location, identifier)
        | { Node.location; value = Starred (Starred.Once expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "*" ^ identifier
        | { Node.location; value = Starred (Starred.Twice expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "**" ^ identifier
        | _ ->
            raise (ParserError "Unexpected parameters") in
      identifier expression
    ) in
                                                                  (
      {
        Node.location = fst name;
        value = { Parameter.name = snd name; value = Some value; annotation };
      }
    )
in
                                   ( (with_annotation ~parameter ~annotation) :: parameters )}
| asteriks = ASTERIKS annotation = option_comment_annotation_
    {let parameter =                         (
      {
        Node.location = Location.create ~start:(fst asteriks) ~stop:(snd asteriks);
        value = {
            Parameter.name = "*";
            value = None;
            annotation = None;
        };
      }
    ) in
                                     ( [with_annotation ~parameter ~annotation] )}
| slash = SLASH annotation = option_comment_annotation_
    {let parameter =                   (
    {
      Node.location = Location.create ~start:slash ~stop:slash;
      value = {
          Parameter.name = "/";
          value = None;
          annotation = None;
      };
    }
  ) in
                                     ( [with_annotation ~parameter ~annotation] )}
| expression = expression annotation_inlined1 = option_annotation_ annotation = option_comment_annotation_
    {let parameter =
  let annotation = annotation_inlined1 in
  let name =                             (
      let rec identifier expression =
        match expression with
        | { Node.location; value = Expression.Name (Name.Identifier identifier) } ->
            (location, identifier)
        | { Node.location; value = Starred (Starred.Once expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "*" ^ identifier
        | { Node.location; value = Starred (Starred.Twice expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "**" ^ identifier
        | _ ->
            raise (ParserError "Unexpected parameters") in
      identifier expression
    ) in
                                            (
      {
        Node.location = fst name;
        value = { Parameter.name = snd name; value = None; annotation };
      }
    )
in
                                     ( [with_annotation ~parameter ~annotation] )}
| expression = expression annotation_inlined1 = option_annotation_ _3 = EQUALS value = test annotation = option_comment_annotation_
    {let parameter =
  let annotation = annotation_inlined1 in
  let name =                             (
      let rec identifier expression =
        match expression with
        | { Node.location; value = Expression.Name (Name.Identifier identifier) } ->
            (location, identifier)
        | { Node.location; value = Starred (Starred.Once expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "*" ^ identifier
        | { Node.location; value = Starred (Starred.Twice expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "**" ^ identifier
        | _ ->
            raise (ParserError "Unexpected parameters") in
      identifier expression
    ) in
                                                                  (
      {
        Node.location = fst name;
        value = { Parameter.name = snd name; value = Some value; annotation };
      }
    )
in
                                     ( [with_annotation ~parameter ~annotation] )}
| 
    {    ( [] )}

with_item:
  resource = test
    {                    ( resource, None )}
| resource = test _2 = AS target = expression
    {                                             ( resource, Some target )}

handler:
  start = EXCEPT _2 = COLON handler_body = block
    {                                                (
      location_create_with_stop ~start ~stop:(fst handler_body).Location.stop,
      { Try.Handler.kind = None; name = None; body = snd handler_body }
    )}
| start = EXCEPT kind = expression _3 = COLON handler_body = block
    {                                                                   (
      location_create_with_stop ~start ~stop:(fst handler_body).Location.stop,
      { Try.Handler.kind = Some kind >>| convert; name = None; body = snd handler_body }
    )}
| start = EXCEPT kind = expression _3 = AS name = identifier _5 = COLON handler_body = block
    {                                (
      location_create_with_stop ~start ~stop:(fst handler_body).Location.stop,
      { Try.Handler.kind = Some kind >>| convert; name = Some (snd name); body = snd handler_body }
    )}
| start = EXCEPT kind = expression _3 = COMMA name = identifier _5 = COLON handler_body = block
    {                                (
      location_create_with_stop ~start ~stop:(fst handler_body).Location.stop,
      { Try.Handler.kind = Some kind >>| convert; name = Some (snd name); body = snd handler_body }
    )}
| start = EXCEPT kind = or_test _3 = COLON handler_body = block
    {                                                (
      location_create_with_stop ~start ~stop:(fst handler_body).Location.stop,
      { Try.Handler.kind = Some kind >>| convert; name = None; body = snd handler_body }
    )}
| start = EXCEPT kind = or_test _3 = AS name = identifier _5 = COLON handler_body = block
    {                                (
      location_create_with_stop ~start ~stop:(fst handler_body).Location.stop,
      { Try.Handler.kind = Some kind >>| convert; name = Some (snd name); body = snd handler_body }
    )}

from:
  from = from_string
    {                       (
      { Node.location = fst from; value = Reference.create (snd from) }
      |> Option.some
    )}

from_string:
  identifier = identifier
    {                            (
      identifier
  )}
| identifier = identifier from_string = from_string
    {                                                       (
      let location =
        { (fst identifier) with Location.stop = (fst from_string).Location.stop }
      in
      location, (snd identifier) ^ (snd from_string)
    )}
| relative = nonempty_list_ellipsis_or_dot_
    {                                              (
      let location =
        Location.create
          ~start:(fst (fst (List.hd_exn relative)))
          ~stop:(snd (fst (List.last_exn relative)))
      in
      location, String.concat (List.map ~f:snd relative)
    )}
| relative = nonempty_list_ellipsis_or_dot_ from_string = from_string
    {                              (
      let location =
        location_create_with_stop
          ~start:(fst (fst (List.hd_exn relative)))
          ~stop:((fst from_string).Location.stop)
      in
      location, (String.concat (List.map ~f:snd relative)) ^ (snd from_string)
    )}

ellipsis_or_dot:
  position = DOT
    {                   (
      position, "."
    )}
| position = ELLIPSES
    {                        (
      position, "..."
    )}

imports:
  imports = parser_generator_separated_nonempty_list_COMMA_import_
    {                                                                      (
      let location =
        let (start, _) = List.hd_exn imports in
        let (stop, _) = List.last_exn imports in
        { start with Location.stop = stop.Location.stop }
      in
      location, List.map ~f:snd imports
    )}
| start = LEFTPARENS imports = parser_generator_separated_nonempty_list_COMMA_import_ stop = RIGHTPARENS
    {                       (
      (Location.create ~start ~stop),
      List.map ~f:snd imports
    )}

import:
  position = ASTERIKS
    {                        (
      let location =
        let start, stop = position in
        Location.create ~start ~stop
      in
      location,
      {
        Import.name = { Node.location; value = Reference.create "*" };
        alias = None;
      }
    )}
| name = reference
    {                     (
      fst name,
      {
        Import.name = { Node.location = fst name; value = snd name };
        alias = None;
      }
    )}
| name = reference _2 = AS alias = identifier
    {                           (
      {(fst name) with Location.stop = (fst alias).Location.stop},
      {
        Import.name = { Node.location = fst name; value = snd name };
        alias = Some { Node.location = fst alias; value = snd alias };
      }
    )}

targets:
  target = test_list _2 = EQUALS
    {let target =                        (
      let assignment_with_annotation ~value ~annotation =
        {
          Node.location = {
            target.Node.location with Location.stop =
              value.Node.location.Location.stop;
          };
          value = Statement.Assign {
            Assign.target = convert target;
            annotation = annotation >>| convert;
            value = convert value;
            parent = None;
          };
        }
      in
      assignment_with_annotation
    ) in
                            ( [target] )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _2 = EQUALS
    {let target =
  let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                            ( subscript_mutation ~subscript )
in
                            ( [target] )}
| targets = targets target = test_list _3 = EQUALS
    {let target =                        (
      let assignment_with_annotation ~value ~annotation =
        {
          Node.location = {
            target.Node.location with Location.stop =
              value.Node.location.Location.stop;
          };
          value = Statement.Assign {
            Assign.target = convert target;
            annotation = annotation >>| convert;
            value = convert value;
            parent = None;
          };
        }
      in
      assignment_with_annotation
    ) in
                                               ( targets @ [target] )}
| targets = targets head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET _3 = EQUALS
    {let target =
  let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                            ( subscript_mutation ~subscript )
in
                                               ( targets @ [target] )}

value:
  test = test_list
    {                     ( test )}
| yield = yield
    {                  ( snd yield )}

atom:
  identifier = identifier
    {                            (
      {
        Node.location = fst identifier;
        value = Name (Name.Identifier (snd identifier));
      }
    )}
| ellipsis = ELLIPSES
    {                        (
      let location = Location.create ~start:(fst ellipsis) ~stop:(snd ellipsis) in
      Node.create Expression.Ellipsis ~location
    )}
| left = expression _1 = PLUS right = expression
    {let operator =          ( Add ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| left = expression _1 = AT right = expression
    {let operator =        ( At ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| left = expression _1 = AMPERSAND right = expression
    {let operator =               ( BitAnd ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| left = expression _1 = BAR right = expression
    {let operator =         ( BitOr ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| left = expression _1 = HAT right = expression
    {let operator =         ( BitXor ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| left = expression _1 = SLASH _2 = SLASH right = expression
    {let operator =                  ( FloorDivide ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| left = expression _1 = SLASH right = expression
    {let operator =           ( Divide ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| left = expression _1 = LEFTANGLELEFTANGLE right = expression
    {let operator =                        ( LeftShift ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| left = expression _1 = PERCENT right = expression
    {let operator =             ( Modulo ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| left = expression _1 = ASTERIKS _2 = ASTERIKS right = expression
    {let operator =                        ( Power ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| left = expression _1 = ASTERIKS right = expression
    {let operator =              ( Multiply ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| left = expression _1 = RIGHTANGLERIGHTANGLE right = expression
    {let operator =                          ( RightShift ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| left = expression _1 = MINUS right = expression
    {let operator =           ( Subtract ) in
                        (
      binary_operator ~compound:false ~left ~operator ~right
    )}
| bytes = nonempty_list_BYTES_
    {                   (
      let (start, stop), _, _ = List.hd_exn bytes in
      {
        Node.location = Location.create ~start ~stop;
        value = String (
          StringLiteral.create
            ~bytes:true
            (String.concat (List.map bytes ~f:(fun (_, _, value) -> value)))
        );
      }
    )}
| format = FORMAT mixed_string = mixed_string
    {                                                 (
      let all_strings = create_substring AstExpression.Substring.Format format :: mixed_string in
      let all_pieces = List.map all_strings ~f:snd in
      let (head, _), (last, _) = List.hd_exn all_strings, List.last_exn all_strings in
      let (start, _) = head in
      let (_, stop) = last in
      {
        Node.location = Location.create ~start ~stop;
        value = String (StringLiteral.create_mixed all_pieces);
      }
    )}
| name = expression start = LEFTPARENS arguments = arguments stop = RIGHTPARENS
    {                       (
      let call_location = Location.create ~start ~stop in
      Expression.Call { callee = name; arguments }
      |> Node.create
        ~location:({ name.Node.location with Location.stop = call_location.Location.stop })
    )}
| set_or_dictionary = set_or_dictionary
    {                                          (
      set_or_dictionary
    )}
| position = FALSE
    {                     (
      let start, stop = position in
      {
        Node.location = Location.create ~start ~stop;
        value = Expression.False;
      }
    )}
| number = COMPLEX
    {                     (
      let start, stop = fst number in
      {
        Node.location = Location.create ~start ~stop;
        value = Expression.Complex (snd number);
      }
    )}
| number = FLOAT
    {                   (
      let start, stop = fst number in
      {
        Node.location = Location.create ~start ~stop;
        value = Expression.Float (snd number);
      }
    )}
| number = INTEGER
    {                     (
      let start, stop = fst number in
      {
        Node.location = Location.create ~start ~stop;
        value = Expression.Integer (snd number);
      }
    )}
| start = LEFTBRACKET items = parser_generator_separated_list_COMMA_test_ stop = RIGHTBRACKET
    {                        (
      {
        Node.location = Location.create ~start ~stop;
        value = Expression.List items;
      }
    )}
| start = LEFTBRACKET element = test generators = nonempty_list_comprehension_ stop = RIGHTBRACKET
    {                        (
      {
        Node.location = Location.create ~start ~stop;
        value = Expression.ListComprehension { Comprehension.element; generators };
      }
    )}
| start = LEFTCURLY element = test generators = nonempty_list_comprehension_ stop = RIGHTCURLY
    {                      (
      {
        Node.location = Location.create ~start ~stop;
        value = Expression.SetComprehension { Comprehension.element; generators };
      }
    )}
| position = ASTERIKS test = expression
    {                                           (
    let start, _ = position in
    let location = location_create_with_stop ~start ~stop:(Node.stop test) in
    match test with
    | {
        Node.value = Starred (Starred.Once test);
        _;
      } -> {
        Node.location;
        value = Starred (Starred.Twice test);
      }
    | _ -> {
        Node.location;
        value = Starred (Starred.Once test);
      }
    )}
| string = STRING mixed_string = mixed_string
    {                                                 (
      let all_strings = create_substring AstExpression.Substring.Literal string :: mixed_string in
      let all_pieces = List.map all_strings ~f:snd in
      let (head, _), (last, _) = List.hd_exn all_strings, List.last_exn all_strings in
      let (start, _) = head in
      let (_, stop) = last in
      {
        Node.location = Location.create ~start ~stop;
        value = String (StringLiteral.create_mixed all_pieces);
      }
    )}
| position = TRUE
    {                    (
      let start, stop = position in
      { Node.location = Location.create ~start ~stop; value = True }
    )}
| position = TILDE operand = expression
    {let operator =                      ( position, AstExpression.UnaryOperator.Invert ) in
                                                    (
      let start, operator = operator in
      let { Node.value; _ } = operand in
      let location = location_create_with_stop ~start ~stop:(Node.stop operand)
      in
      match operator, value with
      | AstExpression.UnaryOperator.Negative, Integer literal -> {
        Node.location;
        value = Integer (-1 * literal);
      }
      | _, _ -> {
        Node.location;
        value = UnaryOperator {
          UnaryOperator.operator = operator;
          operand;
        };
      }
    )}
| position = MINUS operand = expression
    {let operator =                      ( position, AstExpression.UnaryOperator.Negative ) in
                                                    (
      let start, operator = operator in
      let { Node.value; _ } = operand in
      let location = location_create_with_stop ~start ~stop:(Node.stop operand)
      in
      match operator, value with
      | AstExpression.UnaryOperator.Negative, Integer literal -> {
        Node.location;
        value = Integer (-1 * literal);
      }
      | _, _ -> {
        Node.location;
        value = UnaryOperator {
          UnaryOperator.operator = operator;
          operand;
        };
      }
    )}
| position = NOT operand = expression
    {let operator =                    ( position, AstExpression.UnaryOperator.Not ) in
                                                    (
      let start, operator = operator in
      let { Node.value; _ } = operand in
      let location = location_create_with_stop ~start ~stop:(Node.stop operand)
      in
      match operator, value with
      | AstExpression.UnaryOperator.Negative, Integer literal -> {
        Node.location;
        value = Integer (-1 * literal);
      }
      | _, _ -> {
        Node.location;
        value = UnaryOperator {
          UnaryOperator.operator = operator;
          operand;
        };
      }
    )}
| position = PLUS operand = expression
    {let operator =                     ( position, AstExpression.UnaryOperator.Positive ) in
                                                    (
      let start, operator = operator in
      let { Node.value; _ } = operand in
      let location = location_create_with_stop ~start ~stop:(Node.stop operand)
      in
      match operator, value with
      | AstExpression.UnaryOperator.Negative, Integer literal -> {
        Node.location;
        value = Integer (-1 * literal);
      }
      | _, _ -> {
        Node.location;
        value = UnaryOperator {
          UnaryOperator.operator = operator;
          operand;
        };
      }
    )}

expression:
  atom = atom
    {                ( atom )}
| start = LEFTPARENS stop = RIGHTPARENS
    {                                           (
      {
        Node.location = Location.create ~start ~stop;
        value = Tuple [];
      }
    )}
| start = LEFTPARENS test = test_list stop = RIGHTPARENS
    {                                                             (
      {
        Node.location = Location.create ~start ~stop;
        value = Parenthesis test;
      }
    )}
| expression = expression _2 = DOT identifier = identifier
    {                                                          (
      let location =
        { expression.Node.location with Location.stop = Location.stop (fst identifier) }
      in
      {
        Node.location;
        value = Name (
          Name.Attribute { base = expression; attribute = snd identifier; special = false }
        )
      }
    )}
| head = expression left = LEFTBRACKET subscripts = parser_generator_separated_nonempty_list_COMMA_subscript_key_ right = RIGHTBRACKET
    {let subscript =                          (
      head, subscripts, Location.create ~start:left ~stop:right
    ) in
                          ( subscript_access subscript )}
| start = AWAIT expression = expression
    {                                           (
      {
        Node.location = location_create_with_stop ~start ~stop:(Node.stop expression);
        value = Await expression;
      }
    )}
| _1 = LEFTPARENS generator = generator _3 = RIGHTPARENS
    {                                                   ( generator )}
| _1 = LEFTPARENS yield = yield _3 = RIGHTPARENS
    {                                          ( snd yield )}

expression_list:
  items = separated_nonempty_list_indicator_COMMA_expression_
    {                                                                 (
      match items with
      | head::[], has_trailing_comma ->
          if has_trailing_comma then
            {
              Node.location = head.Node.location;
              value = Tuple [head];
            }
          else head
      | (head :: _) as items, _ ->
          let last = List.last_exn items in
          {
            Node.location = { head.Node.location with Location.stop = Node.stop last };
            value = Tuple items;
          }
      | _ -> raise (ParserError "invalid atom")
    )}

mixed_string:
  
    {    ( [] )}
| first_string = FORMAT rest = mixed_string
    {                                               (
      create_substring AstExpression.Substring.Format first_string :: rest
    )}
| first_string = STRING rest = mixed_string
    {                                               (
      create_substring AstExpression.Substring.Literal first_string :: rest
    )}

comparison:
  expression = expression
    {                            ( expression )}
| left = expression comparisons = nonempty_list_comparison_operator_
    {                                                                        (
      let rec comparison ({ Node.location; _ } as left) comparisons =
        match comparisons with
        | (operator, right) :: comparisons when List.length comparisons > 0 ->
            let left =
              Expression.ComparisonOperator { ComparisonOperator.left; operator; right }
              |> Node.create ~location:({ location with Location.stop = Node.stop right })
            in
            let right = comparison right comparisons in
            Expression.BooleanOperator {
              BooleanOperator.left;
              operator = AstExpression.BooleanOperator.And;
              right;
            }
            |> Node.create ~location;
        | [operator, right] ->
            Expression.ComparisonOperator { ComparisonOperator.left; operator; right }
            |> Node.create ~location:({ location with Location.stop = Node.stop right })
        | _ ->
            failwith "The parser is a lie! Did not get a non-empty comparison list."
      in
      comparison left comparisons
    )}

not_test:
  comparison = comparison
    {                            ( comparison )}
| start = NOT not_test = not_test
    {                                     (
      let location = location_create_with_stop ~start ~stop:(Node.stop not_test) in
      {
        Node.location;
        value = UnaryOperator {
          UnaryOperator.operator = AstExpression.UnaryOperator.Not;
          operand = not_test;
        }
      }
  )}

and_test:
  not_test = not_test
    {                        ( not_test )}
| left = not_test _2 = AND right = and_test
    {                                           (
      let location = { (Node.location left) with Location.stop = Node.stop right } in
      {
        Node.location;
        value = BooleanOperator {
          BooleanOperator.left;
          operator = AstExpression.BooleanOperator.And;
          right;
        }
      }
   )}

or_test:
  and_test = and_test
    {                        ( and_test )}
| left = and_test _2 = OR right = or_test
    {                                         (
      let location = { (Node.location left) with Location.stop = Node.stop right } in
      {
        Node.location;
        value = BooleanOperator {
          BooleanOperator.left;
          operator = AstExpression.BooleanOperator.Or;
          right;
        }
      }
   )}

test_with_generator:
  generator = generator
    {                          ( generator )}
| test = test
    {                ( test )}

test:
  or_test = or_test
    {                      ( or_test )}
| target = identifier _2 = COLONEQUALS value = test
    {                                                   (
      {
        Node.location = { (fst target) with Location.stop = Node.stop value };
        value = Expression.WalrusOperator {
          target =
            Expression.Name (Name.Identifier (snd target))
            |> Node.create ~location:(fst target);
          value = value;
        }
      }
    )}
| target = or_test _2 = IF test = test_list _4 = ELSE alternative = test
    {                       (
      {
        Node.location = { target.Node.location with Location.stop = Node.stop alternative };
        value = Expression.Ternary { Ternary.target; test; alternative };
      }
    )}
| start = LAMBDA parameters = parser_generator_separated_list_COMMA_lambda_parameter_ _3 = COLON body = test
    {                (
      {
        Node.location =  location_create_with_stop ~start ~stop:(Node.stop body);
        value = Expression.Lambda { Lambda.parameters; body }
      }
    )}

test_list:
  items = separated_nonempty_list_indicator_COMMA_test_
    {                                                           (
      match items with
      | head :: [], has_trailing_comma ->
        if has_trailing_comma then
          {
            Node.location = head.Node.location;
            value = Expression.Tuple [head];
          }
        else
          head
      | (head :: _ as items), _ ->
          let last = List.last_exn items in
          {
            Node.location = { head.Node.location with Location.stop = Node.stop last };
            value = Expression.Tuple items;
          }
      | _ -> raise (ParserError "invalid atom")
    )}

yield:
  position = YIELD has_from = option_FROM_ test = option_test_list_
    {                                                           (
      let start, stop = position in
      let location =
        Option.map
         ~f:(fun test -> location_create_with_stop ~start ~stop:(Node.stop test))
         test
        |> Option.value ~default:(Location.create ~start ~stop)
      in
      Option.is_some has_from,
      {
        Node.location;
        value = Expression.Yield test;
      }
    )}

comparison_operator:
  _1 = DOUBLEEQUALS operand = expression
    {                                       ( AstExpression.ComparisonOperator.Equals, operand )}
| _1 = RIGHTANGLE operand = expression
    {                                     ( AstExpression.ComparisonOperator.GreaterThan, operand )}
| _1 = RIGHTANGLEEQUALS operand = expression
    {                                           (
      AstExpression.ComparisonOperator.GreaterThanOrEquals, operand
    )}
| _1 = IN operand = expression
    {                             ( AstExpression.ComparisonOperator.In, operand )}
| _1 = IS operand = expression
    {                             ( AstExpression.ComparisonOperator.Is, operand )}
| _1 = ISNOT operand = expression
    {                                ( AstExpression.ComparisonOperator.IsNot, operand )}
| _1 = LEFTANGLE operand = expression
    {                                    ( AstExpression.ComparisonOperator.LessThan, operand )}
| _1 = LEFTANGLEEQUALS operand = expression
    {                                          (
      AstExpression.ComparisonOperator.LessThanOrEquals, operand
    )}
| _1 = EXCLAMATIONMARK _2 = EQUALS operand = expression
    {                                                  (
      AstExpression.ComparisonOperator.NotEquals, operand
    )}
| _1 = NOT _2 = IN operand = expression
    {                                  ( AstExpression.ComparisonOperator.NotIn, operand )}

arguments:
  arguments = parser_generator_separated_list_COMMA_argument_
    {                                                                 ( arguments )}
| test = test_with_generator
    {                               ( [{ Call.Argument.name = None; value = test }] )}
| test = generator _2 = COMMA
    {                            ( [{ Call.Argument.name = None; value = test }] )}

argument:
  identifier = identifier _2 = EQUALS value = test
    {                                                  (
      {
        Call.Argument.name = Some { Node.location = fst identifier; value = snd identifier };
        value;
      }
    )}
| value = test
    {                 ( { Call.Argument.name = None; value } )}

subscript_key:
  index = test
    {                 ( index )}
| lower = option_test_ bound_colon = COLON upper = option_test_
    {                                                      (
      slice ~lower ~upper ~step:None ~bound_colon ~step_colon:None
    )}
| lower = option_test_ bound_colon = COLON upper = option_test_ step_colon = COLON step = option_test_
    {                                                                                        (
      slice ~lower ~upper ~step ~bound_colon ~step_colon:(Some step_colon)
    )}

set_or_dictionary_entry:
  test = test
    {                (
      match test with
      | { Node.value = Starred (Starred.Twice keywords); _ } ->
          Keywords keywords
      | _ ->
          Item test
    )}
| key = test _2 = COLON value = test
    {                                    (
      Entry { Dictionary.Entry.key = key; value = value; }
    )}

set_or_dictionary_maker:
  entry = set_or_dictionary_entry
    {                                    (
      add_entry { entries = []; comprehensions = []; items = []; keywords = [] } entry
    )}
| items = set_or_dictionary_maker _2 = COMMA entry = set_or_dictionary_entry
    {                                                                            (
      add_entry items entry
    )}
| items = set_or_dictionary_maker comprehension = comprehension
    {                                                                   (
      add_entry items (Comprehension comprehension)
    )}

set_or_dictionary:
  start = LEFTCURLY stop = RIGHTCURLY
    {                                         (
      {
        Node.location = Location.create ~start ~stop;
        value = Dictionary { Dictionary.entries = []; keywords = [] };
      }
    )}
| start = LEFTCURLY items = set_or_dictionary_maker _3 = option_COMMA_ stop = RIGHTCURLY
    {                                                                                  (
      let value =
        match items with
        | { entries; keywords; comprehensions = []; items = [] } ->
             Expression.Dictionary { Dictionary.entries = List.rev entries; keywords = List.rev keywords }
        | { entries = [entry]; keywords = []; items = []; comprehensions  } ->
              Expression.DictionaryComprehension {
                Comprehension.element = entry;
                generators = List.rev comprehensions;
              }
        | { items; entries = []; comprehensions = []; keywords = [] } ->
               Expression.Set (List.rev items)
        | { items = [item]; comprehensions; keywords = []; entries = [] } ->
             Expression.SetComprehension {
               Comprehension.element = item;
               generators = List.rev comprehensions;
             }
        | _ -> failwith "Invalid dictionary or set"
      in
      { Node.location = Location.create ~start ~stop; value }
    )}

generator:
  element = test generators = nonempty_list_comprehension_
    {                                                (
      let stop =
        let { Comprehension.Generator.iterator; conditions; _ } = List.last_exn generators in
        match List.rev conditions with
        | [] -> Node.stop iterator
        | condition :: _ -> Node.stop condition
      in
      {
        Node.location = { element.Node.location with Location.stop };
        value = Expression.Generator { Comprehension.element; generators };
      }
    )}

comprehension:
  _1 = ASYNC _2 = FOR target = expression_list _4 = IN iterator = or_test conditions = list_condition_
    {                                 (
      { Comprehension.Generator.target; iterator; conditions; async = true }
    )}
| _1 = FOR target = expression_list _3 = IN iterator = or_test conditions = list_condition_
    {                                 (
      { Comprehension.Generator.target; iterator; conditions; async = false }
    )}

condition:
  _1 = IF test = or_test
    {                       ( test )}

parser_generator_separated_list_COMMA_argument_:
  
    {    ( [] )}
| item = argument
    {                ( [item] )}
| item = argument _2 = COMMA rest = parser_generator_separated_list_COMMA_argument_
    {                                                                                    (
      item::rest
    )}

parser_generator_separated_list_COMMA_identifier_:
  
    {    ( [] )}
| item = identifier
    {                ( [item] )}
| item = identifier _2 = COMMA rest = parser_generator_separated_list_COMMA_identifier_
    {                                                                                    (
      item::rest
    )}

parser_generator_separated_list_COMMA_import_:
  
    {    ( [] )}
| item = import
    {                ( [item] )}
| item = import _2 = COMMA rest = parser_generator_separated_list_COMMA_import_
    {                                                                                    (
      item::rest
    )}

parser_generator_separated_list_COMMA_lambda_parameter_:
  
    {    ( [] )}
| asteriks = ASTERIKS
    {let item =                         (
      {
        Node.location = Location.create ~start:(fst asteriks) ~stop:(snd asteriks);
        value = {
            Parameter.name = "*";
            value = None;
            annotation = None;
        };
      }
    ) in
                ( [item] )}
| expression = expression
    {let item =
  let name =                             (
      let rec identifier expression =
        match expression with
        | { Node.location; value = Expression.Name (Name.Identifier identifier) } ->
            (location, identifier)
        | { Node.location; value = Starred (Starred.Once expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "*" ^ identifier
        | { Node.location; value = Starred (Starred.Twice expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "**" ^ identifier
        | _ ->
            raise (ParserError "Unexpected parameters") in
      identifier expression
    ) in
                  (
      {
        Node.location = fst name;
        value = { Parameter.name = snd name; value = None; annotation = None }
      }
    )
in
                ( [item] )}
| expression = expression _2 = EQUALS value = test
    {let item =
  let name =                             (
      let rec identifier expression =
        match expression with
        | { Node.location; value = Expression.Name (Name.Identifier identifier) } ->
            (location, identifier)
        | { Node.location; value = Starred (Starred.Once expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "*" ^ identifier
        | { Node.location; value = Starred (Starred.Twice expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "**" ^ identifier
        | _ ->
            raise (ParserError "Unexpected parameters") in
      identifier expression
    ) in
                                        (
      {
        Node.location = { (fst name) with Location.stop = value.Node.location.Location.stop };
        value = { Parameter.name = snd name; value = Some value; annotation = None};
      }
    )
in
                ( [item] )}
| asteriks = ASTERIKS _2 = COMMA rest = parser_generator_separated_list_COMMA_lambda_parameter_
    {let item =                         (
      {
        Node.location = Location.create ~start:(fst asteriks) ~stop:(snd asteriks);
        value = {
            Parameter.name = "*";
            value = None;
            annotation = None;
        };
      }
    ) in
                                                                                    (
      item::rest
    )}
| expression = expression _2 = COMMA rest = parser_generator_separated_list_COMMA_lambda_parameter_
    {let item =
  let name =                             (
      let rec identifier expression =
        match expression with
        | { Node.location; value = Expression.Name (Name.Identifier identifier) } ->
            (location, identifier)
        | { Node.location; value = Starred (Starred.Once expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "*" ^ identifier
        | { Node.location; value = Starred (Starred.Twice expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "**" ^ identifier
        | _ ->
            raise (ParserError "Unexpected parameters") in
      identifier expression
    ) in
                  (
      {
        Node.location = fst name;
        value = { Parameter.name = snd name; value = None; annotation = None }
      }
    )
in
                                                                                    (
      item::rest
    )}
| expression = expression _2_inlined1 = EQUALS value = test _2 = COMMA rest = parser_generator_separated_list_COMMA_lambda_parameter_
    {let item =
  let name =                             (
      let rec identifier expression =
        match expression with
        | { Node.location; value = Expression.Name (Name.Identifier identifier) } ->
            (location, identifier)
        | { Node.location; value = Starred (Starred.Once expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "*" ^ identifier
        | { Node.location; value = Starred (Starred.Twice expression) } ->
            location,
            identifier expression
            |> snd
            |> fun identifier -> "**" ^ identifier
        | _ ->
            raise (ParserError "Unexpected parameters") in
      identifier expression
    ) in
                                        (
      {
        Node.location = { (fst name) with Location.stop = value.Node.location.Location.stop };
        value = { Parameter.name = snd name; value = Some value; annotation = None};
      }
    )
in
                                                                                    (
      item::rest
    )}

parser_generator_separated_list_COMMA_subscript_key_:
  
    {    ( [] )}
| item = subscript_key
    {                ( [item] )}
| item = subscript_key _2 = COMMA rest = parser_generator_separated_list_COMMA_subscript_key_
    {                                                                                    (
      item::rest
    )}

parser_generator_separated_list_COMMA_test_:
  
    {    ( [] )}
| item = test
    {                ( [item] )}
| item = test _2 = COMMA rest = parser_generator_separated_list_COMMA_test_
    {                                                                                    (
      item::rest
    )}

parser_generator_separated_list_COMMA_with_item_:
  
    {    ( [] )}
| item = with_item
    {                ( [item] )}
| item = with_item _2 = COMMA rest = parser_generator_separated_list_COMMA_with_item_
    {                                                                                    (
      item::rest
    )}

parser_generator_separated_list_DOT_identifier_:
  
    {    ( [] )}
| item = identifier
    {                ( [item] )}
| item = identifier _2 = DOT rest = parser_generator_separated_list_DOT_identifier_
    {                                                                                    (
      item::rest
    )}

separated_nonempty_list_indicator_tail_COMMA_expression_:
  
    {    ( [], false )}
| _1 = COMMA
    {              ( [], true )}
| _1 = COMMA item = expression rest = separated_nonempty_list_indicator_tail_COMMA_expression_
    {                                                                                           (
      let rest, has_trailing = rest in
      item :: rest, has_trailing
    )}

separated_nonempty_list_indicator_tail_COMMA_test_:
  
    {    ( [], false )}
| _1 = COMMA
    {              ( [], true )}
| _1 = COMMA item = test rest = separated_nonempty_list_indicator_tail_COMMA_test_
    {                                                                                           (
      let rest, has_trailing = rest in
      item :: rest, has_trailing
    )}

separated_nonempty_list_indicator_COMMA_expression_:
  item = expression rest = separated_nonempty_list_indicator_tail_COMMA_expression_
    {                                                                                (
      let rest, has_trailing = rest in
      item :: rest, has_trailing
    )}

separated_nonempty_list_indicator_COMMA_test_:
  item = test rest = separated_nonempty_list_indicator_tail_COMMA_test_
    {                                                                                (
      let rest, has_trailing = rest in
      item :: rest, has_trailing
    )}

parser_generator_separated_nonempty_list_COMMA_identifier_:
  item = identifier
    {                ( [item] )}
| item = identifier _2 = COMMA rest = parser_generator_separated_list_COMMA_identifier_
    {                                                                                    (
      item::rest
    )}

parser_generator_separated_nonempty_list_COMMA_import_:
  item = import
    {                ( [item] )}
| item = import _2 = COMMA rest = parser_generator_separated_list_COMMA_import_
    {                                                                                    (
      item::rest
    )}

parser_generator_separated_nonempty_list_COMMA_subscript_key_:
  item = subscript_key
    {                ( [item] )}
| item = subscript_key _2 = COMMA rest = parser_generator_separated_list_COMMA_subscript_key_
    {                                                                                    (
      item::rest
    )}

parser_generator_separated_nonempty_list_COMMA_with_item_:
  item = with_item
    {                ( [item] )}
| item = with_item _2 = COMMA rest = parser_generator_separated_list_COMMA_with_item_
    {                                                                                    (
      item::rest
    )}

parser_generator_separated_nonempty_list_DOT_identifier_:
  item = identifier
    {                ( [item] )}
| item = identifier _2 = DOT rest = parser_generator_separated_list_DOT_identifier_
    {                                                                                    (
      item::rest
    )}

parser_generator_separated_list_of_lists_SEMICOLON_small_statement_:
  
    {    ( [] )}
| list_item = small_statement
    {                          ( [list_item] )}
| list_item = small_statement _2 = SEMICOLON rest = parser_generator_separated_list_of_lists_SEMICOLON_small_statement_
    {                                                                          (
      list_item::rest
    )}

parser_generator_separated_nonempty_list_of_lists_SEMICOLON_small_statement_:
  list_item = small_statement
    {                          ( [list_item] )}
| list_item = small_statement _2 = SEMICOLON rest = parser_generator_separated_list_of_lists_SEMICOLON_small_statement_
    {                                                                          (
      list_item::rest
    )}

%%
