%{
open Rdf_sparql_types;;

let mk_loc start stop =
  { loc_start = start ;
    loc_end = stop ;
  }
;;

let mk_lit = Rdf_term.mk_literal ;;
let xsd_integer = Rdf_rdf.xsd_integer;;
let xsd_double = Rdf_rdf.xsd_double;;
let xsd_decimal = Rdf_rdf.xsd_decimal;;
let xsd_boolean = Rdf_rdf.xsd_boolean;;

let mk_integer = mk_lit ~typ: xsd_integer;;
let mk_decimal = mk_lit ~typ: xsd_decimal;;
let mk_double = mk_lit ~typ: xsd_double;;
let mk_boolean = mk_lit ~typ: xsd_boolean;;

%}
%start query
%token A
%token ABS
%token AMPAMP
%token ANON
%token AS
%token ASC
%token ASK
%token AVG
%token BANG
%token BASE
%token BIND
%token BNODE
%token BOUND
%token BY
%token <string> Blank_node_label
%token <string> Boolean
%token CEIL
%token COALESCE
%token COMMA
%token CONCAT
%token CONSTRUCT
%token CONTAINS
%token COUNT
%token DATATYPE
%token DAY
%token DESC
%token DESCRIBE
%token DISTINCT
%token DOT
%token <string> Decimal
%token <string> Decimal_negative
%token <string> Decimal_positive
%token <string> Double
%token <string> Double_negative
%token <string> Double_positive
%token ENCODE_FOR_URI
%token EOF
%token EQUAL
%token EXISTS
%token FILTER
%token FLOOR
%token FROM
%token GRAPH
%token GROUP
%token GROUP_CONCAT
%token GT
%token GTE
%token HAT
%token HATHAT
%token HAVING
%token HOURS
%token IF
%token IN
%token IRI
%token ISBLANK
%token ISIRI
%token ISLITERAL
%token ISNUMERIC
%token ISURI
%token <string> Integer
%token <string> Integer_negative
%token <string> Integer_positive
%token <Rdf_sparql_types.rel_iri> Iriref_
%token LANG
%token LANGMATCHES
%token LBRACE
%token LBRACKET
%token LCASE
%token LIMIT
%token LPAR
%token LT
%token LTE
%token <string> Langtag
%token MAX
%token MD5
%token MIN
%token MINUS
%token MINUTES
%token MONTH
%token NAMED
%token NIL
%token NOT
%token NOTEQUAL
%token NOW
%token OFFSET
%token OPTIONAL
%token ORDER
%token PIPE
%token PIPEPIPE
%token PLUS
%token PREFIX
%token <Rdf_sparql_types.prefixed_name> Pname_ln
%token <Rdf_sparql_types.pname_ns> Pname_ns
%token QM
%token RAND
%token RBRACE
%token RBRACKET
%token REDUCED
%token REGEX
%token REPLACE
%token ROUND
%token RPAR
%token SAMETERM
%token SAMPLE
%token SECONDS
%token SELECT
%token SEMICOLON
%token SEPARATOR
%token SERVICE
%token SHA1
%token SHA256
%token SHA384
%token SHA512
%token SILENT
%token SLASH
%token STAR
%token STR
%token STRAFTER
%token STRBEFORE
%token STRDT
%token STRENDS
%token STRLANG
%token STRLEN
%token STRSTARTS
%token STRUUID
%token SUBSTR
%token SUM
%token <string> String_literal
%token TIMEZONE
%token TZ
%token UCASE
%token UNDEF
%token UNION
%token URI
%token UUID
%token VALUES
%token <string> Var1
%token <string> Var2
%token WHERE
%token YEAR
%left AMPAMP
%left PIPEPIPE
%nonassoc EQUAL GT GTE IN LT LTE NOT NOTEQUAL
%left MINUS PLUS
%left SLASH STAR
%nonassoc BANG
%type <Rdf_sparql_types.query> query
%%

option_DISTINCT_:
  
    {    ( None )}
| x = DISTINCT
    {    ( Some x )}

option_DOT_:
  
    {    ( None )}
| x = DOT
    {    ( Some x )}

option_SILENT_:
  
    {    ( None )}
| x = SILENT
    {    ( Some x )}

option_WHERE_:
  
    {    ( None )}
| x = WHERE
    {    ( Some x )}

option_construct_triples_:
  
    {    ( None )}
| x = construct_triples
    {    ( Some x )}

option_group_clause_:
  
    {    ( None )}
| x = group_clause
    {    ( Some x )}

option_having_clause_:
  
    {    ( None )}
| x = having_clause
    {    ( Some x )}

option_limit_clause_:
  
    {    ( None )}
| x = limit_clause
    {    ( Some x )}

option_limit_offset_clause_:
  
    {    ( None )}
| x = limit_offset_clause
    {    ( Some x )}

option_offset_clause_:
  
    {    ( None )}
| x = offset_clause
    {    ( Some x )}

option_order_clause_:
  
    {    ( None )}
| x = order_clause
    {    ( Some x )}

option_path_mod_:
  
    {    ( None )}
| x = path_mod
    {    ( Some x )}

option_property_list_not_empty_:
  
    {    ( None )}
| x = property_list_not_empty
    {    ( Some x )}

option_property_list_path_not_empty_:
  
    {    ( None )}
| x = property_list_path_not_empty
    {    ( Some x )}

option_select_flag_:
  
    {    ( None )}
| x = select_flag
    {    ( Some x )}

option_triples_block_:
  
    {    ( None )}
| x = triples_block
    {    ( Some x )}

option_triples_block_details_:
  
    {    ( None )}
| x = triples_block_details
    {    ( Some x )}

option_triples_block_details2_:
  
    {    ( None )}
| x = triples_block_details2
    {    ( Some x )}

option_values_clause__:
  
    {    ( None )}
| x = values_clause_
    {    ( Some x )}

option_verb_object_list_:
  
    {    ( None )}
| x = verb_object_list
    {    ( Some x )}

option_verbp_object_list_:
  
    {    ( None )}
| x = verbp_object_list
    {    ( Some x )}

option_where_clause_:
  
    {    ( None )}
| x = where_clause
    {    ( Some x )}

loption_separated_nonempty_list_PIPE_path_one_in_property_set__:
  
    {    ( [] )}
| x = separated_nonempty_list_PIPE_path_one_in_property_set_
    {    ( x )}

list_data_block_value_:
  
    {    ( [] )}
| x = data_block_value xs = list_data_block_value_
    {    ( x :: xs )}

list_data_block_values_or_nil_:
  
    {    ( [] )}
| x = data_block_values_or_nil xs = list_data_block_values_or_nil_
    {    ( x :: xs )}

list_dataset_clause_:
  
    {    ( [] )}
| x = dataset_clause xs = list_dataset_clause_
    {    ( x :: xs )}

list_gp_triples_:
  
    {    ( [] )}
| x = gp_triples xs = list_gp_triples_
    {    ( x :: xs )}

list_prologue_item_:
  
    {    ( [] )}
| x = prologue_item xs = list_prologue_item_
    {    ( x :: xs )}

list_var_:
  
    {    ( [] )}
| x = var xs = list_var_
    {    ( x :: xs )}

list_verb_object_list_l_:
  
    {    ( [] )}
| x = verb_object_list_l xs = list_verb_object_list_l_
    {    ( x :: xs )}

list_verbp_object_list_l_:
  
    {    ( [] )}
| x = verbp_object_list_l xs = list_verbp_object_list_l_
    {    ( x :: xs )}

nonempty_list_graph_node_:
  x = graph_node
    {    ( [ x ] )}
| x = graph_node xs = nonempty_list_graph_node_
    {    ( x :: xs )}

nonempty_list_graph_node_path_:
  x = graph_node_path
    {    ( [ x ] )}
| x = graph_node_path xs = nonempty_list_graph_node_path_
    {    ( x :: xs )}

nonempty_list_group_condition_:
  x = group_condition
    {    ( [ x ] )}
| x = group_condition xs = nonempty_list_group_condition_
    {    ( x :: xs )}

nonempty_list_having_condition_:
  x = having_condition
    {    ( [ x ] )}
| x = having_condition xs = nonempty_list_having_condition_
    {    ( x :: xs )}

nonempty_list_order_condition_:
  x = order_condition
    {    ( [ x ] )}
| x = order_condition xs = nonempty_list_order_condition_
    {    ( x :: xs )}

nonempty_list_select_var_:
  x = select_var
    {    ( [ x ] )}
| x = select_var xs = nonempty_list_select_var_
    {    ( x :: xs )}

nonempty_list_var_or_iri_:
  x = var_or_iri
    {    ( [ x ] )}
| x = var_or_iri xs = nonempty_list_var_or_iri_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_expression_:
  x = expression
    {    ( [ x ] )}
| x = expression _2 = COMMA xs = separated_nonempty_list_COMMA_expression_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_object__:
  x = object_
    {    ( [ x ] )}
| x = object_ _2 = COMMA xs = separated_nonempty_list_COMMA_object__
    {    ( x :: xs )}

separated_nonempty_list_COMMA_object_path_:
  x = object_path
    {    ( [ x ] )}
| x = object_path _2 = COMMA xs = separated_nonempty_list_COMMA_object_path_
    {    ( x :: xs )}

separated_nonempty_list_PIPE_path_one_in_property_set_:
  x = path_one_in_property_set
    {    ( [ x ] )}
| x = path_one_in_property_set _2 = PIPE xs = separated_nonempty_list_PIPE_path_one_in_property_set_
    {    ( x :: xs )}

separated_nonempty_list_PIPE_path_sequence_:
  x = path_sequence
    {    ( [ x ] )}
| x = path_sequence _2 = PIPE xs = separated_nonempty_list_PIPE_path_sequence_
    {    ( x :: xs )}

separated_nonempty_list_SLASH_path_elt_or_inverse_:
  x = path_elt_or_inverse
    {    ( [ x ] )}
| x = path_elt_or_inverse _2 = SLASH xs = separated_nonempty_list_SLASH_path_elt_or_inverse_
    {    ( x :: xs )}

separated_nonempty_list_UNION_group_graph_pattern_:
  x = group_graph_pattern
    {    ( [ x ] )}
| x = group_graph_pattern _2 = UNION xs = separated_nonempty_list_UNION_group_graph_pattern_
    {    ( x :: xs )}

query:
  p = prologue k = query_kind v = values_clause _4 = EOF
    {  (
    { q_prolog = p ;
      q_kind = k ;
      q_values = v ;
    }
  )}

prologue:
  _1 = list_prologue_item_
    {                              ( _1 )}

prologue_item:
  _1 = BASE _2 = Iriref_
    {               ( BaseDecl _2 )}
| _1 = PREFIX name = Pname_ns ir = Iriref_
    {                                  ( PrefixDecl (name, ir) )}

query_kind:
  s = select_clause ds = list_dataset_clause_ w = where_clause m = solution_modifier
    {  (
    Select {
      select_select = s ; select_dataset = ds ;
      select_where = w ; select_modifier = m ;
    }
  )}
| _1 = CONSTRUCT t = construct_template ds = list_dataset_clause_ w = where_clause m = solution_modifier
    {  (
    Construct
      { constr_template = Some t ;
        constr_dataset = ds ;
        constr_where = Constr_ggp w ;
        constr_modifier = m ;
      }
  )}
| _1 = CONSTRUCT ds = list_dataset_clause_ _3 = WHERE _4 = LBRACE l = triples_template _6 = RBRACE m = solution_modifier
    {  (
    Construct
      { constr_template = None ;
        constr_dataset = ds ;
        constr_where = Constr_template l ;
        constr_modifier = m ;
      }
  )}
| _1 = DESCRIBE l = nonempty_list_var_or_iri_ ds = list_dataset_clause_ w = option_where_clause_ m = solution_modifier
    {  (
    Describe {
      desc_sel = l;
      desc_dataset = ds ;
      desc_where = w ;
      desc_modifier = m ;
    }
  )}
| _1 = DESCRIBE _2 = STAR ds = list_dataset_clause_ w = option_where_clause_ m = solution_modifier
    {  (
    Describe {
      desc_sel = [] ;
      desc_dataset = ds ;
      desc_where = w ;
      desc_modifier = m ;
    }
  )}
| _1 = ASK ds = list_dataset_clause_ w = where_clause m = solution_modifier
    {  (
    Ask {
      ask_dataset = ds ;
      ask_where = w ;
      ask_modifier = m ;
    }
  )}

select_clause:
  _1 = SELECT f = option_select_flag_ v = select_vars
    {   (
    { sel_flag = f ;
      sel_vars = v ;
    }
  )}

select_flag:
  _1 = DISTINCT
    {           ( Distinct )}
| _1 = REDUCED
    {          ( Reduced )}

select_vars:
  _1 = STAR
    {       ( SelectAll )}
| _1 = nonempty_list_select_var_
    {                            ( SelectVars _1 )}

select_var:
  _1 = var
    {      (
    { sel_var_loc = mk_loc _startpos__1_ _endpos__1_ ;
      sel_var_expr = None ;
      sel_var = _1 ;
    }
  )}
| _1 = LPAR e = expression _3 = AS v = var _5 = RPAR
    {                                  (
    { sel_var_loc = mk_loc _startpos_e_ _endpos_v_ ;
      sel_var_expr = Some e ;
      sel_var = v ;
    }
  )}

construct_template:
  _1 = LBRACE _2 = option_construct_triples_ _3 = RBRACE
    {                                         (
   match _2 with None -> [] | Some l -> l
  )}

construct_triples:
  _1 = triples_same_subject
    {                       ( [ _1 ] )}
| _1 = triples_same_subject _2 = DOT
    {                           ( [ _1 ] )}
| _1 = triples_same_subject _2 = DOT _3 = construct_triples
    {                                             ( _1 :: _3 )}

triples_template:
  _1 = construct_triples
    {                                    ( _1 )}

triples_same_subject:
  v = var_or_term l = property_list_not_empty
    {  (
    TriplesVar (v, l)
  )}
| t = triples_node l = property_list
    {  (
    TriplesNode (t, l)
  )}

dataset_clause:
  _1 = FROM _2 = source_selector
    {                       ( DefaultGraphClause _2 )}
| _1 = FROM _2 = NAMED _3 = source_selector
    {                             ( NamedGraphClause _3 )}

source_selector:
  _1 = iri
    {                     ( _1 )}

iri:
  _1 = Iriref_
    {          ( Rdf_sparql_types.Reliri _1 )}
| _1 = prefixed_name
    {                ( Rdf_sparql_types.PrefixedName _1 )}

prefixed_name:
  _1 = Pname_ns
    {           (
    { pname_loc = mk_loc _startpos__1_ _endpos__1_ ;
      pname_ns = _1 ;
      pname_local = None ;
    }
  )}
| _1 = Pname_ln
    {           (
    _1
  )}

values_clause:
  _1 = option_values_clause__
    {                                      ( _1 )}

values_clause_:
  _1 = VALUES d = datablock
    {                     ( d )}

datablock:
  _1 = inline_data_one_var
    {                      ( InLineDataOneVar _1 )}
| _1 = inline_data_full
    {                   ( InLineDataFull _1 )}

inline_data_one_var:
  v = var _2 = LBRACE l = list_data_block_value_ _4 = RBRACE
    {  (
    let loc = mk_loc _startpos_v_ _endpos__4_ in
    { idov_loc = loc ;
      idov_var = v ;
      idov_data = l ;
    }
  )}

inline_data_full:
  vars = nil_or_var_list _2 = LBRACE l = list_data_block_values_or_nil_ _4 = RBRACE
    {  (
    let loc = mk_loc _startpos_vars_ _endpos__4_ in
    {
      idf_loc = loc ;
      idf_vars = vars ;
      idf_values = l ;
    }
  )}

nil_or_var_list:
  _1 = NIL
    {      ( [] )}
| _1 = LPAR l = list_var_ _3 = RPAR
    {                        ( l )}

data_block_values_or_nil:
  _1 = NIL
    {      ( Nil )}
| _1 = LPAR l = list_data_block_value_ _3 = RPAR
    {                                     ( Value l )}

data_block_value:
  _1 = iri
    {      ( DataBlockValueIri _1 )}
| _1 = rdf_literal
    {              ( DataBlockValueRdf _1 )}
| _1 = numeric_literal
    {                  ( DataBlockValueNumeric _1 )}
| _1 = boolean_literal
    {                  ( DataBlockValueBoolean _1 )}
| _1 = UNDEF
    {        ( DataBlockValueUndef )}

solution_modifier:
  g = option_group_clause_ h = option_having_clause_ o = option_order_clause_ lo = option_limit_offset_clause_
    {  (
    let loc = mk_loc _startpos_g_ _endpos_lo_ in
    { solmod_loc = loc ;
      solmod_group = (match g with None -> [] | Some l -> l) ;
      solmod_having = (match h with None -> [] | Some l -> l) ;
      solmod_order = o ;
      solmod_limoff = lo ;
    }
  )}

group_clause:
  _1 = GROUP _2 = BY l = nonempty_list_group_condition_
    {  ( l )}

group_condition:
  _1 = built_in_call
    {                ( GroupBuiltInCall _1 )}
| _1 = function_call
    {                ( GroupFunctionCall _1 )}
| _1 = group_var
    {            ( GroupVar _1 )}

group_var:
  v = var
    {        (
    let loc = mk_loc _startpos_v_ _endpos_v_ in
    { grpvar_loc = loc ; grpvar_expr = None ; grpvar = Some v }
  )}
| e = expression _2 = AS v = var
    {                        (
    let loc = mk_loc _startpos_e_ _endpos_v_ in
    { grpvar_loc = loc ; grpvar_expr = Some e ; grpvar = Some v }
  )}
| e = expression
    {               (
    let loc = mk_loc _startpos_e_ _endpos_e_ in
    { grpvar_loc = loc ; grpvar_expr = Some e ; grpvar = None }
  )}

limit_offset_clause:
  l = limit_clause o = option_offset_clause_
    {  (
    let loc = mk_loc _startpos_l_ _endpos_o_ in
    { limoff_loc = loc ; limoff_limit = Some l ; limoff_offset = o }
  )}
| o = offset_clause l = option_limit_clause_
    {  (
    let loc = mk_loc _startpos_o_ _endpos_l_ in
    { limoff_loc = loc ; limoff_limit = l ; limoff_offset = Some o }
  )}

limit_clause:
  _1 = LIMIT _2 = Integer
    {                            ( int_of_string _2 )}

offset_clause:
  _1 = OFFSET _2 = Integer
    {                              ( int_of_string _2 )}

order_clause:
  _1 = ORDER _2 = BY l = nonempty_list_order_condition_
    {                                            ( l )}

order_condition:
  _1 = ASC _2 = bracketted_expression
    {                            ( OrderAsc _2 )}
| _1 = DESC _2 = bracketted_expression
    {                             ( OrderDesc _2 )}
| _1 = constraint_
    {              ( OrderConstr _1 )}
| _1 = var
    {      ( OrderVar _1 )}

having_clause:
  _1 = HAVING l = nonempty_list_having_condition_
    {                                           ( l )}

having_condition:
  _1 = constraint_
    {                              ( _1 )}

bracketted_expression:
  _1 = LPAR _2 = expression _3 = RPAR
    {                                            ( _2 )}

constraint_:
  _1 = bracketted_expression
    {                        ( ConstrExpr _1 )}
| _1 = built_in_call
    {                ( ConstrBuiltInCall _1 )}
| _1 = function_call
    {                ( ConstrFunctionCall _1 )}

where_clause:
  _1 = option_WHERE_ _2 = group_graph_pattern
    {                                    ( _2 )}

group_graph_pattern:
  _1 = LBRACE _2 = subselect _3 = RBRACE
    {                          ( SubSelect _2 )}
| _1 = LBRACE _2 = group_graph_pattern_sub _3 = RBRACE
    {                                        ( GGPSub _2 )}

subselect:
  sel = select_clause w = where_clause sol = solution_modifier v = values_clause
    {  (
   let loc = mk_loc _startpos_sel_ _endpos_v_ in
   {
    subsel_loc = loc ;
    subsel_select = sel ;
    subsel_where = w ;
    subsel_modifier = sol ;
    subsel_values = v ;
   }
  )}

group_graph_pattern_sub:
  t = option_triples_block_ l = list_gp_triples_
    {  (
    let loc = mk_loc _startpos_t_ _endpos_l_ in
    let l =
      List.fold_left
        (fun acc (g, t) ->
          match t with
            None -> g :: acc
          | Some t -> t :: g :: acc)
        []
        l
    in
    let l = List.rev l in
    let elts = match t with None -> l | Some t -> t :: l in
    { ggp_sub_loc = loc ;
      ggp_sub_elts = elts ;
    }
  )}

gp_triples:
  gp = graph_pattern_not_triples _2 = option_DOT_ t = option_triples_block_
    {  ( (gp, t) )}

triples_block:
  l = triples_block_details
    {  (
    let loc = mk_loc _startpos_l_ _endpos_l_ in
    Triples
      { triples_loc = loc ;
        triples = l ;
      }
  )}

triples_block_details:
  s = triples_same_subject_path rest = option_triples_block_details2_
    {  (
    match rest with
      None -> [s]
    | Some l -> s :: l
  )}

triples_block_details2:
  _1 = DOT t = option_triples_block_details_
    {  ( match t with None -> [] | Some l -> l )}

triples_same_subject_path:
  v = var_or_term p = property_list_path_not_empty
    {  (
    TriplesVar (v, p)
  )}
| t = triples_node_path p = property_list_path
    {  (
    TriplesNode (t, p)
  )}

property_list_path:
  l = option_property_list_path_not_empty_
    {  ( match l with None -> [] | Some l -> l )}

property_list_path_not_empty:
  v = verb_path_or_simple olp = object_list_path more = list_verbp_object_list_l_
    {  (
    let loc = mk_loc _startpos_v_ _endpos_more_ in
    let more = List.fold_left
      (fun acc -> function
         | None -> acc
         | Some x -> x :: acc
      )
      []
      more
    in
    {
      propol_loc = loc ;
      propol_verb = v ;
      propol_objects = olp ;
    } :: (List.rev more)
  )}

verbp_object_list_l:
  _1 = SEMICOLON _2 = option_verbp_object_list_
    {  ( _2 )}

verbp_object_list:
  v = verb_path_or_simple l = object_list
    {  (
    let loc = mk_loc _startpos_v_ _endpos_l_ in
    { propol_loc = loc ;
      propol_verb = v ;
      propol_objects = l
    }
  )}

object_list:
  _1 = separated_nonempty_list_COMMA_object__
    {                                                     ( _1 )}

object_:
  _1 = graph_node
    {                    ( _1 )}

verb_path_or_simple:
  _1 = path
    {       ( VerbPath _1 )}
| _1 = var
    {      ( VerbVar _1 )}

graph_node:
  _1 = var_or_term
    {              ( GraphNodeVT _1 )}
| _1 = triples_node
    {               ( GraphNodeTriples _1 )}

triples_node:
  _1 = collection
    {             ( TNodeCollection _1 )}
| _1 = blank_node_property_list
    {                           ( TNodeBlank _1 )}

collection:
  _1 = LPAR _2 = nonempty_list_graph_node_ _3 = RPAR
    {                                    ( _2 )}

blank_node_property_list:
  _1 = LBRACKET _2 = property_list_not_empty _3 = RBRACKET
    {                                          ( _2 )}

property_list:
  l = option_property_list_not_empty_
    {                                    (
    match l with None -> [] | Some l -> l
  )}

property_list_not_empty:
  v = verb_object_list l = list_verb_object_list_l_
    {  (
    let l = List.fold_left
      (fun acc -> function
        | None -> acc
        | Some x -> x :: acc
       )
       []
       l
     in
     let l = List.rev l in
     v :: l
  )}

verb_object_list_l:
  _1 = SEMICOLON _2 = option_verb_object_list_
    {  ( _2 )}

verb_object_list:
  v = verb l = object_list
    {  (
    let loc = mk_loc _startpos_v_ _endpos_l_ in
    { propol_loc = loc ;
      propol_verb = v ;
      propol_objects = l
    }
  )}

verb:
  _1 = var_or_iri
    {             (
  match _1 with
    VIVar v -> VerbVar v
  | VIIri iri -> VerbIri iri
  )}
| _1 = A
    {    ( VerbA )}

var_or_iri:
  _1 = var
    {      ( VIVar _1 )}
| _1 = iri
    {      ( VIIri _1 )}

var_or_term:
  _1 = var
    {      ( Var _1 )}
| _1 = graph_term
    {             ( GraphTerm _1 )}

var:
  s = Var1
    {  (
    let loc = mk_loc _startpos_s_ _endpos_s_ in
    { var_loc = loc ; var_name = s }
  )}
| s = Var2
    {  (
    let loc = mk_loc _startpos_s_ _endpos_s_ in
    { var_loc = loc ; var_name = s }
  )}

graph_term:
  _1 = iri
    {      ( GraphTermIri _1 )}
| _1 = rdf_literal
    {              ( GraphTermLit _1 )}
| _1 = numeric_literal
    {                  ( GraphTermNumeric _1 )}
| _1 = boolean_literal
    {                  ( GraphTermBoolean _1 )}
| _1 = blank_node
    {             ( GraphTermBlank _1 )}
| _1 = NIL
    {      ( GraphTermNil )}

graph_pattern_not_triples:
  _1 = group_of_union_graph_pattern
    {                               ( _1 )}
| _1 = optional_graph_pattern
    {                         ( _1 )}
| _1 = minus_graph_pattern
    {                      ( _1 )}
| _1 = graph_graph_pattern
    {                      ( _1 )}
| _1 = service_graph_pattern
    {                        ( _1 )}
| _1 = filter
    {         ( _1 )}
| _1 = bind
    {       ( _1 )}
| _1 = inline_data
    {              ( _1 )}

group_of_union_graph_pattern:
  l = separated_nonempty_list_UNION_group_graph_pattern_
    {                                                        ( Union l )}

optional_graph_pattern:
  _1 = OPTIONAL g = group_graph_pattern
    {                                 ( Optional g )}

minus_graph_pattern:
  _1 = MINUS g = group_graph_pattern
    {                              ( Minus g )}

graph_graph_pattern:
  _1 = GRAPH vi = var_or_iri g = group_graph_pattern
    {  (
    let loc = mk_loc _startpos__1_ _endpos_g_ in
    let t =
      { graphgp_loc = loc ;
        graphgp_name = vi ;
        graphgp_pat = g ;
      }
    in
    GGP t
  )}

service_graph_pattern:
  _1 = SERVICE silent = option_SILENT_ vi = var_or_iri g = group_graph_pattern
    {  (
    let loc = mk_loc _startpos__1_ _endpos_g_ in
    let t =
      { servgp_loc = loc ;
        servgp_silent = silent <> None ;
        servgp_name = vi ;
        servgp_pat = g ;
      }
    in
    Service t
  )}

filter:
  _1 = FILTER _2 = constraint_
    {                           ( Filter _2 )}

bind:
  _1 = BIND _2 = LPAR e = expression _4 = AS v = var _6 = RPAR
    {  (
    let loc = mk_loc _startpos__1_ _endpos__6_ in
    let t =
      { bind_loc = loc ;
        bind_expr = e ;
        bind_var = v ;
      }
    in
    Bind t
  )}

inline_data:
  _1 = VALUES _2 = datablock
    {                   ( InlineData _2 )}

object_list_path:
  _1 = separated_nonempty_list_COMMA_object_path_
    {                                                              ( _1 )}

object_path:
  _1 = graph_node_path
    {                             ( _1 )}

graph_node_path:
  _1 = var_or_term
    {              ( GraphNodeVT _1 )}
| _1 = triples_node_path
    {                    ( GraphNodeTriples _1 )}

triples_node_path:
  _1 = collection_path
    {                  ( TNodeCollection _1 )}
| _1 = blank_node_property_list_path
    {                                ( TNodeBlank _1 )}

collection_path:
  _1 = LPAR _2 = nonempty_list_graph_node_path_ _3 = RPAR
    {                                         ( _2 )}

blank_node_property_list_path:
  _1 = LBRACKET _2 = property_list_path_not_empty _3 = RBRACKET
    {                                               ( _2 )}

path:
  _1 = path_alternative
    {                       ( _1 )}

path_alternative:
  _1 = separated_nonempty_list_PIPE_path_sequence_
    {  ( _1 )}

path_sequence:
  _1 = separated_nonempty_list_SLASH_path_elt_or_inverse_
    {  ( _1 )}

path_elt_or_inverse:
  _1 = path_elt
    {           ( Elt _1 )}
| _1 = HAT _2 = path_elt
    {               ( Inv _2 )}

path_elt:
  p = path_primary m = option_path_mod_
    {  (
    let loc = mk_loc _startpos_p_ _endpos_m_ in
    { pelt_loc = loc ;
      pelt_primary = p ;
      pelt_mod = m ;
    }
  )}

path_primary:
  _1 = iri
    {      ( PathIri _1 )}
| _1 = A
    {    ( PathA )}
| _1 = BANG _2 = path_negated_property_list
    {                                  ( PathNegPropSet _2 )}
| _1 = LPAR _2 = path _3 = RPAR
    {                 ( Path _2 )}

path_negated_property_list:
  _1 = path_one_in_property_set
    {                           ( [ _1 ] )}
| _1 = LPAR xs = loption_separated_nonempty_list_PIPE_path_one_in_property_set__
    {let l =     ( xs ) in
                                                        ( l )}

path_one_in_property_set:
  _1 = iri
    {      ( PathOneInIri _1 )}
| _1 = A
    {    ( PathOneInA )}
| _1 = HAT _2 = iri
    {          ( PathOneInNotIri _2 )}
| _1 = HAT _2 = A
    {        ( PathOneInNotA )}

path_mod:
  _1 = QM
    {     ( ModOptional )}
| _1 = STAR
    {       ( ModList )}
| _1 = PLUS
    {       ( ModOneOrMore )}

blank_node:
  s = Blank_node_label
    {  (
    let loc = mk_loc _startpos_s_ _endpos_s_ in
    { bnode_loc = loc ;
      bnode_label = Some s ;
    }
  )}
| _1 = ANON
    {  (
    let loc = mk_loc _startpos__1_ _endpos__1_ in
    { bnode_loc = loc ;
      bnode_label = None ;
    }
  )}

arg_list:
  _1 = NIL
    {      (
    let loc = mk_loc _startpos__1_ _endpos__1_ in
    { argl_loc = loc ; argl_distinct = false ; argl = [] }
  )}
| _1 = LPAR o = option_DISTINCT_ l = separated_nonempty_list_COMMA_expression_ _4 = RPAR
    {  (
    let loc = mk_loc _startpos__1_ _endpos__4_ in
    { argl_loc = loc ; argl_distinct = o <> None ; argl = l }
  )}

iri_or_function:
  iri = iri
    {  (
    EIri iri
  )}
| _1 = function_call
    {                ( EFuncall _1 )}

function_call:
  i = iri a = arg_list
    {  (
    let loc = mk_loc _startpos_i_ _endpos_a_ in
    { func_loc = loc ; func_iri = i ; func_args = a }
  )}

expression:
  e = value_logical
    {                            ( e )}

value_logical:
  e = relational_expression
    {                            ( e )}
| e1 = value_logical _2 = AMPAMP e2 = value_logical
    {  (
    { expr_loc = mk_loc _startpos_e1_ _endpos_e2_ ;
      expr = EBin (e1, EAnd, e2) ;
    }
  )}
| e1 = value_logical _2 = PIPEPIPE e2 = value_logical
    {                                             (
    let loc = mk_loc _startpos_e1_ _endpos_e2_ in
    { expr_loc = loc ; expr = EBin (e1, EOr, e2) }
  )}

relational_expression:
  e1 = numexp _2 = EQUAL e2 = numexp
    {                            (
    { expr_loc = mk_loc _startpos_e1_ _endpos_e2_ ;
      expr = EBin (e1, EEqual, e2) ;
    }
  )}
| e1 = numexp _2 = NOTEQUAL e2 = numexp
    {                               (
    { expr_loc = mk_loc _startpos_e1_ _endpos_e2_ ;
      expr = EBin (e1, ENotEqual, e2) ;
    }
  )}
| e1 = numexp _2 = LT e2 = numexp
    {                         (
    { expr_loc = mk_loc _startpos_e1_ _endpos_e2_ ;
      expr = EBin (e1, ELt, e2) ;
    }
  )}
| e1 = numexp _2 = GT e2 = numexp
    {                         (
    { expr_loc = mk_loc _startpos_e1_ _endpos_e2_ ;
      expr = EBin (e1, EGt, e2) ;
    }
  )}
| e1 = numexp _2 = LTE e2 = numexp
    {                          (
    { expr_loc = mk_loc _startpos_e1_ _endpos_e2_ ;
      expr = EBin (e1, ELte, e2) ;
    }
  )}
| e1 = numexp _2 = GTE e2 = numexp
    {                          (
    { expr_loc = mk_loc _startpos_e1_ _endpos_e2_ ;
      expr = EBin (e1, EGte, e2) ;
    }
  )}
| e = numexp _2 = IN l = expression_list
    {                                (
    { expr_loc = mk_loc _startpos_e_ _endpos_l_ ;
      expr = EIn (e, l) ;
    }
  )}
| e = numexp _2 = NOT _3 = IN l = expression_list
    {                                    (
    { expr_loc = mk_loc _startpos_e_ _endpos_l_ ;
      expr = ENotIn (e, l) ;
    }
  )}
| _1 = numexp
    {         ( _1 )}

numexp:
  e = primary_expression
    {                       ( e )}
| e1 = expression _2 = STAR e2 = expression
    {                                   (
    let loc = mk_loc _startpos_e1_ _endpos_e2_ in
    { expr_loc = loc ;
      expr = EBin (e1, EMult, e2) ;
    }
  )}
| e1 = expression _2 = SLASH e2 = expression
    {                                    (
    let loc = mk_loc _startpos_e1_ _endpos_e2_ in
    { expr_loc = loc ;
      expr = EBin (e1, EDiv, e2) ;
    }
  )}
| e1 = expression _2 = PLUS e2 = expression
    {                                   (
    let loc = mk_loc _startpos_e1_ _endpos_e2_ in
    { expr_loc = loc ;
      expr = EBin (e1, EPlus, e2) ;
    }
  )}
| e1 = expression _2 = MINUS e2 = expression
    {                                    (
    let loc = mk_loc _startpos_e1_ _endpos_e2_ in
    { expr_loc = loc ;
      expr = EBin (e1, EMinus, e2) ;
    }
  )}
| e1 = expression lit = numeric_literal_positive
    {                                             (
    let loc = mk_loc _startpos_e1_ _endpos_lit_ in
    let lit2 =
      let s = lit.Rdf_term.lit_value in
      let len = String.length s in
      (* remove starting '+' *)
      { lit with Rdf_term.lit_value = String.sub s 1 (len - 1) }
    in
    let e2 =
      let loc = mk_loc _startpos_lit_ _endpos_lit_ in
      let lit2 = { rdf_lit_loc = loc ; rdf_lit = lit2 ; rdf_lit_type = None } in
      { expr_loc = loc ;
        expr = ENumeric lit2 ;
      }
    in
    { expr_loc = loc ;
      expr = EBin (e1, EPlus, e2) ;
    }
  )}
| e1 = expression lit = numeric_literal_negative
    {                                             (
    let loc = mk_loc _startpos_e1_ _endpos_lit_ in
    let lit2 =
      let s = lit.Rdf_term.lit_value in
      let len = String.length s in
      (* remove starting '-' *)
      { lit with Rdf_term.lit_value = String.sub s 1 (len - 1) }
    in
    let e2 =
      let loc = mk_loc _startpos_lit_ _endpos_lit_ in
      let lit2 = { rdf_lit_loc = loc ; rdf_lit = lit2 ; rdf_lit_type = None } in
      { expr_loc = loc ;
        expr = ENumeric lit2 ;
      }
    in
    { expr_loc = loc ;
      expr = EBin (e1, EMinus, e2) ;
    }
  )}
| _1 = BANG e = expression
    {                    (
    { expr_loc = mk_loc _startpos__1_ _endpos_e_ ;
      expr = ENot e ;
    }
  )}
| _1 = PLUS e = expression
    {                    ( e )}
| _1 = MINUS e = expression %prec BANG
    {                                (
    { expr_loc = mk_loc _startpos__1_ _endpos_e_ ;
      expr = EUMinus e ;
    }
  )}

expression_list:
  _1 = NIL
    {      ( [] )}
| _1 = LPAR l = separated_nonempty_list_COMMA_expression_ _3 = RPAR
    {                                                         ( l )}

primary_expression:
  _1 = bracketted_expression
    {                        ( _1 )}
| bic = built_in_call
    {                    (
    { expr_loc = mk_loc _startpos_bic_ _endpos_bic_ ;
      expr = EBic bic ;
    }
  )}
| lit = rdf_literal
    {                  (
    { expr_loc = mk_loc _startpos_lit_ _endpos_lit_ ;
      expr = ELit lit ;
    }
  )}
| lit = numeric_literal
    {                      (
  { expr_loc = mk_loc _startpos_lit_ _endpos_lit_ ;
      expr = ENumeric lit ;
    }
  )}
| lit = boolean_literal
    {                      (
    { expr_loc = mk_loc _startpos_lit_ _endpos_lit_ ;
      expr = EBoolean lit ;
    }
  )}
| v = var
    {        (
    { expr_loc = mk_loc _startpos_v_ _endpos_v_ ;
      expr = EVar v ;
    }
  )}
| x = iri_or_function
    {                    (
    { expr_loc = mk_loc _startpos_x_ _endpos_x_ ;
      expr = x ;
    }
  )}

numeric_literal:
  _1 = numeric_literal_
    {  (
    let loc = mk_loc _startpos__1_ _endpos__1_ in
    { rdf_lit_loc = loc ;
      rdf_lit = _1 ;
      rdf_lit_type = None ;
    }
  )}

numeric_literal_:
  _1 = numeric_literal_unsigned
    {                           ( _1 )}
| _1 = numeric_literal_positive
    {                           ( _1 )}
| _1 = numeric_literal_negative
    {                           ( _1 )}

numeric_literal_unsigned:
  _1 = Integer
    {          ( mk_integer _1 )}
| _1 = Decimal
    {          ( mk_decimal _1 )}
| _1 = Double
    {         ( mk_double _1 )}

numeric_literal_positive:
  _1 = Integer_positive
    {                   ( mk_integer _1 )}
| _1 = Decimal_positive
    {                   ( mk_decimal _1 )}
| _1 = Double_positive
    {                  ( mk_double _1 )}

numeric_literal_negative:
  _1 = Integer_negative
    {                   ( mk_integer _1 )}
| _1 = Decimal_negative
    {                   ( mk_decimal _1 )}
| _1 = Double_negative
    {                  ( mk_double _1 )}

boolean_literal:
  _1 = Boolean
    {          (
    let loc = mk_loc _startpos__1_ _endpos__1_ in
    { rdf_lit_loc = loc ;
      rdf_lit = mk_boolean _1 ;
      rdf_lit_type = None ;
    }
  )}

string:
  _1 = String_literal
    {                       ( _1 )}

rdf_literal:
  r = rdf_literal_
    {  (
    let loc = mk_loc _startpos_r_ _endpos_r_ in
    let (s, lang, typ) = r in
    { rdf_lit_loc = loc ;
      rdf_lit = mk_lit ?lang s ;
      rdf_lit_type = typ ;
    }
  )}

rdf_literal_:
  s = string
    {           ( (s, None, None) )}
| s = string _2 = HATHAT iri = iri
    {                          ( (s, None, Some iri) )}
| s = string t = Langtag
    {                     ( (s, Some t, None) )}

built_in_call:
  _1 = aggregate
    {            ( Bic_agg _1 )}
| _1 = regexp_expression
    {                    ( _1 )}
| _1 = STR _2 = LPAR e = expression _4 = RPAR
    {                             ( Bic_fun ("STR", [e]) )}
| _1 = LANG _2 = LPAR e = expression _4 = RPAR
    {                              ( Bic_fun ("LANG", [e]) )}
| _1 = LANGMATCHES _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = RPAR
    {                                                          ( Bic_fun ("LANGMATCHES", [e1; e2]) )}
| _1 = DATATYPE _2 = LPAR e = expression _4 = RPAR
    {                                  ( Bic_fun ("DATATYPE", [e]))}
| _1 = BOUND _2 = LPAR v = var _4 = RPAR
    {                        ( Bic_BOUND v )}
| _1 = IRI _2 = LPAR e = expression _4 = RPAR
    {                             ( Bic_fun ("IRI", [e]))}
| _1 = URI _2 = LPAR e = expression _4 = RPAR
    {                             ( Bic_fun ("URI", [e]))}
| _1 = BNODE _2 = LPAR e = expression _4 = RPAR
    {                               ( Bic_fun ("BNODE", [e]) )}
| _1 = BNODE _2 = NIL
    {            ( Bic_fun ("BNODE", []) )}
| _1 = RAND _2 = NIL
    {           ( Bic_fun ("RAND", []) )}
| _1 = ABS _2 = LPAR e = expression _4 = RPAR
    {                             ( Bic_fun ("ABS", [e]))}
| _1 = CEIL _2 = LPAR e = expression _4 = RPAR
    {                              ( Bic_fun ("CEIL", [e]))}
| _1 = FLOOR _2 = LPAR e = expression _4 = RPAR
    {                               ( Bic_fun ("FLOOR", [e]))}
| _1 = ROUND _2 = LPAR e = expression _4 = RPAR
    {                               ( Bic_fun ("ROUND", [e]))}
| _1 = CONCAT e = expression_list
    {                           ( Bic_fun ("CONCAT", e))}
| _1 = substring_expression
    {                       ( _1 )}
| _1 = STRLEN _2 = LPAR e = expression _4 = RPAR
    {                                ( Bic_fun ("STRLEN", [e]))}
| _1 = str_replace_expression
    {                         ( _1 )}
| _1 = UCASE _2 = LPAR e = expression _4 = RPAR
    {                               ( Bic_fun ("UCASE", [e]))}
| _1 = LCASE _2 = LPAR e = expression _4 = RPAR
    {                               ( Bic_fun ("LCASE", [e]))}
| _1 = ENCODE_FOR_URI _2 = LPAR e = expression _4 = RPAR
    {                                        ( Bic_fun ("ENCODE_FOR_URI", [e]))}
| _1 = CONTAINS _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = RPAR
    {                                                       ( Bic_fun ("CONTAINS", [e1 ; e2]) )}
| _1 = STRSTARTS _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = RPAR
    {                                                        ( Bic_fun ("STRSTARTS", [e1 ; e2]) )}
| _1 = STRENDS _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = RPAR
    {                                                      ( Bic_fun ("STRENDS", [e1 ; e2]) )}
| _1 = STRBEFORE _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = RPAR
    {                                                        ( Bic_fun ("STRBEFORE", [e1 ; e2]) )}
| _1 = STRAFTER _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = RPAR
    {                                                       ( Bic_fun ("STRAFTER", [e1 ; e2]) )}
| _1 = YEAR _2 = LPAR e = expression _4 = RPAR
    {                              ( Bic_fun ("YEAR", [e]))}
| _1 = MONTH _2 = LPAR e = expression _4 = RPAR
    {                               ( Bic_fun ("MONTH", [e]))}
| _1 = DAY _2 = LPAR e = expression _4 = RPAR
    {                             ( Bic_fun ("DAY", [e]))}
| _1 = HOURS _2 = LPAR e = expression _4 = RPAR
    {                               ( Bic_fun ("HOURS", [e]))}
| _1 = MINUTES _2 = LPAR e = expression _4 = RPAR
    {                                 ( Bic_fun ("MINUTES", [e]))}
| _1 = SECONDS _2 = LPAR e = expression _4 = RPAR
    {                                 ( Bic_fun ("SECONDS", [e]))}
| _1 = TIMEZONE _2 = LPAR e = expression _4 = RPAR
    {                                  ( Bic_fun ("TIMEZONE", [e]))}
| _1 = TZ _2 = LPAR e = expression _4 = RPAR
    {                            ( Bic_fun ("TZ", [e]))}
| _1 = NOW _2 = NIL
    {          ( Bic_fun ("NOW", []) )}
| _1 = UUID _2 = NIL
    {           ( Bic_fun ("UUID", []) )}
| _1 = STRUUID _2 = NIL
    {              ( Bic_fun ("STRUUID", []) )}
| _1 = MD5 _2 = LPAR e = expression _4 = RPAR
    {                             ( Bic_fun ("MD5", [e]))}
| _1 = SHA1 _2 = LPAR e = expression _4 = RPAR
    {                              ( Bic_fun ("SHA1", [e]))}
| _1 = SHA256 _2 = LPAR e = expression _4 = RPAR
    {                                ( Bic_fun ("SHA256", [e]))}
| _1 = SHA384 _2 = LPAR e = expression _4 = RPAR
    {                                ( Bic_fun ("SHA384", [e]))}
| _1 = SHA512 _2 = LPAR e = expression _4 = RPAR
    {                                ( Bic_fun ("SHA512", [e]))}
| _1 = COALESCE l = expression_list
    {                             ( Bic_fun("COALESCE", l) )}
| _1 = IF _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = COMMA e3 = expression _8 = RPAR
    {                                                                     ( Bic_fun("IF", [e1; e2; e3]) )}
| _1 = STRLANG _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = RPAR
    {                                                      ( Bic_fun ("STRLANG", [e1 ; e2]) )}
| _1 = STRDT _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = RPAR
    {                                                    ( Bic_fun ("STRDT", [e1 ; e2]) )}
| _1 = SAMETERM _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = RPAR
    {                                                       ( Bic_fun ("SAMETERM", [e1 ; e2]) )}
| _1 = ISIRI _2 = LPAR e = expression _4 = RPAR
    {                               ( Bic_fun ("ISIRI", [e]))}
| _1 = ISURI _2 = LPAR e = expression _4 = RPAR
    {                               ( Bic_fun ("ISURI", [e]))}
| _1 = ISBLANK _2 = LPAR e = expression _4 = RPAR
    {                                 ( Bic_fun ("ISBLANK", [e]))}
| _1 = ISLITERAL _2 = LPAR e = expression _4 = RPAR
    {                                   ( Bic_fun ("ISLITERAL", [e]))}
| _1 = ISNUMERIC _2 = LPAR e = expression _4 = RPAR
    {                                   ( Bic_fun ("ISNUMERIC", [e]))}
| _1 = EXISTS g = group_graph_pattern
    {                               ( Bic_EXISTS g )}
| _1 = NOT _2 = EXISTS g = group_graph_pattern
    {                                   ( Bic_NOTEXISTS g )}

regexp_expression:
  _1 = REGEX _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = RPAR
    {  ( Bic_fun("REGEX", [e1 ; e2]) )}
| _1 = REGEX _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = COMMA e3 = expression _8 = RPAR
    {  ( Bic_fun ("REGEX", [e1 ; e2 ; e3]) )}

substring_expression:
  _1 = SUBSTR _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = RPAR
    {  ( Bic_fun("SUBSTR", [e1 ; e2]) )}
| _1 = SUBSTR _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = COMMA e3 = expression _8 = RPAR
    {  ( Bic_fun ("SUBSTR", [e1 ; e2 ; e3]) )}

str_replace_expression:
  _1 = REPLACE _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = COMMA e3 = expression _8 = RPAR
    {  ( Bic_fun("REPLACE", [e1 ; e2 ; e3]) )}
| _1 = REPLACE _2 = LPAR e1 = expression _4 = COMMA e2 = expression _6 = COMMA e3 = expression _8 = COMMA e4 = expression _10 = RPAR
    {  ( Bic_fun ("REPLACE", [e1 ;e2 ; e3 ; e4]) )}

aggregate:
  _1 = COUNT _2 = LPAR d = option_DISTINCT_ _4 = STAR _5 = RPAR
    {                                          ( Bic_COUNT (d<>None, None) )}
| _1 = COUNT _2 = LPAR d = option_DISTINCT_ e = expression _5 = RPAR
    {                                                  ( Bic_COUNT (d<>None, Some e) )}
| _1 = SUM _2 = LPAR d = option_DISTINCT_ e = expression _5 = RPAR
    {                                                ( Bic_SUM (d<>None, e) )}
| _1 = MIN _2 = LPAR d = option_DISTINCT_ e = expression _5 = RPAR
    {                                                ( Bic_MIN (d<>None, e) )}
| _1 = MAX _2 = LPAR d = option_DISTINCT_ e = expression _5 = RPAR
    {                                                ( Bic_MAX (d<>None, e) )}
| _1 = AVG _2 = LPAR d = option_DISTINCT_ e = expression _5 = RPAR
    {                                                ( Bic_AVG (d<>None, e) )}
| _1 = SAMPLE _2 = LPAR d = option_DISTINCT_ e = expression _5 = RPAR
    {                                                   ( Bic_SAMPLE (d<>None, e) )}
| _1 = GROUP_CONCAT _2 = LPAR d = option_DISTINCT_ e = expression _5 = RPAR
    {                                                         ( Bic_GROUP_CONCAT (d<>None, e, None) )}
| _1 = GROUP_CONCAT _2 = LPAR d = option_DISTINCT_ e = expression _5 = SEMICOLON _6 = SEPARATOR _7 = EQUAL sep = string _9 = RPAR
    {  ( Bic_GROUP_CONCAT (d<>None, e, Some sep) )}

%%
