File "reason.3.3.7-reason_parser.mly", line 1222, characters 29-36:
Warning: the token COMMENT is unused.
File "reason.3.3.7-reason_parser.mly", line 1225, characters 7-10:
Warning: the token EOL is unused.
File "reason.3.3.7-reason_parser.mly", line 1179, characters 19-28:
Warning: the token NATIVEINT is unused.
File "reason.3.3.7-reason_parser.mly", line 1201, characters 7-15:
Warning: the token SEMISEMI is unused.
%{
open Migrate_parsetree.OCaml_404.Ast
open Reason_syntax_util
open Location
open Asttypes
open Longident
open Parsetree
open Ast_helper
open Ast_mapper
open Reason_string

(*
   TODO:
   - Remove all [open]s from the top of this file one by one and fix compilation
   failures that ensue by specifying the appropriate long identifiers. That
   will make the parser much easier to reason about.
   - Go back to trunk, do the same (remove [open]s, and fully specify long
   idents), to perform a clean diff.

*)

(**

   location.ml:
   ------------
   let mkloc txt loc = { txt ; loc }
   let rhs_loc n = {
     loc_start = Parsing.rhs_start_pos n;
     loc_end = Parsing.rhs_end_pos n;
     loc_ghost = false;
   }
   let symbol_rloc () = {
     loc_start = Parsing.symbol_start_pos ();
     loc_end = Parsing.symbol_end_pos ();
     loc_ghost = false;
   }

   let symbol_gloc () = {
     loc_start = Parsing.symbol_start_pos ();
     loc_end = Parsing.symbol_end_pos ();
     loc_ghost = true;
   }

   ast_helper.ml:
   ------------
   module Typ = struct
    val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
    let mk ?(loc = !default_loc) ?(attrs = []) d =
       {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
     ..
   end

   parse_tree.mli
   --------------
   and core_type = {
     ptyp_desc: core_type_desc;
     ptyp_loc: Location.t;
     ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
   }

   and core_type_desc =
     | Ptyp_any
           (*  _ *)
     | Ptyp_var of string
           (* 'a *)
     | Ptyp_arrow of label * core_type * core_type
           (* T1 -> T2       (label = "")
              ~l:T1 -> T2    (label = "l")
              ?l:T1 -> T2    (label = "?l")
            *)
     | Ptyp_tuple of core_type list
           (* T1 * ... * Tn   (n >= 2) *)

   reason_parser.mly
   ---------------
   In general:

                                          syntax variant          {pblah_desc: core_blah_desc
                                                                   pblah_loc: {txt, loc}
                                                                   pblah_attributes: ... }
                                         /              \            /       \
   val mkblah: ~loc -> ~attributes ->     core_blah_desc     ->      core_blah
   let mkblah = Blah.mk

*)

let uncurry_payload ?(name="bs") loc = ({loc; txt = name}, PStr [])

let dummy_loc () = {
  loc_start = Lexing.dummy_pos;
  loc_end = Lexing.dummy_pos;
  loc_ghost = false;
}

let mklocation loc_start loc_end = {
  loc_start = loc_start;
  loc_end = loc_end;
  loc_ghost = false;
}

let with_txt a txt = {
    a with txt=txt;
}

let make_real_loc loc = {
    loc with loc_ghost = false
}

let make_ghost_loc loc = {
    loc with loc_ghost = true
}

let ghloc ?(loc=dummy_loc ()) d = { txt = d; loc = (make_ghost_loc loc) }

(**
  * turn an object into a real
  *)
let make_real_exp exp = {
    exp with pexp_loc = make_real_loc exp.pexp_loc
}
let make_real_pat pat = {
    pat with ppat_loc = make_real_loc pat.ppat_loc
}
(*
 * change the location state to be a ghost location or real location
 *)
let set_loc_state is_ghost loc =
    if is_ghost then make_ghost_loc loc else make_real_loc loc

let mktyp ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Typ.mk ~loc d

let mkpat ?(attrs=[]) ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Pat.mk ~loc ~attrs d

let mkexp ?(attrs=[]) ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Exp.mk ~loc ~attrs d

let mkmty ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Mty.mk ~loc d

let mksig ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Sig.mk ~loc d

let mkmod ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Mod.mk ~loc d

let mkstr ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Str.mk ~loc d

let mkclass ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Cl.mk ~loc d

let mkcty ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Cty.mk ~loc d

let mkctf ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Ctf.mk ~loc d

let may_tuple startp endp = function
  | []  -> assert false
  | [x] -> {x with pexp_loc = mklocation startp endp}
  | xs  -> mkexp ~loc:(mklocation startp endp) (Pexp_tuple xs)

(**
  Make a core_type from a as_loc(LIDENT).
  Useful for record type punning.
  type props = {width: int, height: int};
  type state = {nbrOfClicks: int};
  type component = {props, state};
*)
let mkct lbl =
  let lident = Lident lbl.txt in
  let ttype = Ptyp_constr({txt = lident; loc = lbl.loc}, []) in
  {ptyp_desc = ttype; ptyp_loc = lbl.loc; ptyp_attributes = []}

let mkcf ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Cf.mk ~loc d

let simple_ghost_text_attr ?(loc=dummy_loc ()) txt =
  let loc = set_loc_state true loc in
  [({txt; loc}, PStr [])]

let mkExplicitArityTuplePat ?(loc=dummy_loc ()) pat =
  (* Tell OCaml type system that what this tuple construction represents is
     not actually a tuple, and should represent several constructor
     arguments.  This allows the syntax the ability to distinguish between:

     X (10, 20)  -- One argument constructor
     X 10 20     -- Multi argument constructor
  *)
  mkpat
    ~loc
    ~attrs:(simple_ghost_text_attr ~loc "explicit_arity")
    pat

let mkExplicitArityTupleExp ?(loc=dummy_loc ()) exp_desc =
  mkexp
    ~loc
    ~attrs:(simple_ghost_text_attr ~loc "explicit_arity")
    exp_desc

let is_pattern_list_single_any = function
  | [{ppat_desc=Ppat_any; ppat_attributes=[]} as onlyItem] -> Some onlyItem
  | _ -> None

let mkoperator {Location. txt; loc} =
  Exp.mk ~loc (Pexp_ident(mkloc (Lident txt) loc))

(*
  Ghost expressions and patterns:
  expressions and patterns that do not appear explicitly in the
  source file they have the loc_ghost flag set to true.
  Then the profiler will not try to instrument them and the
  -annot option will not try to display their type.

  Every grammar rule that generates an element with a location must
  make at most one non-ghost element, the topmost one.

  How to tell whether your location must be ghost:
  A location corresponds to a range of characters in the source file.
  If the location contains a piece of code that is syntactically
  valid (according to the documentation), and corresponds to the
  AST node, then the location must be real; in all other cases,
  it must be ghost.

  jordwalke: Noticed that ghost expressions are often used when inserting
   additional AST nodes from a parse rule. Either an extra wrapping one, or an
   additional inner node. This is consistent with the above description, I
   believe.
*)


let ghunit ?(loc=dummy_loc ()) () =
  mkexp ~ghost:true ~loc (Pexp_construct (mknoloc (Lident "()"), None))

let mkinfixop arg1 op arg2 =
  mkexp(Pexp_apply(op, [Nolabel, arg1; Nolabel, arg2]))

let mkinfix arg1 name arg2 =
  mkinfixop arg1 (mkoperator name) arg2

let neg_string f =
  if String.length f > 0 && f.[0] = '-'
  then String.sub f 1 (String.length f - 1)
  else "-" ^ f

let mkuminus name arg =
  match name.txt, arg.pexp_desc with
  | "-", Pexp_constant(Pconst_integer (n,m)) ->
      mkexp(Pexp_constant(Pconst_integer(neg_string n,m)))
  | ("-" | "-."), Pexp_constant(Pconst_float (f, m)) ->
      mkexp(Pexp_constant(Pconst_float(neg_string f, m)))
  | txt, _ ->
      let name = {name with txt = "~" ^ txt} in
      mkexp(Pexp_apply(mkoperator name, [Nolabel, arg]))

let prepare_functor_arg = function
  | Some name, mty -> (name, mty)
  | None, (Some {pmty_loc} as mty) ->
      (mkloc "_" (make_ghost_loc pmty_loc), mty)
  | None, None -> assert false

let mk_functor_mod args body =
  let folder arg acc =
    let name, mty = prepare_functor_arg arg.txt in
    mkmod ~loc:arg.loc (Pmod_functor(name, mty, acc))
  in
  List.fold_right folder args body

let mk_functor_mty args body =
  let folder arg acc =
    let name, mty = prepare_functor_arg arg.txt in
    mkmty ~loc:arg.loc (Pmty_functor(name, mty, acc))
  in
  List.fold_right folder args body

let mkuplus name arg =
  match name.txt, arg.pexp_desc with
  | "+", Pexp_constant(Pconst_integer _)
  | ("+" | "+."), Pexp_constant(Pconst_float _) ->
      mkexp arg.pexp_desc
  | txt, _ ->
      let name = {name with txt = "~" ^ txt} in
      mkexp(Pexp_apply(mkoperator name, [Nolabel, arg]))

let mkexp_cons consloc args loc =
  mkexp ~loc (Pexp_construct(mkloc (Lident "::") consloc, Some args))

let mkexp_constructor_unit ?(uncurried=false) consloc loc =
  let attrs = if uncurried then [uncurry_payload ~name:"uncurry" loc] else [] in
  mkexp ~attrs ~loc (Pexp_construct(mkloc (Lident "()") consloc, None))

let ghexp_cons args loc =
  mkexp ~ghost:true ~loc (Pexp_construct(mkloc (Lident "::") loc, Some args))

let mkpat_cons args loc =
  mkpat ~loc (Ppat_construct(mkloc (Lident "::") loc, Some args))

let ghpat_cons args loc =
  mkpat ~ghost:true ~loc (Ppat_construct(mkloc (Lident "::") loc, Some args))

let mkpat_constructor_unit consloc loc =
  mkpat ~loc (Ppat_construct(mkloc (Lident "()") consloc, None))

let simple_pattern_list_to_tuple ?(loc=dummy_loc ()) = function
  | [] -> assert false
  | lst -> mkpat ~loc (Ppat_tuple lst)

let mktailexp_extension loc seq ext_opt =
  let rec handle_seq = function
    | [] ->
        let base_case = match ext_opt with
          | Some ext ->
            ext
          | None ->
            let loc = make_ghost_loc loc in
            let nil = { txt = Lident "[]"; loc } in
            Exp.mk ~loc (Pexp_construct (nil, None)) in
        base_case
    | e1 :: el ->
        let exp_el = handle_seq el in
        let loc = mklocation e1.pexp_loc.loc_start exp_el.pexp_loc.loc_end in
        let arg = mkexp ~ghost:true ~loc (Pexp_tuple [e1; exp_el]) in
        ghexp_cons arg loc
  in
  handle_seq seq

let mktailpat_extension loc (seq, ext_opt) =
  let rec handle_seq = function
    [] ->
      let base_case = match ext_opt with
        | Some ext ->
          ext
        | None ->
          let loc = make_ghost_loc loc in
          let nil = { txt = Lident "[]"; loc } in
          mkpat ~loc (Ppat_construct (nil, None)) in
      base_case
  | p1 :: pl ->
      let pat_pl = handle_seq pl in
      let loc = mklocation p1.ppat_loc.loc_start pat_pl.ppat_loc.loc_end in
      let arg = mkpat ~ghost:true ~loc (Ppat_tuple [p1; pat_pl]) in
      ghpat_cons arg loc in
  handle_seq seq

let makeFrag loc body =
  let attribute = ({txt = "JSX"; loc = loc}, PStr []) in
  { body with pexp_attributes = attribute :: body.pexp_attributes }


(* Applies attributes to the structure item, not the expression itself. Makes
 * structure item have same location as expression. *)

let mkstrexp e attrs =
  match e with
  | ({pexp_desc = Pexp_apply (({pexp_attributes} as e1), args) } as eRewrite)
      when let f = (List.filter (function
        | ({txt = "bs"}, _) -> true
          | _ -> false ) e.pexp_attributes)  in
      List.length f > 0
    ->
      let appExprAttrs = List.filter (function
          | ({txt = "bs"}, PStr []) -> false
          | _ -> true ) pexp_attributes in
      let strEvalAttrs = (uncurry_payload e1.pexp_loc)::(List.filter (function
          | ({txt = "bs"}, PStr []) -> false
          | _ -> true ) attrs) in
      let e = {
        eRewrite with
        pexp_desc = (Pexp_apply(e1, args));
        pexp_attributes = appExprAttrs
      } in
      { pstr_desc = Pstr_eval (e, strEvalAttrs); pstr_loc = e.pexp_loc }
  | _ ->
      { pstr_desc = Pstr_eval (e, attrs); pstr_loc = e.pexp_loc }

let ghexp_constraint loc e (t1, t2) =
  match t1, t2 with
  | Some t, None -> mkexp ~ghost:true ~loc (Pexp_constraint(e, t))
  | _, Some t -> mkexp ~ghost:true ~loc (Pexp_coerce(e, t1, t))
  | None, None -> assert false

let array_function ?(loc=dummy_loc()) str name =
  ghloc ~loc (Ldot(Lident str, (if !Clflags.fast then "unsafe_" ^ name else name)))

let err loc s =
  raise Reason_syntax_util.(
    Error(loc, (Syntax_error s))
  )

let syntax_error_str loc msg =
  if !Reason_config.recoverable then
    Str.mk ~loc:loc (Pstr_extension (Reason_syntax_util.syntax_error_extension_node loc msg, []))
  else
    raise(Syntaxerr.Error(Syntaxerr.Other loc))

let syntax_error () =
  raise Syntaxerr.Escape_error

let syntax_error_exp loc msg =
  if !Reason_config.recoverable then
    Exp.mk ~loc (Pexp_extension (Reason_syntax_util.syntax_error_extension_node loc msg))
  else
    err loc msg

let syntax_error_pat loc msg =
  if !Reason_config.recoverable then
    Pat.extension ~loc (Reason_syntax_util.syntax_error_extension_node loc msg)
  else
    err loc msg

let syntax_error_mod loc msg =
  if !Reason_config.recoverable then
    Mty.extension ~loc (Reason_syntax_util.syntax_error_extension_node loc msg)
  else
    err loc msg

let unclosed opening closing =
  raise(Syntaxerr.Error(Syntaxerr.Unclosed(opening.loc, opening.txt,
                                           closing.loc, closing.txt)))

let unclosed_extension closing =
  Reason_syntax_util.syntax_error_extension_node closing.loc ("Expecting \"" ^ closing.txt ^ "\"")

let unclosed_mod opening closing =
  if !Reason_config.recoverable then
    mkmod(Pmod_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_cl opening closing =
  if !Reason_config.recoverable then
    mkclass(Pcl_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_mty opening closing =
  if !Reason_config.recoverable then
    mkmty(Pmty_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_cty opening closing =
  if !Reason_config.recoverable then
    mkcty(Pcty_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_exp opening closing =
  if !Reason_config.recoverable then
    mkexp(Pexp_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_pat opening closing =
  if !Reason_config.recoverable then
    mkpat(Ppat_extension (unclosed_extension closing))
  else
    unclosed opening closing

let expecting nonterm =
    raise Syntaxerr.(Error(Expecting(nonterm.loc, nonterm.txt)))

let expecting_pat nonterm =
  if !Reason_config.recoverable then
    mkpat(Ppat_extension (Reason_syntax_util.syntax_error_extension_node nonterm.loc ("Expecting " ^ nonterm.txt)))
  else
    expecting nonterm

let not_expecting start_pos end_pos nonterm =
    raise Syntaxerr.(Error(Not_expecting(mklocation start_pos end_pos, nonterm)))

type labelled_parameter =
  | Term of arg_label * expression option * pattern
  | Type of string

let mkexp_fun {Location.txt; loc} body =
  let loc = mklocation loc.loc_start body.pexp_loc.loc_end in
  match txt with
  | Term (label, default_expr, pat) ->
    Exp.fun_ ~loc label default_expr pat body
  | Type str ->
    Exp.newtype ~loc str body

let mkclass_fun {Location. txt ; loc} body =
  let loc = mklocation loc.loc_start body.pcl_loc.loc_end in
  match txt with
  | Term (label, default_expr, pat) ->
    Cl.fun_ ~loc label default_expr pat body
  | Type _ ->
    let pat = syntax_error_pat loc "(type) not allowed in classes" in
    Cl.fun_ ~loc Nolabel None pat body

let mktyp_arrow ({Location.txt = (label, cod); loc}, uncurried) dom =
  let loc = mklocation loc.loc_start dom.ptyp_loc.loc_end in
  let typ = mktyp ~loc (Ptyp_arrow (label, cod, dom)) in
  {typ with ptyp_attributes = (if uncurried then [uncurry_payload loc] else [])}

let mkcty_arrow ({Location.txt = (label, cod); loc}, uncurried) dom =
  let loc = mklocation loc.loc_start dom.pcty_loc.loc_end in
  let ct = mkcty ~loc (Pcty_arrow (label, cod, dom)) in
  {ct with pcty_attributes = (if uncurried then [uncurry_payload loc] else [])}

(**
  * process the occurrence of _ in the arguments of a function application
  * replace _ with a new variable, currently __x, in the arguments
  * return a wrapping function that wraps ((__x) => ...) around an expression
  * e.g. foo(_, 3) becomes (__x) => foo(__x, 3)
  *)
let process_underscore_application args =
  let exp_question = ref None in
  let hidden_var = "__x" in
  let check_arg ((lab, exp) as arg) = match exp.pexp_desc with
    | Pexp_ident ({ txt = Lident "_"} as id) ->
        let new_id = mkloc (Lident hidden_var) id.loc in
        let new_exp = mkexp (Pexp_ident new_id) ~loc:exp.pexp_loc in
        exp_question := Some new_exp;
        (lab, new_exp)
    | _ ->
        arg in
  let args = List.map check_arg args in
  let wrap exp_apply = match !exp_question with
    | Some {pexp_loc=loc} ->
        let pattern = mkpat (Ppat_var (mkloc hidden_var loc)) ~loc in
        begin match exp_apply.pexp_desc with
        (* Transform fast pipe with underscore application correct:
         * 5->doStuff(3, _, 7);
         * (5 |. doStuff)(3, _, 7)
         * 5 |. (__x => doStuff(3, __x, 7))
         *)
        | Pexp_apply(
          {pexp_desc= Pexp_apply(
            {pexp_desc = Pexp_ident({txt = Longident.Lident("|.")})} as pipeExp,
            [Nolabel, arg1; Nolabel, ({pexp_desc = Pexp_ident _} as arg2)]
            (*         5                            doStuff                   *)
          )},
          args (* [3, __x, 7] *)
          ) ->
            (* build `doStuff(3, __x, 7)` *)
            let innerApply = {arg2 with pexp_desc = Pexp_apply(arg2, args)} in
            (* build `__x => doStuff(3, __x, 7)` *)
            let innerFun =
              mkexp (Pexp_fun (Nolabel, None, pattern, innerApply)) ~loc
            in
            (* build `5 |. (__x => doStuff(3, __x, 7))` *)
            {exp_apply with pexp_desc =
              Pexp_apply(pipeExp, [Nolabel, arg1; Nolabel, innerFun])
            }
        | _ ->
          mkexp (Pexp_fun (Nolabel, None, pattern, exp_apply)) ~loc
        end
    | None ->
        exp_apply in
  (args, wrap)

(**
  * Joins a 'body' and it's 'args' to form a Pexp_apply.
  * Example:
  * 'add' (body) and '[1, 2]' (args) become a Pexp_apply representing 'add(1, 2)'
  *
  * Note that `add(. 1, 2)(. 3, 4)` & `add(. 1, 2, . 3, 4)` both
  * give `[[@uncurry] 1, 2, [@uncurry] 3, 4]]` as args.
  * The dot is parsed as [@uncurry] to distinguish between specific
  * uncurrying and [@bs]. They can appear in the same arg:
  * `add(. [@bs] 1)` is a perfectly valid, the dot indicates uncurrying
  * for the whole application of 'add' and [@bs] sits on the `1`.
  * Due to the dot of uncurried application possibly appearing in any
  * position of the args, we need to post-process the args and split
  * all args in groups that are uncurried (or not).
  * add(. 1, . 2) should be parsed as (add(. 1))(. 2)
  * The args can be splitted here in [1] & [2], based on those groups
  * we can recursively build the correct nested Pexp_apply here.
  *  -> Pexp_apply (Pexp_apply (add, 1), 2)   (* simplified ast *)
  *)
let mkexp_app_rev startp endp (body, args) =
  let loc = mklocation startp endp in
  if args = [] then {body with pexp_loc = loc}
  else
  (*
   * Post process the arguments and transform [@uncurry] into [@bs].
   * Returns a tuple with a boolean (was it uncurried?) and
   * the posible rewritten arg.
   *)
  let rec process_args acc es =
    match es with
    | (lbl, e)::es ->
        let attrs = e.pexp_attributes in
        let hasUncurryAttr = ref false in
        let newAttrs = List.filter (function
          | ({txt = "uncurry"}, PStr []) ->
              hasUncurryAttr := true;
              false
          | _ -> true) attrs
        in
        let uncurried = !hasUncurryAttr in
        let newArg = (lbl, { e with pexp_attributes = newAttrs }) in
        process_args ((uncurried, newArg)::acc) es
    | [] -> acc
    in
    (*
     * Groups all uncurried args falling under the same Pexp_apply
     * Example:
     *    add(. 2, 3, . 4, 5) or add(. 2, 3)(. 4, 5)  (equivalent)
     * This results in two groups: (true, [2, 3]) & (true, [4, 5])
     * Both groups have 'true' as their first tuple element, because
     * they are uncurried.
     * add(2, 3, . 4) results in the groups (false, [2, 3]) & (true, [4])
     *)
    let rec group grp acc = function
    | (uncurried, arg)::xs ->
        let (_u, grp) = grp in
        if uncurried = true then begin
          group (true, [arg]) ((_u, (List.rev grp))::acc) xs
        end else begin
          group (_u, (arg::grp)) acc xs
        end
    | [] ->
        let (_u, grp) = grp in
        List.rev ((_u, (List.rev grp))::acc)
    in
    (*
     * Recursively transforms all groups into a (possibly uncurried)
     * Pexp_apply
     *
     * Example:
     *   Given the groups (true, [2, 3]) & (true, [4, 5]) and body 'add',
     *   we get the two nested Pexp_apply associated with
     *   (add(. 2, 3))(. 4, 5)
     *)
    let rec make_appl body = function
      | args::xs ->
          let (uncurried, args) = args in
          let expr = if args = [] then body
          else
            let (args, wrap) = process_underscore_application args in
            let args_loc = match args, List.rev args with
              | ((_, s)::_), ((_, e)::_) -> mklocation s.pexp_loc.loc_start e.pexp_loc.loc_end
              | _ -> assert false in
            let expr = mkexp ~loc:args_loc (Pexp_apply (body, args)) in
            let expr = if uncurried then {expr with pexp_attributes = [uncurry_payload loc]} else expr in
            wrap expr
          in
            make_appl expr xs
      | [] -> {body with pexp_loc = loc}
    in
    let processed_args = process_args [] args in
    let groups = group (false, []) [] processed_args in
    make_appl body groups

let mkmod_app mexp marg =
  mkmod ~loc:(mklocation mexp.pmod_loc.loc_start marg.pmod_loc.loc_end)
    (Pmod_apply (mexp, marg))

let bigarray_function ?(loc=dummy_loc()) str name =
  ghloc ~loc (Ldot(Ldot(Lident "Bigarray", str), name))

let bigarray_get ?(loc=dummy_loc()) arr arg =
  let get = if !Clflags.fast then "unsafe_get" else "get" in
  match arg with
    [c1] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array1" get)),
                       [Nolabel, arr; Nolabel, c1]))
  | [c1;c2] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array2" get)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array3" get)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2; Nolabel, c3]))
  | coords ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Genarray" "get")),
                       [Nolabel, arr; Nolabel, mkexp ~ghost:true ~loc (Pexp_array coords)]))

let bigarray_set ?(loc=dummy_loc()) arr arg newval =
  let set = if !Clflags.fast then "unsafe_set" else "set" in
  match arg with
    [c1] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array1" set)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, newval]))
  | [c1;c2] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array2" set)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2; Nolabel, newval]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array3" set)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2; Nolabel, c3; Nolabel, newval]))
  | coords ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Genarray" "set")),
                       [Nolabel, arr;
                        Nolabel, mkexp ~ghost:true ~loc (Pexp_array coords);
                        Nolabel, newval]))

let exp_of_label label =
  mkexp ~loc:label.loc (Pexp_ident {label with txt=Lident(Longident.last label.txt)})

let pat_of_label label =
  mkpat ~loc:label.loc (Ppat_var {label with txt=(Longident.last label.txt)})

let check_variable vl loc v =
  if List.mem v vl then
    raise Syntaxerr.(Error(Variable_in_scope(loc,v)))

let varify_constructors var_names t =
  let rec loop t =
    let desc =
      match t.ptyp_desc with
      | Ptyp_any -> Ptyp_any
      | Ptyp_var x ->
          check_variable var_names t.ptyp_loc x;
          Ptyp_var x
      | Ptyp_arrow (label,core_type,core_type') ->
          Ptyp_arrow(label, loop core_type, loop core_type')
      | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)
      | Ptyp_constr( { txt = Lident s }, []) when List.mem s var_names ->
          Ptyp_var s
      | Ptyp_constr(longident, lst) ->
          Ptyp_constr(longident, List.map loop lst)
      | Ptyp_object (lst, o) ->
          Ptyp_object
            (List.map (fun (s, attrs, t) -> (s, attrs, loop t)) lst, o)
      | Ptyp_class (longident, lst) ->
          Ptyp_class (longident, List.map loop lst)
      | Ptyp_alias(core_type, string) ->
          check_variable var_names t.ptyp_loc string;
          Ptyp_alias(loop core_type, string)
      | Ptyp_variant(row_field_list, flag, lbl_lst_option) ->
          Ptyp_variant(List.map loop_row_field row_field_list,
                       flag, lbl_lst_option)
      | Ptyp_poly(string_lst, core_type) ->
          List.iter (check_variable var_names t.ptyp_loc) string_lst;
          Ptyp_poly(string_lst, loop core_type)
      | Ptyp_package(longident,lst) ->
          Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)
      | Ptyp_extension (s, arg) ->
          Ptyp_extension (s, arg)
    in
    {t with ptyp_desc = desc}
  and loop_row_field  =
    function
      | Rtag(label,attrs,flag,lst) ->
          Rtag(label,attrs,flag,List.map loop lst)
      | Rinherit t ->
          Rinherit (loop t)
  in
  loop t

let pexp_newtypes ?loc newtypes exp =
  List.fold_right (fun newtype exp -> mkexp ?loc (Pexp_newtype (newtype, exp)))
    newtypes exp

(**
  I believe that wrap_type_annotation will automatically generate the type
  arguments (type a) (type b) based on what was listed before the dot in a
  polymorphic type annotation that uses locally abstract types.
 *)
let wrap_type_annotation newtypes core_type body =
  let exp = mkexp(Pexp_constraint(body,core_type)) in
  let exp = pexp_newtypes newtypes exp in
  let typ = mktyp ~ghost:true (Ptyp_poly(newtypes,varify_constructors newtypes core_type)) in
  (exp, typ)


let struct_item_extension (ext_attrs, ext_id) structure_items =
  mkstr ~ghost:true (Pstr_extension ((ext_id, PStr structure_items), ext_attrs))

let expression_extension ?loc (ext_attrs, ext_id) item_expr =
  let extension = (ext_id, PStr [mkstrexp item_expr []]) in
  let loc = match loc with
    | Some loc -> loc
    | None -> make_ghost_loc (dummy_loc ())
  in
  Exp.extension ~loc ~attrs:ext_attrs extension

(* There's no more need for these functions - this was for the following:
 *
 *     fun % ext [@foo] arg => arg;
 *
 *   Becoming
 *
 *     [%ext  (fun arg => arg) [@foo]]
 *
 *   Which we no longer support.
 *)
(* Applies the attributes to the body, then wraps entire thing in an extension
 * expression, whose payload consists of a single structure item that is body
 *)
(* let wrap_exp_attrs body (ext, attrs) = *)
(*   (* todo: keep exact location for the entire attribute *) *)
(*   let body = {body with pexp_attributes = attrs @ body.pexp_attributes} in *)
(*   match ext with *)
(*   | None -> body *)
(*   | Some id -> mkexp ~ghost:true (Pexp_extension (id, PStr [mkstrexp body []])) *)

(* Why not just mkexp with the right attributes in the first place? *)
(* let mkexp_attrs d attrs = *)
(*   wrap_exp_attrs (mkexp d) attrs *)

let mkcf_attrs ?(loc=dummy_loc()) d attrs =
  Cf.mk ~loc ~attrs d

let mkctf_attrs d attrs =
  Ctf.mk ~attrs d

type let_bindings =
  { lbs_bindings: Parsetree.value_binding list;
    lbs_rec: rec_flag;
    lbs_extension: (attributes * string Asttypes.loc) option;
    lbs_loc: Location.t }

let mklbs ext rf lb loc =
  { lbs_bindings = [lb];
    lbs_rec = rf;
    lbs_extension = ext;
    lbs_loc = loc; }

let addlbs lbs lbs' =
  { lbs with lbs_bindings = lbs.lbs_bindings @ lbs' }

let val_of_let_bindings lbs =
  let str = Str.value lbs.lbs_rec lbs.lbs_bindings in
  match lbs.lbs_extension with
  | None -> str
  | Some ext -> struct_item_extension ext [str]

let expr_of_let_bindings ~loc lbs body =
    let item_expr = Exp.let_ ~loc lbs.lbs_rec lbs.lbs_bindings body in
    match lbs.lbs_extension with
    | None -> item_expr
    | Some ext -> expression_extension ~loc:(make_ghost_loc loc) ext item_expr

let class_of_let_bindings lbs body =
  if lbs.lbs_extension <> None then
    raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "extension")));
  Cl.let_ lbs.lbs_rec lbs.lbs_bindings body

(*
 * arity_conflict_resolving_mapper is triggered when both "implicit_arity" "explicit_arity"
 * are in the attribtues. In that case we have to remove "explicit_arity"
 *
 * However, if we simply remove explicit_arity, we would end up with a
 * wrapping tuple which has only one component (inner tuple).
 * This is against the invariance where tuples must have 2+ components.
 * Therefore, in the case we have to remove explicit_arity, we also need to
 * unwrap the tuple to expose the inner tuple directly.
 *
 *)
let arity_conflict_resolving_mapper super =
{ super with
  expr = begin fun mapper expr ->
    match expr with
      | {pexp_desc=Pexp_construct(lid, args);
         pexp_loc;
         pexp_attributes} when attributes_conflicted "implicit_arity" "explicit_arity" pexp_attributes ->
         let new_args =
           match args with
             | Some {pexp_desc = Pexp_tuple [sp]} -> Some sp
             | _ -> args in
         super.expr mapper
         {pexp_desc=Pexp_construct(lid, new_args); pexp_loc; pexp_attributes=
          normalized_attributes "explicit_arity" pexp_attributes}
      | x -> super.expr mapper x
  end;
  pat = begin fun mapper pattern ->
    match pattern with
      | {ppat_desc=Ppat_construct(lid, args);
         ppat_loc;
         ppat_attributes} when attributes_conflicted "implicit_arity" "explicit_arity" ppat_attributes ->
         let new_args =
           match args with
             | Some {ppat_desc = Ppat_tuple [sp]} -> Some sp
             | _ -> args in
         super.pat mapper
         {ppat_desc=Ppat_construct(lid, new_args); ppat_loc; ppat_attributes=
          normalized_attributes "explicit_arity" ppat_attributes}
      | x -> super.pat mapper x
  end;
}

let reason_mapper =
  default_mapper
  |> reason_to_ml_swap_operator_mapper
  |> arity_conflict_resolving_mapper

let rewriteFunctorApp module_name elt loc =
  let rec applies = function
    | Lident _ -> false
    | Ldot (m, _) -> applies m
    | Lapply (_, _) -> true in
  let rec flattenModName = function
    | Lident id -> id
    | Ldot (m, id) -> flattenModName m ^ "." ^ id
    | Lapply (m1, m2) -> flattenModName m1 ^ "(" ^ flattenModName m2 ^ ")" in
  let rec mkModExp = function
    | Lident id -> mkmod ~loc (Pmod_ident {txt=Lident id; loc})
    | Ldot (m, id) -> mkmod ~loc (Pmod_ident {txt=Ldot (m, id); loc})
    | Lapply (m1, m2) -> mkmod ~loc (Pmod_apply (mkModExp m1, mkModExp m2)) in
  if applies module_name then
    let flat = flattenModName module_name in
    mkexp ~loc (Pexp_letmodule({txt=flat; loc},
                         mkModExp module_name,
                         mkexp(Pexp_ident {txt=Ldot (Lident flat, elt); loc})))
  else
    mkexp ~loc (Pexp_ident {txt=Ldot (module_name, elt); loc})

let jsx_component module_name attrs children loc =
  let rec getFirstPart = function
    | Lident fp -> fp
    | Ldot (fp, _) -> getFirstPart fp
    | Lapply (fp, _) -> getFirstPart fp in
  let firstPart = getFirstPart module_name.txt in
  let element_fn = if String.get firstPart 0 != '_' && firstPart = String.capitalize_ascii firstPart then
    (* firstPart will be non-empty so the 0th access is fine. Modules can't start with underscore *)
    rewriteFunctorApp module_name.txt "createElement" module_name.loc
  else
    mkexp ~loc:module_name.loc (Pexp_ident(mkloc (Lident firstPart) module_name.loc))
  in
  let body = mkexp(Pexp_apply(element_fn, attrs @ children)) ~loc in
  let attribute = ({txt = "JSX"; loc = loc}, PStr []) in
  { body with pexp_attributes = attribute :: body.pexp_attributes }

(* We might raise some custom error messages in this file.
  Do _not_ directly raise a Location.Error. Our public interface guarantees that we only throw Syntaxerr or Reason_syntax_util.Error *)
let raiseSyntaxErrorFromSyntaxUtils loc fmt =
  Printf.ksprintf
    (fun msg -> raise Reason_syntax_util.(Error(loc, (Syntax_error msg))))
    fmt

let rec ignoreLapply = function
  | Lident id -> Lident id
  | Ldot (lid, id) -> Ldot (ignoreLapply lid, id)
  | Lapply (m1, _) -> ignoreLapply m1

(* Like Longident.flatten, but ignores `Lapply`s. Useful because 1) we don't want to require `Lapply` in
   closing tags, and 2) Longident.flatten doesn't support `Lapply`. *)
let rec flattenWithoutLapply = function
  | Lident id -> [id]
  | Ldot (lid, id) -> flattenWithoutLapply lid @ [id]
  | Lapply (m1, _) -> flattenWithoutLapply m1

let ensureTagsAreEqual startTag endTag loc =
  if ignoreLapply startTag <> endTag then
     let startTag = (String.concat "" (flattenWithoutLapply startTag)) in
     let endTag = (String.concat "" (flattenWithoutLapply endTag)) in
     raiseSyntaxErrorFromSyntaxUtils loc
      "Start tag <%s> does not match end tag </%s>" startTag endTag

(* `{. "foo": bar}` -> `Js.t {. foo: bar}` and {.. "foo": bar} -> `Js.t {.. foo: bar} *)
let mkBsObjTypeSugar ~loc ~closed rows =
  let obj = mktyp ~loc (Ptyp_object (rows, closed)) in
  let jsDotTCtor = { txt = Longident.Ldot (Longident.Lident "Js", "t"); loc } in
  mktyp(Ptyp_constr(jsDotTCtor, [obj]))

let doc_loc loc = {txt = "ocaml.doc"; loc = loc}

let doc_attr text loc =
  let open Parsetree in
  let exp =
    { pexp_desc = Pexp_constant (Pconst_string(text, None));
      pexp_loc = loc;
      pexp_attributes = []; }
  in
  let item =
    { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
  in
    (doc_loc loc, PStr [item])

let prepend_attrs_to_labels attrs = function
  | [] -> [] (* not possible for valid inputs *)
  | x :: xs -> {x with pld_attributes = attrs @ x.pld_attributes} :: xs

let raise_record_trailing_semi_error loc =
  let msg = "Record entries are separated by comma; we've found a semicolon instead." in
  raise Reason_syntax_util.(Error(loc, (Syntax_error msg)))

let record_exp_spread_msg =
  "Records can only have one `...` spread, at the beginning.
Explanation: since records have a known, fixed shape, a spread like `{a, ...b}` wouldn't make sense, as `b` would override every field of `a` anyway."

let record_pat_spread_msg =
  "Record's `...` spread is not supported in pattern matches.
Explanation: you can't collect a subset of a record's field into its own record, since a record needs an explicit declaration and that subset wouldn't have one.
Solution: you need to pull out each field you want explicitly."

let lowercase_module_msg =
  Printf.sprintf "Module names must start with an uppercase letter."

(* Handles "over"-parsing of spread syntax with `opt_spread`.
 * The grammar allows a spread operator at every position, when
 * generating the parsetree we raise a helpful error message. *)
let filter_raise_spread_syntax msg nodes =
  List.map (fun (dotdotdot, node) ->
    match dotdotdot with
    | Some dotdotdotLoc ->
        raise Reason_syntax_util.(Error(dotdotdotLoc, (Syntax_error msg)))
    | None -> node
    ) nodes

(*
 * See https://github.com/ocaml/ocaml/commit/e1e03820e5fea322aa3156721bc1cc0231668101
 * Rely on the parsing rules for generic module types, and then
 * extract a package type, enabling more explicit error messages
 * *)
let package_type_of_module_type pmty =
  let map_cstr = function
    | Pwith_type (lid, ptyp) ->
        let loc = ptyp.ptype_loc in
        if ptyp.ptype_params <> [] then
          err loc "parametrized types are not supported";
        if ptyp.ptype_cstrs <> [] then
          err loc "constrained types are not supported";
        if ptyp.ptype_private <> Public then
          err loc "private types are not supported";

        (* restrictions below are checked by the 'with_constraint' rule *)
        assert (ptyp.ptype_kind = Ptype_abstract);
        assert (ptyp.ptype_attributes = []);
        let ty =
          match ptyp.ptype_manifest with
          | Some ty -> ty
          | None -> assert false
        in
        (lid, ty)
    | _ ->
        err pmty.pmty_loc "only 'with type t =' constraints are supported"
  in
  match pmty with
  | {pmty_desc = Pmty_ident lid} -> (lid, [])
  | {pmty_desc = Pmty_with({pmty_desc = Pmty_ident lid}, cstrs)} ->
      (lid, List.map map_cstr cstrs)
  | _ ->
      err pmty.pmty_loc
        "only module type identifier and 'with type' constraints are supported"
%}
%start implementation
%start interface
%start parse_core_type
%start parse_expression
%start parse_pattern
%start toplevel_phrase
%start use_file
%token AMPERAMPER
%token AMPERSAND
%token AND
%token AS
%token ASSERT
%token BACKQUOTE
%token BANG
%token BAR
%token BARBAR
%token BARRBRACKET
%token BEGIN
%token <char> CHAR
%token CLASS
%token COLON
%token COLONCOLON
%token COLONEQUAL
%token COLONGREATER
%token COMMA
%token <string * Location.t> COMMENT
%token CONSTRAINT
%token DO
%token <string> DOCSTRING
%token DONE
%token DOT
%token DOTDOT
%token DOTDOTDOT
%token DOWNTO
%token ELSE
%token END
%token EOF
%token EOL
%token EQUAL
%token EQUALGREATER
%token ES6_FUN
%token EXCEPTION
%token EXTERNAL
%token FALSE
%token <string * char option> FLOAT
%token FOR
%token FUN
%token FUNCTION
%token FUNCTOR
%token GREATER
%token GREATERDOTDOTDOT
%token GREATERRBRACE
%token IF
%token IN
%token INCLUDE
%token <string> INFIXOP0
%token <string> INFIXOP1
%token <string> INFIXOP2
%token <string> INFIXOP3
%token <string> INFIXOP4
%token INHERIT
%token INITIALIZER
%token <string * char option> INT
%token LAZY
%token LBRACE
%token LBRACELESS
%token LBRACKET
%token LBRACKETAT
%token LBRACKETBAR
%token LBRACKETGREATER
%token LBRACKETLESS
%token LBRACKETPERCENT
%token LBRACKETPERCENTPERCENT
%token LESS
%token LESSDOTDOTGREATER
%token LESSGREATER
%token <string> LESSIDENT
%token LESSSLASHGREATER
%token <string> LESSSLASHIDENTGREATER
%token LET
%token <string> LIDENT
%token LPAREN
%token MINUS
%token MINUSDOT
%token MINUSGREATER
%token MODULE
%token MUTABLE
%token <nativeint> NATIVEINT
%token NEW
%token NONREC
%token OBJECT
%token OF
%token OPEN
%token OR
%token PERCENT
%token PLUS
%token PLUSDOT
%token PLUSEQ
%token <string> POSTFIXOP
%token <string> PREFIXOP
%token PRI
%token PUB
%token QUESTION
%token QUOTE
%token RBRACE
%token RBRACKET
%token REC
%token RPAREN
%token SEMI
%token SEMISEMI
%token SHARP
%token SHARPEQUAL
%token <string> SHARPOP
%token SIG
%token SLASHGREATER
%token STAR
%token <string * string option * string option> STRING
%token STRUCT
%token SWITCH
%token THEN
%token TILDE
%token TO
%token TRUE
%token TRY
%token TYPE
%token <string> UIDENT
%token UNDERSCORE
%token VAL
%token VIRTUAL
%token WHEN
%token WHILE
%token WITH
%nonassoc below_SEMI
%right EQUALGREATER
%right COLON
%right EQUAL
%right COLONEQUAL
%nonassoc QUESTION
%nonassoc WITH
%nonassoc AND
%nonassoc ELSE
%nonassoc AS
%nonassoc below_BAR
%left BAR
%right BARBAR OR
%right AMPERAMPER AMPERSAND
%left GREATER GREATERDOTDOTDOT INFIXOP0 LESS
%left LESSDOTDOTGREATER
%right INFIXOP1
%right COLONCOLON
%left INFIXOP2 MINUS MINUSDOT PLUS PLUSDOT PLUSEQ
%left INFIXOP3 PERCENT SLASHGREATER STAR
%right INFIXOP4
%nonassoc attribute_precedence
%nonassoc prec_unary
%nonassoc prec_constant_constructor
%nonassoc prec_constr_appl
%nonassoc below_DOT_AND_SHARP
%nonassoc SHARP
%nonassoc below_DOT
%left SHARPEQUAL
%nonassoc POSTFIXOP
%left DOT LBRACKET MINUSGREATER SHARPOP
%nonassoc LBRACE LBRACELESS LBRACKETLESS LPAREN
%type <Ast_404.Parsetree.structure> implementation
%type <Ast_404.Parsetree.signature> interface
%type <Ast_404.Parsetree.core_type> parse_core_type
%type <Ast_404.Parsetree.expression> parse_expression
%type <Ast_404.Parsetree.pattern> parse_pattern
%type <Ast_404.Parsetree.toplevel_phrase> toplevel_phrase
%type <Ast_404.Parsetree.toplevel_phrase list> use_file
%on_error_reduce constr_longident expr_optional_constraint fun_def_EQUAL_core_type_ fun_def_EQUALGREATER_non_arrowed_core_type_ let_binding_body nonempty_list_as_loc_attribute__ nonrec_flag option_SEMI_ pattern structure_item type_longident val_ident
%%

embedded___anonymous_0_:
  _1 = EOF
    {let x =                                      ( raise End_of_file) in
    ( x )}
| _1 = structure_item _2 = SEMI
    {let x =                                      ( Ptop_def _1 ) in
    ( x )}
| _1 = toplevel_directive _2 = SEMI
    {let x =                                      ( _1 ) in
    ( x )}

embedded___anonymous_1_:
  _1 = EOF
    {let x =                                    ( [] ) in
    ( x )}
| _1 = structure_item _2 = SEMI _3 = use_file_no_mapper
    {let x =                                                ( Ptop_def _1  :: _3 ) in
    ( x )}
| _1 = toplevel_directive _2 = SEMI _3 = use_file_no_mapper
    {let x =                                                ( _1 :: _3 ) in
    ( x )}
| _1 = structure_item _2 = EOF
    {let x =                                      ( [Ptop_def _1 ] ) in
    ( x )}
| _1 = toplevel_directive _2 = EOF
    {let x =                                      ( [_1] ) in
    ( x )}

embedded___anonymous_32_:
  _1 = QUOTE _2 = ident
    {let x =                       ( (mktyp (Ptyp_var _2) , Invariant    ) ) in
    ( x )}
| _1 = UNDERSCORE
    {let x =                       ( (mktyp (Ptyp_any)    , Invariant    ) ) in
    ( x )}
| _1 = PLUS _2 = QUOTE _3 = ident
    {let x =                       ( (mktyp (Ptyp_var _3) , Covariant    ) ) in
    ( x )}
| _1 = PLUS _2 = UNDERSCORE
    {let x =                       ( (mktyp (Ptyp_any)    , Covariant    ) ) in
    ( x )}
| _1 = MINUS _2 = QUOTE _3 = ident
    {let x =                       ( (mktyp (Ptyp_var _3) , Contravariant) ) in
    ( x )}
| _1 = MINUS _2 = UNDERSCORE
    {let x =                       ( (mktyp Ptyp_any      , Contravariant) ) in
    ( x )}

embedded___anonymous_38_:
  
    {let x =                           ( Pdir_none ) in
    ( x )}
| _1 = STRING
    {let x =                           ( let (s, _, _) = _1 in Pdir_string s ) in
    ( x )}
| _1 = INT
    {let x =                           ( let (n, m) = _1 in Pdir_int (n, m) ) in
    ( x )}
| _1 = val_longident
    {let x =                           ( Pdir_ident _1 ) in
    ( x )}
| _1 = mod_longident
    {let x =                           ( Pdir_ident _1 ) in
    ( x )}
| _1 = FALSE
    {let x =                           ( Pdir_bool false ) in
    ( x )}
| _1 = TRUE
    {let x =                           ( Pdir_bool true ) in
    ( x )}

embedded_private_flag_:
  
    {let x =                   ( Public ) in
    ( x )}
| _1 = PRI
    {let x =                   ( Private ) in
    ( x )}

option_COMMA_:
  
    {    ( None )}
| x = COMMA
    {    ( Some x )}

option_DOT_:
  
    {    ( None )}
| x = DOT
    {    ( Some x )}

option_DOTDOTDOT_:
  
    {    ( None )}
| x = DOTDOTDOT
    {    ( Some x )}

option_LET_:
  
    {    ( None )}
| x = LET
    {    ( Some x )}

option_MODULE_:
  
    {    ( None )}
| x = MODULE
    {    ( Some x )}

option_OF_:
  
    {    ( None )}
| x = OF
    {    ( Some x )}

option_SEMI_:
  
    {    ( None )}
| x = SEMI
    {    ( Some x )}

option_constructor_arguments_:
  
    {    ( None )}
| x = constructor_arguments
    {    ( Some x )}

option_item_extension_sugar_:
  
    {    ( None )}
| x = item_extension_sugar
    {    ( Some x )}

option_preceded_AS_LIDENT__:
  
    {    ( None )}
| _1 = AS x = LIDENT
    {let x =     ( x ) in
    ( Some x )}

option_preceded_COLON_class_constructor_type__:
  
    {    ( None )}
| _1 = COLON x = class_constructor_type
    {let x =     ( x ) in
    ( Some x )}

option_preceded_COLON_core_type__:
  
    {    ( None )}
| _1 = COLON x = core_type
    {let x =     ( x ) in
    ( Some x )}

option_preceded_COLON_expr__:
  
    {    ( None )}
| _1 = COLON x = expr
    {let x =     ( x ) in
    ( Some x )}

option_preceded_COLON_non_arrowed_core_type__:
  
    {    ( None )}
| _1 = COLON x = non_arrowed_core_type
    {let x =     ( x ) in
    ( Some x )}

option_preceded_COLON_poly_type__:
  
    {    ( None )}
| _1 = COLON x = poly_type
    {let x =     ( x ) in
    ( Some x )}

option_preceded_COLON_simple_module_type__:
  
    {    ( None )}
| _1 = COLON x = simple_module_type
    {let x =     ( x ) in
    ( Some x )}

option_preceded_COLONGREATER_core_type__:
  
    {    ( None )}
| _1 = COLONGREATER x = core_type
    {let x =     ( x ) in
    ( Some x )}

option_preceded_WHEN_expr__:
  
    {    ( None )}
| _1 = WHEN x = expr
    {let x =     ( x ) in
    ( Some x )}

option_type_constraint_:
  
    {    ( None )}
| x = type_constraint
    {    ( Some x )}

boption_AMPERSAND_:
  
    {    ( false )}
| _1 = AMPERSAND
    {    ( true )}

loption_class_type_parameters_:
  
    {    ( [] )}
| _1 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_type_parameter_ _2 = option_COMMA_ _3 = RPAREN
    {let x =
  let _1 =
    let _1 =
      let x =
        let _1 = _1_inlined1 in
        let _1 =                                        ( List.rev _1 ) in
                                                                     (_1)
      in
          ( x )
    in
                                                           ( _1 )
  in
    ( _1 )
in
    ( x )}

loption_functor_parameters_:
  
    {    ( [] )}
| x = functor_parameters
    {    ( x )}

loption_located_attributes_:
  
    {    ( [] )}
| _1 = nonempty_list_as_loc_attribute__
    {let x =                                                ( _1 ) in
    ( x )}

loption_object_label_declarations_:
  
    {    ( [] )}
| x = object_label_declarations
    {    ( x )}

loption_parenthesized_class_type_arguments_comma_list__:
  
    {    ( [] )}
| _1 = LPAREN x = class_type_arguments_comma_list _3 = RPAREN
    {let x =
  let _1 =     ( x ) in
                                                         ( _1 )
in
    ( x )}

loption_parenthesized_type_variables_with_variance_comma_list__:
  
    {    ( [] )}
| _1 = LPAREN x = type_variables_with_variance_comma_list _3 = RPAREN
    {let x =
  let _1 =     ( x ) in
                                                         ( _1 )
in
    ( x )}

loption_preceded_GREATER_nonempty_list_name_tag___:
  
    {    ( [] )}
| _1 = GREATER x = nonempty_list_name_tag_
    {let x =     ( x ) in
    ( x )}

loption_row_field_list_:
  
    {    ( [] )}
| x = row_field_list
    {    ( x )}

loption_terminated_pattern_comma_list_option_COMMA___:
  
    {    ( [] )}
| _1 = lseparated_nonempty_list_aux_COMMA_opt_spread_pattern__ _2 = option_COMMA_
    {let x =
  let x =
    let _1 =                                        ( List.rev _1 ) in
      ( let msg = "Array's `...` spread is not supported in pattern matches.
Explanation: such spread would create a subarray; out of performance concern, our pattern matching currently guarantees to never create new intermediate data.
Solution: if it's to validate the first few elements, use a `when` clause + Array size check + `get` checks on the current pattern. If it's to obtain a subarray, use `Array.sub` or `Belt.Array.slice`." in
    filter_raise_spread_syntax msg _1 )
  in
      ( x )
in
    ( x )}

loption_type_parameters_:
  
    {    ( [] )}
| x = type_parameters
    {    ( x )}

list_and_class_declaration_:
  
    {    ( [] )}
| x = and_class_declaration xs = list_and_class_declaration_
    {    ( x :: xs )}

list_and_class_description_:
  
    {    ( [] )}
| x = and_class_description xs = list_and_class_description_
    {    ( x :: xs )}

list_and_class_type_declaration_:
  
    {    ( [] )}
| x = and_class_type_declaration xs = list_and_class_type_declaration_
    {    ( x :: xs )}

list_and_let_binding_:
  
    {    ( [] )}
| _2 = AND _3 = let_binding_body xs = list_and_let_binding_
    {let x =
  let _1 =     ( [] ) in
  let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
  let _endpos = _endpos__3_ in
  let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
    _startpos__1_
  else
    _startpos__2_ in
    ( let pat, expr = _3 in
    Vb.mk ~loc:(mklocation _symbolstartpos _endpos) ~attrs:_1 pat expr )
in
    ( x :: xs )}
| _1 = nonempty_list_as_loc_attribute__ _2 = AND _3 = let_binding_body xs = list_and_let_binding_
    {let x =
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _endpos = _endpos__3_ in
  let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
    _startpos__1_
  else
    _startpos__2_ in
    ( let pat, expr = _3 in
    Vb.mk ~loc:(mklocation _symbolstartpos _endpos) ~attrs:_1 pat expr )
in
    ( x :: xs )}

list_and_module_bindings_:
  
    {    ( [] )}
| x = and_module_bindings xs = list_and_module_bindings_
    {    ( x :: xs )}

list_and_module_rec_declaration_:
  
    {    ( [] )}
| x = and_module_rec_declaration xs = list_and_module_rec_declaration_
    {    ( x :: xs )}

list_attributed_ext_constructor_either_extension_constructor_declaration_extension_constructor_rebind___:
  
    {    ( [] )}
| _2 = BAR _4 = either_extension_constructor_declaration_extension_constructor_rebind_ xs = list_attributed_ext_constructor_either_extension_constructor_declaration_extension_constructor_rebind___
    {let x =
  let _3 =     ( [] ) in
  let _1 =     ( [] ) in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}
| _2 = BAR _1 = nonempty_list_as_loc_attribute__ _4 = either_extension_constructor_declaration_extension_constructor_rebind_ xs = list_attributed_ext_constructor_either_extension_constructor_declaration_extension_constructor_rebind___
    {let x =
  let _3 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _1 =     ( [] ) in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _4 = either_extension_constructor_declaration_extension_constructor_rebind_ xs = list_attributed_ext_constructor_either_extension_constructor_declaration_extension_constructor_rebind___
    {let x =
  let _3 =     ( [] ) in
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _1_inlined1 = nonempty_list_as_loc_attribute__ _4 = either_extension_constructor_declaration_extension_constructor_rebind_ xs = list_attributed_ext_constructor_either_extension_constructor_declaration_extension_constructor_rebind___
    {let x =
  let _3 =
    let _1 = _1_inlined1 in
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}

list_attributed_ext_constructor_extension_constructor_declaration__:
  
    {    ( [] )}
| _2 = BAR _4 = extension_constructor_declaration xs = list_attributed_ext_constructor_extension_constructor_declaration__
    {let x =
  let _3 =     ( [] ) in
  let _1 =     ( [] ) in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}
| _2 = BAR _1 = nonempty_list_as_loc_attribute__ _4 = extension_constructor_declaration xs = list_attributed_ext_constructor_extension_constructor_declaration__
    {let x =
  let _3 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _1 =     ( [] ) in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _4 = extension_constructor_declaration xs = list_attributed_ext_constructor_extension_constructor_declaration__
    {let x =
  let _3 =     ( [] ) in
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _1_inlined1 = nonempty_list_as_loc_attribute__ _4 = extension_constructor_declaration xs = list_attributed_ext_constructor_extension_constructor_declaration__
    {let x =
  let _3 =
    let _1 = _1_inlined1 in
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}

list_bar_row_field_:
  
    {    ( [] )}
| x = bar_row_field xs = list_bar_row_field_
    {    ( x :: xs )}

list_simple_expr_no_call_:
  
    {    ( [] )}
| x = simple_expr_no_call xs = list_simple_expr_no_call_
    {    ( x :: xs )}

nonempty_list_LIDENT_:
  x = LIDENT
    {    ( [ x ] )}
| x = LIDENT xs = nonempty_list_LIDENT_
    {    ( x :: xs )}

nonempty_list___anonymous_31_:
  _1 = STRING
    {let x =                                             ( let (s, _, _) = _1 in s ) in
    ( [ x ] )}
| _1 = STRING xs = nonempty_list___anonymous_31_
    {let x =                                             ( let (s, _, _) = _1 in s ) in
    ( x :: xs )}

nonempty_list_as_loc_attribute__:
  x = attribute
    {let x =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( [ x ] )}
| x = attribute xs = nonempty_list_as_loc_attribute__
    {let x =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( x :: xs )}

nonempty_list_attributed_ext_constructor_either_extension_constructor_declaration_extension_constructor_rebind___:
  _2 = BAR _4 = either_extension_constructor_declaration_extension_constructor_rebind_
    {let x =
  let _3 =     ( [] ) in
  let _1 =     ( [] ) in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( [ x ] )}
| _2 = BAR _1 = nonempty_list_as_loc_attribute__ _4 = either_extension_constructor_declaration_extension_constructor_rebind_
    {let x =
  let _3 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _1 =     ( [] ) in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( [ x ] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _4 = either_extension_constructor_declaration_extension_constructor_rebind_
    {let x =
  let _3 =     ( [] ) in
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( [ x ] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _1_inlined1 = nonempty_list_as_loc_attribute__ _4 = either_extension_constructor_declaration_extension_constructor_rebind_
    {let x =
  let _3 =
    let _1 = _1_inlined1 in
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( [ x ] )}
| _2 = BAR _4 = either_extension_constructor_declaration_extension_constructor_rebind_ xs = nonempty_list_attributed_ext_constructor_either_extension_constructor_declaration_extension_constructor_rebind___
    {let x =
  let _3 =     ( [] ) in
  let _1 =     ( [] ) in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}
| _2 = BAR _1 = nonempty_list_as_loc_attribute__ _4 = either_extension_constructor_declaration_extension_constructor_rebind_ xs = nonempty_list_attributed_ext_constructor_either_extension_constructor_declaration_extension_constructor_rebind___
    {let x =
  let _3 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _1 =     ( [] ) in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _4 = either_extension_constructor_declaration_extension_constructor_rebind_ xs = nonempty_list_attributed_ext_constructor_either_extension_constructor_declaration_extension_constructor_rebind___
    {let x =
  let _3 =     ( [] ) in
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _1_inlined1 = nonempty_list_as_loc_attribute__ _4 = either_extension_constructor_declaration_extension_constructor_rebind_ xs = nonempty_list_attributed_ext_constructor_either_extension_constructor_declaration_extension_constructor_rebind___
    {let x =
  let _3 =
    let _1 = _1_inlined1 in
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}

nonempty_list_attributed_ext_constructor_extension_constructor_declaration__:
  _2 = BAR _4 = extension_constructor_declaration
    {let x =
  let _3 =     ( [] ) in
  let _1 =     ( [] ) in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( [ x ] )}
| _2 = BAR _1 = nonempty_list_as_loc_attribute__ _4 = extension_constructor_declaration
    {let x =
  let _3 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _1 =     ( [] ) in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( [ x ] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _4 = extension_constructor_declaration
    {let x =
  let _3 =     ( [] ) in
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( [ x ] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _1_inlined1 = nonempty_list_as_loc_attribute__ _4 = extension_constructor_declaration
    {let x =
  let _3 =
    let _1 = _1_inlined1 in
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( [ x ] )}
| _2 = BAR _4 = extension_constructor_declaration xs = nonempty_list_attributed_ext_constructor_extension_constructor_declaration__
    {let x =
  let _3 =     ( [] ) in
  let _1 =     ( [] ) in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}
| _2 = BAR _1 = nonempty_list_as_loc_attribute__ _4 = extension_constructor_declaration xs = nonempty_list_attributed_ext_constructor_extension_constructor_declaration__
    {let x =
  let _3 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _1 =     ( [] ) in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _4 = extension_constructor_declaration xs = nonempty_list_attributed_ext_constructor_extension_constructor_declaration__
    {let x =
  let _3 =     ( [] ) in
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _1_inlined1 = nonempty_list_as_loc_attribute__ _4 = extension_constructor_declaration xs = nonempty_list_attributed_ext_constructor_extension_constructor_declaration__
    {let x =
  let _3 =
    let _1 = _1_inlined1 in
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
  let _1 =
    let _1 =                                                ( _1 ) in
                           ( List.map (fun x -> x.txt) _1 )
  in
                                          ( {_4 with pext_attributes = List.concat [_1; _3; _4.pext_attributes]} )
in
    ( x :: xs )}

nonempty_list_name_tag_:
  _1 = BACKQUOTE _2 = ident
    {let x =                                   ( _2 ) in
    ( [ x ] )}
| _1 = BACKQUOTE _2 = ident xs = nonempty_list_name_tag_
    {let x =                                   ( _2 ) in
    ( x :: xs )}

nonempty_list_preceded_CONSTRAINT_constrain__:
  _1 = CONSTRAINT x = constrain
    {let x =     ( x ) in
    ( [ x ] )}
| _1 = CONSTRAINT x = constrain xs = nonempty_list_preceded_CONSTRAINT_constrain__
    {let x =     ( x ) in
    ( x :: xs )}

nonempty_list_preceded_QUOTE_ident__:
  _1 = QUOTE x = ident
    {let x =     ( x ) in
    ( [ x ] )}
| _1 = QUOTE x = ident xs = nonempty_list_preceded_QUOTE_ident__
    {let x =     ( x ) in
    ( x :: xs )}

separated_nonempty_list_AMPERSAND_non_arrowed_simple_core_types_:
  x = non_arrowed_simple_core_types
    {    ( [ x ] )}
| x = non_arrowed_simple_core_types _2 = AMPERSAND xs = separated_nonempty_list_AMPERSAND_non_arrowed_simple_core_types_
    {    ( x :: xs )}

implementation:
  _1 = structure _2 = EOF
    {  ( apply_mapper_to_structure _1 reason_mapper )}

interface:
  _1 = signature _2 = EOF
    {  ( apply_mapper_to_signature _1 reason_mapper )}

toplevel_phrase:
  _1 = embedded___anonymous_0_
    {    ( apply_mapper_to_toplevel_phrase _1 reason_mapper )}

use_file_no_mapper:
  _1 = embedded___anonymous_1_
    {    ( _1 )}

use_file:
  _1 = use_file_no_mapper
    {                     ( apply_mapper_to_use_file _1 reason_mapper )}

parse_core_type:
  _1 = core_type _2 = EOF
    {  ( apply_mapper_to_type _1 reason_mapper )}

parse_expression:
  _1 = expr _2 = EOF
    {  ( apply_mapper_to_expr _1 reason_mapper )}

parse_pattern:
  _1 = pattern _2 = EOF
    {  ( apply_mapper_to_pattern _1 reason_mapper )}

module_parameter:
  _1 = LPAREN _2 = RPAREN
    {let _1 =
  let x =
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
        ( (Some (mkloc "*" (mklocation _startpos _endpos)), None) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (_1)}
| _1 = UIDENT _2 = COLON _3 = module_type
    {let _1 =
  let x =
    let _1 =
      let x =                   (_1) in
      let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( (Some _1, Some _3) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (_1)}
| _1 = UNDERSCORE _2 = COLON _3 = module_type
    {let _1 =
  let x =
    let _1 =
      let x =                                     ("_") in
      let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( (Some _1, Some _3) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (_1)}
| _1 = module_type
    {let _1 =
  let x =     ( (None, Some _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (_1)}

functor_parameters:
  _1 = LPAREN _2 = RPAREN
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
    ( let loc = mklocation _startpos _endpos in
      [mkloc (Some (mkloc "*" loc), None) loc]
    )}
| _1 = LPAREN _2 = module_parameter _3 = RPAREN
    {                                   ([_2])}
| _1 = LPAREN _2 = module_parameter _3 = COMMA _4 = RPAREN
    {                                         ([_2])}
| _1 = LPAREN _1_inlined1 = module_parameter _2_inlined1 = COMMA _1_inlined2 = lseparated_nonempty_list_aux_COMMA_module_parameter_ _2 = option_COMMA_ _3 = RPAREN
    {let _1 =
  let _1 =
    let x =
      let (_1_inlined1, _1) = (_1_inlined2, _1_inlined1) in
      let _1 =
        let _3 =
          let _1 = _1_inlined1 in
                                                 ( List.rev _1 )
        in
                                                 ( _1 :: _3 )
      in
                                                               (_1)
    in
        ( x )
  in
                                                         ( _1 )
in
                                                            ( _1 )}

module_complex_expr:
  _1 = module_expr
    {let _1 =
  let x =     ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = module_expr _2 = COLON _3 = module_type
    {let _1 =
  let x =     ( mkmod(Pmod_constraint(_1, _3)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = VAL _2 = expr
    {let _1 =
  let x =     ( mkmod(Pmod_unpack _2) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = VAL _2 = expr _3 = COLON _4 = option_MODULE_ _5 = package_type
    {let _1 =
  let x =
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      mkmod (Pmod_unpack(
           mkexp ~ghost:true ~loc (Pexp_constraint(_2, (mktyp ~ghost:true ~loc (Ptyp_package _5))))))
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = VAL _2 = expr _3 = COLON _4 = option_MODULE_ _5 = package_type _6 = COLONGREATER _7 = option_MODULE_ _8 = package_type
    {let _1 =
  let x =
    let _endpos = _endpos__8_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      mkmod (Pmod_unpack(
             mkexp ~ghost:true ~loc (Pexp_coerce(_2, Some(mktyp ~ghost:true ~loc (Ptyp_package _5)),
                                    mktyp ~ghost:true ~loc (Ptyp_package _8))))) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__8_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = VAL _2 = expr _3 = COLONGREATER _4 = option_MODULE_ _5 = package_type
    {let _1 =
  let x =
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos and ghost = true in
      let mty = mktyp ~ghost ~loc (Ptyp_package _5) in
      mkmod (Pmod_unpack(mkexp ~ghost ~loc (Pexp_coerce(_2, None, mty))))
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

module_arguments_comma_list:
  _2 = option_COMMA_
    {let _1 =                 ( [] ) in
                                                     (_1)}
| _1 = lseparated_nonempty_list_aux_COMMA_module_complex_expr_ _2 = option_COMMA_
    {let _1 =
  let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
in
                                                     (_1)}

module_arguments:
  _1 = module_expr_structure
    {                          ( [_1] )}
| _1 = LPAREN x = module_arguments_comma_list _3 = RPAREN
    {let _1 =
  let _1 =     ( x ) in
                                                         ( _1 )
in
let _endpos__1_ = _endpos__3_ in
let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
    ( match _1 with
      | [] -> [mkmod ~loc:(mklocation _startpos _endpos) (Pmod_structure [])]
      | xs -> xs
    )}

module_expr_body:
  _1 = EQUAL x = module_expr
    {let _1 =     ( x ) in
                                                                      ( _1 )}
| _1 = module_expr_structure
    {                                                                      ( _1 )}

module_expr_structure:
  _1 = LBRACE _2 = structure _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( mkmod ~loc:(mklocation _startpos _endpos) (Pmod_structure(_2)) )}

module_expr:
  x = mod_longident
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkmod(Pmod_ident _1) )
  in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = module_expr_structure
    {let _1 =
  let x =                           ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LPAREN _2 = module_expr _3 = COLON _4 = module_type x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_mod (with_txt _1 "(") (with_txt _5 ")"))
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LPAREN _2 = module_complex_expr _3 = RPAREN
    {let _1 =
  let x =     ( _2 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LPAREN _2 = RPAREN
    {let _1 =
  let x =     ( mkmod (Pmod_structure []) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = extension
    {let _1 =
  let x =     ( mkmod (Pmod_extension _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = either_ES6_FUN_FUN_ _2 = functor_parameters _3 = option_preceded_COLON_simple_module_type__ _4 = EQUALGREATER _5 = module_expr
    {let _1 =
  let x =
    let _endpos = _endpos__5_ in
        ( let me = match _3 with
        | None -> _5
        | Some mt ->
          let loc = mklocation _startpos__3_ _endpos in
          mkmod ~loc (Pmod_constraint(_5, mt))
      in
      mk_functor_mod _2 me
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = module_expr _2 = module_arguments
    {let _1 =
  let x =     ( List.fold_left mkmod_app _1 _2 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = module_expr x = LPAREN _3 = module_expr x_inlined1 = error
    {let _1 =
  let x =
    let _4 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_mod (with_txt _2 "(") (with_txt _4 ")") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LPAREN _2 = module_expr x_inlined1 = error
    {let _1 =
  let x =
    let _3 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_mod (with_txt _1 "(") (with_txt _3 ")") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LPAREN _2 = VAL _3 = expr _4 = COLON x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_mod (with_txt _1 "(") (with_txt _5 ")") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LPAREN _2 = VAL _3 = expr _4 = COLONGREATER x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_mod (with_txt _1 "(") (with_txt _5 ")") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LPAREN _2 = VAL _3 = expr x_inlined1 = error
    {let _1 =
  let x =
    let _4 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_mod (with_txt _1 "(") (with_txt _4 ")") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = attribute _2 = module_expr %prec attribute_precedence
    {let _1 =
  let x =     ( {_2 with pmod_attributes = _1 :: _2.pmod_attributes} ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

structure:
  
    {                ( [] )}
| _1 = structure_item
    {                   ( _1 )}
| _1 = structure_item _2 = SEMI _3 = structure
    {                                  ( _1 @ _3 )}
| x = error _2 = structure
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( let menhirError = Reason_syntax_util.findMenhirErrorMessage _1.loc in
      match menhirError with
      | MenhirMessagesError errMessage -> (syntax_error_str errMessage.loc errMessage.msg) :: _2
      | _ -> (syntax_error_str _1.loc "Invalid statement") :: _2
    )}
| x = error _2 = SEMI _3 = structure
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( let menhirError = Reason_syntax_util.findMenhirErrorMessage _1.loc in
      match menhirError with
      | MenhirMessagesError errMessage -> (syntax_error_str errMessage.loc errMessage.msg) :: _3
      | _ -> (syntax_error_str _1.loc "Invalid statement") :: _3
    )}
| x = structure_item _2 = error _3 = structure
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( let menhirError = Reason_syntax_util.findMenhirErrorMessage _1.loc in
      match menhirError with
      | MenhirMessagesError errMessage -> (syntax_error_str errMessage.loc errMessage.msg) :: _3
      | _ -> (syntax_error_str _1.loc "Statement has to end with a semicolon") :: _3
    )}

opt_LET_MODULE_ident:
  _1 = opt_LET_MODULE x = UIDENT
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                  ( _2 )}
| _1 = opt_LET_MODULE x = LIDENT
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( let {loc} = _2 in
      err loc lowercase_module_msg )}

opt_LET_MODULE_REC_ident:
  _1 = opt_LET_MODULE _2 = REC x = UIDENT
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                      ( _3 )}
| _1 = opt_LET_MODULE _2 = REC x = LIDENT
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( let {loc} = _3 in
      err loc lowercase_module_msg )}

structure_item:
  _2 = unattributed_expr
    {let _1 =
  let x =
    let _1 =     ( [] ) in
          ( mkstrexp _2 _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = unattributed_expr
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkstrexp _2 _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = item_extension_sugar _3 = structure_item
    {let _1 =
  let x =
    let _1 =     ( [] ) in
          ( let (ext_attrs, ext_id) = _2 in
        struct_item_extension (_1@ext_attrs, ext_id) _3 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = item_extension_sugar _3 = structure_item
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( let (ext_attrs, ext_id) = _2 in
        struct_item_extension (_1@ext_attrs, ext_id) _3 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = EXTERNAL x = val_ident _4 = COLON _5 = core_type _6 = EQUAL _7 = primitive_declaration
    {let _1 =
  let x =
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =     ( [] ) in
    let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos__7_ in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let loc = mklocation _symbolstartpos _endpos in
        mkstr (Pstr_primitive (Val.mk _3 _5 ~prim:_7 ~attrs:_1 ~loc)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__7_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = EXTERNAL x = val_ident _4 = COLON _5 = core_type _6 = EQUAL _7 = primitive_declaration
    {let _1 =
  let x =
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
    let _endpos = _endpos__7_ in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let loc = mklocation _symbolstartpos _endpos in
        mkstr (Pstr_primitive (Val.mk _3 _5 ~prim:_7 ~attrs:_1 ~loc)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__7_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = type_declarations
    {let _1 =
  let x =       ( let (nonrec_flag, tyl) = _1 in mkstr(Pstr_type (nonrec_flag, tyl)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = str_type_extension
    {let _1 =
  let x =       ( mkstr(Pstr_typext _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = str_exception_declaration
    {let _1 =
  let x =       ( mkstr(Pstr_exception _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = opt_LET_MODULE_ident _3 = module_binding_body
    {let _1 =
  let x =
    let _1 =     ( [] ) in
    let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos__3_ in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let loc = mklocation _symbolstartpos _endpos in
        mkstr(Pstr_module (Mb.mk _2 _3 ~attrs:_1 ~loc)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = opt_LET_MODULE_ident _3 = module_binding_body
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
    let _endpos = _endpos__3_ in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let loc = mklocation _symbolstartpos _endpos in
        mkstr(Pstr_module (Mb.mk _2 _3 ~attrs:_1 ~loc)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = opt_LET_MODULE_REC_ident _3 = module_binding_body _4 = list_and_module_bindings_
    {let _1 =
  let x =
    let _1 =     ( [] ) in
    let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let loc = mklocation _symbolstartpos _endpos__2_ in
        mkstr (Pstr_recmodule ((Mb.mk _2 _3 ~attrs:_1 ~loc) :: _4))
      )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = opt_LET_MODULE_REC_ident _3 = module_binding_body _4 = list_and_module_bindings_
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let loc = mklocation _symbolstartpos _endpos__2_ in
        mkstr (Pstr_recmodule ((Mb.mk _2 _3 ~attrs:_1 ~loc) :: _4))
      )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = MODULE _3 = TYPE _4 = option_OF_ x = ident
    {let _1 =
  let x =
    let _5 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _endpos__5_ = _endpos_x_ in
    let _1 =     ( [] ) in
    let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let loc = mklocation _symbolstartpos _endpos in
        mkstr(Pstr_modtype (Mtd.mk _5 ~attrs:_1 ~loc)) )
  in
  let _startpos_x_ = _startpos__2_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = MODULE _3 = TYPE _4 = option_OF_ x = ident
    {let _1 =
  let x =
    let _5 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _endpos__5_ = _endpos_x_ in
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let loc = mklocation _symbolstartpos _endpos in
        mkstr(Pstr_modtype (Mtd.mk _5 ~attrs:_1 ~loc)) )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = MODULE _3 = TYPE _4 = option_OF_ x = ident _6 = module_type_body_EQUAL_
    {let _1 =
  let x =
    let _5 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =     ( [] ) in
    let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos__6_ in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let loc = mklocation _symbolstartpos _endpos in
        mkstr(Pstr_modtype (Mtd.mk _5 ~typ:_6 ~attrs:_1 ~loc)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = MODULE _3 = TYPE _4 = option_OF_ x = ident _6 = module_type_body_EQUAL_
    {let _1 =
  let x =
    let _5 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
    let _endpos = _endpos__6_ in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let loc = mklocation _symbolstartpos _endpos in
        mkstr(Pstr_modtype (Mtd.mk _5 ~typ:_6 ~attrs:_1 ~loc)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = open_statement
    {let _1 =
  let x =       ( mkstr(Pstr_open _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = CLASS _3 = class_declaration_details _4 = list_and_class_declaration_
    {let _1 =
  let x =
    let _1 =     ( [] ) in
    let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let (ident, binding, virt, params) = _3 in
        let loc = mklocation _symbolstartpos _endpos__3_ in
        let first = Ci.mk ident binding ~virt ~params ~attrs:_1 ~loc in
        mkstr (Pstr_class (first :: _4))
      )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = CLASS _3 = class_declaration_details _4 = list_and_class_declaration_
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let (ident, binding, virt, params) = _3 in
        let loc = mklocation _symbolstartpos _endpos__3_ in
        let first = Ci.mk ident binding ~virt ~params ~attrs:_1 ~loc in
        mkstr (Pstr_class (first :: _4))
      )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = class_type_declarations
    {let _1 =
  let x =       ( mkstr(Pstr_class_type _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = INCLUDE _3 = module_expr
    {let _1 =
  let x =
    let _1 =     ( [] ) in
    let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
    let _endpos = _endpos__3_ in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let loc = mklocation _symbolstartpos _endpos in
        mkstr(Pstr_include (Incl.mk _3 ~attrs:_1 ~loc))
      )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = INCLUDE _3 = module_expr
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
    let _endpos = _endpos__3_ in
    let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
      _startpos__1_
    else
      _startpos__2_ in
          ( let loc = mklocation _symbolstartpos _endpos in
        mkstr(Pstr_include (Incl.mk _3 ~attrs:_1 ~loc))
      )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = item_extension
    {let _1 =
  let x =
    let _1 =     ( [] ) in
          ( mkstr(Pstr_extension (_2, _1)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = item_extension
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkstr(Pstr_extension (_2, _1)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = let_bindings
    {let _1 =
  let x =       ( val_of_let_bindings _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__
    {let _1 =                                                ( _1 ) in
   ( List.map (fun x -> mkstr ~loc:x.loc (Pstr_attribute x.txt)) _1 )}

module_binding_body:
  _1 = loption_functor_parameters_ _2 = module_expr_body
    {    ( mk_functor_mod _1 _2 )}
| _1 = loption_functor_parameters_ _2 = COLON _3 = module_type _4 = module_expr_body
    {    ( let loc = mklocation _startpos__3_ _endpos__4_ in
      mk_functor_mod _1 (mkmod ~loc (Pmod_constraint(_4, _3))) )}

and_module_bindings:
  _2 = AND x = UIDENT _4 = module_binding_body
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( Mb.mk _3 _4 ~attrs:_1 ~loc:(mklocation _symbolstartpos _endpos) )}
| _1 = nonempty_list_as_loc_attribute__ _2 = AND x = UIDENT _4 = module_binding_body
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( Mb.mk _3 _4 ~attrs:_1 ~loc:(mklocation _symbolstartpos _endpos) )}

simple_module_type:
  _1 = LPAREN x = module_parameter _3 = RPAREN
    {let _1 =
  let x =
    let _1 =
      let _1 =     ( x ) in
                                                             ( _1 )
    in
        ( match _1.txt with
      | (None, Some x) -> x
      | _ -> syntax_error_mod _1.loc "Expecting a simple module type"
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = module_type_signature
    {let _1 =
  let x =                           ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LPAREN _2 = module_type x_inlined1 = error
    {let _1 =
  let x =
    let _3 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_mty (with_txt _1 "(") (with_txt _3 ")"))
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = mty_longident
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkmty (Pmty_ident _1) )
  in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LBRACE _2 = signature x_inlined1 = error
    {let _1 =
  let x =
    let _3 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_mty (with_txt _1 "{") (with_txt _3 "}"))
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = extension
    {let _1 =
  let x =     ( mkmty (Pmty_extension _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

module_type_signature:
  _1 = LBRACE _2 = signature _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( mkmty ~loc:(mklocation _startpos _endpos) (Pmty_signature _2) )}

module_type:
  _1 = module_type _1_inlined1 = WITH _1_inlined2 = lseparated_nonempty_list_aux_AND_with_constraint_
    {let _1 =
  let x =
    let _2 =
      let _1_inlined1 = _1_inlined2 in
      let _2 =
        let _1 = _1_inlined1 in
                                               ( List.rev _1 )
      in
                                                            ( _2 )
    in
        ( mkmty (Pmty_with(_1, _2)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = simple_module_type
    {let _1 =
  let x =     (_1) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LPAREN _2 = MODULE _3 = TYPE _4 = OF _5 = module_expr _6 = RPAREN
    {let _1 =
  let x =     ( mkmty (Pmty_typeof _5) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = attribute _2 = module_type %prec attribute_precedence
    {let _1 =
  let x =     ( {_2 with pmty_attributes = _1 :: _2.pmty_attributes} ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = functor_parameters _2 = EQUALGREATER _3 = module_type %prec below_SEMI
    {let _1 =
  let x =     ( mk_functor_mty _1 _3 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

signature:
  
    {                ( [] )}
| _1 = signature_items
    {                    ( _1 )}
| _1 = signature_items _2 = SEMI _3 = signature
    {                                   ( _1 @ _3 )}

signature_item:
  _2 = LET x = val_ident _4 = COLON _5 = core_type
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =     ( [] ) in
let _endpos = _endpos__5_ in
    ( let loc = mklocation _startpos__2_ _endpos in
      Psig_value (Val.mk _3 _5 ~attrs:_1 ~loc)
    )}
| _1 = nonempty_list_as_loc_attribute__ _2 = LET x = val_ident _4 = COLON _5 = core_type
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__5_ in
    ( let loc = mklocation _startpos__2_ _endpos in
      Psig_value (Val.mk _3 _5 ~attrs:_1 ~loc)
    )}
| _2 = EXTERNAL x = val_ident _4 = COLON _5 = core_type _6 = EQUAL _7 = primitive_declaration
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Psig_value (Val.mk _3 _5 ~prim:_7 ~attrs:_1 ~loc)
    )}
| _1 = nonempty_list_as_loc_attribute__ _2 = EXTERNAL x = val_ident _4 = COLON _5 = core_type _6 = EQUAL _7 = primitive_declaration
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Psig_value (Val.mk _3 _5 ~prim:_7 ~attrs:_1 ~loc)
    )}
| _1 = type_declarations
    {    ( let (nonrec_flag, tyl) = _1 in Psig_type (nonrec_flag, tyl) )}
| _1 = sig_type_extension
    {    ( Psig_typext _1 )}
| _1 = sig_exception_declaration
    {    ( Psig_exception _1 )}
| _2 = opt_LET_MODULE_ident _3 = module_declaration
    {let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Psig_module (Md.mk _2 _3 ~attrs:_1 ~loc)
    )}
| _1 = nonempty_list_as_loc_attribute__ _2 = opt_LET_MODULE_ident _3 = module_declaration
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Psig_module (Md.mk _2 _3 ~attrs:_1 ~loc)
    )}
| _2 = opt_LET_MODULE_ident _3 = EQUAL x = mod_longident
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let (_endpos__4_, _startpos__4_) = (_endpos_x_, _startpos_x_) in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      let loc_mod = mklocation _startpos__4_ _endpos__4_ in
      Psig_module (
        Md.mk
            _2
            (Mty.alias ~loc:loc_mod _4)
            ~attrs:_1
            ~loc
            )
    )}
| _1 = nonempty_list_as_loc_attribute__ _2 = opt_LET_MODULE_ident _3 = EQUAL x = mod_longident
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let (_endpos__4_, _startpos__4_) = (_endpos_x_, _startpos_x_) in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      let loc_mod = mklocation _startpos__4_ _endpos__4_ in
      Psig_module (
        Md.mk
            _2
            (Mty.alias ~loc:loc_mod _4)
            ~attrs:_1
            ~loc
            )
    )}
| _2 = opt_LET_MODULE_REC_ident _3 = module_type_body_COLON_ _4 = list_and_module_rec_declaration_
    {let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos__3_ in
      Psig_recmodule (Md.mk _2 _3 ~attrs:_1 ~loc :: _4) )}
| _1 = nonempty_list_as_loc_attribute__ _2 = opt_LET_MODULE_REC_ident _3 = module_type_body_COLON_ _4 = list_and_module_rec_declaration_
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos__3_ in
      Psig_recmodule (Md.mk _2 _3 ~attrs:_1 ~loc :: _4) )}
| _2 = MODULE _3 = TYPE x = ident
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos__4_ = _endpos_x_ in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Psig_modtype (Mtd.mk _4 ~attrs:_1 ~loc)
    )}
| _1 = nonempty_list_as_loc_attribute__ _2 = MODULE _3 = TYPE x = ident
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos__4_ = _endpos_x_ in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Psig_modtype (Mtd.mk _4 ~attrs:_1 ~loc)
    )}
| _2 = MODULE _3 = TYPE x = ident _5 = module_type_body_EQUAL_
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Psig_modtype (Mtd.mk _4 ~typ:_5 ~loc ~attrs:_1)
    )}
| _1 = nonempty_list_as_loc_attribute__ _2 = MODULE _3 = TYPE x = ident _5 = module_type_body_EQUAL_
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Psig_modtype (Mtd.mk _4 ~typ:_5 ~loc ~attrs:_1)
    )}
| _1 = open_statement
    {    ( Psig_open _1 )}
| _2 = INCLUDE _3 = module_type
    {let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Psig_include (Incl.mk _3 ~attrs:_1 ~loc)
    )}
| _1 = nonempty_list_as_loc_attribute__ _2 = INCLUDE _3 = module_type
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Psig_include (Incl.mk _3 ~attrs:_1 ~loc)
    )}
| _1 = class_descriptions
    {    ( Psig_class _1 )}
| _1 = class_type_declarations
    {    ( Psig_class_type _1 )}
| _2 = item_extension
    {let _1 =     ( [] ) in
    ( Psig_extension (_2, _1) )}
| _1 = nonempty_list_as_loc_attribute__ _2 = item_extension
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
    ( Psig_extension (_2, _1) )}

signature_items:
  x = signature_item
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                           ( [mksig ~loc:_1.loc _1.txt] )}
| _1 = nonempty_list_as_loc_attribute__
    {let _1 =                                                ( _1 ) in
    ( List.map (fun x -> mksig ~loc:x.loc (Psig_attribute x.txt)) _1 )}

open_statement:
  _2 = OPEN _3 = override_flag x = mod_longident
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos__4_ = _endpos_x_ in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( Opn.mk _4 ~override:_3 ~attrs:_1 ~loc:(mklocation _symbolstartpos _endpos) )}
| _1 = nonempty_list_as_loc_attribute__ _2 = OPEN _3 = override_flag x = mod_longident
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos__4_ = _endpos_x_ in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( Opn.mk _4 ~override:_3 ~attrs:_1 ~loc:(mklocation _symbolstartpos _endpos) )}

module_declaration:
  _1 = loption_functor_parameters_ _2 = module_type_body_COLON_
    {  ( mk_functor_mty _1 _2 )}

module_type_body_COLON_:
  _1 = COLON _2 = module_type
    {                      ( _2 )}
| _1 = module_type_signature
    {                          ( _1 )}

module_type_body_EQUAL_:
  _1 = EQUAL _2 = module_type
    {                      ( _2 )}
| _1 = module_type_signature
    {                          ( _1 )}

and_module_rec_declaration:
  _2 = AND x = UIDENT _4 = module_type_body_COLON_
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( Md.mk _3 _4 ~attrs:_1 ~loc:(mklocation _symbolstartpos _endpos) )}
| _1 = nonempty_list_as_loc_attribute__ _2 = AND x = UIDENT _4 = module_type_body_COLON_
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( Md.mk _3 _4 ~attrs:_1 ~loc:(mklocation _symbolstartpos _endpos) )}

and_class_declaration:
  _2 = AND _3 = class_declaration_details
    {let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let (ident, binding, virt, params) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident binding ~virt ~params ~attrs:_1 ~loc
  )}
| _1 = nonempty_list_as_loc_attribute__ _2 = AND _3 = class_declaration_details
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let (ident, binding, virt, params) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident binding ~virt ~params ~attrs:_1 ~loc
  )}

class_declaration_details:
  _1 = virtual_flag x = LIDENT _5 = class_declaration_body
    {let _4 =     ( None ) in
let _3 =     ( None ) in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (
    let tree = match _4 with
    | None -> []
    | Some (lpl, _uncurried) -> lpl
    in
    let body = List.fold_right mkclass_fun tree _5 in
    let params = match _3 with None -> [] | Some x -> x in
    (_2, body, _1, params)
  )}
| _1 = virtual_flag x = LIDENT _1_inlined1 = LPAREN _2 = RPAREN _5 = class_declaration_body
    {let _4 =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let x =
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                      (
    let loc = mklocation _startpos _endpos in
    ([mkloc (Term (Nolabel, None, mkpat_constructor_unit loc loc)) loc], false)
  )
  in
      ( Some x )
in
let _3 =     ( None ) in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (
    let tree = match _4 with
    | None -> []
    | Some (lpl, _uncurried) -> lpl
    in
    let body = List.fold_right mkclass_fun tree _5 in
    let params = match _3 with None -> [] | Some x -> x in
    (_2, body, _1, params)
  )}
| _1 = virtual_flag x = LIDENT _1_inlined1 = LPAREN _1_inlined2 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2 = option_COMMA_ _3 = RPAREN _5 = class_declaration_body
    {let _4 =
  let _1_inlined1 = _1_inlined2 in
  let x =
    let _1 =
      let _1 =
        let x =
          let _1 = _1_inlined1 in
          let _1 =                                        ( List.rev _1 ) in
                                                                    ( _1 )
        in
            ( x )
      in
                                                             ( _1 )
    in
                                                   (
    (_1, false)
  )
  in
      ( Some x )
in
let _3 =     ( None ) in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (
    let tree = match _4 with
    | None -> []
    | Some (lpl, _uncurried) -> lpl
    in
    let body = List.fold_right mkclass_fun tree _5 in
    let params = match _3 with None -> [] | Some x -> x in
    (_2, body, _1, params)
  )}
| _1 = virtual_flag x = LIDENT _1_inlined1 = LPAREN _2 = DOT _3 = RPAREN _5 = class_declaration_body
    {let _4 =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let x =
    let _endpos = _endpos__3_ in
    let _startpos = _startpos__1_ in
                          (
      let loc = mklocation _startpos _endpos in
      ([mkloc (Term (Nolabel, None, mkpat_constructor_unit loc loc)) loc], true)
  )
  in
      ( Some x )
in
let _3 =     ( None ) in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (
    let tree = match _4 with
    | None -> []
    | Some (lpl, _uncurried) -> lpl
    in
    let body = List.fold_right mkclass_fun tree _5 in
    let params = match _3 with None -> [] | Some x -> x in
    (_2, body, _1, params)
  )}
| _1 = virtual_flag x = LIDENT _1_inlined1 = LPAREN _2 = DOT _1_inlined2 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2_inlined1 = option_COMMA_ _4 = RPAREN _5 = class_declaration_body
    {let _4 =
  let _1_inlined1 = _1_inlined2 in
  let x =
    let _3 =
      let _1 = _1_inlined1 in
      let _1 =                                        ( List.rev _1 ) in
                                                                ( _1 )
    in
                                                      (
    let () = List.iter (fun p ->
        match p.txt with
        | Term (Labelled _, _, _)
        | Term (Optional _, _, _)  ->
            raise Reason_syntax_util.(
              Error(p.loc, (Syntax_error "Uncurried function definition with labelled arguments is not supported at the moment."))
            )
        | _ -> ()
      ) _3 in
    (_3, true)
  )
  in
      ( Some x )
in
let _3 =     ( None ) in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (
    let tree = match _4 with
    | None -> []
    | Some (lpl, _uncurried) -> lpl
    in
    let body = List.fold_right mkclass_fun tree _5 in
    let params = match _3 with None -> [] | Some x -> x in
    (_2, body, _1, params)
  )}
| _1 = virtual_flag x = LIDENT _1_inlined1 = LPAREN _1_inlined2 = lseparated_nonempty_list_aux_COMMA_type_parameter_ _2 = option_COMMA_ _3 = RPAREN _5 = class_declaration_body
    {let _4 =     ( None ) in
let _3 =
  let _1_inlined1 = _1_inlined2 in
  let x =
    let _1 =
      let _1 =
        let x =
          let _1 = _1_inlined1 in
          let _1 =                                        ( List.rev _1 ) in
                                                                       (_1)
        in
            ( x )
      in
                                                             ( _1 )
    in
      ( _1 )
  in
      ( Some x )
in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (
    let tree = match _4 with
    | None -> []
    | Some (lpl, _uncurried) -> lpl
    in
    let body = List.fold_right mkclass_fun tree _5 in
    let params = match _3 with None -> [] | Some x -> x in
    (_2, body, _1, params)
  )}
| _1 = virtual_flag x = LIDENT _1_inlined1 = LPAREN _1_inlined2 = lseparated_nonempty_list_aux_COMMA_type_parameter_ _2 = option_COMMA_ _3 = RPAREN _1_inlined3 = LPAREN _2_inlined1 = RPAREN _5 = class_declaration_body
    {let _4 =
  let (_endpos__2_, _startpos__1_) = (_endpos__2_inlined1_, _startpos__1_inlined3_) in
  let x =
    let _endpos = _endpos__2_ in
    let _startpos = _startpos__1_ in
                      (
    let loc = mklocation _startpos _endpos in
    ([mkloc (Term (Nolabel, None, mkpat_constructor_unit loc loc)) loc], false)
  )
  in
      ( Some x )
in
let _3 =
  let _1_inlined1 = _1_inlined2 in
  let x =
    let _1 =
      let _1 =
        let x =
          let _1 = _1_inlined1 in
          let _1 =                                        ( List.rev _1 ) in
                                                                       (_1)
        in
            ( x )
      in
                                                             ( _1 )
    in
      ( _1 )
  in
      ( Some x )
in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (
    let tree = match _4 with
    | None -> []
    | Some (lpl, _uncurried) -> lpl
    in
    let body = List.fold_right mkclass_fun tree _5 in
    let params = match _3 with None -> [] | Some x -> x in
    (_2, body, _1, params)
  )}
| _1 = virtual_flag x = LIDENT _1_inlined1 = LPAREN _1_inlined2 = lseparated_nonempty_list_aux_COMMA_type_parameter_ _2 = option_COMMA_ _3 = RPAREN _1_inlined3 = LPAREN _1_inlined4 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2_inlined1 = option_COMMA_ _3_inlined1 = RPAREN _5 = class_declaration_body
    {let _4 =
  let _1_inlined1 = _1_inlined4 in
  let x =
    let _1 =
      let _1 =
        let x =
          let _1 = _1_inlined1 in
          let _1 =                                        ( List.rev _1 ) in
                                                                    ( _1 )
        in
            ( x )
      in
                                                             ( _1 )
    in
                                                   (
    (_1, false)
  )
  in
      ( Some x )
in
let _3 =
  let _1_inlined1 = _1_inlined2 in
  let x =
    let _1 =
      let _1 =
        let x =
          let _1 = _1_inlined1 in
          let _1 =                                        ( List.rev _1 ) in
                                                                       (_1)
        in
            ( x )
      in
                                                             ( _1 )
    in
      ( _1 )
  in
      ( Some x )
in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (
    let tree = match _4 with
    | None -> []
    | Some (lpl, _uncurried) -> lpl
    in
    let body = List.fold_right mkclass_fun tree _5 in
    let params = match _3 with None -> [] | Some x -> x in
    (_2, body, _1, params)
  )}
| _1 = virtual_flag x = LIDENT _1_inlined1 = LPAREN _1_inlined2 = lseparated_nonempty_list_aux_COMMA_type_parameter_ _2 = option_COMMA_ _3 = RPAREN _1_inlined3 = LPAREN _2_inlined1 = DOT _3_inlined1 = RPAREN _5 = class_declaration_body
    {let _4 =
  let (_endpos__3_, _startpos__1_) = (_endpos__3_inlined1_, _startpos__1_inlined3_) in
  let x =
    let _endpos = _endpos__3_ in
    let _startpos = _startpos__1_ in
                          (
      let loc = mklocation _startpos _endpos in
      ([mkloc (Term (Nolabel, None, mkpat_constructor_unit loc loc)) loc], true)
  )
  in
      ( Some x )
in
let _3 =
  let _1_inlined1 = _1_inlined2 in
  let x =
    let _1 =
      let _1 =
        let x =
          let _1 = _1_inlined1 in
          let _1 =                                        ( List.rev _1 ) in
                                                                       (_1)
        in
            ( x )
      in
                                                             ( _1 )
    in
      ( _1 )
  in
      ( Some x )
in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (
    let tree = match _4 with
    | None -> []
    | Some (lpl, _uncurried) -> lpl
    in
    let body = List.fold_right mkclass_fun tree _5 in
    let params = match _3 with None -> [] | Some x -> x in
    (_2, body, _1, params)
  )}
| _1 = virtual_flag x = LIDENT _1_inlined1 = LPAREN _1_inlined2 = lseparated_nonempty_list_aux_COMMA_type_parameter_ _2 = option_COMMA_ _3 = RPAREN _1_inlined3 = LPAREN _2_inlined1 = DOT _1_inlined4 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2_inlined2 = option_COMMA_ _4 = RPAREN _5 = class_declaration_body
    {let _4 =
  let _1_inlined1 = _1_inlined4 in
  let x =
    let _3 =
      let _1 = _1_inlined1 in
      let _1 =                                        ( List.rev _1 ) in
                                                                ( _1 )
    in
                                                      (
    let () = List.iter (fun p ->
        match p.txt with
        | Term (Labelled _, _, _)
        | Term (Optional _, _, _)  ->
            raise Reason_syntax_util.(
              Error(p.loc, (Syntax_error "Uncurried function definition with labelled arguments is not supported at the moment."))
            )
        | _ -> ()
      ) _3 in
    (_3, true)
  )
  in
      ( Some x )
in
let _3 =
  let _1_inlined1 = _1_inlined2 in
  let x =
    let _1 =
      let _1 =
        let x =
          let _1 = _1_inlined1 in
          let _1 =                                        ( List.rev _1 ) in
                                                                       (_1)
        in
            ( x )
      in
                                                             ( _1 )
    in
      ( _1 )
  in
      ( Some x )
in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (
    let tree = match _4 with
    | None -> []
    | Some (lpl, _uncurried) -> lpl
    in
    let body = List.fold_right mkclass_fun tree _5 in
    let params = match _3 with None -> [] | Some x -> x in
    (_2, body, _1, params)
  )}

class_declaration_body:
  _1 = option_preceded_COLON_class_constructor_type__ _2 = either_preceded_EQUAL_class_expr__class_body_expr_
    {let _endpos = _endpos__2_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( match _1 with
    | None -> _2
    | Some ct -> Cl.constraint_ ~loc:(mklocation _symbolstartpos _endpos) _2 ct
  )}

class_expr_lets_and_rest:
  _1 = class_expr
    {let _1 =
  let x =                ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = if _startpos_x_ != _endpos_x_ then
    _startpos_x_
  else
    _endpos in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = let_bindings _2 = SEMI _3 = class_expr_lets_and_rest
    {let _1 =
  let x =     ( class_of_let_bindings _1 _3 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = if _startpos_x_ != _endpos_x_ then
    _startpos_x_
  else
    _endpos in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = object_body
    {let _1 =
  let x =                 ( mkclass (Pcl_structure _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = if _startpos_x_ != _endpos_x_ then
    _startpos_x_
  else
    _endpos in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

object_body_class_fields:
  _2 = option_SEMI_
    {let _1 =                 ( [] ) in
                                             ( List.concat _1 )}
| _1 = lseparated_nonempty_list_aux_SEMI_class_field_ _2 = option_SEMI_
    {let _1 =
  let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
in
                                             ( List.concat _1 )}

object_body:
  _1 = loption_located_attributes_ x = class_self_expr
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    ( let attrs = List.map (fun x -> mkcf ~loc:x.loc (Pcf_attribute x.txt)) _1 in
      Cstr.mk _2 attrs )}
| _1 = loption_located_attributes_ x = class_self_expr _3 = SEMI _4 = object_body_class_fields
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    ( let attrs = List.map (fun x -> mkcf ~loc:x.loc (Pcf_attribute x.txt)) _1 in
      Cstr.mk _2 (attrs @ _4) )}
| _1 = object_body_class_fields
    {let _endpos = _endpos__1_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _endpos in
    ( let loc = mklocation _symbolstartpos _symbolstartpos in
      Cstr.mk (mkpat ~loc (Ppat_var (mkloc "this" loc))) _1 )}

class_self_expr:
  _1 = AS _2 = pattern
    {               ( _2 )}

class_expr:
  _1 = class_simple_expr
    {let _1 =
  let x =     ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = either_ES6_FUN_FUN_ _1_inlined1 = LPAREN _2 = RPAREN _3 = EQUALGREATER _4 = class_expr
    {let _1 =
  let x =
    let _2 =
      let _startpos__1_ = _startpos__1_inlined1_ in
      let _endpos = _endpos__2_ in
      let _startpos = _startpos__1_ in
                        (
    let loc = mklocation _startpos _endpos in
    ([mkloc (Term (Nolabel, None, mkpat_constructor_unit loc loc)) loc], false)
  )
    in
        ( let (lp, _) = _2 in
      List.fold_right mkclass_fun lp _4 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = either_ES6_FUN_FUN_ _1_inlined1 = LPAREN _1_inlined2 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2 = option_COMMA_ _3_inlined1 = RPAREN _3 = EQUALGREATER _4 = class_expr
    {let _1 =
  let x =
    let _2 =
      let _1_inlined1 = _1_inlined2 in
      let _1 =
        let _1 =
          let x =
            let _1 = _1_inlined1 in
            let _1 =                                        ( List.rev _1 ) in
                                                                      ( _1 )
          in
              ( x )
        in
                                                               ( _1 )
      in
                                                     (
    (_1, false)
  )
    in
        ( let (lp, _) = _2 in
      List.fold_right mkclass_fun lp _4 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = either_ES6_FUN_FUN_ _1_inlined1 = LPAREN _2 = DOT _3_inlined1 = RPAREN _3 = EQUALGREATER _4 = class_expr
    {let _1 =
  let x =
    let _2 =
      let (_endpos__3_, _startpos__1_) = (_endpos__3_inlined1_, _startpos__1_inlined1_) in
      let _endpos = _endpos__3_ in
      let _startpos = _startpos__1_ in
                            (
      let loc = mklocation _startpos _endpos in
      ([mkloc (Term (Nolabel, None, mkpat_constructor_unit loc loc)) loc], true)
  )
    in
        ( let (lp, _) = _2 in
      List.fold_right mkclass_fun lp _4 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = either_ES6_FUN_FUN_ _1_inlined1 = LPAREN _2 = DOT _1_inlined2 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2_inlined1 = option_COMMA_ _4_inlined1 = RPAREN _3 = EQUALGREATER _4 = class_expr
    {let _1 =
  let x =
    let _2 =
      let _1_inlined1 = _1_inlined2 in
      let _3 =
        let _1 = _1_inlined1 in
        let _1 =                                        ( List.rev _1 ) in
                                                                  ( _1 )
      in
                                                        (
    let () = List.iter (fun p ->
        match p.txt with
        | Term (Labelled _, _, _)
        | Term (Optional _, _, _)  ->
            raise Reason_syntax_util.(
              Error(p.loc, (Syntax_error "Uncurried function definition with labelled arguments is not supported at the moment."))
            )
        | _ -> ()
      ) _3 in
    (_3, true)
  )
    in
        ( let (lp, _) = _2 in
      List.fold_right mkclass_fun lp _4 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = class_simple_expr _2 = labeled_arguments
    {let _1 =
  let x =     ( mkclass(Pcl_apply(_1, _2)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = attribute _2 = class_expr
    {let _1 =
  let x =     ( {_2 with pcl_attributes = _1 :: _2.pcl_attributes} ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = CLASS x = class_longident _3 = loption_type_parameters_
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkclass(Pcl_constr(_2, _3)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = extension
    {let _1 =
  let x =     ( mkclass(Pcl_extension _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

class_simple_expr:
  x = class_longident
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkclass(Pcl_constr(_1, [])) )
  in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LBRACE _2 = class_expr_lets_and_rest _3 = RBRACE
    {let _1 =
  let x =
    let _1 =                                                                 ( _2 ) in
        ( _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LBRACE _2 = class_expr_lets_and_rest x_inlined1 = error
    {let _1 =
  let x =
    let _3 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_cl (with_txt _1 "{") (with_txt _3 "}") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LPAREN _2 = class_expr _3 = COLON _4 = class_constructor_type _5 = RPAREN
    {let _1 =
  let x =     ( mkclass(Pcl_constraint(_2, _4)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LPAREN _2 = class_expr _3 = COLON _4 = class_constructor_type x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_cl (with_txt _1 "(") (with_txt _5 ")") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LPAREN _2 = class_expr _3 = RPAREN
    {let _1 =
  let x =     ( _2 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LPAREN _2 = class_expr x_inlined1 = error
    {let _1 =
  let x =
    let _3 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_cl (with_txt _1 "(") (with_txt _3 ")") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

class_field:
  _2 = INHERIT _3 = override_flag _4 = class_expr _5 = option_preceded_AS_LIDENT__
    {let _1 =
  let x =
    let _1 =     ( [] ) in
          ( mkcf_attrs (Pcf_inherit (_3, _4, _5)) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = INHERIT _3 = override_flag _4 = class_expr _5 = option_preceded_AS_LIDENT__
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkcf_attrs (Pcf_inherit (_3, _4, _5)) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = VAL _3 = value
    {let _1 =
  let x =
    let _1 =     ( [] ) in
          ( mkcf_attrs (Pcf_val _3) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = VAL _3 = value
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkcf_attrs (Pcf_val _3) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = either___anonymous_12___anonymous_13_ _3 = method_
    {let _1 =
  let x =
    let _1 =     ( [] ) in
          ( let (a, b) = _3 in mkcf_attrs (Pcf_method (a, _2, b)) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = either___anonymous_12___anonymous_13_ _3 = method_
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( let (a, b) = _3 in mkcf_attrs (Pcf_method (a, _2, b)) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = CONSTRAINT _3 = constrain_field
    {let _1 =
  let x =
    let _1 =     ( [] ) in
          ( mkcf_attrs (Pcf_constraint _3) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = CONSTRAINT _3 = constrain_field
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkcf_attrs (Pcf_constraint _3) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = INITIALIZER _1 = simple_expr_call
    {let _1 =
  let x =
    let _3 =
      let x =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
      let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
    in
    let _1 =     ( [] ) in
          ( mkcf_attrs (Pcf_initializer _3) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = INITIALIZER _1_inlined1 = simple_expr_call
    {let _1 =
  let x =
    let _3 =
      let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
      let x =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
      let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
    in
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkcf_attrs (Pcf_initializer _3) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = item_extension
    {let _1 =
  let x =
    let _1 =     ( [] ) in
          ( mkcf_attrs (Pcf_extension _2) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = item_extension
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkcf_attrs (Pcf_extension _2) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__
    {let _1 =                                                ( _1 ) in
    ( List.map (fun x -> mkcf ~loc:x.loc (Pcf_attribute x.txt)) _1 )}

value:
  _1 = override_flag _2 = MUTABLE _3 = VIRTUAL _1_inlined1 = LIDENT _5 = COLON _6 = core_type
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                       ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( if _1 = Override
      then not_expecting _symbolstartpos _endpos "members marked virtual may not also be marked overridden"
      else (_4, Mutable, Cfk_virtual _6)
    )}
| _1 = override_flag _2 = MUTABLE _3 = VIRTUAL _1_inlined1 = LIDENT _5 = COLON _6 = core_type _7 = EQUAL
    {let _4 =
  let _1 = _1_inlined1 in
                        ( _1 )
in
    ( not_expecting _startpos__7_ _endpos__7_ "not expecting equal - cannot specify value for virtual val" )}
| _1 = VIRTUAL _2 = mutable_flag _1_inlined1 = LIDENT _4 = COLON _5 = core_type
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                       ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( (_3, _2, Cfk_virtual _5) )}
| _1 = VIRTUAL _2 = mutable_flag _1_inlined1 = LIDENT _4 = COLON _5 = core_type _6 = EQUAL
    {let _3 =
  let _1 = _1_inlined1 in
                        ( _1 )
in
    ( not_expecting _startpos__6_ _endpos__6_ "not expecting equal - cannot specify value for virtual val" )}
| _1 = override_flag _2 = mutable_flag _1_inlined1 = LIDENT _4 = EQUAL _5 = expr
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                       ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( (_3, _2, Cfk_concrete (_1, _5)) )}
| _1 = override_flag _2 = mutable_flag _1_inlined1 = LIDENT _4 = type_constraint _5 = EQUAL _6 = expr
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                       ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__3_ = _startpos__1_inlined1_ in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  if _startpos__2_ != _endpos__2_ then
    _startpos__2_
  else
    _startpos__3_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      let e = ghexp_constraint loc _6 _4 in
      (_3, _2, Cfk_concrete (_1, e)) )}

method_:
  _1 = override_flag _2 = VIRTUAL _1_inlined1 = LIDENT _4 = COLON _5 = poly_type
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                       ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( if _1 = Override then syntax_error ();
      (_3, Cfk_virtual _5)
    )}
| _1 = override_flag _1_inlined1 = LIDENT _3 = fun_def_EQUAL_core_type_
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                       ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_inlined1_ in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      (_2, Cfk_concrete (_1, mkexp ~ghost:true ~loc (Pexp_poly (_3, None))))
    )}
| _1 = override_flag _1_inlined1 = LIDENT _3 = option_preceded_COLON_poly_type__ _4 = either_preceded_EQUAL_expr__braced_expr_
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                       ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_inlined1_ in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      (_2, Cfk_concrete (_1, mkexp ~ghost:true ~loc (Pexp_poly(_4, _3))))
    )}
| _1 = override_flag _1_inlined1 = LIDENT _3 = COLON _4 = TYPE _5 = nonempty_list_LIDENT_ _6 = DOT _7 = core_type _8 = either_preceded_EQUAL_expr__braced_expr_
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                       ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_inlined1_ in
let _endpos = _endpos__8_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    (
      (* For non, methods we'd create a pattern binding:
         ((Ppat_constraint(mkpatvar ..., Ptyp_poly (typeVars, poly_type_varified))),
          exp_with_newtypes_constrained_by_non_varified)

         For methods, we create:
         Pexp_poly (Pexp_constraint (methodFunWithNewtypes, non_varified), Some (Ptyp_poly newTypes varified))
       *)
      let (exp_non_varified, poly_vars) = wrap_type_annotation _5 _7 _8 in
      let exp = Pexp_poly(exp_non_varified, Some poly_vars) in
      let loc = mklocation _symbolstartpos _endpos in
      (_2, Cfk_concrete (_1, mkexp ~ghost:true ~loc exp))
    )}

class_constructor_type:
  _1 = class_instance_type
    {                        ( _1 )}
| _1 = arrow_type_parameters _2 = EQUALGREATER _3 = class_constructor_type
    {    ( List.fold_right mkcty_arrow _1 _3 )}

class_type_arguments_comma_list:
  _1 = lseparated_nonempty_list_aux_COMMA_core_type_ _2 = option_COMMA_
    {let _1 =                                        ( List.rev _1 ) in
                                                     (_1)}

class_instance_type:
  x = clty_longident _2 = loption_parenthesized_class_type_arguments_comma_list__
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkcty (Pcty_constr (_1, _2)) )
  in
  let _endpos_x_ = _endpos__2_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = attribute _2 = class_instance_type
    {let _1 =
  let x =     ( {_2 with pcty_attributes = _1 :: _2.pcty_attributes} ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = class_type_body
    {let _1 =
  let x =     ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = extension
    {let _1 =
  let x =     ( mkcty (Pcty_extension _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

class_type_body:
  _1 = LBRACE _2 = class_sig_body _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( mkcty ~loc:(mklocation _startpos _endpos) (Pcty_signature _2) )}
| _1 = LBRACE _2 = DOT _3 = class_sig_body _4 = RBRACE
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
    ( let loc = mklocation _startpos _endpos in
      let ct = mkcty ~loc (Pcty_signature _3) in
      {ct with pcty_attributes = [uncurry_payload loc]}
    )}
| x = LBRACE _2 = class_sig_body x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( unclosed_cty (with_txt _1 "{") (with_txt _3 "}") )}

class_sig_body_fields:
  _2 = option_SEMI_
    {let _1 =                 ( [] ) in
                                               ( List.concat _1 )}
| _1 = lseparated_nonempty_list_aux_SEMI_class_sig_field_ _2 = option_SEMI_
    {let _1 =
  let _1 =                                        ( List.rev _1 ) in
                                       ( _1 )
in
                                               ( List.concat _1 )}

class_sig_body:
  _1 = class_self_type
    {  ( Csig.mk _1 [] )}
| _1 = class_self_type _2 = SEMI _3 = class_sig_body_fields
    {  ( Csig.mk _1 _3 )}
| _1 = class_sig_body_fields
    {let _endpos = _endpos__1_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _endpos in
  ( Csig.mk (Typ.mk ~loc:(mklocation _symbolstartpos _endpos) Ptyp_any) _1 )}

class_self_type:
  _1 = AS _2 = core_type
    {                 ( _2 )}

class_sig_field:
  _2 = INHERIT _3 = class_instance_type
    {let _1 =
  let x =
    let _1 =     ( [] ) in
          ( mkctf_attrs (Pctf_inherit _3) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = INHERIT _3 = class_instance_type
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkctf_attrs (Pctf_inherit _3) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = VAL _3 = value_type
    {let _1 =
  let x =
    let _1 =     ( [] ) in
          ( mkctf_attrs (Pctf_val _3) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = VAL _3 = value_type
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkctf_attrs (Pctf_val _3) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = PRI _3 = virtual_flag _1 = LIDENT _5 = COLON _6 = poly_type
    {let _1 =
  let x =
    let _4 =                       ( _1 ) in
    let _1 =     ( [] ) in
          ( mkctf_attrs (Pctf_method (_4, Private, _3, _6)) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = PRI _3 = virtual_flag _1_inlined1 = LIDENT _5 = COLON _6 = poly_type
    {let _1 =
  let x =
    let _4 =
      let _1 = _1_inlined1 in
                            ( _1 )
    in
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkctf_attrs (Pctf_method (_4, Private, _3, _6)) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = PUB _3 = virtual_flag _1 = LIDENT _5 = COLON _6 = poly_type
    {let _1 =
  let x =
    let _4 =                       ( _1 ) in
    let _1 =     ( [] ) in
          ( mkctf_attrs (Pctf_method (_4, Public, _3, _6)) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = PUB _3 = virtual_flag _1_inlined1 = LIDENT _5 = COLON _6 = poly_type
    {let _1 =
  let x =
    let _4 =
      let _1 = _1_inlined1 in
                            ( _1 )
    in
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkctf_attrs (Pctf_method (_4, Public, _3, _6)) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = CONSTRAINT _3 = constrain_field
    {let _1 =
  let x =
    let _1 =     ( [] ) in
          ( mkctf_attrs (Pctf_constraint _3) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = CONSTRAINT _3 = constrain_field
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkctf_attrs (Pctf_constraint _3) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _2 = item_extension
    {let _1 =
  let x =
    let _1 =     ( [] ) in
          ( mkctf_attrs (Pctf_extension _2) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__2_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__ _2 = item_extension
    {let _1 =
  let x =
    let _1 =
      let _1 =                                                ( _1 ) in
                             ( List.map (fun x -> x.txt) _1 )
    in
          ( mkctf_attrs (Pctf_extension _2) _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
      ( [_1] )}
| _1 = nonempty_list_as_loc_attribute__
    {let _1 =                                                ( _1 ) in
    ( List.map (fun x -> mkctf ~loc:x.loc (Pctf_attribute x.txt)) _1 )}

value_type:
  _1 = mutable_or_virtual_flags _1_inlined1 = LIDENT _3 = COLON _4 = core_type
    {let _2 =
  let _1 = _1_inlined1 in
                        ( _1 )
in
  ( let (mut, virt) = _1 in (_2, mut, virt, _4) )}

constrain:
  _1 = core_type _2 = EQUAL _3 = core_type
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
  ( (_1, _3, mklocation _symbolstartpos _endpos) )}

constrain_field:
  _1 = core_type _2 = EQUAL _3 = core_type
    {  ( (_1, _3) )}

class_descriptions:
  _2 = CLASS _3 = class_description_details _4 = list_and_class_description_
    {let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let (ident, binding, virt, params) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    (Ci.mk ident binding ~virt ~params ~attrs:_1 ~loc :: _4)
  )}
| _1 = nonempty_list_as_loc_attribute__ _2 = CLASS _3 = class_description_details _4 = list_and_class_description_
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let (ident, binding, virt, params) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    (Ci.mk ident binding ~virt ~params ~attrs:_1 ~loc :: _4)
  )}

and_class_description:
  _2 = AND _3 = class_description_details
    {let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let (ident, binding, virt, params) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident binding ~virt ~params ~attrs:_1 ~loc
  )}
| _1 = nonempty_list_as_loc_attribute__ _2 = AND _3 = class_description_details
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let (ident, binding, virt, params) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident binding ~virt ~params ~attrs:_1 ~loc
  )}

class_description_details:
  _1 = virtual_flag x = LIDENT _3 = loption_class_type_parameters_ _4 = COLON _5 = class_constructor_type
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  ( (_2, _5, _1, _3) )}

class_type_declarations:
  _2 = CLASS _3 = TYPE _4 = class_type_declaration_details _5 = list_and_class_type_declaration_
    {let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let (ident, instance_type, virt, params) = _4 in
    let loc = mklocation _symbolstartpos _endpos in
    (Ci.mk ident instance_type ~virt ~params ~attrs:_1 ~loc :: _5)
  )}
| _1 = nonempty_list_as_loc_attribute__ _2 = CLASS _3 = TYPE _4 = class_type_declaration_details _5 = list_and_class_type_declaration_
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let (ident, instance_type, virt, params) = _4 in
    let loc = mklocation _symbolstartpos _endpos in
    (Ci.mk ident instance_type ~virt ~params ~attrs:_1 ~loc :: _5)
  )}

and_class_type_declaration:
  _2 = AND _3 = class_type_declaration_details
    {let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let (ident, instance_type, virt, params) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident instance_type ~virt ~params ~attrs:_1 ~loc
  )}
| _1 = nonempty_list_as_loc_attribute__ _2 = AND _3 = class_type_declaration_details
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let (ident, instance_type, virt, params) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident instance_type ~virt ~params ~attrs:_1 ~loc
  )}

class_type_declaration_details:
  _1 = virtual_flag x = LIDENT _3 = loption_class_type_parameters_ _4 = either_preceded_EQUAL_class_instance_type__class_type_body_
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  ( (_2, _4, _1, _3) )}

braced_expr:
  _1 = LBRACE _2 = seq_expr _3 = RBRACE
    {let _1 =
  let x =     ( _2 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
  (_1)}
| _1 = LBRACE x = seq_expr _3 = error
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( syntax_error_exp _2.loc "SyntaxError in block" )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
  (_1)}
| _1 = LBRACE _2 = DOTDOTDOT _3 = expr_optional_constraint _4 = option_COMMA_ _5 = RBRACE
    {let _1 =
  let x =
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let msg = "Record construction must have at least one field explicitly set" in
      syntax_error_exp loc msg
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
  (_1)}
| _1 = LBRACE _2 = DOTDOTDOT _3 = expr_optional_constraint _4 = SEMI _5 = RBRACE
    {let _1 =
  let x =     ( let loc = mklocation _startpos__4_ _endpos__4_ in
      raise_record_trailing_semi_error loc ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
  (_1)}
| _1 = LBRACE _2 = record_expr _3 = RBRACE
    {let _1 =
  let x =     ( let (exten, fields) = _2 in mkexp (Pexp_record(fields, exten)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
  (_1)}
| x = LBRACE _2 = record_expr x_inlined1 = error
    {let _1 =
  let x =
    let _3 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _1 "{") (with_txt _3 "}"))
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
  (_1)}
| _1 = LBRACE _2 = record_expr_with_string_keys _3 = RBRACE
    {let _1 =
  let x =
    let _endpos = _endpos__3_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let (exten, fields) = _2 in
      mkexp ~loc (Pexp_extension (mkloc ("bs.obj") loc,
             PStr [mkstrexp (mkexp ~loc (Pexp_record(fields, exten))) []]))
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
  (_1)}
| x = LBRACE _2 = record_expr_with_string_keys x_inlined1 = error
    {let _1 =
  let x =
    let _3 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _1 "{") (with_txt _3 "}"))
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
  (_1)}
| _1 = LBRACE _2 = object_body _3 = RBRACE
    {let _1 =
  let x =     ( mkexp (Pexp_object _2) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
  (_1)}
| x = LBRACE _2 = object_body x_inlined1 = error
    {let _1 =
  let x =
    let _3 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _1 "{") (with_txt _3 "}") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
  (_1)}

seq_expr_no_seq:
  _1 = expr _2 = option_SEMI_
    {             ( _1 )}
| _1 = opt_LET_MODULE_ident _2 = module_binding_body _3 = SEMI _4 = seq_expr
    {  ( mkexp (Pexp_letmodule(_1, _2, _4)) )}
| _2 = option_LET_ _3 = OPEN _4 = override_flag x = mod_longident _6 = SEMI _7 = seq_expr
    {let _5 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =     ( [] ) in
  ( let exp = mkexp (Pexp_open(_4, _5, _7)) in
    { exp with pexp_attributes = _1 }
  )}
| _1 = nonempty_list_as_loc_attribute__ _2 = option_LET_ _3 = OPEN _4 = override_flag x = mod_longident _6 = SEMI _7 = seq_expr
    {let _5 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
  ( let exp = mkexp (Pexp_open(_4, _5, _7)) in
    { exp with pexp_attributes = _1 }
  )}
| _1 = str_exception_declaration _2 = SEMI _3 = seq_expr
    {                                          (
   mkexp (Pexp_letexception (_1, _3)) )}
| _1 = let_bindings _2 = SEMI _3 = seq_expr
    {  ( let loc = mklocation _startpos__1_ _endpos__3_ in
    expr_of_let_bindings ~loc _1 _3
  )}
| _1 = let_bindings _2 = option_SEMI_
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
  ( let loc = mklocation _symbolstartpos _endpos in
    expr_of_let_bindings ~loc _1 (ghunit ~loc ())
  )}

seq_expr:
  _1 = seq_expr_no_seq
    {let _1 =
  let x =     ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    ( _1 )}
| _1 = item_extension_sugar x = seq_expr_no_seq
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
    in
        ( expression_extension _1 _2 )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    ( _1 )}
| _1 = expr _2 = SEMI _3 = seq_expr
    {let _1 =
  let x =     ( mkexp (Pexp_sequence(_1, _3)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    ( _1 )}
| _1 = item_extension_sugar _2 = expr _3 = SEMI _4 = seq_expr
    {let _1 =
  let x =     ( let loc = mklocation _startpos__1_ _endpos__2_ in
      mkexp (Pexp_sequence(expression_extension ~loc _1 _2, _4)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    ( _1 )}

labeled_pattern_constraint:
  _1 = AS _2 = pattern_optional_constraint
    {                                   ( fun _punned -> _2 )}
| _1 = option_preceded_COLON_core_type__
    {let _endpos = _endpos__1_ in
    ( fun punned ->
      let pat = mkpat (Ppat_var punned) ~loc:punned.loc in
      match _1 with
      | None -> pat
      | Some typ ->
        let loc = mklocation punned.loc.loc_start _endpos in
        mkpat ~loc (Ppat_constraint(pat, typ))
    )}

labeled_pattern:
  _1 = TILDE x = LIDENT _3 = labeled_pattern_constraint
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( Term (Labelled _2.txt, None, _3 _2) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( _1 )}
| _1 = TILDE x = LIDENT _3 = labeled_pattern_constraint _4 = EQUAL _5 = expr
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( Term (Optional _2.txt, Some _5, _3 _2) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( _1 )}
| _1 = TILDE x = LIDENT _3 = labeled_pattern_constraint _4 = EQUAL _5 = QUESTION
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( Term (Optional _2.txt, None, _3 _2) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( _1 )}
| _1 = pattern_optional_constraint
    {let _1 =
  let x =     ( Term (Nolabel, None, _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( _1 )}
| _1 = TYPE _2 = LIDENT
    {let _1 =
  let x =     ( Type _2 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( _1 )}

es6_parameters:
  _1 = LPAREN _2 = RPAREN
    {let _1 =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                    (
    let loc = mklocation _startpos _endpos in
    ([mkloc (Term (Nolabel, None, mkpat_constructor_unit loc loc)) loc], false)
  )
in
                         ( _1 )}
| _1 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2 = option_COMMA_ _3 = RPAREN
    {let _1 =
  let _1 =
    let _1 =
      let x =
        let _1 = _1_inlined1 in
        let _1 =                                        ( List.rev _1 ) in
                                                                  ( _1 )
      in
          ( x )
    in
                                                           ( _1 )
  in
                                                 (
    (_1, false)
  )
in
                         ( _1 )}
| _1 = LPAREN _2 = DOT _3 = RPAREN
    {let _1 =
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                        (
      let loc = mklocation _startpos _endpos in
      ([mkloc (Term (Nolabel, None, mkpat_constructor_unit loc loc)) loc], true)
  )
in
                         ( _1 )}
| _1 = LPAREN _2 = DOT _1_inlined1 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2_inlined1 = option_COMMA_ _4 = RPAREN
    {let _1 =
  let _3 =
    let _1 = _1_inlined1 in
    let _1 =                                        ( List.rev _1 ) in
                                                              ( _1 )
  in
                                                    (
    let () = List.iter (fun p ->
        match p.txt with
        | Term (Labelled _, _, _)
        | Term (Optional _, _, _)  ->
            raise Reason_syntax_util.(
              Error(p.loc, (Syntax_error "Uncurried function definition with labelled arguments is not supported at the moment."))
            )
        | _ -> ()
      ) _3 in
    (_3, true)
  )
in
                         ( _1 )}
| x = UNDERSCORE
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( ([{_1 with txt = Term (Nolabel, None, mkpat ~loc:_1.loc Ppat_any)}], false) )}
| _1 = simple_pattern_ident
    {    ( ([Location.mkloc (Term (Nolabel, None, _1)) _1.ppat_loc], false) )}

jsx_arguments:
  
    {              ( [] )}
| _1 = LIDENT _2 = EQUAL _3 = QUESTION _1_inlined1 = simple_expr_call _5 = jsx_arguments
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                                        ( mkexp_app_rev _startpos _endpos _1 )
in
    ( (* a=?b *)
      [(Optional _1, _4)] @ _5
    )}
| _1 = QUESTION _2 = LIDENT _3 = jsx_arguments
    {    ( (* <Foo ?bar /> punning with explicitly passed optional *)
      let loc_lident = mklocation _startpos__2_ _endpos__2_ in
      [(Optional _2, mkexp (Pexp_ident {txt = Lident _2; loc = loc_lident}) ~loc:loc_lident)] @ _3
    )}
| _1 = LIDENT _2 = EQUAL _1_inlined1 = simple_expr_call _4 = jsx_arguments
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                                        ( mkexp_app_rev _startpos _endpos _1 )
in
    ( (* a=b *)
      [(Labelled _1, _3)] @ _4
    )}
| _1 = LIDENT _2 = jsx_arguments
    {    ( (* a (punning) *)
      let loc_lident = mklocation _startpos__1_ _endpos__1_ in
      [(Labelled _1, mkexp (Pexp_ident {txt = Lident _1; loc = loc_lident}) ~loc:loc_lident)] @ _2
    )}
| x = INFIXOP3
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  (
    match _1.txt with
    | "/>>" ->
     let err = Reason_syntax_util.Syntax_error {|JSX in a JSX-argument needs to be wrapped in braces.
    If you wrote:
      <Description term=<Text text="Age" />> child </Description>
    Try wrapping <Text /> in braces.
      <Description term={<Text text="Age" />}> child </Description>|} in
      raise (Reason_syntax_util.Error(_1.loc, err))
    | "/>/>" ->
     let err = Reason_syntax_util.Syntax_error {|JSX in a JSX-argument needs to be wrapped in braces.
    If you wrote:
      <Description term=<Text text="Age" />/>
    Try wrapping <Text /> in braces.
      <Description term={<Text text="Age" />} />|} in
      raise (Reason_syntax_util.Error(_1.loc, err))
    | _ -> syntax_error ()
  )}

jsx_start_tag_and_args:
  x = LESSIDENT _2 = jsx_arguments
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( let name = Longident.parse _1.txt in
      (jsx_component {_1 with txt = name} _2, name)
    )}
| _1 = LESS x = mod_ext_longident _3 = jsx_arguments
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( jsx_component _2 _3, _2.txt )}

jsx_start_tag_and_args_without_leading_less:
  x = mod_ext_longident _2 = jsx_arguments
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( (jsx_component _1 _2, _1.txt) )}
| x = LIDENT _2 = jsx_arguments
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( let lident = Longident.Lident _1.txt in
      (jsx_component {_1 with txt = lident } _2, lident)
    )}

greater_spread:
  _1 = GREATERDOTDOTDOT
    {                      ( ">..." )}
| _1 = GREATER _2 = DOTDOTDOT
    {                      ( ">..." )}

jsx:
  _1 = LESSGREATER _2 = list_simple_expr_no_call_ _3 = LESSSLASHGREATER
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      let body = mktailexp_extension loc _2 None in
      makeFrag loc body
    )}
| _1 = jsx_start_tag_and_args _2 = SLASHGREATER
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
    ( let (component, _) = _1 in
      let loc = mklocation _symbolstartpos _endpos in
      component [
        (Labelled "children", mktailexp_extension loc [] None);
        (Nolabel, mkexp_constructor_unit loc loc)
      ] loc
    )}
| _1 = jsx_start_tag_and_args _2 = GREATER _3 = list_simple_expr_no_call_ _4 = LESSSLASHIDENTGREATER
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
    ( let (component, start) = _1 in
      let loc = mklocation _symbolstartpos _endpos in
      (* TODO: Make this tag check simply a warning *)
      let endName = Longident.parse _4 in
      let _ = ensureTagsAreEqual start endName loc in
      let siblings = if List.length _3 > 0 then _3 else [] in
      component [
        (Labelled "children", mktailexp_extension loc siblings None);
        (Nolabel, mkexp_constructor_unit loc loc)
      ] loc
    )}
| _1 = jsx_start_tag_and_args _2 = greater_spread _3 = simple_expr_no_call _4 = LESSSLASHIDENTGREATER
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
    ( let (component, start) = _1 in
      let loc = mklocation _symbolstartpos _endpos in
      (* TODO: Make this tag check simply a warning *)
      let endName = Longident.parse _4 in
      let _ = ensureTagsAreEqual start endName loc in
      let child = _3 in
      component [
        (Labelled "children", child);
        (Nolabel, mkexp_constructor_unit loc loc)
      ] loc
    )}

jsx_without_leading_less:
  _1 = GREATER _2 = list_simple_expr_no_call_ _3 = LESSSLASHGREATER
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                                  (
    let loc = mklocation _symbolstartpos _endpos in
    let body = mktailexp_extension loc _2 None in
    makeFrag loc body
  )}
| _1 = jsx_start_tag_and_args_without_leading_less _2 = SLASHGREATER
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
                                                             (
    let (component, _) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    component [
      (Labelled "children", mktailexp_extension loc [] None);
      (Nolabel, mkexp_constructor_unit loc loc)
    ] loc
  )}
| _1 = jsx_start_tag_and_args_without_leading_less _2 = GREATER _3 = list_simple_expr_no_call_ _4 = LESSSLASHIDENTGREATER
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
                                                                                                   (
    let (component, start) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    (* TODO: Make this tag check simply a warning *)
    let endName = Longident.parse _4 in
    let _ = ensureTagsAreEqual start endName loc in
    let siblings = if List.length _3 > 0 then _3 else [] in
    component [
      (Labelled "children", mktailexp_extension loc siblings None);
      (Nolabel, mkexp_constructor_unit loc loc)
    ] loc
  )}
| _1 = jsx_start_tag_and_args_without_leading_less _2 = greater_spread _3 = simple_expr_no_call _4 = LESSSLASHIDENTGREATER
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
                                                                                                           (
    let (component, start) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    (* TODO: Make this tag check simply a warning *)
    let endName = Longident.parse _4 in
    let _ = ensureTagsAreEqual start endName loc in
    let child = _3 in
    component [
      (Labelled "children", child);
      (Nolabel, mkexp_constructor_unit loc loc)
    ] loc
  )}

optional_expr_extension:
  
    {                ( fun exp -> exp )}
| _1 = item_extension_sugar
    {                         ( fun exp -> expression_extension _1 exp  )}

expr:
  _1 = simple_expr_call
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( _1 )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = FUN _2 = optional_expr_extension _3 = fun_def_EQUALGREATER_non_arrowed_core_type_
    {let _1 =
  let _1 =
    let x =     ( _2 _3 ) in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = ES6_FUN _2 = es6_parameters _3 = EQUALGREATER _4 = expr
    {let _1 =
  let _1 =
    let x =
      let _endpos = _endpos__4_ in
      let _startpos = _startpos__1_ in
          ( let (ps, uncurried) = _2 in
      let exp = List.fold_right mkexp_fun ps _4 in
      if uncurried then
        let loc = mklocation _startpos _endpos in
        {exp with pexp_attributes = (uncurry_payload loc)::exp.pexp_attributes}
      else exp
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = ES6_FUN _2 = es6_parameters _3 = COLON _4 = non_arrowed_core_type _5 = EQUALGREATER _6 = expr
    {let _1 =
  let _1 =
    let x =
      let _endpos = _endpos__6_ in
      let _startpos = _startpos__1_ in
          ( let (ps, uncurried) = _2 in
    let exp = List.fold_right mkexp_fun ps
        (ghexp_constraint (mklocation _startpos__4_ _endpos) _6 (Some _4, None))  in
    if uncurried then
      let loc = mklocation _startpos _endpos in
      {exp with pexp_attributes = (uncurry_payload loc)::exp.pexp_attributes}
    else exp
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = FUN _2 = optional_expr_extension _1_inlined1 = match_case_expr_ _2_inlined1 = llist_aux_match_case_expr__ %prec below_BAR
    {let _1 =
  let _1 =
    let x =
      let _3 =
        let (_2, _1) = (_2_inlined1, _1_inlined1) in
        let _1 =                                           ( _1 :: List.rev _2 ) in
                                                                    ( _1 )
      in
          ( _2 (mkexp (Pexp_function _3)) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__2_inlined1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = SWITCH _2 = optional_expr_extension _3 = simple_expr_no_constructor _4 = LBRACE _1_inlined1 = match_case_seq_expr_ _2_inlined1 = llist_aux_match_case_seq_expr__ _6 = RBRACE
    {let _1 =
  let _1 =
    let x =
      let _5 =
        let (_2, _1) = (_2_inlined1, _1_inlined1) in
        let _1 =                                           ( _1 :: List.rev _2 ) in
                                                                    ( _1 )
      in
          ( _2 (mkexp (Pexp_match (_3, _5))) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = TRY _2 = optional_expr_extension _3 = simple_expr_no_constructor _4 = LBRACE _1_inlined1 = match_case_seq_expr_ _2_inlined1 = llist_aux_match_case_seq_expr__ _6 = RBRACE
    {let _1 =
  let _1 =
    let x =
      let _5 =
        let (_2, _1) = (_2_inlined1, _1_inlined1) in
        let _1 =                                           ( _1 :: List.rev _2 ) in
                                                                    ( _1 )
      in
          ( _2 (mkexp (Pexp_try (_3, _5))) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = TRY _2 = optional_expr_extension _3 = simple_expr_no_constructor _4 = WITH _5 = error
    {let _1 =
  let _1 =
    let x =     ( syntax_error_exp (mklocation _startpos__5_ _endpos__5_) "Invalid try with") in
    let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = IF _2 = optional_expr_extension _3 = parenthesized_expr _1_inlined1 = simple_expr_call
    {let _1 =
  let _1 =
    let x =
      let _5 =     ( None ) in
      let _4 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( _2 (mkexp (Pexp_ifthenelse(_3, _4, _5))) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = IF _2 = optional_expr_extension _3 = parenthesized_expr _1_inlined1 = simple_expr_call _1_inlined2 = ELSE x = expr
    {let _1 =
  let _1 =
    let x =
      let _5 =
        let x =     ( x ) in
            ( Some x )
      in
      let _4 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( _2 (mkexp (Pexp_ifthenelse(_3, _4, _5))) )
    in
    let _startpos_x_ = _startpos__1_ in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = WHILE _2 = optional_expr_extension _3 = parenthesized_expr _1_inlined1 = simple_expr_call
    {let _1 =
  let _1 =
    let x =
      let _4 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( _2 (mkexp (Pexp_while(_3, _4))) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = FOR _2 = optional_expr_extension _3 = LPAREN _4 = pattern _5 = IN _6 = expr _7 = direction_flag _8 = expr _9 = RPAREN _1_inlined1 = simple_expr_call
    {let _1 =
  let _1 =
    let x =
      let _10 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( _2 (mkexp (Pexp_for(_4, _6, _8, _7, _10))) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = LPAREN _2 = COLONCOLON _3 = RPAREN _4 = LPAREN _5 = expr _6 = COMMA _7 = expr _8 = RPAREN
    {let _1 =
  let _1 =
    let x =
      let _endpos = _endpos__8_ in
      let _symbolstartpos = _startpos__1_ in
          ( let loc_colon = mklocation _startpos__2_ _endpos__2_ in
      let loc = mklocation _symbolstartpos _endpos in
      mkexp_cons loc_colon (mkexp ~ghost:true ~loc (Pexp_tuple[_5;_7])) loc
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__8_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP0 _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP1 _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP2 _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP3 _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = SLASHGREATER _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "/>" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP4 _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = PLUS _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "+" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = PLUSDOT _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "+." ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = MINUS _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "-" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = MINUSDOT _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "-." ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = STAR _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "*" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = LESS _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "<" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = GREATER _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( ">" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = OR _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "or" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = BARBAR _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "||" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = AMPERSAND _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "&" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = AMPERAMPER _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "&&" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = COLONEQUAL _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( ":=" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = PLUSEQ _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "+=" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = PERCENT _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "%" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = LESSDOTDOTGREATER _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "<..>" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = GREATER _2 = GREATER _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let _startpos__1_ = _startpos__1_inlined1_ in
        let x =                       ( ">>" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = GREATERDOTDOTDOT _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                      ( ">..." ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP0 _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP1 _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP2 _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP3 _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = SLASHGREATER _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "/>" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP4 _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = PLUS _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "+" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = PLUSDOT _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "+." ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = MINUS _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "-" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = MINUSDOT _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "-." ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = STAR _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "*" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = LESS _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "<" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = GREATER _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( ">" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = OR _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "or" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = BARBAR _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "||" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = AMPERSAND _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "&" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = AMPERAMPER _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "&&" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = COLONEQUAL _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( ":=" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = PLUSEQ _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "+=" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = PERCENT _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "%" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = LESSDOTDOTGREATER _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "<..>" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = GREATER _2 = GREATER _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let _startpos__1_ = _startpos__1_inlined1_ in
        let x =                       ( ">>" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _1_inlined1 = GREATERDOTDOTDOT _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                      ( ">..." ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| x = subtractive _2 = expr %prec prec_unary
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( mkuminus _1 _2 )
    in
    let _endpos_x_ = _endpos__2_ in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| x = additive _2 = expr %prec prec_unary
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( mkuplus _1 _2 )
    in
    let _endpos_x_ = _endpos__2_ in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = BANG _2 = expr %prec prec_unary
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let x =                 ("!") in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( mkexp(Pexp_apply(mkoperator _1, [Nolabel,_2])) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = simple_expr_call _2 = DOT x = label_longident _4 = EQUAL _5 = expr
    {let _1 =
  let _1 =
    let x =
      let _3 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
      let _1 =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( mkexp(Pexp_setfield(_1, _3, _5)) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = simple_expr_call _2 = LBRACKET _3 = expr _4 = RBRACKET _5 = EQUAL _6 = expr
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
      let _endpos = _endpos__6_ in
      let _symbolstartpos = _startpos__1_ in
          ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Pexp_ident(array_function ~loc "Array" "set") in
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc exp,
                       [Nolabel,_1; Nolabel,_3; Nolabel,_6]))
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = simple_expr_call _2 = DOT _3 = LBRACKET _4 = expr _5 = RBRACKET _6 = EQUAL _7 = expr
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
      let _endpos = _endpos__7_ in
      let _symbolstartpos = _startpos__1_ in
          ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Pexp_ident(array_function ~loc "String" "set") in
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc exp,
                       [Nolabel,_1; Nolabel,_4; Nolabel,_7]))
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__7_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = simple_expr_call _1_inlined1 = DOT _2 = LBRACE _1_inlined2 = lseparated_nonempty_list_aux_COMMA_expr_ _4_inlined1 = option_COMMA_ _5 = RBRACE _3 = EQUAL _4 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let _1_inlined1 = _1_inlined2 in
        let _3 =
          let _1 = _1_inlined1 in
                                                 ( List.rev _1 )
        in
                                                                         ( _3 )
      in
      let _1 =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
      let _endpos = _endpos__4_ in
      let _symbolstartpos = _startpos__1_ in
          ( let loc = mklocation _symbolstartpos _endpos in
      bigarray_set ~loc _1 _2 _4
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = LIDENT _2 = EQUAL _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( mkexp(Pexp_setinstvar(_1, _3)) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = ASSERT _1_inlined1 = simple_expr_call
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( mkexp (Pexp_assert _2) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = LAZY _1_inlined1 = simple_expr_call
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( mkexp (Pexp_lazy _2) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = expr _2 = QUESTION _3 = expr _4 = COLON _5 = expr
    {let _1 =
  let _1 =
    let x =     ( (* Should use ghost expressions, but not sure how that would work with source maps *)
      (* So ? will become true and : becomes false for now*)
      let loc_question = mklocation _startpos__2_ _endpos__2_ in
      let loc_colon = mklocation _startpos__4_ _endpos__4_ in
      let fauxTruePat =
        Pat.mk ~loc:loc_question (Ppat_construct({txt = Lident "true"; loc = loc_question}, None)) in
      let fauxFalsePat =
        Pat.mk ~loc:loc_colon (Ppat_construct({txt = Lident "false"; loc = loc_colon}, None)) in
      let fauxMatchCaseTrue = Exp.case fauxTruePat _3 in
      let fauxMatchCaseFalse = Exp.case fauxFalsePat _5 in
      mkexp (Pexp_match (_1, [fauxMatchCaseTrue; fauxMatchCaseFalse]))
    ) in
    let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                     ( _1 )}
| _1 = attribute _2 = expr %prec attribute_precedence
    {let _1 =
  let x =                      ( {_2 with pexp_attributes = _1 :: _2.pexp_attributes} ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    ( _1 )}

unattributed_expr:
  _1 = simple_expr_call
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( _1 )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = FUN _2 = optional_expr_extension _3 = fun_def_EQUALGREATER_non_arrowed_core_type_
    {let _1 =
  let _1 =
    let x =     ( _2 _3 ) in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = ES6_FUN _2 = es6_parameters _3 = EQUALGREATER _4 = expr
    {let _1 =
  let _1 =
    let x =
      let _endpos = _endpos__4_ in
      let _startpos = _startpos__1_ in
          ( let (ps, uncurried) = _2 in
      let exp = List.fold_right mkexp_fun ps _4 in
      if uncurried then
        let loc = mklocation _startpos _endpos in
        {exp with pexp_attributes = (uncurry_payload loc)::exp.pexp_attributes}
      else exp
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = ES6_FUN _2 = es6_parameters _3 = COLON _4 = non_arrowed_core_type _5 = EQUALGREATER _6 = expr
    {let _1 =
  let _1 =
    let x =
      let _endpos = _endpos__6_ in
      let _startpos = _startpos__1_ in
          ( let (ps, uncurried) = _2 in
    let exp = List.fold_right mkexp_fun ps
        (ghexp_constraint (mklocation _startpos__4_ _endpos) _6 (Some _4, None))  in
    if uncurried then
      let loc = mklocation _startpos _endpos in
      {exp with pexp_attributes = (uncurry_payload loc)::exp.pexp_attributes}
    else exp
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = FUN _2 = optional_expr_extension _1_inlined1 = match_case_expr_ _2_inlined1 = llist_aux_match_case_expr__ %prec below_BAR
    {let _1 =
  let _1 =
    let x =
      let _3 =
        let (_2, _1) = (_2_inlined1, _1_inlined1) in
        let _1 =                                           ( _1 :: List.rev _2 ) in
                                                                    ( _1 )
      in
          ( _2 (mkexp (Pexp_function _3)) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__2_inlined1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = SWITCH _2 = optional_expr_extension _3 = simple_expr_no_constructor _4 = LBRACE _1_inlined1 = match_case_seq_expr_ _2_inlined1 = llist_aux_match_case_seq_expr__ _6 = RBRACE
    {let _1 =
  let _1 =
    let x =
      let _5 =
        let (_2, _1) = (_2_inlined1, _1_inlined1) in
        let _1 =                                           ( _1 :: List.rev _2 ) in
                                                                    ( _1 )
      in
          ( _2 (mkexp (Pexp_match (_3, _5))) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = TRY _2 = optional_expr_extension _3 = simple_expr_no_constructor _4 = LBRACE _1_inlined1 = match_case_seq_expr_ _2_inlined1 = llist_aux_match_case_seq_expr__ _6 = RBRACE
    {let _1 =
  let _1 =
    let x =
      let _5 =
        let (_2, _1) = (_2_inlined1, _1_inlined1) in
        let _1 =                                           ( _1 :: List.rev _2 ) in
                                                                    ( _1 )
      in
          ( _2 (mkexp (Pexp_try (_3, _5))) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = TRY _2 = optional_expr_extension _3 = simple_expr_no_constructor _4 = WITH _5 = error
    {let _1 =
  let _1 =
    let x =     ( syntax_error_exp (mklocation _startpos__5_ _endpos__5_) "Invalid try with") in
    let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = IF _2 = optional_expr_extension _3 = parenthesized_expr _1_inlined1 = simple_expr_call
    {let _1 =
  let _1 =
    let x =
      let _5 =     ( None ) in
      let _4 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( _2 (mkexp (Pexp_ifthenelse(_3, _4, _5))) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = IF _2 = optional_expr_extension _3 = parenthesized_expr _1_inlined1 = simple_expr_call _1_inlined2 = ELSE x = expr
    {let _1 =
  let _1 =
    let x =
      let _5 =
        let x =     ( x ) in
            ( Some x )
      in
      let _4 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( _2 (mkexp (Pexp_ifthenelse(_3, _4, _5))) )
    in
    let _startpos_x_ = _startpos__1_ in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = WHILE _2 = optional_expr_extension _3 = parenthesized_expr _1_inlined1 = simple_expr_call
    {let _1 =
  let _1 =
    let x =
      let _4 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( _2 (mkexp (Pexp_while(_3, _4))) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = FOR _2 = optional_expr_extension _3 = LPAREN _4 = pattern _5 = IN _6 = expr _7 = direction_flag _8 = expr _9 = RPAREN _1_inlined1 = simple_expr_call
    {let _1 =
  let _1 =
    let x =
      let _10 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( _2 (mkexp (Pexp_for(_4, _6, _8, _7, _10))) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = LPAREN _2 = COLONCOLON _3 = RPAREN _4 = LPAREN _5 = expr _6 = COMMA _7 = expr _8 = RPAREN
    {let _1 =
  let _1 =
    let x =
      let _endpos = _endpos__8_ in
      let _symbolstartpos = _startpos__1_ in
          ( let loc_colon = mklocation _startpos__2_ _endpos__2_ in
      let loc = mklocation _symbolstartpos _endpos in
      mkexp_cons loc_colon (mkexp ~ghost:true ~loc (Pexp_tuple[_5;_7])) loc
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__8_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = INFIXOP0 _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = INFIXOP1 _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = INFIXOP2 _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = INFIXOP3 _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = SLASHGREATER _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "/>" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = INFIXOP4 _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = PLUS _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "+" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = PLUSDOT _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "+." ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = MINUS _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "-" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = MINUSDOT _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "-." ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = STAR _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "*" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = LESS _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "<" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = GREATER _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( ">" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = OR _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "or" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = BARBAR _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "||" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = AMPERSAND _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "&" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = AMPERAMPER _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "&&" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = COLONEQUAL _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( ":=" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = PLUSEQ _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "+=" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = PERCENT _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "%" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = LESSDOTDOTGREATER _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "<..>" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = GREATER _2 = GREATER _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let _startpos__1_ = _startpos__1_inlined1_ in
        let x =                       ( ">>" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = GREATERDOTDOTDOT _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                      ( ">..." ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( let op = match _2.txt with
      | "->" -> {_2 with txt = "|."}
      | _ -> _2
      in mkinfix _1 op _3
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = INFIXOP0 _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = INFIXOP1 _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = INFIXOP2 _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = INFIXOP3 _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = SLASHGREATER _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "/>" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = INFIXOP4 _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = PLUS _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "+" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = PLUSDOT _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "+." ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = MINUS _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "-" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = MINUSDOT _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "-." ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = STAR _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "*" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = LESS _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "<" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = GREATER _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( ">" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = OR _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "or" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = BARBAR _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "||" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = AMPERSAND _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "&" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = AMPERAMPER _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "&&" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = COLONEQUAL _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( ":=" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = PLUSEQ _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "+=" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = PERCENT _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "%" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = LESSDOTDOTGREATER _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                       ( "<..>" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = GREATER _2 = GREATER _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let _startpos__1_ = _startpos__1_inlined1_ in
        let x =                       ( ">>" ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _1_inlined1 = GREATERDOTDOTDOT _3 = error
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
        let x =                      ( ">..." ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( expecting (with_txt _2 "expression after infix operator") )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| x = subtractive _2 = expr %prec prec_unary
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( mkuminus _1 _2 )
    in
    let _endpos_x_ = _endpos__2_ in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| x = additive _2 = expr %prec prec_unary
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( mkuplus _1 _2 )
    in
    let _endpos_x_ = _endpos__2_ in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = BANG _2 = expr %prec prec_unary
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let x =                 ("!") in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( mkexp(Pexp_apply(mkoperator _1, [Nolabel,_2])) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = simple_expr_call _2 = DOT x = label_longident _4 = EQUAL _5 = expr
    {let _1 =
  let _1 =
    let x =
      let _3 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
      let _1 =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( mkexp(Pexp_setfield(_1, _3, _5)) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = simple_expr_call _2 = LBRACKET _3 = expr _4 = RBRACKET _5 = EQUAL _6 = expr
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
      let _endpos = _endpos__6_ in
      let _symbolstartpos = _startpos__1_ in
          ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Pexp_ident(array_function ~loc "Array" "set") in
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc exp,
                       [Nolabel,_1; Nolabel,_3; Nolabel,_6]))
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__6_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = simple_expr_call _2 = DOT _3 = LBRACKET _4 = expr _5 = RBRACKET _6 = EQUAL _7 = expr
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
      let _endpos = _endpos__7_ in
      let _symbolstartpos = _startpos__1_ in
          ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Pexp_ident(array_function ~loc "String" "set") in
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc exp,
                       [Nolabel,_1; Nolabel,_4; Nolabel,_7]))
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__7_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = simple_expr_call _1_inlined1 = DOT _2 = LBRACE _1_inlined2 = lseparated_nonempty_list_aux_COMMA_expr_ _4_inlined1 = option_COMMA_ _5 = RBRACE _3 = EQUAL _4 = expr
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let _1_inlined1 = _1_inlined2 in
        let _3 =
          let _1 = _1_inlined1 in
                                                 ( List.rev _1 )
        in
                                                                         ( _3 )
      in
      let _1 =
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
      let _endpos = _endpos__4_ in
      let _symbolstartpos = _startpos__1_ in
          ( let loc = mklocation _symbolstartpos _endpos in
      bigarray_set ~loc _1 _2 _4
    )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = LIDENT _2 = EQUAL _3 = expr
    {let _1 =
  let _1 =
    let x =
      let _1 =
        let x =                       ( _1 ) in
        let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( mkexp(Pexp_setinstvar(_1, _3)) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = ASSERT _1_inlined1 = simple_expr_call
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( mkexp (Pexp_assert _2) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = LAZY _1_inlined1 = simple_expr_call
    {let _1 =
  let _1 =
    let x =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
                                              ( mkexp_app_rev _startpos _endpos _1 )
      in
          ( mkexp (Pexp_lazy _2) )
    in
    let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}
| _1 = unattributed_expr _2 = QUESTION _3 = expr _4 = COLON _5 = expr
    {let _1 =
  let _1 =
    let x =     ( (* Should use ghost expressions, but not sure how that would work with source maps *)
      (* So ? will become true and : becomes false for now*)
      let loc_question = mklocation _startpos__2_ _endpos__2_ in
      let loc_colon = mklocation _startpos__4_ _endpos__4_ in
      let fauxTruePat =
        Pat.mk ~loc:loc_question (Ppat_construct({txt = Lident "true"; loc = loc_question}, None)) in
      let fauxFalsePat =
        Pat.mk ~loc:loc_colon (Ppat_construct({txt = Lident "false"; loc = loc_colon}, None)) in
      let fauxMatchCaseTrue = Exp.case fauxTruePat _3 in
      let fauxMatchCaseFalse = Exp.case fauxFalsePat _5 in
      mkexp (Pexp_match (_1, [fauxMatchCaseTrue; fauxMatchCaseFalse]))
    ) in
    let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
                                                ( _1 )}

parenthesized_expr:
  _1 = braced_expr
    {    ( _1 )}
| _1 = LPAREN _2 = DOT _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( let loc = mklocation _startpos _endpos in
      mkexp_constructor_unit ~uncurried:true loc loc )}
| _1 = LPAREN _2 = expr_list _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( may_tuple _startpos _endpos _2 )}

simple_expr_no_constructor:
  x = val_longident
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
                              ( mkexp (Pexp_ident _1) )
  in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = constant
    {let _1 =
  let x =     ( let attrs, cst = _1 in mkexp ~attrs (Pexp_constant cst) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = jsx
    {let _1 =
  let x =                           ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = simple_expr_direct_argument
    {let _1 =
  let x =                                 ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = LBRACKETBAR _3 = option_COMMA_ _4 = BARRBRACKET
    {let _1 =
  let x =
    let _1 =
      let _2 =                 ( [] ) in
        ( let msg = "Arrays can't use the `...` spread currently. Please use `concat` or other Array helpers." in
    filter_raise_spread_syntax msg _2
  )
    in
        ( mkexp (Pexp_array _1) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = LBRACKETBAR _1_inlined1 = lseparated_nonempty_list_aux_COMMA_opt_spread_expr_optional_constraint__ _3 = option_COMMA_ _4 = BARRBRACKET
    {let _1 =
  let x =
    let _1 =
      let _2 =
        let _1 = _1_inlined1 in
        let _1 =                                        ( List.rev _1 ) in
                                             ( _1 )
      in
        ( let msg = "Arrays can't use the `...` spread currently. Please use `concat` or other Array helpers." in
    filter_raise_spread_syntax msg _2
  )
    in
        ( mkexp (Pexp_array _1) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = constr_longident %prec prec_constant_constructor
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp (Pexp_construct (_1, None)) )
  in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = BACKQUOTE _2 = ident %prec prec_constant_constructor
    {let _1 =
  let x =
    let _1 =                                   ( _2 ) in
        ( mkexp (Pexp_variant (_1, None)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = LPAREN _2 = expr_list _3 = RPAREN
    {let _1 =
  let x =
    let _endpos = _endpos__3_ in
    let _startpos = _startpos__1_ in
        ( may_tuple _startpos _endpos _2 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = LPAREN _2 = expr_list x_inlined1 = error
    {let _1 =
  let x =
    let _3 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _1 "(") (with_txt _3 ")") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = simple_expr_no_constructor x = POSTFIXOP
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp(Pexp_apply(mkoperator _2, [Nolabel, _1])) )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = mod_longident _2 = DOT _3 = LPAREN _4 = expr_list _5 = RPAREN
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp(Pexp_open(Fresh, _1, may_tuple _startpos__3_ _endpos__5_ _4)) )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = mod_longident _2 = DOT x = LPAREN _4 = expr_list x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "(") (with_txt _5 ")") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = simple_expr_no_constructor _2 = DOT x = label_longident
    {let _1 =
  let x =
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp(Pexp_field(_1, _3)) )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACE _4 = RBRACE
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__4_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let pat = mkpat (Ppat_var (mkloc "this" loc)) in
      mkexp(Pexp_open (Fresh, _1,
                       mkexp(Pexp_object(Cstr.mk pat []))))
    )
  in
  let _endpos_x_ = _endpos__4_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = simple_expr_no_constructor _2 = LBRACKET _3 = expr _4 = RBRACKET
    {let _1 =
  let x =
    let _endpos = _endpos__4_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Pexp_ident(array_function ~loc "Array" "get") in
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc exp, [Nolabel,_1; Nolabel,_3]))
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = simple_expr_no_constructor x = LBRACKET _3 = expr x_inlined1 = error
    {let _1 =
  let x =
    let _4 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _2 "(") (with_txt _4 ")") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = simple_expr_no_constructor _2 = DOT _3 = LBRACKET _4 = expr _5 = RBRACKET
    {let _1 =
  let x =
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Pexp_ident(array_function ~loc "String" "get") in
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc exp, [Nolabel,_1; Nolabel,_4]))
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = simple_expr_no_constructor _2 = DOT x = LBRACKET _4 = expr x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "[") (with_txt _5 "]") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = simple_expr_no_constructor _1_inlined1 = DOT _2 = LBRACE _1_inlined2 = lseparated_nonempty_list_aux_COMMA_expr_ _4 = option_COMMA_ _5 = RBRACE
    {let _1 =
  let x =
    let _2 =
      let _1_inlined1 = _1_inlined2 in
      let _3 =
        let _1 = _1_inlined1 in
                                               ( List.rev _1 )
      in
                                                                       ( _3 )
    in
    let _endpos__2_ = _endpos__5_ in
    let _endpos = _endpos__2_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      bigarray_get ~loc _1 _2 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACE _4 = record_expr _5 = RBRACE
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let (exten, fields) = _4 in
      let loc = mklocation _symbolstartpos _endpos in
      let rec_exp = mkexp ~loc (Pexp_record (fields, exten)) in
      mkexp(Pexp_open(Fresh, _1, rec_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = mod_longident _2 = DOT x = LBRACE _4 = record_expr x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "{") (with_txt _5 "}") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACE _4 = record_expr_with_string_keys _5 = RBRACE
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let (exten, fields) = _4 in
      let loc = mklocation _symbolstartpos _endpos in
      let rec_exp = mkexp ~loc (Pexp_extension (mkloc ("bs.obj") loc,
             PStr [mkstrexp (mkexp ~loc (Pexp_record(fields, exten))) []]))
      in
      mkexp(Pexp_open(Fresh, _1, rec_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = mod_longident _2 = DOT x = LBRACE _4 = record_expr_with_string_keys x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "{") (with_txt _5 "}") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACKETBAR _4 = expr_list _5 = BARRBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let rec_exp = Exp.mk ~loc ~attrs:[] (Pexp_array _4) in
      mkexp(Pexp_open(Fresh, _1, rec_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = mod_longident _2 = DOT x = LBRACKETBAR _4 = expr_list x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "[|") (with_txt _5 "|]") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACKETLESS _4 = jsx_without_leading_less _5 = RBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( let seq, ext_opt = [_4], None in
      let loc = mklocation _startpos__4_ _endpos__4_ in
      let list_exp = make_real_exp (mktailexp_extension loc seq ext_opt) in
      let list_exp = { list_exp with pexp_loc = loc } in
      mkexp (Pexp_open (Fresh, _1, list_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACKET _4 = RBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( let loc = mklocation _startpos__3_ _endpos__4_ in
      let list_exp = make_real_exp (mktailexp_extension loc [] None) in
      let list_exp = { list_exp with pexp_loc = loc } in
      mkexp (Pexp_open (Fresh, _1, list_exp))
    )
  in
  let _endpos_x_ = _endpos__4_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACKET _4 = expr_comma_seq_extension _5 = RBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( let seq, ext_opt = _4 in
      let loc = mklocation _startpos__4_ _endpos__4_ in
      let list_exp = make_real_exp (mktailexp_extension loc seq ext_opt) in
      let list_exp = { list_exp with pexp_loc = loc } in
      mkexp (Pexp_open (Fresh, _1, list_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = PREFIXOP _2 = simple_expr_no_constructor %prec below_DOT_AND_SHARP
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp(Pexp_apply(mkoperator _1, [Nolabel, _2])) )
  in
  let _endpos_x_ = _endpos__2_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = NEW x = class_longident
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp (Pexp_new _2) )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACELESS _1 = lseparated_nonempty_list_aux_COMMA_field_expr_ _5 = option_COMMA_ _6 = GREATERRBRACE
    {let _1 =
  let x =
    let _4 =
      let _1 =                                        ( List.rev _1 ) in
                                                                           ( _1 )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__6_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Exp.mk ~loc ~attrs:[] (Pexp_override _4) in
      mkexp (Pexp_open(Fresh, _1, exp))
    )
  in
  let _endpos_x_ = _endpos__6_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = mod_longident _2 = DOT x = LBRACELESS _1_inlined1 = lseparated_nonempty_list_aux_COMMA_field_expr_ _5 = option_COMMA_ x_inlined1 = error
    {let _1 =
  let x =
    let _6 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _4 =
      let _1 = _1_inlined1 in
      let _1 =                                        ( List.rev _1 ) in
                                                                           ( _1 )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "{<") (with_txt _6 ">}") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = simple_expr_no_constructor _2 = SHARP _1_inlined1 = LIDENT
    {let _1 =
  let x =
    let _3 =
      let _1 = _1_inlined1 in
                            ( _1 )
    in
        ( mkexp (Pexp_send(_1, _3)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = simple_expr_no_constructor x = SHARPOP _3 = simple_expr_no_call
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkinfixop _1 (mkoperator _2) _3 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = simple_expr_no_constructor x = SHARPEQUAL _1_inlined1 = simple_expr_call
    {let _1 =
  let x =
    let _3 =
      let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( let op = { _2 with txt = "#=" } in
      mkinfixop _1 (mkoperator op) _3 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = simple_expr_no_constructor x = MINUSGREATER _3 = simple_expr_no_call
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkinfixop _1 (mkoperator {_2 with txt = "|."}) _3 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| x = mod_longident _2 = DOT _3 = LPAREN _4 = MODULE _5 = module_expr _6 = COLON _7 = package_type _8 = RPAREN
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__8_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      mkexp (Pexp_open(Fresh, _1,
        mkexp ~loc (Pexp_constraint (mkexp ~ghost:true ~loc (Pexp_pack _5),
                                     mktyp ~ghost:true ~loc (Ptyp_package _7)))))
    )
  in
  let _endpos_x_ = _endpos__8_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = mod_longident _2 = DOT x = LPAREN _4 = MODULE _5 = module_expr _6 = COLON x_inlined1 = error
    {let _1 =
  let x =
    let _7 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "(") (with_txt _7 ")"))
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}
| _1 = extension
    {let _1 =
  let x =     ( mkexp (Pexp_extension _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}

simple_expr_template_constructor:
  x = constr_longident _1 = non_labeled_argument_list
    {let _2 =
  let x =                                     ( mkexp (Pexp_tuple(_1)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( mkExplicitArityTupleExp (Pexp_construct(_1, Some _2))
    )}
| x = constr_longident _1 = simple_expr_direct_argument
    {let _2 =
  let x =                                     ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( mkExplicitArityTupleExp (Pexp_construct(_1, Some _2))
    )}
| _1 = BACKQUOTE _2_inlined1 = ident _1_inlined1 = non_labeled_argument_list
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =         ( (* only wrap in a tuple if there are more than one arguments *)
          match _1 with
          | [x] -> x
          | l -> mkexp (Pexp_tuple(l))
        ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
let _1 =
  let _2 = _2_inlined1 in
                                    ( _2 )
in
    ( mkexp(Pexp_variant(_1, Some _2)) )}
| _1 = BACKQUOTE _2_inlined1 = ident _1_inlined1 = simple_expr_direct_argument
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                                     ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
let _1 =
  let _2 = _2_inlined1 in
                                    ( _2 )
in
    ( mkexp(Pexp_variant(_1, Some _2)) )}

simple_expr_no_call:
  x = val_longident
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
                              ( mkexp (Pexp_ident _1) )
  in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = constant
    {let _1 =
  let x =     ( let attrs, cst = _1 in mkexp ~attrs (Pexp_constant cst) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = jsx
    {let _1 =
  let x =                           ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_direct_argument
    {let _1 =
  let x =                                 ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = LBRACKETBAR _3 = option_COMMA_ _4 = BARRBRACKET
    {let _1 =
  let x =
    let _1 =
      let _2 =                 ( [] ) in
        ( let msg = "Arrays can't use the `...` spread currently. Please use `concat` or other Array helpers." in
    filter_raise_spread_syntax msg _2
  )
    in
        ( mkexp (Pexp_array _1) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = LBRACKETBAR _1_inlined1 = lseparated_nonempty_list_aux_COMMA_opt_spread_expr_optional_constraint__ _3 = option_COMMA_ _4 = BARRBRACKET
    {let _1 =
  let x =
    let _1 =
      let _2 =
        let _1 = _1_inlined1 in
        let _1 =                                        ( List.rev _1 ) in
                                             ( _1 )
      in
        ( let msg = "Arrays can't use the `...` spread currently. Please use `concat` or other Array helpers." in
    filter_raise_spread_syntax msg _2
  )
    in
        ( mkexp (Pexp_array _1) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = constr_longident %prec prec_constant_constructor
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp (Pexp_construct (_1, None)) )
  in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = BACKQUOTE _2 = ident %prec prec_constant_constructor
    {let _1 =
  let x =
    let _1 =                                   ( _2 ) in
        ( mkexp (Pexp_variant (_1, None)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = LPAREN _2 = expr_list _3 = RPAREN
    {let _1 =
  let x =
    let _endpos = _endpos__3_ in
    let _startpos = _startpos__1_ in
        ( may_tuple _startpos _endpos _2 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = LPAREN _2 = expr_list x_inlined1 = error
    {let _1 =
  let x =
    let _3 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _1 "(") (with_txt _3 ")") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_no_call x = POSTFIXOP
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp(Pexp_apply(mkoperator _2, [Nolabel, _1])) )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = mod_longident _2 = DOT _3 = LPAREN _4 = expr_list _5 = RPAREN
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp(Pexp_open(Fresh, _1, may_tuple _startpos__3_ _endpos__5_ _4)) )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = mod_longident _2 = DOT x = LPAREN _4 = expr_list x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "(") (with_txt _5 ")") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_no_call _2 = DOT x = label_longident
    {let _1 =
  let x =
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp(Pexp_field(_1, _3)) )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACE _4 = RBRACE
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__4_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let pat = mkpat (Ppat_var (mkloc "this" loc)) in
      mkexp(Pexp_open (Fresh, _1,
                       mkexp(Pexp_object(Cstr.mk pat []))))
    )
  in
  let _endpos_x_ = _endpos__4_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_no_call _2 = LBRACKET _3 = expr _4 = RBRACKET
    {let _1 =
  let x =
    let _endpos = _endpos__4_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Pexp_ident(array_function ~loc "Array" "get") in
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc exp, [Nolabel,_1; Nolabel,_3]))
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_no_call x = LBRACKET _3 = expr x_inlined1 = error
    {let _1 =
  let x =
    let _4 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _2 "(") (with_txt _4 ")") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_no_call _2 = DOT _3 = LBRACKET _4 = expr _5 = RBRACKET
    {let _1 =
  let x =
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Pexp_ident(array_function ~loc "String" "get") in
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc exp, [Nolabel,_1; Nolabel,_4]))
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_no_call _2 = DOT x = LBRACKET _4 = expr x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "[") (with_txt _5 "]") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_no_call _1_inlined1 = DOT _2 = LBRACE _1_inlined2 = lseparated_nonempty_list_aux_COMMA_expr_ _4 = option_COMMA_ _5 = RBRACE
    {let _1 =
  let x =
    let _2 =
      let _1_inlined1 = _1_inlined2 in
      let _3 =
        let _1 = _1_inlined1 in
                                               ( List.rev _1 )
      in
                                                                       ( _3 )
    in
    let _endpos__2_ = _endpos__5_ in
    let _endpos = _endpos__2_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      bigarray_get ~loc _1 _2 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACE _4 = record_expr _5 = RBRACE
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let (exten, fields) = _4 in
      let loc = mklocation _symbolstartpos _endpos in
      let rec_exp = mkexp ~loc (Pexp_record (fields, exten)) in
      mkexp(Pexp_open(Fresh, _1, rec_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = mod_longident _2 = DOT x = LBRACE _4 = record_expr x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "{") (with_txt _5 "}") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACE _4 = record_expr_with_string_keys _5 = RBRACE
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let (exten, fields) = _4 in
      let loc = mklocation _symbolstartpos _endpos in
      let rec_exp = mkexp ~loc (Pexp_extension (mkloc ("bs.obj") loc,
             PStr [mkstrexp (mkexp ~loc (Pexp_record(fields, exten))) []]))
      in
      mkexp(Pexp_open(Fresh, _1, rec_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = mod_longident _2 = DOT x = LBRACE _4 = record_expr_with_string_keys x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "{") (with_txt _5 "}") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACKETBAR _4 = expr_list _5 = BARRBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let rec_exp = Exp.mk ~loc ~attrs:[] (Pexp_array _4) in
      mkexp(Pexp_open(Fresh, _1, rec_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = mod_longident _2 = DOT x = LBRACKETBAR _4 = expr_list x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "[|") (with_txt _5 "|]") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACKETLESS _4 = jsx_without_leading_less _5 = RBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( let seq, ext_opt = [_4], None in
      let loc = mklocation _startpos__4_ _endpos__4_ in
      let list_exp = make_real_exp (mktailexp_extension loc seq ext_opt) in
      let list_exp = { list_exp with pexp_loc = loc } in
      mkexp (Pexp_open (Fresh, _1, list_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACKET _4 = RBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( let loc = mklocation _startpos__3_ _endpos__4_ in
      let list_exp = make_real_exp (mktailexp_extension loc [] None) in
      let list_exp = { list_exp with pexp_loc = loc } in
      mkexp (Pexp_open (Fresh, _1, list_exp))
    )
  in
  let _endpos_x_ = _endpos__4_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACKET _4 = expr_comma_seq_extension _5 = RBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( let seq, ext_opt = _4 in
      let loc = mklocation _startpos__4_ _endpos__4_ in
      let list_exp = make_real_exp (mktailexp_extension loc seq ext_opt) in
      let list_exp = { list_exp with pexp_loc = loc } in
      mkexp (Pexp_open (Fresh, _1, list_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = PREFIXOP _2 = simple_expr_no_call %prec below_DOT_AND_SHARP
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp(Pexp_apply(mkoperator _1, [Nolabel, _2])) )
  in
  let _endpos_x_ = _endpos__2_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = NEW x = class_longident
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp (Pexp_new _2) )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = mod_longident _2 = DOT _3 = LBRACELESS _1 = lseparated_nonempty_list_aux_COMMA_field_expr_ _5 = option_COMMA_ _6 = GREATERRBRACE
    {let _1 =
  let x =
    let _4 =
      let _1 =                                        ( List.rev _1 ) in
                                                                           ( _1 )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__6_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Exp.mk ~loc ~attrs:[] (Pexp_override _4) in
      mkexp (Pexp_open(Fresh, _1, exp))
    )
  in
  let _endpos_x_ = _endpos__6_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = mod_longident _2 = DOT x = LBRACELESS _1_inlined1 = lseparated_nonempty_list_aux_COMMA_field_expr_ _5 = option_COMMA_ x_inlined1 = error
    {let _1 =
  let x =
    let _6 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _4 =
      let _1 = _1_inlined1 in
      let _1 =                                        ( List.rev _1 ) in
                                                                           ( _1 )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "{<") (with_txt _6 ">}") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_no_call _2 = SHARP _1_inlined1 = LIDENT
    {let _1 =
  let x =
    let _3 =
      let _1 = _1_inlined1 in
                            ( _1 )
    in
        ( mkexp (Pexp_send(_1, _3)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_no_call x = SHARPOP _3 = simple_expr_no_call
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkinfixop _1 (mkoperator _2) _3 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_no_call x = SHARPEQUAL _1_inlined1 = simple_expr_call
    {let _1 =
  let x =
    let _3 =
      let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( let op = { _2 with txt = "#=" } in
      mkinfixop _1 (mkoperator op) _3 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_no_call x = MINUSGREATER _3 = simple_expr_no_call
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkinfixop _1 (mkoperator {_2 with txt = "|."}) _3 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| x = mod_longident _2 = DOT _3 = LPAREN _4 = MODULE _5 = module_expr _6 = COLON _7 = package_type _8 = RPAREN
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__8_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      mkexp (Pexp_open(Fresh, _1,
        mkexp ~loc (Pexp_constraint (mkexp ~ghost:true ~loc (Pexp_pack _5),
                                     mktyp ~ghost:true ~loc (Ptyp_package _7)))))
    )
  in
  let _endpos_x_ = _endpos__8_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = mod_longident _2 = DOT x = LPAREN _4 = MODULE _5 = module_expr _6 = COLON x_inlined1 = error
    {let _1 =
  let x =
    let _7 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "(") (with_txt _7 ")"))
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = extension
    {let _1 =
  let x =     ( mkexp (Pexp_extension _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                 ( _1 )}
| _1 = simple_expr_template_constructor
    {                                     ( _1 )}

simple_expr_call:
  x = val_longident
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
                              ( mkexp (Pexp_ident _1) )
  in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = constant
    {let _1 =
  let x =     ( let attrs, cst = _1 in mkexp ~attrs (Pexp_constant cst) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = jsx
    {let _1 =
  let x =                           ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_direct_argument
    {let _1 =
  let x =                                 ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = LBRACKETBAR _3 = option_COMMA_ _4 = BARRBRACKET
    {let _1 =
  let x =
    let _1 =
      let _2 =                 ( [] ) in
        ( let msg = "Arrays can't use the `...` spread currently. Please use `concat` or other Array helpers." in
    filter_raise_spread_syntax msg _2
  )
    in
        ( mkexp (Pexp_array _1) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = LBRACKETBAR _1_inlined1 = lseparated_nonempty_list_aux_COMMA_opt_spread_expr_optional_constraint__ _3 = option_COMMA_ _4 = BARRBRACKET
    {let _1 =
  let x =
    let _1 =
      let _2 =
        let _1 = _1_inlined1 in
        let _1 =                                        ( List.rev _1 ) in
                                             ( _1 )
      in
        ( let msg = "Arrays can't use the `...` spread currently. Please use `concat` or other Array helpers." in
    filter_raise_spread_syntax msg _2
  )
    in
        ( mkexp (Pexp_array _1) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = constr_longident %prec prec_constant_constructor
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp (Pexp_construct (_1, None)) )
  in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = BACKQUOTE _2 = ident %prec prec_constant_constructor
    {let _1 =
  let x =
    let _1 =                                   ( _2 ) in
        ( mkexp (Pexp_variant (_1, None)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = LPAREN _2 = expr_list _3 = RPAREN
    {let _1 =
  let x =
    let _endpos = _endpos__3_ in
    let _startpos = _startpos__1_ in
        ( may_tuple _startpos _endpos _2 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = LPAREN _2 = expr_list x_inlined1 = error
    {let _1 =
  let x =
    let _3 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _1 "(") (with_txt _3 ")") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_call x = POSTFIXOP
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
        ( mkexp(Pexp_apply(mkoperator _2, [Nolabel, _1])) )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = mod_longident _2 = DOT _3 = LPAREN _4 = expr_list _5 = RPAREN
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp(Pexp_open(Fresh, _1, may_tuple _startpos__3_ _endpos__5_ _4)) )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = mod_longident _2 = DOT x = LPAREN _4 = expr_list x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "(") (with_txt _5 ")") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_call _2 = DOT x = label_longident
    {let _1 =
  let x =
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
        ( mkexp(Pexp_field(_1, _3)) )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = mod_longident _2 = DOT _3 = LBRACE _4 = RBRACE
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__4_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let pat = mkpat (Ppat_var (mkloc "this" loc)) in
      mkexp(Pexp_open (Fresh, _1,
                       mkexp(Pexp_object(Cstr.mk pat []))))
    )
  in
  let _endpos_x_ = _endpos__4_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_call _2 = LBRACKET _3 = expr _4 = RBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
    let _endpos = _endpos__4_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Pexp_ident(array_function ~loc "Array" "get") in
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc exp, [Nolabel,_1; Nolabel,_3]))
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_call x = LBRACKET _3 = expr x_inlined1 = error
    {let _1 =
  let x =
    let _4 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
        ( unclosed_exp (with_txt _2 "(") (with_txt _4 ")") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_call _2 = DOT _3 = LBRACKET _4 = expr _5 = RBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Pexp_ident(array_function ~loc "String" "get") in
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc exp, [Nolabel,_1; Nolabel,_4]))
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_call _2 = DOT x = LBRACKET _4 = expr x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
        ( unclosed_exp (with_txt _3 "[") (with_txt _5 "]") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_call _1_inlined1 = DOT _2 = LBRACE _1_inlined2 = lseparated_nonempty_list_aux_COMMA_expr_ _4 = option_COMMA_ _5 = RBRACE
    {let _1 =
  let x =
    let _2 =
      let _1_inlined1 = _1_inlined2 in
      let _3 =
        let _1 = _1_inlined1 in
                                               ( List.rev _1 )
      in
                                                                       ( _3 )
    in
    let _endpos__2_ = _endpos__5_ in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
    let _endpos = _endpos__2_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      bigarray_get ~loc _1 _2 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = mod_longident _2 = DOT _3 = LBRACE _4 = record_expr _5 = RBRACE
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let (exten, fields) = _4 in
      let loc = mklocation _symbolstartpos _endpos in
      let rec_exp = mkexp ~loc (Pexp_record (fields, exten)) in
      mkexp(Pexp_open(Fresh, _1, rec_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = mod_longident _2 = DOT x = LBRACE _4 = record_expr x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "{") (with_txt _5 "}") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = mod_longident _2 = DOT _3 = LBRACE _4 = record_expr_with_string_keys _5 = RBRACE
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let (exten, fields) = _4 in
      let loc = mklocation _symbolstartpos _endpos in
      let rec_exp = mkexp ~loc (Pexp_extension (mkloc ("bs.obj") loc,
             PStr [mkstrexp (mkexp ~loc (Pexp_record(fields, exten))) []]))
      in
      mkexp(Pexp_open(Fresh, _1, rec_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = mod_longident _2 = DOT x = LBRACE _4 = record_expr_with_string_keys x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "{") (with_txt _5 "}") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = mod_longident _2 = DOT _3 = LBRACKETBAR _4 = expr_list _5 = BARRBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let rec_exp = Exp.mk ~loc ~attrs:[] (Pexp_array _4) in
      mkexp(Pexp_open(Fresh, _1, rec_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = mod_longident _2 = DOT x = LBRACKETBAR _4 = expr_list x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "[|") (with_txt _5 "|]") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = mod_longident _2 = DOT _3 = LBRACKETLESS _4 = jsx_without_leading_less _5 = RBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( let seq, ext_opt = [_4], None in
      let loc = mklocation _startpos__4_ _endpos__4_ in
      let list_exp = make_real_exp (mktailexp_extension loc seq ext_opt) in
      let list_exp = { list_exp with pexp_loc = loc } in
      mkexp (Pexp_open (Fresh, _1, list_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = mod_longident _2 = DOT _3 = LBRACKET _4 = RBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( let loc = mklocation _startpos__3_ _endpos__4_ in
      let list_exp = make_real_exp (mktailexp_extension loc [] None) in
      let list_exp = { list_exp with pexp_loc = loc } in
      mkexp (Pexp_open (Fresh, _1, list_exp))
    )
  in
  let _endpos_x_ = _endpos__4_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = mod_longident _2 = DOT _3 = LBRACKET _4 = expr_comma_seq_extension _5 = RBRACKET
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( let seq, ext_opt = _4 in
      let loc = mklocation _startpos__4_ _endpos__4_ in
      let list_exp = make_real_exp (mktailexp_extension loc seq ext_opt) in
      let list_exp = { list_exp with pexp_loc = loc } in
      mkexp (Pexp_open (Fresh, _1, list_exp))
    )
  in
  let _endpos_x_ = _endpos__5_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = PREFIXOP _1 = simple_expr_call %prec below_DOT_AND_SHARP
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp(Pexp_apply(mkoperator _1, [Nolabel, _2])) )
  in
  let _endpos_x_ = _endpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = NEW x = class_longident
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkexp (Pexp_new _2) )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = mod_longident _2 = DOT _3 = LBRACELESS _1 = lseparated_nonempty_list_aux_COMMA_field_expr_ _5 = option_COMMA_ _6 = GREATERRBRACE
    {let _1 =
  let x =
    let _4 =
      let _1 =                                        ( List.rev _1 ) in
                                                                           ( _1 )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__6_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      let exp = Exp.mk ~loc ~attrs:[] (Pexp_override _4) in
      mkexp (Pexp_open(Fresh, _1, exp))
    )
  in
  let _endpos_x_ = _endpos__6_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = mod_longident _2 = DOT x = LBRACELESS _1_inlined1 = lseparated_nonempty_list_aux_COMMA_field_expr_ _5 = option_COMMA_ x_inlined1 = error
    {let _1 =
  let x =
    let _6 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _4 =
      let _1 = _1_inlined1 in
      let _1 =                                        ( List.rev _1 ) in
                                                                           ( _1 )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "{<") (with_txt _6 ">}") )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_call _2 = SHARP _1_inlined1 = LIDENT
    {let _1 =
  let x =
    let _3 =
      let _1 = _1_inlined1 in
                            ( _1 )
    in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
        ( mkexp (Pexp_send(_1, _3)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_call x = SHARPOP _3 = simple_expr_no_call
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
        ( mkinfixop _1 (mkoperator _2) _3 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_call x = SHARPEQUAL _1_inlined1 = simple_expr_call
    {let _1 =
  let x =
    let _3 =
      let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
        ( let op = { _2 with txt = "#=" } in
      mkinfixop _1 (mkoperator op) _3 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_call x = MINUSGREATER _3 = simple_expr_no_call
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
                                            ( mkexp_app_rev _startpos _endpos _1 )
    in
        ( mkinfixop _1 (mkoperator {_2 with txt = "|."}) _3 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| x = mod_longident _2 = DOT _3 = LPAREN _4 = MODULE _5 = module_expr _6 = COLON _7 = package_type _8 = RPAREN
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__8_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      mkexp (Pexp_open(Fresh, _1,
        mkexp ~loc (Pexp_constraint (mkexp ~ghost:true ~loc (Pexp_pack _5),
                                     mktyp ~ghost:true ~loc (Ptyp_package _7)))))
    )
  in
  let _endpos_x_ = _endpos__8_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = mod_longident _2 = DOT x = LPAREN _4 = MODULE _5 = module_expr _6 = COLON x_inlined1 = error
    {let _1 =
  let x =
    let _7 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_exp (with_txt _3 "(") (with_txt _7 ")"))
  in
  let (_endpos_x_, _startpos_x_) = (_endpos_x_inlined1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = extension
    {let _1 =
  let x =     ( mkexp (Pexp_extension _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                         ( (_1, []) )}
| _1 = simple_expr_call _2 = labeled_arguments
    {    ( let (body, args) = _1 in
      (body, List.rev_append _2 args) )}
| _1 = LBRACKET _2 = expr_comma_seq_extension _3 = RBRACKET
    {    ( let seq, ext_opt = _2 in
      let loc = mklocation _startpos__2_ _endpos__2_ in
      (make_real_exp (mktailexp_extension loc seq ext_opt), [])
    )}
| _1 = simple_expr_template_constructor
    {                                     ( (_1, []) )}

simple_expr_direct_argument:
  _1 = braced_expr
    {                ( _1 )}
| _1 = LBRACKETLESS _2 = jsx_without_leading_less _3 = COMMA _4 = expr_comma_seq_extension _5 = RBRACKET
    {    ( let entireLoc = mklocation _startpos__1_ _endpos__4_ in
      let (seq, ext_opt) = _4 in
      mktailexp_extension entireLoc (_2::seq) ext_opt
    )}
| _1 = LBRACKETLESS _2 = jsx_without_leading_less _3 = RBRACKET
    {    ( let entireLoc = mklocation _startpos__1_ _endpos__3_ in
      mktailexp_extension entireLoc (_2::[]) None
    )}
| _1 = LBRACKETLESS _2 = jsx_without_leading_less _3 = COMMA _4 = RBRACKET
    {    ( let entireLoc = mklocation _startpos__1_ _endpos__4_ in
      mktailexp_extension entireLoc [_2] None
    )}
| _1 = LBRACELESS _1_inlined1 = lseparated_nonempty_list_aux_COMMA_field_expr_ _3 = option_COMMA_ _4 = GREATERRBRACE
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =                                        ( List.rev _1 ) in
                                                                       ( _1 )
in
    ( mkexp (Pexp_override _2) )}
| x = LBRACELESS _1 = lseparated_nonempty_list_aux_COMMA_field_expr_ _3 = option_COMMA_ x_inlined1 = error
    {let _4 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _2 =
  let _1 =                                        ( List.rev _1 ) in
                                                                       ( _1 )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( unclosed_exp (with_txt _1 "{<") (with_txt _4 ">}" ) )}
| _1 = LBRACELESS _2 = GREATERRBRACE
    {    ( mkexp (Pexp_override []))}
| _1 = LPAREN _2 = MODULE _3 = module_expr _4 = RPAREN
    {    ( mkexp (Pexp_pack _3) )}
| _1 = LPAREN _2 = MODULE _3 = module_expr _4 = COLON _5 = package_type _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      mkexp (Pexp_constraint (mkexp ~ghost:true ~loc (Pexp_pack _3),
                              mktyp ~ghost:true ~loc (Ptyp_package _5)))
    )}
| x = LPAREN _2 = MODULE _3 = module_expr _4 = COLON x_inlined1 = error
    {let _5 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( unclosed_exp (with_txt _1 "(") (with_txt _5 ")") )}

non_labeled_argument_list:
  _1 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_expr_optional_constraint_ _2 = option_COMMA_ _3 = RPAREN
    {let _1 =
  let _1 =
    let x =
      let _1 = _1_inlined1 in
      let _1 =                                        ( List.rev _1 ) in
                                                                         ( _1 )
    in
        ( x )
  in
                                                         ( _1 )
in
                                                ( _1 )}
| _1 = LPAREN _2 = RPAREN
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
    ( let loc = mklocation _startpos _endpos in
      [mkexp_constructor_unit loc loc] )}

labeled_arguments:
  x = simple_expr_direct_argument
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    ( [(Nolabel, _1)] )}
| _1 = LPAREN _2 = option_COMMA_ _3 = RPAREN
    {let _1 =
  let _1 =
    let x =
      let _1 =                 ( [] ) in
                                                              ( _1 )
    in
        ( x )
  in
                                                         ( _1 )
in
let _endpos__1_ = _endpos__3_ in
let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
    ( match _1 with
      | [] -> let loc = mklocation _startpos _endpos in
              [(Nolabel, mkexp_constructor_unit loc loc)]
      | xs -> xs
    )}
| _1 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_uncurried_labeled_expr_ _2 = option_COMMA_ _3 = RPAREN
    {let _1 =
  let _1 =
    let x =
      let _1 = _1_inlined1 in
      let _1 =
        let _1 =                                        ( List.rev _1 ) in
                                             ( _1 )
      in
                                                              ( _1 )
    in
        ( x )
  in
                                                         ( _1 )
in
let _endpos__1_ = _endpos__3_ in
let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
    ( match _1 with
      | [] -> let loc = mklocation _startpos _endpos in
              [(Nolabel, mkexp_constructor_unit loc loc)]
      | xs -> xs
    )}
| _1 = LPAREN _2 = DOT _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
    ( let loc = mklocation _startpos _endpos in
      [(Nolabel, mkexp_constructor_unit ~uncurried:true loc loc)]
    )}

labeled_expr_constraint:
  _1 = expr_optional_constraint
    {                             ( fun _punned -> _1 )}
| _1 = type_constraint
    {let _endpos = _endpos__1_ in
    ( fun punned ->
      let exp = mkexp (Pexp_ident punned) ~loc:punned.loc in
      match _1 with
      | typ ->
        let loc = mklocation punned.loc.loc_start _endpos in
        ghexp_constraint loc exp typ
    )}

longident_type_constraint:
  x = val_longident _2 = option_type_constraint_
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
 ( _1, _2 )}

labeled_expr:
  _1 = expr_optional_constraint
    {                             ( (Nolabel, _1) )}
| _1 = TILDE x = either_parenthesized_longident_type_constraint__longident_type_constraint_
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( (* add(~a, ~b) -> parses ~a & ~b *)
      let lident_loc, maybe_typ = _2.txt in
      let exp = mkexp (Pexp_ident lident_loc) ~loc:lident_loc.loc in
      let labeled_exp = match maybe_typ with
      | None -> exp
      | Some typ ->
          ghexp_constraint _2.loc exp typ
      in
      (Labelled (Longident.last lident_loc.txt), labeled_exp)
    )}
| _1 = TILDE x = val_longident _3 = QUESTION
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( (* foo(~a?)  -> parses ~a? *)
      let exp = mkexp (Pexp_ident _2) ~loc:_2.loc in
      (Optional (Longident.last _2.txt), exp)
    )}
| _1 = TILDE x = LIDENT _3 = EQUAL _4 = optional _5 = labeled_expr_constraint
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( (* foo(~bar=?Some(1)) or add(~x=1, ~y=2) -> parses ~bar=?Some(1) & ~x=1 & ~y=1 *)
      (_4 _2.txt, _5 { _2 with txt = Lident _2.txt })
    )}
| _1 = TILDE x = LIDENT _3 = EQUAL _4 = optional x_inlined1 = UNDERSCORE
    {let _5 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( (* foo(~l =_) *)
      let loc = _5.loc in
      let exp = mkexp (Pexp_ident (mkloc (Lident "_") loc)) ~loc in
      (_4 _2.txt, exp)
    )}
| x = UNDERSCORE
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( (* foo(_) *)
      let loc = _1.loc in
      let exp = mkexp (Pexp_ident (mkloc (Lident "_") loc)) ~loc in
      (Nolabel, exp)
    )}

let_bindings:
  _1 = let_binding _2 = list_and_let_binding_
    {                                           ( addlbs _1 _2 )}

let_binding:
  _2 = LET _3 = option_item_extension_sugar_ _4 = rec_flag _5 = let_binding_body
    {let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let loc = mklocation _symbolstartpos _endpos in
    let pat, expr = _5 in
    mklbs _3 _4 (Vb.mk ~loc ~attrs:_1 pat expr) loc )}
| _1 = nonempty_list_as_loc_attribute__ _2 = LET _3 = option_item_extension_sugar_ _4 = rec_flag _5 = let_binding_body
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let loc = mklocation _symbolstartpos _endpos in
    let pat, expr = _5 in
    mklbs _3 _4 (Vb.mk ~loc ~attrs:_1 pat expr) loc )}

let_binding_body:
  _1 = simple_pattern_ident _2 = type_constraint _3 = EQUAL _4 = expr
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      (_1, ghexp_constraint loc _4 _2) )}
| _1 = simple_pattern_ident _2 = fun_def_EQUAL_core_type_
    {    ( (_1, _2) )}
| _1 = simple_pattern_ident _2 = COLON _3 = nonempty_list_preceded_QUOTE_ident__ _4 = DOT _5 = core_type _6 = EQUAL x = expr
    {let _7 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
let _endpos__7_ = _endpos_x_ in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
    ( let typ = mktyp ~ghost:true (Ptyp_poly(_3, _5)) in
      let loc = mklocation _symbolstartpos _endpos in
      (mkpat ~ghost:true ~loc (Ppat_constraint(_1, typ)), _7)
    )}
| _1 = simple_pattern_ident _2 = COLON _3 = TYPE _4 = nonempty_list_LIDENT_ _5 = DOT _6 = core_type _7 = EQUAL x = expr
    {let _8 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
let _endpos__8_ = _endpos_x_ in
let _endpos = _endpos__8_ in
let _symbolstartpos = _startpos__1_ in
   ( let exp, poly = wrap_type_annotation _4 _6 _8 in
     let loc = mklocation _symbolstartpos _endpos in
     (mkpat ~ghost:true ~loc (Ppat_constraint(_1, poly)), exp)
   )}
| _1 = pattern _2 = EQUAL _3 = expr
    {    ( (_1, _3) )}
| _1 = simple_pattern_not_ident _2 = COLON _3 = core_type _4 = EQUAL _5 = expr
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      (mkpat ~loc (Ppat_constraint(_1, _3)), _5)
    )}

match_case_expr_:
  x = BAR _2 = pattern _3 = option_preceded_WHEN_expr__ _4 = EQUALGREATER _5 = expr
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  ( let pat = {_2 with ppat_loc =
      { _2.ppat_loc with
        loc_start = _1.loc.loc_start
      }
    } in
    Exp.case pat ?guard:_3 _5 )}

match_case_seq_expr_:
  x = BAR _2 = pattern _3 = option_preceded_WHEN_expr__ _4 = EQUALGREATER _5 = seq_expr
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
  ( let pat = {_2 with ppat_loc =
      { _2.ppat_loc with
        loc_start = _1.loc.loc_start
      }
    } in
    Exp.case pat ?guard:_3 _5 )}

fun_def_EQUAL_core_type_:
  _1 = LPAREN _2_inlined1 = RPAREN _2 = option_preceded_COLON_core_type__ _3 = either_preceded_EQUAL_expr__braced_expr_
    {let _1 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                    (
    let loc = mklocation _startpos _endpos in
    ([mkloc (Term (Nolabel, None, mkpat_constructor_unit loc loc)) loc], false)
  )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( let loc = mklocation _startpos _endpos in
    let (pl, uncurried) = _1 in
    let exp = List.fold_right mkexp_fun pl
        (match _2 with
        | None -> _3
        | Some ct -> Exp.constraint_ ~loc _3 ct)
    in
    if uncurried then
      {exp with pexp_attributes = (uncurry_payload loc)::exp.pexp_attributes}
    else exp
  )}
| _1 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2_inlined1 = option_COMMA_ _3_inlined1 = RPAREN _2 = option_preceded_COLON_core_type__ _3 = either_preceded_EQUAL_expr__braced_expr_
    {let _1 =
  let _1 =
    let _1 =
      let x =
        let _1 = _1_inlined1 in
        let _1 =                                        ( List.rev _1 ) in
                                                                  ( _1 )
      in
          ( x )
    in
                                                           ( _1 )
  in
                                                 (
    (_1, false)
  )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( let loc = mklocation _startpos _endpos in
    let (pl, uncurried) = _1 in
    let exp = List.fold_right mkexp_fun pl
        (match _2 with
        | None -> _3
        | Some ct -> Exp.constraint_ ~loc _3 ct)
    in
    if uncurried then
      {exp with pexp_attributes = (uncurry_payload loc)::exp.pexp_attributes}
    else exp
  )}
| _1 = LPAREN _2_inlined1 = DOT _3_inlined1 = RPAREN _2 = option_preceded_COLON_core_type__ _3 = either_preceded_EQUAL_expr__braced_expr_
    {let _1 =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                        (
      let loc = mklocation _startpos _endpos in
      ([mkloc (Term (Nolabel, None, mkpat_constructor_unit loc loc)) loc], true)
  )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( let loc = mklocation _startpos _endpos in
    let (pl, uncurried) = _1 in
    let exp = List.fold_right mkexp_fun pl
        (match _2 with
        | None -> _3
        | Some ct -> Exp.constraint_ ~loc _3 ct)
    in
    if uncurried then
      {exp with pexp_attributes = (uncurry_payload loc)::exp.pexp_attributes}
    else exp
  )}
| _1 = LPAREN _2_inlined1 = DOT _1_inlined1 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2_inlined2 = option_COMMA_ _4 = RPAREN _2 = option_preceded_COLON_core_type__ _3 = either_preceded_EQUAL_expr__braced_expr_
    {let _1 =
  let _3 =
    let _1 = _1_inlined1 in
    let _1 =                                        ( List.rev _1 ) in
                                                              ( _1 )
  in
                                                    (
    let () = List.iter (fun p ->
        match p.txt with
        | Term (Labelled _, _, _)
        | Term (Optional _, _, _)  ->
            raise Reason_syntax_util.(
              Error(p.loc, (Syntax_error "Uncurried function definition with labelled arguments is not supported at the moment."))
            )
        | _ -> ()
      ) _3 in
    (_3, true)
  )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( let loc = mklocation _startpos _endpos in
    let (pl, uncurried) = _1 in
    let exp = List.fold_right mkexp_fun pl
        (match _2 with
        | None -> _3
        | Some ct -> Exp.constraint_ ~loc _3 ct)
    in
    if uncurried then
      {exp with pexp_attributes = (uncurry_payload loc)::exp.pexp_attributes}
    else exp
  )}

fun_def_EQUALGREATER_non_arrowed_core_type_:
  _1 = LPAREN _2_inlined1 = RPAREN _2 = option_preceded_COLON_non_arrowed_core_type__ _3 = either_preceded_EQUALGREATER_expr__braced_expr_
    {let _1 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                    (
    let loc = mklocation _startpos _endpos in
    ([mkloc (Term (Nolabel, None, mkpat_constructor_unit loc loc)) loc], false)
  )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( let loc = mklocation _startpos _endpos in
    let (pl, uncurried) = _1 in
    let exp = List.fold_right mkexp_fun pl
        (match _2 with
        | None -> _3
        | Some ct -> Exp.constraint_ ~loc _3 ct)
    in
    if uncurried then
      {exp with pexp_attributes = (uncurry_payload loc)::exp.pexp_attributes}
    else exp
  )}
| _1 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2_inlined1 = option_COMMA_ _3_inlined1 = RPAREN _2 = option_preceded_COLON_non_arrowed_core_type__ _3 = either_preceded_EQUALGREATER_expr__braced_expr_
    {let _1 =
  let _1 =
    let _1 =
      let x =
        let _1 = _1_inlined1 in
        let _1 =                                        ( List.rev _1 ) in
                                                                  ( _1 )
      in
          ( x )
    in
                                                           ( _1 )
  in
                                                 (
    (_1, false)
  )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( let loc = mklocation _startpos _endpos in
    let (pl, uncurried) = _1 in
    let exp = List.fold_right mkexp_fun pl
        (match _2 with
        | None -> _3
        | Some ct -> Exp.constraint_ ~loc _3 ct)
    in
    if uncurried then
      {exp with pexp_attributes = (uncurry_payload loc)::exp.pexp_attributes}
    else exp
  )}
| _1 = LPAREN _2_inlined1 = DOT _3_inlined1 = RPAREN _2 = option_preceded_COLON_non_arrowed_core_type__ _3 = either_preceded_EQUALGREATER_expr__braced_expr_
    {let _1 =
  let _endpos__3_ = _endpos__3_inlined1_ in
  let _endpos = _endpos__3_ in
  let _startpos = _startpos__1_ in
                        (
      let loc = mklocation _startpos _endpos in
      ([mkloc (Term (Nolabel, None, mkpat_constructor_unit loc loc)) loc], true)
  )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( let loc = mklocation _startpos _endpos in
    let (pl, uncurried) = _1 in
    let exp = List.fold_right mkexp_fun pl
        (match _2 with
        | None -> _3
        | Some ct -> Exp.constraint_ ~loc _3 ct)
    in
    if uncurried then
      {exp with pexp_attributes = (uncurry_payload loc)::exp.pexp_attributes}
    else exp
  )}
| _1 = LPAREN _2_inlined1 = DOT _1_inlined1 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2_inlined2 = option_COMMA_ _4 = RPAREN _2 = option_preceded_COLON_non_arrowed_core_type__ _3 = either_preceded_EQUALGREATER_expr__braced_expr_
    {let _1 =
  let _3 =
    let _1 = _1_inlined1 in
    let _1 =                                        ( List.rev _1 ) in
                                                              ( _1 )
  in
                                                    (
    let () = List.iter (fun p ->
        match p.txt with
        | Term (Labelled _, _, _)
        | Term (Optional _, _, _)  ->
            raise Reason_syntax_util.(
              Error(p.loc, (Syntax_error "Uncurried function definition with labelled arguments is not supported at the moment."))
            )
        | _ -> ()
      ) _3 in
    (_3, true)
  )
in
let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
  ( let loc = mklocation _startpos _endpos in
    let (pl, uncurried) = _1 in
    let exp = List.fold_right mkexp_fun pl
        (match _2 with
        | None -> _3
        | Some ct -> Exp.constraint_ ~loc _3 ct)
    in
    if uncurried then
      {exp with pexp_attributes = (uncurry_payload loc)::exp.pexp_attributes}
    else exp
  )}

expr_list:
  _1 = lseparated_nonempty_list_aux_COMMA_expr_optional_constraint_ _2 = option_COMMA_
    {let _1 =                                        ( List.rev _1 ) in
  ( _1 )}

expr_comma_seq_extension:
  _1 = lseparated_nonempty_list_aux_COMMA_opt_spread_expr_optional_constraint__ _2 = option_COMMA_
    {let _1 =                                        ( List.rev _1 ) in
  ( match List.rev _1 with
    (* Check if the last expr has been spread with `...` *)
    | ((dotdotdot, e) as hd)::es ->
      let (es, ext) = match dotdotdot with
      | Some _ -> (es, Some e)
      | None -> (hd::es, None)
      in
      let msg = "Lists can only have one `...` spread, at the end.
Explanation: lists are singly-linked list, where a node contains a value and points to the next node. `[a, ...bc]` efficiently creates a new item and links `bc` as its next nodes. `[...bc, a]` would be expensive, as it'd need to traverse `bc` and prepend each item to `a` one by one. We therefore disallow such syntax sugar.
Solution: directly use `concat` or other List helpers." in
      let exprList = filter_raise_spread_syntax msg es in
      (List.rev exprList, ext)
    | [] -> [], None
  )}

expr_optional_constraint:
  _1 = expr
    {         ( _1 )}
| _1 = expr _2 = type_constraint
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
    ( ghexp_constraint (mklocation _symbolstartpos _endpos) _1 _2 )}

record_expr:
  _1 = DOTDOTDOT _2 = expr_optional_constraint _1_inlined1 = COMMA _1_inlined2 = option_DOTDOTDOT_ x = label_longident _2_inlined1 = COLON _3 = expr _2_inlined2 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _4 = option_COMMA_
    {let _3 =
  let (_startpos__1_inlined1_, _2, _1_inlined1) = (_startpos__1_inlined2_, _2_inlined2, _1_inlined2) in
  let _1 =
    let x =
      let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
      let _2 =
        let _1 =
          let _1 =
            let _endpos = _endpos_x_ in
            let _symbolstartpos = _startpos_x_ in
              ( mkloc x (mklocation _symbolstartpos _endpos) )
          in
                                                 ( (_1, _3) )
        in
                                (_1)
      in
      let _endpos__2_ = _endpos__3_ in
          ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
    in
        ( x )
  in
                                            ( _1 :: List.rev _2 )
in
    ( let exprList = filter_raise_spread_syntax record_exp_spread_msg _3
      in (Some _2, exprList)
    )}
| _1 = DOTDOTDOT _2 = expr_optional_constraint _1_inlined1 = COMMA _1_inlined2 = option_DOTDOTDOT_ x = label_longident _2_inlined1 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _4 = option_COMMA_
    {let _3 =
  let (_startpos__1_inlined1_, _2, _1_inlined1) = (_startpos__1_inlined2_, _2_inlined1, _1_inlined2) in
  let _1 =
    let x =
      let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
      let _2 =
        let _1 =
          let _1 =
            let _endpos = _endpos_x_ in
            let _symbolstartpos = _startpos_x_ in
              ( mkloc x (mklocation _symbolstartpos _endpos) )
          in
                                      ( (_1, exp_of_label _1) )
        in
                            (_1)
      in
      let _endpos__2_ = _endpos_x_ in
          ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
    in
        ( x )
  in
                                            ( _1 :: List.rev _2 )
in
    ( let exprList = filter_raise_spread_syntax record_exp_spread_msg _3
      in (Some _2, exprList)
    )}
| _1 = DOTDOTDOT _2 = expr_optional_constraint _3 = SEMI _1_inlined1 = lseparated_nonempty_list_aux_COMMA_opt_spread_lbl_expr__ _5 = option_COMMA_
    {let _4 =
  let _1 = _1_inlined1 in
                                         ( List.rev _1 )
in
    ( let loc = mklocation _startpos__3_ _endpos__3_ in
      raise_record_trailing_semi_error loc
    )}
| _1 = DOTDOTDOT _2 = expr_optional_constraint _1_inlined1 = COMMA _1_inlined2 = option_DOTDOTDOT_ x = label_longident _2_inlined1 = COLON _3 = expr _2_inlined2 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _4 = SEMI
    {let _3 =
  let (_startpos__1_inlined1_, _2, _1_inlined1) = (_startpos__1_inlined2_, _2_inlined2, _1_inlined2) in
  let _1 =
    let x =
      let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
      let _2 =
        let _1 =
          let _1 =
            let _endpos = _endpos_x_ in
            let _symbolstartpos = _startpos_x_ in
              ( mkloc x (mklocation _symbolstartpos _endpos) )
          in
                                                 ( (_1, _3) )
        in
                                (_1)
      in
      let _endpos__2_ = _endpos__3_ in
          ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
    in
        ( x )
  in
                                            ( _1 :: List.rev _2 )
in
    ( let loc = mklocation _startpos__4_ _endpos__4_ in
      raise_record_trailing_semi_error loc
    )}
| _1 = DOTDOTDOT _2 = expr_optional_constraint _1_inlined1 = COMMA _1_inlined2 = option_DOTDOTDOT_ x = label_longident _2_inlined1 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _4 = SEMI
    {let _3 =
  let (_startpos__1_inlined1_, _2, _1_inlined1) = (_startpos__1_inlined2_, _2_inlined1, _1_inlined2) in
  let _1 =
    let x =
      let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
      let _2 =
        let _1 =
          let _1 =
            let _endpos = _endpos_x_ in
            let _symbolstartpos = _startpos_x_ in
              ( mkloc x (mklocation _symbolstartpos _endpos) )
          in
                                      ( (_1, exp_of_label _1) )
        in
                            (_1)
      in
      let _endpos__2_ = _endpos_x_ in
          ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
    in
        ( x )
  in
                                            ( _1 :: List.rev _2 )
in
    ( let loc = mklocation _startpos__4_ _endpos__4_ in
      raise_record_trailing_semi_error loc
    )}
| x = label_longident _2_inlined1 = COLON _3 = expr _2 = option_COMMA_
    {let _1 =
  let _1 =
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( mkloc x (mklocation _symbolstartpos _endpos) )
  in
                                         ( (_1, _3) )
in
    ( (None, [_1]) )}
| x = label_longident _2_inlined1 = COLON _3 = expr _2 = SEMI
    {let _1 =
  let _1 =
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( mkloc x (mklocation _symbolstartpos _endpos) )
  in
                                         ( (_1, _3) )
in
    ( let loc = mklocation _startpos__2_ _endpos__2_ in
      raise_record_trailing_semi_error loc )}
| x = label_longident _2_inlined1 = COLON _3_inlined1 = expr _1 = COMMA _1_inlined1 = option_DOTDOTDOT_ x_inlined1 = label_longident _2_inlined2 = COLON _3_inlined2 = expr _2 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _3 = option_COMMA_
    {let _2 =
  let (_endpos_x_, _startpos_x_, _endpos__3_, _3, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, _endpos__3_inlined2_, _3_inlined2, x_inlined1) in
  let _1 =
    let x =
      let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
      let _2 =
        let _1 =
          let _1 =
            let _endpos = _endpos_x_ in
            let _symbolstartpos = _startpos_x_ in
              ( mkloc x (mklocation _symbolstartpos _endpos) )
          in
                                                 ( (_1, _3) )
        in
                                (_1)
      in
      let _endpos__2_ = _endpos__3_ in
          ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
    in
        ( x )
  in
                                            ( _1 :: List.rev _2 )
in
let _1 =
  let _3 = _3_inlined1 in
  let _1 =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
                                           ( (_1, _3) )
  in
                          (_1)
in
    ( let exprList = filter_raise_spread_syntax record_exp_spread_msg _2 in
      (None, _1 :: exprList) )}
| x = label_longident _2_inlined1 = COLON _3_inlined1 = expr _1 = COMMA _1_inlined1 = option_DOTDOTDOT_ x_inlined1 = label_longident _2 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _3 = option_COMMA_
    {let _2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _1 =
    let x =
      let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
      let _2 =
        let _1 =
          let _1 =
            let _endpos = _endpos_x_ in
            let _symbolstartpos = _startpos_x_ in
              ( mkloc x (mklocation _symbolstartpos _endpos) )
          in
                                      ( (_1, exp_of_label _1) )
        in
                            (_1)
      in
      let _endpos__2_ = _endpos_x_ in
          ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
    in
        ( x )
  in
                                            ( _1 :: List.rev _2 )
in
let _1 =
  let _3 = _3_inlined1 in
  let _1 =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
                                           ( (_1, _3) )
  in
                          (_1)
in
    ( let exprList = filter_raise_spread_syntax record_exp_spread_msg _2 in
      (None, _1 :: exprList) )}
| x = label_longident _1 = COMMA _1_inlined1 = option_DOTDOTDOT_ x_inlined1 = label_longident _2_inlined1 = COLON _3_inlined1 = expr _2 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _3 = option_COMMA_
    {let _2 =
  let (_endpos_x_, _startpos_x_, _endpos__3_, _3, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, _endpos__3_inlined1_, _3_inlined1, x_inlined1) in
  let _1 =
    let x =
      let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
      let _2 =
        let _1 =
          let _1 =
            let _endpos = _endpos_x_ in
            let _symbolstartpos = _startpos_x_ in
              ( mkloc x (mklocation _symbolstartpos _endpos) )
          in
                                                 ( (_1, _3) )
        in
                                (_1)
      in
      let _endpos__2_ = _endpos__3_ in
          ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
    in
        ( x )
  in
                                            ( _1 :: List.rev _2 )
in
let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
                                ( (_1, exp_of_label _1) )
  in
                      (_1)
in
    ( let exprList = filter_raise_spread_syntax record_exp_spread_msg _2 in
      (None, _1 :: exprList) )}
| x = label_longident _1 = COMMA _1_inlined1 = option_DOTDOTDOT_ x_inlined1 = label_longident _2 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _3 = option_COMMA_
    {let _2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _1 =
    let x =
      let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
      let _2 =
        let _1 =
          let _1 =
            let _endpos = _endpos_x_ in
            let _symbolstartpos = _startpos_x_ in
              ( mkloc x (mklocation _symbolstartpos _endpos) )
          in
                                      ( (_1, exp_of_label _1) )
        in
                            (_1)
      in
      let _endpos__2_ = _endpos_x_ in
          ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
    in
        ( x )
  in
                                            ( _1 :: List.rev _2 )
in
let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
                                ( (_1, exp_of_label _1) )
  in
                      (_1)
in
    ( let exprList = filter_raise_spread_syntax record_exp_spread_msg _2 in
      (None, _1 :: exprList) )}
| x = label_longident _2_inlined1 = COLON _3_inlined1 = expr _1 = COMMA _1_inlined1 = option_DOTDOTDOT_ x_inlined1 = label_longident _2_inlined2 = COLON _3_inlined2 = expr _2 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _3 = SEMI
    {let _2 =
  let (_endpos_x_, _startpos_x_, _endpos__3_, _3, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, _endpos__3_inlined2_, _3_inlined2, x_inlined1) in
  let _1 =
    let x =
      let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
      let _2 =
        let _1 =
          let _1 =
            let _endpos = _endpos_x_ in
            let _symbolstartpos = _startpos_x_ in
              ( mkloc x (mklocation _symbolstartpos _endpos) )
          in
                                                 ( (_1, _3) )
        in
                                (_1)
      in
      let _endpos__2_ = _endpos__3_ in
          ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
    in
        ( x )
  in
                                            ( _1 :: List.rev _2 )
in
let _1 =
  let _3 = _3_inlined1 in
  let _1 =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
                                           ( (_1, _3) )
  in
                          (_1)
in
    ( let loc = mklocation _startpos__3_ _endpos__3_ in
      raise_record_trailing_semi_error loc )}
| x = label_longident _2_inlined1 = COLON _3_inlined1 = expr _1 = COMMA _1_inlined1 = option_DOTDOTDOT_ x_inlined1 = label_longident _2 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _3 = SEMI
    {let _2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _1 =
    let x =
      let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
      let _2 =
        let _1 =
          let _1 =
            let _endpos = _endpos_x_ in
            let _symbolstartpos = _startpos_x_ in
              ( mkloc x (mklocation _symbolstartpos _endpos) )
          in
                                      ( (_1, exp_of_label _1) )
        in
                            (_1)
      in
      let _endpos__2_ = _endpos_x_ in
          ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
    in
        ( x )
  in
                                            ( _1 :: List.rev _2 )
in
let _1 =
  let _3 = _3_inlined1 in
  let _1 =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
                                           ( (_1, _3) )
  in
                          (_1)
in
    ( let loc = mklocation _startpos__3_ _endpos__3_ in
      raise_record_trailing_semi_error loc )}
| x = label_longident _1 = COMMA _1_inlined1 = option_DOTDOTDOT_ x_inlined1 = label_longident _2_inlined1 = COLON _3_inlined1 = expr _2 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _3 = SEMI
    {let _2 =
  let (_endpos_x_, _startpos_x_, _endpos__3_, _3, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, _endpos__3_inlined1_, _3_inlined1, x_inlined1) in
  let _1 =
    let x =
      let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
      let _2 =
        let _1 =
          let _1 =
            let _endpos = _endpos_x_ in
            let _symbolstartpos = _startpos_x_ in
              ( mkloc x (mklocation _symbolstartpos _endpos) )
          in
                                                 ( (_1, _3) )
        in
                                (_1)
      in
      let _endpos__2_ = _endpos__3_ in
          ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
    in
        ( x )
  in
                                            ( _1 :: List.rev _2 )
in
let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
                                ( (_1, exp_of_label _1) )
  in
                      (_1)
in
    ( let loc = mklocation _startpos__3_ _endpos__3_ in
      raise_record_trailing_semi_error loc )}
| x = label_longident _1 = COMMA _1_inlined1 = option_DOTDOTDOT_ x_inlined1 = label_longident _2 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _3 = SEMI
    {let _2 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _1 =
    let x =
      let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
      let _2 =
        let _1 =
          let _1 =
            let _endpos = _endpos_x_ in
            let _symbolstartpos = _startpos_x_ in
              ( mkloc x (mklocation _symbolstartpos _endpos) )
          in
                                      ( (_1, exp_of_label _1) )
        in
                            (_1)
      in
      let _endpos__2_ = _endpos_x_ in
          ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
    in
        ( x )
  in
                                            ( _1 :: List.rev _2 )
in
let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
                                ( (_1, exp_of_label _1) )
  in
                      (_1)
in
    ( let loc = mklocation _startpos__3_ _endpos__3_ in
      raise_record_trailing_semi_error loc )}

record_expr_with_string_keys:
  _1 = DOTDOTDOT _2 = expr_optional_constraint _3 = COMMA _4 = string_literal_exprs_maybe_punned
    {    ( (Some _2, _4) )}
| _1 = STRING _2 = COLON _3 = expr _4 = option_COMMA_
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      let (s, _, _) = _1 in
      let lident_lident_loc = mkloc (Lident s) loc in
      (None, [(lident_lident_loc, _3)])
    )}
| _1 = string_literal_expr_maybe_punned_with_comma _2 = string_literal_exprs_maybe_punned
    {                                                                                  (
    (None, _1 :: _2)
  )}

string_literal_exprs_maybe_punned:
  _1 = lseparated_nonempty_list_aux_COMMA_string_literal_expr_maybe_punned_ _2 = option_COMMA_
    {let _1 =                                        ( List.rev _1 ) in
                                                                           ( _1 )}

string_literal_expr_maybe_punned_with_comma:
  _1 = STRING _2 = COMMA
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
  ( let loc = mklocation _startpos _endpos in
    let (s, _, _) = _1 in
    let lident_lident_loc = mkloc (Lident s) loc in
    let exp = mkexp ~loc (Pexp_ident lident_lident_loc) in
    (lident_lident_loc, exp)
  )}
| _1 = STRING _2 = COLON _3 = expr _4 = COMMA
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
  ( let loc = mklocation _startpos _endpos in
    let (s, _, _) = _1 in
    let lident_lident_loc = mkloc (Lident s) loc in
    let exp = _3 in
    (lident_lident_loc, exp)
  )}

string_literal_expr_maybe_punned:
  _1 = STRING _2 = option_preceded_COLON_expr__
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
  ( let loc = mklocation _startpos _endpos in
    let (s, _, _) = _1 in
    let lident_lident_loc = mkloc (Lident s) loc in
    let exp = match _2 with
      | Some x -> x
      | None -> mkexp ~loc (Pexp_ident lident_lident_loc)
    in
    (lident_lident_loc, exp)
  )}

field_expr:
  x = LIDENT _2 = COLON _3 = expr
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
   ( (_1, _3) )}
| _1 = LIDENT
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
   ( let loc = mklocation _symbolstartpos _endpos in
     let lident_loc = mkloc _1 loc in
     let lident_lident_loc = mkloc (Lident _1) loc in
     (lident_loc, mkexp (Pexp_ident lident_lident_loc))
   )}

type_constraint:
  _1 = COLON _2 = core_type _3 = option_preceded_COLONGREATER_core_type__
    {    ( (Some _2, _3) )}
| _1 = COLONGREATER _2 = core_type
    {    ( (None, Some _2) )}
| _1 = COLON _1_inlined1 = MODULE _2 = package_type
    {let _2 =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let _1 =
    let x =     ( mktyp(Ptyp_package(_2)) ) in
    let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
  in
      (_1)
in
    ( (Some _2, None) )}

pattern:
  _1 = pattern_without_or
    {                       ( _1 )}
| _1 = pattern _2 = BAR _3 = pattern
    {let _1 =
  let x =                                           ( mkpat(Ppat_or(_1, _3)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                                                      ( _1 )}

pattern_constructor_argument:
  _1 = simple_pattern_direct_argument
    {    ( [_1] )}
| _1 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_pattern_optional_constraint_ _2 = option_COMMA_ _3 = RPAREN
    {let _1 =
  let _1 =
    let x =
      let _1 = _1_inlined1 in
      let _1 =                                        ( List.rev _1 ) in
                                                                            ( _1 )
    in
        ( x )
  in
                                                         ( _1 )
in
    ( _1 )}

simple_pattern_direct_argument:
  x = constr_longident
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkpat(Ppat_construct(mkloc _1.txt _1.loc, None)) )
  in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LBRACE _1_inlined1 = _lbl_pattern_list _3 = RBRACE
    {let _1 =
  let x =
    let _1 =
      let _2 =
        let _1 = _1_inlined1 in
          ( let (fields, closed) = _1 in
    (filter_raise_spread_syntax record_pat_spread_msg fields, closed)
  )
      in
          ( let (fields, closed) = _2 in mkpat (Ppat_record (fields, closed)) )
    in
                       ( _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LBRACE _1 = _lbl_pattern_list x_inlined1 = error
    {let _1 =
  let x =
    let _1 =
      let _3 =
        let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
      let _2 =   ( let (fields, closed) = _1 in
    (filter_raise_spread_syntax record_pat_spread_msg fields, closed)
  ) in
      let _1 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( unclosed_pat (with_txt _1 "{") (with_txt _3 "}") )
    in
                       ( _1 )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LBRACKET _2 = pattern_comma_list_extension _3 = RBRACKET
    {let _1 =
  let x =
    let _1 =     ( make_real_pat (mktailpat_extension (mklocation _startpos__2_ _endpos__2_) _2) ) in
                     ( _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LBRACKET _2 = pattern_comma_list_extension x_inlined1 = error
    {let _1 =
  let x =
    let _1 =
      let _3 =
        let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
      let _1 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( unclosed_pat (with_txt _1 "[") (with_txt _3 "]") )
    in
                     ( _1 )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LBRACKETBAR _2 = loption_terminated_pattern_comma_list_option_COMMA___ _3 = BARRBRACKET
    {let _1 =
  let x =
    let _1 =     ( mkpat (Ppat_array _2) ) in
                      ( _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

pattern_without_or:
  _1 = simple_pattern
    {let _1 =
  let x =                    ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = pattern_without_or _2 = AS x = val_ident
    {let _1 =
  let x =
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkpat(Ppat_alias(_1, _3)) )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = pattern_without_or _2 = AS x = error
    {let _1 =
  let x =
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( expecting_pat (with_txt _3 "identifier") )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = constr_longident _2 = pattern_constructor_argument
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _startpos__1_ = _startpos_x_ in
    let _endpos = _endpos__2_ in
    let _symbolstartpos = _startpos__1_ in
        ( match is_pattern_list_single_any _2 with
      | Some singleAnyPat ->
        mkpat (Ppat_construct(_1, Some singleAnyPat))
      | None ->
        let loc = mklocation _symbolstartpos _endpos in
        let argPattern = simple_pattern_list_to_tuple ~loc _2 in
        mkExplicitArityTuplePat (Ppat_construct(_1, Some argPattern))
    )
  in
  let _endpos_x_ = _endpos__2_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = BACKQUOTE _2_inlined1 = ident _2 = simple_pattern
    {let _1 =
  let x =
    let _1 =
      let _2 = _2_inlined1 in
                                        ( _2 )
    in
                                ( mkpat (Ppat_variant(_1, Some _2)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = pattern_without_or x = COLONCOLON _3 = pattern_without_or
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( raiseSyntaxErrorFromSyntaxUtils _2.loc
        ":: is not supported in Reason, please use [hd, ...tl] instead" )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = pattern_without_or _2 = COLONCOLON x = error
    {let _1 =
  let x =
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( expecting_pat (with_txt _3 "pattern") )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LPAREN _2 = COLONCOLON _3 = RPAREN _4 = LPAREN _5 = pattern_without_or _6 = COMMA _7 = pattern_without_or _8 = RPAREN
    {let _1 =
  let x =
    let _endpos = _endpos__8_ in
    let _symbolstartpos = _startpos__1_ in
        ( let loc = mklocation _symbolstartpos _endpos in
      mkpat_cons (mkpat ~ghost:true ~loc (Ppat_tuple[_5;_7])) loc
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__8_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LPAREN _2 = COLONCOLON _3 = RPAREN _4 = LPAREN _5 = pattern_without_or _6 = COMMA _7 = pattern_without_or x_inlined1 = error
    {let _1 =
  let x =
    let _8 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_pat (with_txt _1 "(") (with_txt _8 ")") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = EXCEPTION _2 = pattern_without_or %prec prec_constr_appl
    {let _1 =
  let x =     ( mkpat(Ppat_exception _2) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LAZY _2 = simple_pattern
    {let _1 =
  let x =                         ( mkpat(Ppat_lazy _2) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = attribute _2 = pattern_without_or %prec attribute_precedence
    {let _1 =
  let x =     ( {_2 with ppat_attributes = _1 :: _2.ppat_attributes} ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

simple_pattern:
  _1 = simple_pattern_ident
    {                             ( _1 )}
| _1 = simple_pattern_not_ident
    {                             ( _1 )}

simple_pattern_ident:
  x = val_ident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                    ( mkpat ~loc:_1.loc (Ppat_var _1) )}

simple_pattern_not_ident:
  _1 = UNDERSCORE
    {let _1 =
  let x =     ( mkpat (Ppat_any) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = signed_constant
    {let _1 =
  let x =     ( let attrs, cst = _1 in mkpat ~attrs (Ppat_constant cst) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = signed_constant _2 = DOTDOT _3 = signed_constant
    {let _1 =
  let x =     ( mkpat (Ppat_interval (snd _1, snd _3)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = constr_longident
    {let _1 =
  let x =
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkpat (Ppat_construct (_1, None)) )
  in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = BACKQUOTE _2 = ident
    {let _1 =
  let x =
    let _1 =                                   ( _2 ) in
        ( mkpat (Ppat_variant (_1, None)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = SHARP _2 = type_longident
    {let _1 =
  let x =     ( mkpat (Ppat_type (_2)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LBRACKETBAR _1 = lseparated_nonempty_list_aux_COMMA_opt_spread_pattern__ _3 = option_SEMI_ x_inlined1 = error
    {let _1 =
  let x =
    let _4 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _2 =
      let _1 =                                        ( List.rev _1 ) in
        ( let msg = "Array's `...` spread is not supported in pattern matches.
Explanation: such spread would create a subarray; out of performance concern, our pattern matching currently guarantees to never create new intermediate data.
Solution: if it's to validate the first few elements, use a `when` clause + Array size check + `get` checks on the current pattern. If it's to obtain a subarray, use `Array.sub` or `Belt.Array.slice`." in
    filter_raise_spread_syntax msg _1 )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_pat (with_txt _1 "[|") (with_txt _4 "|]") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_pattern_optional_constraint_ _3 = option_COMMA_ _4 = RPAREN
    {let _1 =
  let x =
    let _2 =
      let _1 = _1_inlined1 in
                                             ( List.rev _1 )
    in
    let _endpos = _endpos__4_ in
    let _startpos = _startpos__1_ in
        ( match _2 with
      | [] -> (* This shouldn't be possible *)
        let loc = mklocation _startpos _endpos in
        mkpat_constructor_unit loc loc
      | [hd] -> hd
      | _ :: _ -> mkpat (Ppat_tuple _2)
    )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LPAREN _2 = pattern x_inlined1 = error
    {let _1 =
  let x =
    let _3 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_pat (with_txt _1 "(") (with_txt _3 ")") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LPAREN _2 = pattern _3 = COLON _4 = core_type x_inlined1 = error
    {let _1 =
  let x =
    let _5 =
      let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
    let _1 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( unclosed_pat (with_txt _1 "(") (with_txt _5 ")") )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LPAREN _2 = pattern _3 = COLON x = error
    {let _1 =
  let x =
    let _4 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( expecting_pat (with_txt _4 "type") )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LPAREN _2 = MODULE x = UIDENT _4 = RPAREN
    {let _1 =
  let x =
    let _3 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkpat(Ppat_unpack(_3)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LBRACE _1_inlined1 = _lbl_pattern_list _3 = RBRACE
    {let _1 =
  let x =
    let _1 =
      let _2 =
        let _1 = _1_inlined1 in
          ( let (fields, closed) = _1 in
    (filter_raise_spread_syntax record_pat_spread_msg fields, closed)
  )
      in
          ( let (fields, closed) = _2 in mkpat (Ppat_record (fields, closed)) )
    in
                       ( _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LBRACE _1 = _lbl_pattern_list x_inlined1 = error
    {let _1 =
  let x =
    let _1 =
      let _3 =
        let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
      let _2 =   ( let (fields, closed) = _1 in
    (filter_raise_spread_syntax record_pat_spread_msg fields, closed)
  ) in
      let _1 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( unclosed_pat (with_txt _1 "{") (with_txt _3 "}") )
    in
                       ( _1 )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LBRACKET _2 = pattern_comma_list_extension _3 = RBRACKET
    {let _1 =
  let x =
    let _1 =     ( make_real_pat (mktailpat_extension (mklocation _startpos__2_ _endpos__2_) _2) ) in
                     ( _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| x = LBRACKET _2 = pattern_comma_list_extension x_inlined1 = error
    {let _1 =
  let x =
    let _1 =
      let _3 =
        let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
      let _1 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
          ( unclosed_pat (with_txt _1 "[") (with_txt _3 "]") )
    in
                     ( _1 )
  in
  let _endpos_x_ = _endpos_x_inlined1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LBRACKETBAR _2 = loption_terminated_pattern_comma_list_option_COMMA___ _3 = BARRBRACKET
    {let _1 =
  let x =
    let _1 =     ( mkpat (Ppat_array _2) ) in
                      ( _1 )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = extension
    {let _1 =
  let x =     ( mkpat(Ppat_extension _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

pattern_optional_constraint:
  _1 = pattern
    {let _1 =
  let x =                             ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = pattern _2 = COLON _3 = core_type
    {let _1 =
  let x =     ( mkpat(Ppat_constraint(_1, _3)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = MODULE x = UIDENT _3 = COLON _4 = option_MODULE_ _5 = package_type
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mkpat(
        Ppat_constraint(
          mkpat(Ppat_unpack(_2)),
          let loc = match _4 with
          | Some _ -> mklocation _startpos__4_ _endpos__5_
          | None -> mklocation _startpos__5_ _endpos__5_
          in
          mktyp ~loc (Ptyp_package(_5)))) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__5_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
     ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

pattern_comma_list_extension:
  _1 = lseparated_nonempty_list_aux_COMMA_opt_spread_pattern__ _2 = option_COMMA_
    {let _1 =                                        ( List.rev _1 ) in
  ( match List.rev _1 with
    (* spread syntax is only allowed at the end *)
    | ((dotdotdot, p) as hd)::ps ->
      let (ps, spreadPat) = match dotdotdot with
      | Some _ -> (ps, Some p)
      | None -> (hd::ps, None)
      in
      let msg = "List pattern matches only supports one `...` spread, at the end.
Explanation: a list spread at the tail is efficient, but a spread in the middle would create new list(s); out of performance concern, our pattern matching currently guarantees to never create new intermediate data." in
      let patList = filter_raise_spread_syntax msg ps in
      (List.rev patList, spreadPat)
    | [] -> [], None
  )}

_lbl_pattern_list:
  _1 = option_DOTDOTDOT_ _2 = lbl_pattern
    {let _1 =     ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    ) in
                                                       ( ([_1], Closed) )}
| _1 = option_DOTDOTDOT_ _2_inlined1 = lbl_pattern _2 = COMMA
    {let _1 =
  let (_endpos__2_, _2) = (_endpos__2_inlined1_, _2_inlined1) in
      ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
in
                                                       ( ([_1], Closed) )}
| _1 = option_DOTDOTDOT_ _2_inlined1 = lbl_pattern _2 = COMMA _3 = UNDERSCORE _4 = option_COMMA_
    {let _1 =
  let (_endpos__2_, _2) = (_endpos__2_inlined1_, _2_inlined1) in
      ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
in
                                                       ( ([_1], Open)   )}
| _1 = option_DOTDOTDOT_ _2_inlined1 = lbl_pattern _2 = COMMA _3 = _lbl_pattern_list
    {let _1 =
  let (_endpos__2_, _2) = (_endpos__2_inlined1_, _2_inlined1) in
      ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
in
    ( let (fields, closed) = _3 in _1 :: fields, closed )}

lbl_pattern:
  x = label_longident _2 = COLON _3 = pattern
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                          ( (_1,_3) )}
| x = label_longident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                          ( (_1, pat_of_label _1) )}
| x = label_longident _2 = AS x_inlined1 = val_ident
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( (* punning with alias eg. {ReasonReact.state as prevState}
       *  -> {ReasonReact.state: state as prevState} *)
      (_1, mkpat(Ppat_alias(pat_of_label _1, _3)))
    )}

primitive_declaration:
  _1 = nonempty_list___anonymous_31_
    {                                                                         (_1)}

type_declarations:
  _2 = TYPE _3 = nonrec_flag _4 = type_declaration_details
    {let _1 =     ( [] ) in
  ( let (ident, params, constraints, kind, priv, manifest), endpos, and_types = _4 in
    let loc = mklocation _startpos__2_ endpos in
    let ty = Type.mk ident ~params:params ~cstrs:constraints
             ~kind ~priv ?manifest ~attrs:_1 ~loc in
    (_3, ty :: and_types)
  )}
| _1 = nonempty_list_as_loc_attribute__ _2 = TYPE _3 = nonrec_flag _4 = type_declaration_details
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
  ( let (ident, params, constraints, kind, priv, manifest), endpos, and_types = _4 in
    let loc = mklocation _startpos__2_ endpos in
    let ty = Type.mk ident ~params:params ~cstrs:constraints
             ~kind ~priv ?manifest ~attrs:_1 ~loc in
    (_3, ty :: and_types)
  )}

and_type_declaration:
  
    {    ( [] )}
| _2 = AND _3 = type_declaration_details
    {let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let (ident, params, cstrs, kind, priv, manifest), endpos, and_types = _3 in
      let loc = mklocation _symbolstartpos endpos in
      Type.mk ident ~params ~cstrs ~kind ~priv ?manifest ~attrs:_1 ~loc
      :: and_types
    )}
| _1 = nonempty_list_as_loc_attribute__ _2 = AND _3 = type_declaration_details
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
    ( let (ident, params, cstrs, kind, priv, manifest), endpos, and_types = _3 in
      let loc = mklocation _symbolstartpos endpos in
      Type.mk ident ~params ~cstrs ~kind ~priv ?manifest ~attrs:_1 ~loc
      :: and_types
    )}

type_declaration_details:
  x = UIDENT _2 = type_variables_with_variance _3 = type_declaration_kind
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( raiseSyntaxErrorFromSyntaxUtils _1.loc
        "a type name must start with a lower-case letter or an underscore" )}
| x = LIDENT _2 = type_variables_with_variance _3 = type_declaration_kind
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( let (kind, priv, manifest), constraints, endpos, and_types = _3 in
      ((_1, _2, constraints, kind, priv, manifest), endpos, and_types) )}

type_declaration_kind:
  _1 = EQUAL _3 = constructor_declarations
    {let _2 =                   ( Public ) in
    ( let (cstrs, constraints, endpos, and_types) = _3 in
      ((Ptype_variant (cstrs), _2, None), constraints, endpos, and_types) )}
| _1 = EQUAL _1_inlined1 = PRI _3 = constructor_declarations
    {let _2 =                   ( Private ) in
    ( let (cstrs, constraints, endpos, and_types) = _3 in
      ((Ptype_variant (cstrs), _2, None), constraints, endpos, and_types) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _5 = constructor_declarations
    {let _4 =                   ( Public ) in
    ( let (cstrs, constraints, endpos, and_types) = _5 in
      ((Ptype_variant cstrs, _4, Some _2), constraints, endpos, and_types) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _1_inlined1 = PRI _5 = constructor_declarations
    {let _4 =                   ( Private ) in
    ( let (cstrs, constraints, endpos, and_types) = _5 in
      ((Ptype_variant cstrs, _4, Some _2), constraints, endpos, and_types) )}
| _1 = type_other_kind _3 = and_type_declaration
    {let _2 =     ( [] ) in
let _endpos__2_ = _endpos__1_ in
    ( (_1, _2, _endpos__2_, _3) )}
| _1 = type_other_kind _1_inlined1 = nonempty_list_preceded_CONSTRAINT_constrain__ _3 = and_type_declaration
    {let _2 =
  let _1 = _1_inlined1 in
                                       ( _1 )
in
let _endpos__2_ = _endpos__1_inlined1_ in
    ( (_1, _2, _endpos__2_, _3) )}

type_other_kind:
  
    {    ( (Ptype_abstract, Public, None) )}
| _1 = EQUAL _3 = core_type
    {let _2 =                   ( Public ) in
    ( (Ptype_abstract, _2, Some _3) )}
| _1 = EQUAL _1_inlined1 = PRI _3 = core_type
    {let _2 =                   ( Private ) in
    ( (Ptype_abstract, _2, Some _3) )}
| _1 = EQUAL _4 = record_declaration
    {let _3 =     ( [] ) in
let _2 =                   ( Public ) in
    ( (Ptype_record (prepend_attrs_to_labels _3 _4), _2, None) )}
| _1 = EQUAL _1_inlined1 = nonempty_list_as_loc_attribute__ _4 = record_declaration
    {let _3 =
  let _1 = _1_inlined1 in
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _2 =                   ( Public ) in
    ( (Ptype_record (prepend_attrs_to_labels _3 _4), _2, None) )}
| _1 = EQUAL _1_inlined1 = PRI _4 = record_declaration
    {let _3 =     ( [] ) in
let _2 =                   ( Private ) in
    ( (Ptype_record (prepend_attrs_to_labels _3 _4), _2, None) )}
| _1 = EQUAL _1_inlined1 = PRI _1_inlined2 = nonempty_list_as_loc_attribute__ _4 = record_declaration
    {let _3 =
  let _1 = _1_inlined2 in
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _2 =                   ( Private ) in
    ( (Ptype_record (prepend_attrs_to_labels _3 _4), _2, None) )}
| _1 = EQUAL _2 = DOTDOT
    {    ( (Ptype_open, Public, None) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _4 = DOTDOT
    {    ( (Ptype_open, Public, Some _2) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _6 = record_declaration
    {let _5 =     ( [] ) in
let _4 =                   ( Public ) in
    ( (Ptype_record (prepend_attrs_to_labels _5 _6), _4, Some _2) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _1_inlined1 = nonempty_list_as_loc_attribute__ _6 = record_declaration
    {let _5 =
  let _1 = _1_inlined1 in
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _4 =                   ( Public ) in
    ( (Ptype_record (prepend_attrs_to_labels _5 _6), _4, Some _2) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _1_inlined1 = PRI _6 = record_declaration
    {let _5 =     ( [] ) in
let _4 =                   ( Private ) in
    ( (Ptype_record (prepend_attrs_to_labels _5 _6), _4, Some _2) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _1_inlined1 = PRI _1_inlined2 = nonempty_list_as_loc_attribute__ _6 = record_declaration
    {let _5 =
  let _1 = _1_inlined2 in
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _4 =                   ( Private ) in
    ( (Ptype_record (prepend_attrs_to_labels _5 _6), _4, Some _2) )}

type_variables_with_variance_comma_list:
  _1 = lseparated_nonempty_list_aux_COMMA_type_variable_with_variance_ _2 = option_COMMA_
    {let _1 =                                        ( List.rev _1 ) in
                                                                      (_1)}

type_variables_with_variance:
  _1 = loption_parenthesized_type_variables_with_variance_comma_list__
    {  ( _1 )}

type_variable_with_variance:
  _1 = embedded___anonymous_32_
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
  ( let first, second = _1 in
    let ptyp_loc =
        {first.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}
    in
    ({first with ptyp_loc}, second)
  )}

type_parameter:
  _1 = type_variance _2 = type_variable
    {                                            ( (_2, _1) )}

type_variance:
  
    {                ( Invariant )}
| _1 = PLUS
    {                ( Covariant )}
| _1 = MINUS
    {                ( Contravariant )}

type_variable:
  _1 = QUOTE _2 = ident
    {let _1 =
  let x =                ( mktyp (Ptyp_var _2) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
  ( _1 )}

constructor_declarations:
  _1 = either_constructor_declaration_bar_constructor_declaration_ _2 = constructor_declarations_aux
    {  ( let (cstrs, constraints, endpos, and_types) = _2 in
    (_1 :: cstrs, constraints, endpos, and_types)
  )}

constructor_declarations_aux:
  _1 = bar_constructor_declaration _2 = constructor_declarations_aux
    {    ( let (cstrs, constraints, endpos, and_types) = _2 in
      (_1 :: cstrs, constraints, endpos, and_types)
    )}
| _2 = and_type_declaration
    {let _1 =     ( [] ) in
let _endpos__1_ = _endpos__0_ in
    ( ([], _1, _endpos__1_, _2) )}
| _1 = nonempty_list_preceded_CONSTRAINT_constrain__ _2 = and_type_declaration
    {let _1 =                                      ( _1 ) in
    ( ([], _1, _endpos__1_, _2) )}

bar_constructor_declaration:
  _2 = BAR _3 = constructor_declaration
    {let _1 =     ( [] ) in
  ( {_3 with pcd_attributes = _1 @ _3.pcd_attributes} )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _3 = constructor_declaration
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
  ( {_3 with pcd_attributes = _1 @ _3.pcd_attributes} )}

constructor_declaration:
  _1 = UIDENT _3 = generalized_constructor_arguments
    {let _2 =
  let x =                       ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_ in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let args, res = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.constructor ~attrs:_1 _2 ~args ?res ~loc )}
| _1 = LBRACKET _2 = RBRACKET _3 = generalized_constructor_arguments
    {let _2 =
  let x =                       ( "[]" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_ in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let args, res = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.constructor ~attrs:_1 _2 ~args ?res ~loc )}
| _1 = LPAREN _2 = RPAREN _3 = generalized_constructor_arguments
    {let _2 =
  let x =                       ( "()" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_ in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let args, res = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.constructor ~attrs:_1 _2 ~args ?res ~loc )}
| _1 = COLONCOLON _3 = generalized_constructor_arguments
    {let _2 =
  let x =                       ( "::" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_ in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let args, res = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.constructor ~attrs:_1 _2 ~args ?res ~loc )}
| _1 = FALSE _3 = generalized_constructor_arguments
    {let _2 =
  let x =                       ( "false" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_ in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let args, res = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.constructor ~attrs:_1 _2 ~args ?res ~loc )}
| _1 = TRUE _3 = generalized_constructor_arguments
    {let _2 =
  let x =                       ( "true" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_ in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let args, res = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.constructor ~attrs:_1 _2 ~args ?res ~loc )}
| _1 = nonempty_list_as_loc_attribute__ _1_inlined1 = UIDENT _3 = generalized_constructor_arguments
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                       ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_inlined1_ in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let args, res = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.constructor ~attrs:_1 _2 ~args ?res ~loc )}
| _1 = nonempty_list_as_loc_attribute__ _1_inlined1 = LBRACKET _2 = RBRACKET _3 = generalized_constructor_arguments
    {let _2 =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let x =                       ( "[]" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_inlined1_ in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let args, res = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.constructor ~attrs:_1 _2 ~args ?res ~loc )}
| _1 = nonempty_list_as_loc_attribute__ _1_inlined1 = LPAREN _2 = RPAREN _3 = generalized_constructor_arguments
    {let _2 =
  let _startpos__1_ = _startpos__1_inlined1_ in
  let x =                       ( "()" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_inlined1_ in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let args, res = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.constructor ~attrs:_1 _2 ~args ?res ~loc )}
| _1 = nonempty_list_as_loc_attribute__ _1_inlined1 = COLONCOLON _3 = generalized_constructor_arguments
    {let _2 =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =                       ( "::" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_inlined1_ in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let args, res = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.constructor ~attrs:_1 _2 ~args ?res ~loc )}
| _1 = nonempty_list_as_loc_attribute__ _1_inlined1 = FALSE _3 = generalized_constructor_arguments
    {let _2 =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =                       ( "false" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_inlined1_ in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let args, res = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.constructor ~attrs:_1 _2 ~args ?res ~loc )}
| _1 = nonempty_list_as_loc_attribute__ _1_inlined1 = TRUE _3 = generalized_constructor_arguments
    {let _2 =
  let (_endpos__1_, _startpos__1_) = (_endpos__1_inlined1_, _startpos__1_inlined1_) in
  let x =                       ( "true" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos__1_inlined1_ in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
  ( let args, res = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.constructor ~attrs:_1 _2 ~args ?res ~loc )}

str_exception_declaration:
  _2 = EXCEPTION _3 = either_extension_constructor_declaration_extension_constructor_rebind_
    {let _1 =     ( [] ) in
  ( {_3 with pext_attributes = _3.pext_attributes @ _1} )}
| _1 = nonempty_list_as_loc_attribute__ _2 = EXCEPTION _3 = either_extension_constructor_declaration_extension_constructor_rebind_
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
  ( {_3 with pext_attributes = _3.pext_attributes @ _1} )}

sig_exception_declaration:
  _2 = EXCEPTION _3 = extension_constructor_declaration
    {let _1 =     ( [] ) in
  ( {_3 with pext_attributes = _3.pext_attributes @ _1} )}
| _1 = nonempty_list_as_loc_attribute__ _2 = EXCEPTION _3 = extension_constructor_declaration
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
  ( {_3 with pext_attributes = _3.pext_attributes @ _1} )}

generalized_constructor_arguments:
  _1 = option_constructor_arguments_ _2 = option_preceded_COLON_core_type__
    {  ( ((match _1 with None -> Pcstr_tuple [] | Some x -> x), _2) )}

constructor_arguments_comma_list:
  _1 = lseparated_nonempty_list_aux_COMMA_core_type_ _2 = option_COMMA_
    {let _1 =                                        ( List.rev _1 ) in
                                                    (_1)}

constructor_arguments:
  _1 = object_record_type
    {                       ( Pcstr_tuple [_1] )}
| _1 = record_declaration
    {                       ( Pcstr_record _1 )}
| _1 = LPAREN x = constructor_arguments_comma_list _3 = RPAREN
    {let _1 =
  let _1 =     ( x ) in
                                                         ( _1 )
in
    ( Pcstr_tuple _1 )}

record_label_declaration:
  _2 = mutable_flag x = LIDENT
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let (_endpos__3_, _startpos__3_) = (_endpos_x_, _startpos_x_) in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  if _startpos__2_ != _endpos__2_ then
    _startpos__2_
  else
    _startpos__3_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Type.field _3 (mkct _3) ~attrs:_1 ~mut:_2 ~loc
    )}
| _1 = nonempty_list_as_loc_attribute__ _2 = mutable_flag x = LIDENT
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let (_endpos__3_, _startpos__3_) = (_endpos_x_, _startpos_x_) in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  if _startpos__2_ != _endpos__2_ then
    _startpos__2_
  else
    _startpos__3_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Type.field _3 (mkct _3) ~attrs:_1 ~mut:_2 ~loc
    )}
| _2 = mutable_flag x = LIDENT _4 = COLON _5 = poly_type
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__3_ = _startpos_x_ in
let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  if _startpos__2_ != _endpos__2_ then
    _startpos__2_
  else
    _startpos__3_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Type.field _3 _5 ~attrs:_1 ~mut:_2 ~loc
    )}
| _1 = nonempty_list_as_loc_attribute__ _2 = mutable_flag x = LIDENT _4 = COLON _5 = poly_type
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__3_ = _startpos_x_ in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  if _startpos__2_ != _endpos__2_ then
    _startpos__2_
  else
    _startpos__3_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      Type.field _3 _5 ~attrs:_1 ~mut:_2 ~loc
    )}

record_declaration:
  _1 = LBRACE _1_inlined1 = lseparated_nonempty_list_aux_COMMA_record_label_declaration_ _3 = option_COMMA_ _4 = RBRACE
    {let _2 =
  let _1 = _1_inlined1 in
                                         ( List.rev _1 )
in
  ( _2 )}

str_type_extension:
  _2 = TYPE flag = nonrec_flag _1 = LIDENT params = type_variables_with_variance _6 = PLUSEQ priv = embedded_private_flag_ constructors = attributed_ext_constructors_either_extension_constructor_declaration_extension_constructor_rebind__
    {let ident =
  let x =                                   ( Lident _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let attrs =     ( [] ) in
  ( if flag <> Recursive then
      not_expecting _startpos_flag_ _endpos_flag_ "nonrec flag";
    Te.mk ~params ~priv ~attrs ident constructors
  )}
| _2 = TYPE flag = nonrec_flag _1 = mod_ext_longident _2_inlined1 = DOT _3 = LIDENT params = type_variables_with_variance _6 = PLUSEQ priv = embedded_private_flag_ constructors = attributed_ext_constructors_either_extension_constructor_declaration_extension_constructor_rebind__
    {let ident =
  let x =                                   ( Ldot(_1, _3) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let attrs =     ( [] ) in
  ( if flag <> Recursive then
      not_expecting _startpos_flag_ _endpos_flag_ "nonrec flag";
    Te.mk ~params ~priv ~attrs ident constructors
  )}
| _1 = nonempty_list_as_loc_attribute__ _2 = TYPE flag = nonrec_flag _1_inlined1 = LIDENT params = type_variables_with_variance _6 = PLUSEQ priv = embedded_private_flag_ constructors = attributed_ext_constructors_either_extension_constructor_declaration_extension_constructor_rebind__
    {let ident =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                                   ( Lident _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let attrs =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
  ( if flag <> Recursive then
      not_expecting _startpos_flag_ _endpos_flag_ "nonrec flag";
    Te.mk ~params ~priv ~attrs ident constructors
  )}
| _1 = nonempty_list_as_loc_attribute__ _2 = TYPE flag = nonrec_flag _1_inlined1 = mod_ext_longident _2_inlined1 = DOT _3 = LIDENT params = type_variables_with_variance _6 = PLUSEQ priv = embedded_private_flag_ constructors = attributed_ext_constructors_either_extension_constructor_declaration_extension_constructor_rebind__
    {let ident =
  let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
  let x =                                   ( Ldot(_1, _3) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let attrs =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
  ( if flag <> Recursive then
      not_expecting _startpos_flag_ _endpos_flag_ "nonrec flag";
    Te.mk ~params ~priv ~attrs ident constructors
  )}

sig_type_extension:
  _2 = TYPE flag = nonrec_flag _1 = LIDENT params = type_variables_with_variance _6 = PLUSEQ priv = embedded_private_flag_ constructors = attributed_ext_constructors_extension_constructor_declaration_
    {let ident =
  let x =                                   ( Lident _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let attrs =     ( [] ) in
  ( if flag <> Recursive then
      not_expecting _startpos_flag_ _endpos_flag_ "nonrec flag";
    Te.mk ~params ~priv ~attrs ident constructors
  )}
| _2 = TYPE flag = nonrec_flag _1 = mod_ext_longident _2_inlined1 = DOT _3 = LIDENT params = type_variables_with_variance _6 = PLUSEQ priv = embedded_private_flag_ constructors = attributed_ext_constructors_extension_constructor_declaration_
    {let ident =
  let x =                                   ( Ldot(_1, _3) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let attrs =     ( [] ) in
  ( if flag <> Recursive then
      not_expecting _startpos_flag_ _endpos_flag_ "nonrec flag";
    Te.mk ~params ~priv ~attrs ident constructors
  )}
| _1 = nonempty_list_as_loc_attribute__ _2 = TYPE flag = nonrec_flag _1_inlined1 = LIDENT params = type_variables_with_variance _6 = PLUSEQ priv = embedded_private_flag_ constructors = attributed_ext_constructors_extension_constructor_declaration_
    {let ident =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                                   ( Lident _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let attrs =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
  ( if flag <> Recursive then
      not_expecting _startpos_flag_ _endpos_flag_ "nonrec flag";
    Te.mk ~params ~priv ~attrs ident constructors
  )}
| _1 = nonempty_list_as_loc_attribute__ _2 = TYPE flag = nonrec_flag _1_inlined1 = mod_ext_longident _2_inlined1 = DOT _3 = LIDENT params = type_variables_with_variance _6 = PLUSEQ priv = embedded_private_flag_ constructors = attributed_ext_constructors_extension_constructor_declaration_
    {let ident =
  let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
  let x =                                   ( Ldot(_1, _3) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let attrs =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
  ( if flag <> Recursive then
      not_expecting _startpos_flag_ _endpos_flag_ "nonrec flag";
    Te.mk ~params ~priv ~attrs ident constructors
  )}

attributed_ext_constructors_either_extension_constructor_declaration_extension_constructor_rebind__:
  _1 = either_extension_constructor_declaration_extension_constructor_rebind_ _2 = list_attributed_ext_constructor_either_extension_constructor_declaration_extension_constructor_rebind___
    {                                     ( _1 :: _2 )}
| _1 = nonempty_list_attributed_ext_constructor_either_extension_constructor_declaration_extension_constructor_rebind___
    {                                   ( _1 )}

attributed_ext_constructors_extension_constructor_declaration_:
  _1 = extension_constructor_declaration _2 = list_attributed_ext_constructor_extension_constructor_declaration__
    {                                     ( _1 :: _2 )}
| _1 = nonempty_list_attributed_ext_constructor_extension_constructor_declaration__
    {                                   ( _1 )}

extension_constructor_declaration:
  _1 = UIDENT _2 = generalized_constructor_arguments
    {let _1 =
  let x =                       ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
  ( let args, res = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Te.decl _1 ~args ?res ~loc
  )}
| _1 = LBRACKET _2_inlined1 = RBRACKET _2 = generalized_constructor_arguments
    {let _1 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let x =                       ( "[]" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
  ( let args, res = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Te.decl _1 ~args ?res ~loc
  )}
| _1 = LPAREN _2_inlined1 = RPAREN _2 = generalized_constructor_arguments
    {let _1 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let x =                       ( "()" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
  ( let args, res = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Te.decl _1 ~args ?res ~loc
  )}
| _1 = COLONCOLON _2 = generalized_constructor_arguments
    {let _1 =
  let x =                       ( "::" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
  ( let args, res = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Te.decl _1 ~args ?res ~loc
  )}
| _1 = FALSE _2 = generalized_constructor_arguments
    {let _1 =
  let x =                       ( "false" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
  ( let args, res = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Te.decl _1 ~args ?res ~loc
  )}
| _1 = TRUE _2 = generalized_constructor_arguments
    {let _1 =
  let x =                       ( "true" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
  ( let args, res = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Te.decl _1 ~args ?res ~loc
  )}

extension_constructor_rebind:
  _1 = UIDENT _2 = EQUAL x = constr_longident
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos__3_ = _endpos_x_ in
let _1 =
  let x =                       ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
  ( let loc = mklocation _symbolstartpos _endpos in
    Te.rebind _1 _3 ~loc
  )}
| _1 = LBRACKET _2_inlined1 = RBRACKET _2 = EQUAL x = constr_longident
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos__3_ = _endpos_x_ in
let _1 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let x =                       ( "[]" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
  ( let loc = mklocation _symbolstartpos _endpos in
    Te.rebind _1 _3 ~loc
  )}
| _1 = LPAREN _2_inlined1 = RPAREN _2 = EQUAL x = constr_longident
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos__3_ = _endpos_x_ in
let _1 =
  let _endpos__2_ = _endpos__2_inlined1_ in
  let x =                       ( "()" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
  ( let loc = mklocation _symbolstartpos _endpos in
    Te.rebind _1 _3 ~loc
  )}
| _1 = COLONCOLON _2 = EQUAL x = constr_longident
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos__3_ = _endpos_x_ in
let _1 =
  let x =                       ( "::" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
  ( let loc = mklocation _symbolstartpos _endpos in
    Te.rebind _1 _3 ~loc
  )}
| _1 = FALSE _2 = EQUAL x = constr_longident
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos__3_ = _endpos_x_ in
let _1 =
  let x =                       ( "false" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
  ( let loc = mklocation _symbolstartpos _endpos in
    Te.rebind _1 _3 ~loc
  )}
| _1 = TRUE _2 = EQUAL x = constr_longident
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos__3_ = _endpos_x_ in
let _1 =
  let x =                       ( "true" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
  ( let loc = mklocation _symbolstartpos _endpos in
    Te.rebind _1 _3 ~loc
  )}

with_constraint:
  _1 = TYPE x = label_longident _3 = type_variables_with_variance _4 = EQUAL _5 = embedded_private_flag_ _6 = core_type
    {let _7 =     ( [] ) in
let _endpos__7_ = _endpos__6_ in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      let typ = Type.mk {_2 with txt=Longident.last _2.txt}
                  ~params:_3 ~cstrs:_7 ~manifest:_6 ~priv:_5 ~loc in
      Pwith_type (_2, typ)
    )}
| _1 = TYPE x = label_longident _3 = type_variables_with_variance _4 = EQUAL _5 = embedded_private_flag_ _6 = core_type _1_inlined1 = nonempty_list_preceded_CONSTRAINT_constrain__
    {let _7 =
  let _1 = _1_inlined1 in
                                       ( _1 )
in
let _endpos__7_ = _endpos__1_inlined1_ in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      let typ = Type.mk {_2 with txt=Longident.last _2.txt}
                  ~params:_3 ~cstrs:_7 ~manifest:_6 ~priv:_5 ~loc in
      Pwith_type (_2, typ)
    )}
| _1 = TYPE x = label_longident _3 = type_variables_with_variance _4 = COLONEQUAL _5 = core_type
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let (_endpos__2_, _startpos__2_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
    ( let last = match _2.txt with
        | Lident s -> s
        | _ -> not_expecting _startpos__2_ _endpos__2_ "Long type identifier"
      in
      let loc = mklocation _symbolstartpos _endpos in
      Pwith_typesubst (Type.mk {_2 with txt=last} ~params:_3 ~manifest:_5 ~loc)
    )}
| _1 = MODULE x = mod_longident _3 = EQUAL x_inlined1 = mod_ext_longident
    {let _4 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( Pwith_module (_2, _4) )}
| _1 = MODULE x = UIDENT _3 = COLONEQUAL x_inlined1 = mod_ext_longident
    {let _4 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( Pwith_modsubst (_2, _4) )}

poly_type:
  _1 = core_type
    {let _1 =
  let x =     ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = nonempty_list_preceded_QUOTE_ident__ _2 = DOT _3 = core_type
    {let _1 =
  let x =     ( mktyp(Ptyp_poly(_1, _3)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

core_type:
  _1 = core_type2
    {let _1 =
  let x =     ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = core_type2 _2 = AS _3 = QUOTE _4 = ident
    {let _1 =
  let x =     ( mktyp(Ptyp_alias(_1, _4)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

core_type2:
  ct = unattributed_core_type
    {let _1 =     ( [] ) in
let (_endpos__1_, _startpos__1_) = (_endpos__0_, _endpos__0_) in
let _endpos = _endpos_ct_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_ct_ in
  ( match _1 with
    | [] -> ct
    | attrs ->
      let loc_start = _symbolstartpos and loc_end = _endpos in
      let ptyp_loc = {ct.ptyp_loc with loc_start; loc_end} in
      let ptyp_attributes = attrs @ ct.ptyp_attributes in
      {ct with ptyp_attributes; ptyp_loc}
  )}
| _1 = nonempty_list_as_loc_attribute__ ct = unattributed_core_type
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
let _endpos = _endpos_ct_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos_ct_ in
  ( match _1 with
    | [] -> ct
    | attrs ->
      let loc_start = _symbolstartpos and loc_end = _endpos in
      let ptyp_loc = {ct.ptyp_loc with loc_start; loc_end} in
      let ptyp_attributes = attrs @ ct.ptyp_attributes in
      {ct with ptyp_attributes; ptyp_loc}
  )}

unattributed_core_type:
  _1 = non_arrowed_simple_core_type
    {                                 ( _1 )}
| _1 = arrowed_simple_core_type
    {                             ( _1 )}

arrowed_simple_core_type:
  _1 = ES6_FUN _2 = arrow_type_parameters _3 = EQUALGREATER _4 = core_type2
    {    ( List.fold_right mktyp_arrow _2 _4 )}
| x = labelled_arrow_type_parameter_optional _2 = EQUALGREATER _3 = core_type2
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( mktyp_arrow (_1, false) _3 )}
| _1 = basic_core_type _2 = EQUALGREATER _3 = core_type2
    {    ( mktyp (Ptyp_arrow (Nolabel, _1, _3)) )}

labelled_arrow_type_parameter_optional:
  _1 = TILDE _2 = LIDENT _3 = COLON _4 = protected_type _5 = EQUAL _6 = optional
    {    ( (_6 _2, _4) )}

arrow_type_parameter:
  _1 = protected_type
    {                    ( (Nolabel, _1) )}
| _1 = TILDE _2 = LIDENT _3 = COLON _4 = protected_type
    {    ( (Labelled _2, _4) )}
| _1 = labelled_arrow_type_parameter_optional
    {                                           ( _1 )}

arrow_type_parameters:
  _1 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_uncurried_arrow_type_parameter_ _2 = option_COMMA_ _3 = RPAREN
    {let _2 =
  let _1 = _1_inlined1 in
  let _1 =                                        ( List.rev _1 ) in
                                                                               (_1)
in
                                                 ( _2 )}

non_arrowed_core_type:
  _1 = non_arrowed_simple_core_type
    {    ( _1 )}
| _1 = attribute _2 = non_arrowed_core_type
    {    ( {_2 with ptyp_attributes = _1 :: _2.ptyp_attributes} )}

type_parameters:
  _1 = LPAREN _1_inlined1 = lseparated_nonempty_list_aux_COMMA_protected_type_ _2 = option_COMMA_ _3 = RPAREN
    {let _1 =
  let _1 =
    let x =
      let _1 = _1_inlined1 in
      let _1 =                                        ( List.rev _1 ) in
                                                                 (_1)
    in
        ( x )
  in
                                                         ( _1 )
in
                                             ( _1 )}

protected_type:
  _1 = MODULE _2 = package_type
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
                        (
      let loc = mklocation _symbolstartpos _endpos in
      { (mktyp(Ptyp_package _2)) with ptyp_loc = loc }
    )}
| _1 = core_type
    {              ( _1 )}

non_arrowed_simple_core_types:
  _1 = type_parameters
    {let _1 =
  let x =     ( match _1 with
      | [one] -> one
      | many -> mktyp (Ptyp_tuple many)
    ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

non_arrowed_simple_core_type:
  _1 = non_arrowed_simple_core_types
    {                                        ( _1 )}
| x = basic_core_type
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
                                       ( _1 )}

basic_core_type:
  _1 = type_longident _2 = type_parameters
    {let _1 =
  let x =     ( mktyp(Ptyp_constr(_1, _2)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = SHARP x = class_longident _3 = type_parameters
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mktyp(Ptyp_class(_2, _3)) )
  in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = QUOTE _2 = ident
    {let _1 =
  let x =     ( mktyp(Ptyp_var _2) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = SHARP x = class_longident
    {let _1 =
  let x =
    let _2 =
      let _endpos = _endpos_x_ in
      let _symbolstartpos = _startpos_x_ in
        ( mkloc x (mklocation _symbolstartpos _endpos) )
    in
        ( mktyp(Ptyp_class(_2, [])) )
  in
  let _startpos_x_ = _startpos__1_ in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = UNDERSCORE
    {let _1 =
  let x =     ( mktyp(Ptyp_any) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = type_longident
    {let _1 =
  let x =     ( mktyp(Ptyp_constr(_1, [])) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = object_record_type
    {let _1 =
  let x =     ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LBRACKET _2 = row_field_list _3 = RBRACKET
    {let _1 =
  let x =     ( mktyp(Ptyp_variant (_2, Closed, None)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LBRACKETGREATER _2 = loption_row_field_list_ _3 = RBRACKET
    {let _1 =
  let x =     ( mktyp(Ptyp_variant (_2, Open, None)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = LBRACKETLESS _2 = row_field_list _3 = loption_preceded_GREATER_nonempty_list_name_tag___ _4 = RBRACKET
    {let _1 =
  let x =     ( mktyp(Ptyp_variant (_2, Closed, Some _3)) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__4_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}
| _1 = extension
    {let _1 =
  let x =     ( mktyp(Ptyp_extension _1) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )
in
    (_1)}

object_record_type:
  _1 = LBRACE _2 = RBRACE
    {    ( syntax_error () )}
| _1 = LBRACE _2 = DOT _3 = string_literal_labels _4 = RBRACE
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
    ( (* `{. "foo": bar}` -> `Js.t({. foo: bar})` *)
      let loc = mklocation _symbolstartpos _endpos in
      mkBsObjTypeSugar ~loc ~closed:Closed _3
    )}
| _1 = LBRACE _2 = DOTDOT _3 = string_literal_labels _4 = RBRACE
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
    ( (* `{.. "foo": bar}` -> `Js.t({.. foo: bar})` *)
      let loc = mklocation _symbolstartpos _endpos in
      mkBsObjTypeSugar ~loc ~closed:Open _3
    )}
| _1 = LBRACE _2 = DOT _3 = loption_object_label_declarations_ _4 = RBRACE
    {    ( mktyp (Ptyp_object (_3, Closed)) )}
| _1 = LBRACE _2 = DOTDOT _3 = loption_object_label_declarations_ _4 = RBRACE
    {    ( mktyp (Ptyp_object (_3, Open)) )}

object_label_declaration:
  x = LIDENT
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =     ( [] ) in
    ( (_2.txt, _1, mkct _2) )}
| _1 = nonempty_list_as_loc_attribute__ x = LIDENT
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
    ( (_2.txt, _1, mkct _2) )}
| _2 = LIDENT _3 = COLON _4 = poly_type
    {let _1 =     ( [] ) in
    ( (_2, _1, _4) )}
| _1 = nonempty_list_as_loc_attribute__ _2 = LIDENT _3 = COLON _4 = poly_type
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
    ( (_2, _1, _4) )}

object_label_declarations:
  _1 = lseparated_nonempty_list_aux_COMMA_object_label_declaration_ _2 = option_COMMA_
    {let _1 =                                        ( List.rev _1 ) in
                                                                   ( _1 )}

string_literal_label:
  _2 = STRING _3 = COLON _4 = poly_type
    {let _1 =     ( [] ) in
  ( let (label, _raw, _delim) = _2 in (label, _1, _4) )}
| _1 = nonempty_list_as_loc_attribute__ _2 = STRING _3 = COLON _4 = poly_type
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
  ( let (label, _raw, _delim) = _2 in (label, _1, _4) )}

string_literal_labels:
  _1 = lseparated_nonempty_list_aux_COMMA_string_literal_label_ _2 = option_COMMA_
    {let _1 =                                        ( List.rev _1 ) in
                                                               ( _1 )}

package_type:
  _1 = module_type
    {              ( package_type_of_module_type _1 )}

row_field_list:
  _1 = row_field _2 = list_bar_row_field_
    {                             ( _1 :: _2 )}
| _1 = bar_row_field _2 = list_bar_row_field_
    {                                 ( _1 :: _2 )}

row_field:
  _1 = tag_field
    {                          ( _1 )}
| _1 = non_arrowed_core_type
    {                          ( Rinherit _1 )}

bar_row_field:
  _2 = BAR _3 = row_field
    {let _1 =     ( [] ) in
  ( match _3 with
    | Rtag (name, attrs, amp, typs) ->
        Rtag (name, _1 @ attrs, amp, typs)
    | Rinherit typ ->
        Rinherit {typ with ptyp_attributes = _1 @ typ.ptyp_attributes}
  )}
| _1 = nonempty_list_as_loc_attribute__ _2 = BAR _3 = row_field
    {let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
  ( match _3 with
    | Rtag (name, attrs, amp, typs) ->
        Rtag (name, _1 @ attrs, amp, typs)
    | Rinherit typ ->
        Rinherit {typ with ptyp_attributes = _1 @ typ.ptyp_attributes}
  )}

tag_field:
  _1 = BACKQUOTE _2 = ident _3 = boption_AMPERSAND_ _4 = separated_nonempty_list_AMPERSAND_non_arrowed_simple_core_types_
    {let _2 =                                   ( _2 ) in
let _1 =     ( [] ) in
    ( Rtag (_2, _1, _3, _4) )}
| _1 = nonempty_list_as_loc_attribute__ _1_inlined1 = BACKQUOTE _2 = ident _3 = boption_AMPERSAND_ _4 = separated_nonempty_list_AMPERSAND_non_arrowed_simple_core_types_
    {let _2 =                                   ( _2 ) in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
    ( Rtag (_2, _1, _3, _4) )}
| _1 = BACKQUOTE _2 = ident
    {let _2 =                                   ( _2 ) in
let _1 =     ( [] ) in
    ( Rtag (_2, _1, true, []) )}
| _1 = nonempty_list_as_loc_attribute__ _1_inlined1 = BACKQUOTE _2 = ident
    {let _2 =                                   ( _2 ) in
let _1 =
  let _1 =                                                ( _1 ) in
                         ( List.map (fun x -> x.txt) _1 )
in
    ( Rtag (_2, _1, true, []) )}

constant:
  _1 = INT
    {                 ( let (n, m) = _1 in ([], Pconst_integer (n, m)) )}
| _1 = CHAR
    {                 ( ([], Pconst_char _1) )}
| _1 = FLOAT
    {                 ( let (f, m) = _1 in ([], Pconst_float (f, m)) )}
| _1 = STRING
    {                 (
    let (s, raw, d) = _1 in
    let attr = match raw with
      | None -> []
      | Some raw ->
        let constant = Ast_helper.Exp.constant (Pconst_string (raw, None)) in
        [Location.mknoloc "reason.raw_literal", PStr [mkstrexp constant []]]
    in
    (attr, Pconst_string (s, d))
  )}

signed_constant:
  _1 = constant
    {                 ( _1 )}
| _1 = MINUS _2 = INT
    {                 ( let (n, m) = _2 in ([], Pconst_integer("-" ^ n, m)) )}
| _1 = MINUS _2 = FLOAT
    {                 ( let (f, m) = _2 in ([], Pconst_float("-" ^ f, m)) )}
| _1 = PLUS _2 = INT
    {                 ( let (n, m) = _2 in ([], Pconst_integer (n, m)) )}
| _1 = PLUS _2 = FLOAT
    {                 ( let (f, m) = _2 in ([], Pconst_float(f, m)) )}

ident:
  _1 = UIDENT
    {                       ( _1 )}
| _1 = LIDENT
    {                       ( _1 )}

val_ident:
  _1 = LIDENT
    {                           ( _1 )}
| _1 = LPAREN _2 = operator _3 = RPAREN
    {                           ( _2 )}

operator:
  _1 = PREFIXOP
    {                      ( _1 )}
| _1 = POSTFIXOP
    {                      ( _1 )}
| _1 = BANG
    {                      ( "!" )}
| _1 = INFIXOP0
    {let _1 =                       ( _1 ) in
                      ( _1 )}
| _1 = INFIXOP1
    {let _1 =                       ( _1 ) in
                      ( _1 )}
| _1 = INFIXOP2
    {let _1 =                       ( _1 ) in
                      ( _1 )}
| _1 = INFIXOP3
    {let _1 =                       ( _1 ) in
                      ( _1 )}
| _1 = SLASHGREATER
    {let _1 =                       ( "/>" ) in
                      ( _1 )}
| _1 = INFIXOP4
    {let _1 =                       ( _1 ) in
                      ( _1 )}
| _1 = PLUS
    {let _1 =                       ( "+" ) in
                      ( _1 )}
| _1 = PLUSDOT
    {let _1 =                       ( "+." ) in
                      ( _1 )}
| _1 = MINUS
    {let _1 =                       ( "-" ) in
                      ( _1 )}
| _1 = MINUSDOT
    {let _1 =                       ( "-." ) in
                      ( _1 )}
| _1 = STAR
    {let _1 =                       ( "*" ) in
                      ( _1 )}
| _1 = LESS
    {let _1 =                       ( "<" ) in
                      ( _1 )}
| _1 = GREATER
    {let _1 =                       ( ">" ) in
                      ( _1 )}
| _1 = OR
    {let _1 =                       ( "or" ) in
                      ( _1 )}
| _1 = BARBAR
    {let _1 =                       ( "||" ) in
                      ( _1 )}
| _1 = AMPERSAND
    {let _1 =                       ( "&" ) in
                      ( _1 )}
| _1 = AMPERAMPER
    {let _1 =                       ( "&&" ) in
                      ( _1 )}
| _1 = COLONEQUAL
    {let _1 =                       ( ":=" ) in
                      ( _1 )}
| _1 = PLUSEQ
    {let _1 =                       ( "+=" ) in
                      ( _1 )}
| _1 = PERCENT
    {let _1 =                       ( "%" ) in
                      ( _1 )}
| _1 = LESSDOTDOTGREATER
    {let _1 =                       ( "<..>" ) in
                      ( _1 )}
| _1 = GREATER _2 = GREATER
    {let _1 =                       ( ">>" ) in
                      ( _1 )}
| _1 = GREATERDOTDOTDOT
    {let _1 =                      ( ">..." ) in
                      ( _1 )}

val_longident:
  _1 = val_ident
    {                                  ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = val_ident
    {                                  ( Ldot(_1, _3) )}

constr_longident:
  _1 = mod_longident %prec below_DOT
    {                                  ( _1 )}
| _1 = LBRACKET _2 = RBRACKET
    {                                  ( Lident "[]" )}
| _1 = LPAREN _2 = RPAREN
    {                                  ( Lident "()" )}
| _1 = FALSE
    {                                  ( Lident "false" )}
| _1 = TRUE
    {                                  ( Lident "true" )}

label_longident:
  _1 = LIDENT
    {                                  ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = LIDENT
    {                                  ( Ldot(_1, _3) )}

type_longident:
  _1 = LIDENT
    {let _1 =
  let x =                                   ( Lident _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                        ( _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = LIDENT
    {let _1 =
  let x =                                   ( Ldot(_1, _3) ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__3_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                        ( _1 )}

mod_longident:
  _1 = UIDENT
    {                                  ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = UIDENT
    {                                  ( Ldot(_1, _3) )}

mod_ext_longident:
  _1 = UIDENT
    {let _1 =                                   ( Lident _1 ) in
                                      ( _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = UIDENT
    {let _1 =                                   ( Ldot(_1, _3) ) in
                                      ( _1 )}
| _1 = mod_ext_apply
    {let _1 =                                   ( _1 ) in
                                      ( _1 )}

mod_ext_apply:
  _1 = UIDENT _1_inlined1 = LPAREN _1_inlined2 = lseparated_nonempty_list_aux_COMMA_mod_ext_longident_ _3 = RPAREN
    {let _2 =
  let _1_inlined1 = _1_inlined2 in
  let _1 =
    let x =
      let _1 = _1_inlined1 in
                                             ( List.rev _1 )
    in
        ( x )
  in
                                                         ( _1 )
in
let _endpos__2_ = _endpos__3_ in
let _1 =                                   ( Lident _1 ) in
let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
  ( if not !Clflags.applicative_functors then
      raise Syntaxerr.(Error(Applicative_path(mklocation _startpos _endpos)));
    List.fold_left (fun p1 p2 -> Lapply (p1, p2)) _1 _2
  )}
| _1 = mod_ext_longident _2_inlined1 = DOT _3 = UIDENT _1_inlined1 = LPAREN _1_inlined2 = lseparated_nonempty_list_aux_COMMA_mod_ext_longident_ _3_inlined1 = RPAREN
    {let _2 =
  let _1_inlined1 = _1_inlined2 in
  let _1 =
    let x =
      let _1 = _1_inlined1 in
                                             ( List.rev _1 )
    in
        ( x )
  in
                                                         ( _1 )
in
let _endpos__2_ = _endpos__3_inlined1_ in
let _1 =                                   ( Ldot(_1, _3) ) in
let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
  ( if not !Clflags.applicative_functors then
      raise Syntaxerr.(Error(Applicative_path(mklocation _startpos _endpos)));
    List.fold_left (fun p1 p2 -> Lapply (p1, p2)) _1 _2
  )}
| _1 = mod_ext_apply _1_inlined1 = LPAREN _1_inlined2 = lseparated_nonempty_list_aux_COMMA_mod_ext_longident_ _3 = RPAREN
    {let _2 =
  let _1_inlined1 = _1_inlined2 in
  let _1 =
    let x =
      let _1 = _1_inlined1 in
                                             ( List.rev _1 )
    in
        ( x )
  in
                                                         ( _1 )
in
let _endpos__2_ = _endpos__3_ in
let _1 =                                   ( _1 ) in
let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
  ( if not !Clflags.applicative_functors then
      raise Syntaxerr.(Error(Applicative_path(mklocation _startpos _endpos)));
    List.fold_left (fun p1 p2 -> Lapply (p1, p2)) _1 _2
  )}

mty_longident:
  _1 = ident
    {                                 ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = ident
    {                                 ( Ldot(_1, _3) )}

clty_longident:
  _1 = LIDENT
    {                                 ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = LIDENT
    {                                 ( Ldot(_1, _3) )}

class_longident:
  _1 = LIDENT
    {                                 ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = LIDENT
    {                                 ( Ldot(_1, _3) )}

toplevel_directive:
  _1 = SHARP _2 = ident _3 = embedded___anonymous_38_
    {  ( Ptop_dir(_2, _3) )}

opt_LET_MODULE:
  _1 = MODULE
    {                       ( () )}
| _1 = LET _2 = MODULE
    {                                           ( () )}

rec_flag:
  
    {                  ( Nonrecursive )}
| _1 = REC
    {                  ( Recursive )}

nonrec_flag:
  
    {                  ( Recursive )}
| _1 = NONREC
    {                  ( Nonrecursive )}

direction_flag:
  _1 = TO
    {                  ( Upto )}
| _1 = DOWNTO
    {                  ( Downto )}

mutable_flag:
  
    {                  ( Immutable )}
| _1 = MUTABLE
    {                  ( Mutable )}

virtual_flag:
  
    {                  ( Concrete )}
| _1 = VIRTUAL
    {                  ( Virtual )}

mutable_or_virtual_flags:
  
    {                  ( Immutable, Concrete )}
| _1 = VIRTUAL _2 = mutable_flag
    {                         ( _2, Virtual )}
| _1 = MUTABLE _2 = virtual_flag
    {                         ( Mutable, _2 )}

override_flag:
  
    {                  ( Fresh )}
| _1 = BANG
    {                  ( Override )}

subtractive:
  _1 = MINUS
    {                  ( "-"  )}
| _1 = MINUSDOT
    {                  ( "-." )}

additive:
  _1 = PLUS
    {                  ( "+"  )}
| _1 = PLUSDOT
    {                  ( "+." )}

single_attr_id:
  _1 = LIDENT
    {                ( _1 )}
| _1 = UIDENT
    {                ( _1 )}
| _1 = AND
    {                ( "and" )}
| _1 = AS
    {                ( "as" )}
| _1 = ASSERT
    {                ( "assert" )}
| _1 = BEGIN
    {                ( "begin" )}
| _1 = CLASS
    {                ( "class" )}
| _1 = CONSTRAINT
    {                ( "constraint" )}
| _1 = DO
    {                ( "do" )}
| _1 = DONE
    {                ( "done" )}
| _1 = DOWNTO
    {                ( "downto" )}
| _1 = ELSE
    {                ( "else" )}
| _1 = END
    {                ( "end" )}
| _1 = EXCEPTION
    {                ( "exception" )}
| _1 = EXTERNAL
    {                ( "external" )}
| _1 = FALSE
    {                ( "false" )}
| _1 = FOR
    {                ( "for" )}
| _1 = FUN
    {                ( "fun" )}
| _1 = FUNCTION
    {                ( "function" )}
| _1 = FUNCTOR
    {                ( "functor" )}
| _1 = IF
    {                ( "if" )}
| _1 = IN
    {                ( "in" )}
| _1 = INCLUDE
    {                ( "include" )}
| _1 = INHERIT
    {                ( "inherit" )}
| _1 = INITIALIZER
    {                ( "initializer" )}
| _1 = LAZY
    {                ( "lazy" )}
| _1 = LET
    {                ( "let" )}
| _1 = SWITCH
    {                ( "switch" )}
| _1 = MODULE
    {                ( "module" )}
| _1 = MUTABLE
    {                ( "mutable" )}
| _1 = NEW
    {                ( "new" )}
| _1 = NONREC
    {                ( "nonrec" )}
| _1 = OBJECT
    {                ( "object" )}
| _1 = OF
    {                ( "of" )}
| _1 = OPEN
    {                ( "open" )}
| _1 = OR
    {                ( "or" )}
| _1 = PRI
    {                ( "private" )}
| _1 = REC
    {                ( "rec" )}
| _1 = SIG
    {                ( "sig" )}
| _1 = STRUCT
    {                ( "struct" )}
| _1 = THEN
    {                ( "then" )}
| _1 = TO
    {                ( "to" )}
| _1 = TRUE
    {                ( "true" )}
| _1 = TRY
    {                ( "try" )}
| _1 = TYPE
    {                ( "type" )}
| _1 = VAL
    {                ( "val" )}
| _1 = VIRTUAL
    {                ( "virtual" )}
| _1 = WHEN
    {                ( "when" )}
| _1 = WHILE
    {                ( "while" )}
| _1 = WITH
    {                ( "with" )}

attr_id:
  x = single_attr_id
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
    ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                           ( _1 )}
| _1 = single_attr_id _2 = DOT _3 = attr_id
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                               ( mkloc (_1 ^ "." ^ _3.txt) (mklocation _symbolstartpos _endpos) )}

attribute:
  _1 = LBRACKETAT _2 = attr_id _3 = payload _4 = RBRACKET
    {                                        ( (_2, _3) )}
| _1 = DOCSTRING
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
              ( doc_attr _1 (mklocation _symbolstartpos _endpos) )}

item_extension_sugar:
  _1 = PERCENT _2 = attr_id
    {                  ( ([], _2) )}

extension:
  _1 = LBRACKETPERCENT _2 = attr_id _3 = payload _4 = RBRACKET
    {                                           ( (_2, _3) )}

item_extension:
  _1 = LBRACKETPERCENTPERCENT _2 = attr_id _3 = payload _4 = RBRACKET
    {                                                  ( (_2, _3) )}

payload:
  _1 = structure
    {                                    ( PStr _1 )}
| _1 = COLON _2 = signature
    {                                    ( PSig _2 )}
| _1 = COLON _2 = core_type
    {                                    ( PTyp _2 )}
| _1 = QUESTION _2 = pattern
    {                                    ( PPat (_2, None) )}
| _1 = QUESTION _2 = pattern _3 = WHEN _4 = expr
    {                                    ( PPat (_2, Some _4) )}
| _1 = simple_pattern_ident _2 = EQUALGREATER _3 = expr
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
    ( let loc = mklocation _symbolstartpos _endpos in
      let expr = Exp.fun_ ~loc Nolabel None _1 _3 in
      PStr([mkstrexp expr []])
    )}

optional:
  
    {    ( fun x -> Labelled x )}
| _1 = QUESTION
    {             ( fun x -> Optional x )}

either_ES6_FUN_FUN_:
  _1 = ES6_FUN
    {      ( _1 )}
| _1 = FUN
    {      ( _1 )}

either___anonymous_12___anonymous_13_:
  _1 = PUB
    {let _1 =                                  (Public) in
      ( _1 )}
| _1 = PRI
    {let _1 =                                                (Private) in
      ( _1 )}

either_constructor_declaration_bar_constructor_declaration_:
  _1 = constructor_declaration
    {      ( _1 )}
| _1 = bar_constructor_declaration
    {      ( _1 )}

either_extension_constructor_declaration_extension_constructor_rebind_:
  _1 = extension_constructor_declaration
    {      ( _1 )}
| _1 = extension_constructor_rebind
    {      ( _1 )}

either_parenthesized_longident_type_constraint__longident_type_constraint_:
  _1 = LPAREN x = longident_type_constraint _3 = RPAREN
    {let _1 =
  let _1 =     ( x ) in
                                                         ( _1 )
in
      ( _1 )}
| _1 = longident_type_constraint
    {      ( _1 )}

either_preceded_EQUAL_class_expr__class_body_expr_:
  _1 = EQUAL x = class_expr
    {let _1 =     ( x ) in
      ( _1 )}
| _1 = LBRACE _2 = class_expr_lets_and_rest _3 = RBRACE
    {let _1 =                                                                 ( _2 ) in
      ( _1 )}

either_preceded_EQUAL_class_instance_type__class_type_body_:
  _1 = EQUAL x = class_instance_type
    {let _1 =     ( x ) in
      ( _1 )}
| _1 = class_type_body
    {      ( _1 )}

either_preceded_EQUAL_expr__braced_expr_:
  _1 = EQUAL x = expr
    {let _1 =     ( x ) in
      ( _1 )}
| _1 = braced_expr
    {      ( _1 )}

either_preceded_EQUALGREATER_expr__braced_expr_:
  _1 = EQUALGREATER x = expr
    {let _1 =     ( x ) in
      ( _1 )}
| _1 = braced_expr
    {      ( _1 )}

llist_aux_match_case_expr__:
  
    {                ( [] )}
| _1 = llist_aux_match_case_expr__ _2 = match_case_expr_
    {                   ( _2 :: _1 )}

llist_aux_match_case_seq_expr__:
  
    {                ( [] )}
| _1 = llist_aux_match_case_seq_expr__ _2 = match_case_seq_expr_
    {                   ( _2 :: _1 )}

llist_aux_preceded_COMMA_opt_spread_lbl_expr___:
  
    {                ( [] )}
| _1 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _1_inlined1 = COMMA _1_inlined2 = option_DOTDOTDOT_ x = label_longident _2 = COLON _3 = expr
    {let _2 =
  let (_startpos__1_inlined1_, _1_inlined1) = (_startpos__1_inlined2_, _1_inlined2) in
  let x =
    let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
    let _2 =
      let _1 =
        let _1 =
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
            ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                               ( (_1, _3) )
      in
                              (_1)
    in
    let _endpos__2_ = _endpos__3_ in
        ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
  in
      ( x )
in
                   ( _2 :: _1 )}
| _1 = llist_aux_preceded_COMMA_opt_spread_lbl_expr___ _1_inlined1 = COMMA _1_inlined2 = option_DOTDOTDOT_ x = label_longident
    {let _2 =
  let (_startpos__1_inlined1_, _1_inlined1) = (_startpos__1_inlined2_, _1_inlined2) in
  let x =
    let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
    let _2 =
      let _1 =
        let _1 =
          let _endpos = _endpos_x_ in
          let _symbolstartpos = _startpos_x_ in
            ( mkloc x (mklocation _symbolstartpos _endpos) )
        in
                                    ( (_1, exp_of_label _1) )
      in
                          (_1)
    in
    let _endpos__2_ = _endpos_x_ in
        ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
  in
      ( x )
in
                   ( _2 :: _1 )}

lseparated_nonempty_list_aux_AND_with_constraint_:
  _1 = with_constraint
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_AND_with_constraint_ _2 = AND _3 = with_constraint
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_core_type_:
  _1 = core_type
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_core_type_ _2 = COMMA _3 = core_type
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_expr_:
  _1 = expr
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_expr_ _2 = COMMA _3 = expr
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_expr_optional_constraint_:
  _1 = expr_optional_constraint
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_expr_optional_constraint_ _2 = COMMA _3 = expr_optional_constraint
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_field_expr_:
  _1 = field_expr
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_field_expr_ _2 = COMMA _3 = field_expr
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_labeled_pattern_:
  _1 = labeled_pattern
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_labeled_pattern_ _2 = COMMA _3 = labeled_pattern
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_mod_ext_longident_:
  _1 = mod_ext_longident
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_mod_ext_longident_ _2 = COMMA _3 = mod_ext_longident
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_module_complex_expr_:
  _1 = module_complex_expr
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_module_complex_expr_ _2 = COMMA _3 = module_complex_expr
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_module_parameter_:
  _1 = module_parameter
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_module_parameter_ _2 = COMMA _3 = module_parameter
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_object_label_declaration_:
  _1 = object_label_declaration
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_object_label_declaration_ _2 = COMMA _3 = object_label_declaration
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_opt_spread_expr_optional_constraint__:
  _1 = option_DOTDOTDOT_ _2 = expr_optional_constraint
    {let _1 =     ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    ) in
      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_opt_spread_expr_optional_constraint__ _2 = COMMA _1_inlined1 = option_DOTDOTDOT_ _2_inlined1 = expr_optional_constraint
    {let _3 =
  let (_endpos__2_, _startpos__1_, _2, _1) = (_endpos__2_inlined1_, _startpos__1_inlined1_, _2_inlined1, _1_inlined1) in
      ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
in
                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_opt_spread_lbl_expr__:
  _1 = option_DOTDOTDOT_ x = label_longident _2 = COLON _3 = expr
    {let _1 =
  let _2 =
    let _1 =
      let _1 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
                                             ( (_1, _3) )
    in
                            (_1)
  in
  let _endpos__2_ = _endpos__3_ in
      ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
in
      ( [_1] )}
| _1 = option_DOTDOTDOT_ x = label_longident
    {let _1 =
  let _2 =
    let _1 =
      let _1 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
                                  ( (_1, exp_of_label _1) )
    in
                        (_1)
  in
  let _endpos__2_ = _endpos_x_ in
      ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
in
      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_opt_spread_lbl_expr__ _2 = COMMA _1_inlined1 = option_DOTDOTDOT_ x = label_longident _2_inlined1 = COLON _3 = expr
    {let _3 =
  let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
  let _2 =
    let _1 =
      let _1 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
                                             ( (_1, _3) )
    in
                            (_1)
  in
  let _endpos__2_ = _endpos__3_ in
      ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
in
                                               ( _3 :: _1 )}
| _1 = lseparated_nonempty_list_aux_COMMA_opt_spread_lbl_expr__ _2 = COMMA _1_inlined1 = option_DOTDOTDOT_ x = label_longident
    {let _3 =
  let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
  let _2 =
    let _1 =
      let _1 =
        let _endpos = _endpos_x_ in
        let _symbolstartpos = _startpos_x_ in
          ( mkloc x (mklocation _symbolstartpos _endpos) )
      in
                                  ( (_1, exp_of_label _1) )
    in
                        (_1)
  in
  let _endpos__2_ = _endpos_x_ in
      ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
in
                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_opt_spread_pattern__:
  _1 = option_DOTDOTDOT_ _2 = pattern
    {let _1 =     ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    ) in
      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_opt_spread_pattern__ _2 = COMMA _1_inlined1 = option_DOTDOTDOT_ _2_inlined1 = pattern
    {let _3 =
  let (_endpos__2_, _startpos__1_, _2, _1) = (_endpos__2_inlined1_, _startpos__1_inlined1_, _2_inlined1, _1_inlined1) in
      ( let dotdotdot = match _1 with
      | Some _ -> Some (mklocation _startpos__1_ _endpos__2_)
      | None -> None
      in
      (dotdotdot, _2)
    )
in
                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_pattern_optional_constraint_:
  _1 = pattern_optional_constraint
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_pattern_optional_constraint_ _2 = COMMA _3 = pattern_optional_constraint
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_protected_type_:
  _1 = protected_type
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_protected_type_ _2 = COMMA _3 = protected_type
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_record_label_declaration_:
  _1 = record_label_declaration
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_record_label_declaration_ _2 = COMMA _3 = record_label_declaration
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_string_literal_expr_maybe_punned_:
  _1 = string_literal_expr_maybe_punned
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_string_literal_expr_maybe_punned_ _2 = COMMA _3 = string_literal_expr_maybe_punned
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_string_literal_label_:
  _1 = string_literal_label
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_string_literal_label_ _2 = COMMA _3 = string_literal_label
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_type_parameter_:
  _1 = type_parameter
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_type_parameter_ _2 = COMMA _3 = type_parameter
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_type_variable_with_variance_:
  _1 = type_variable_with_variance
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_type_variable_with_variance_ _2 = COMMA _3 = type_variable_with_variance
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_uncurried_arrow_type_parameter_:
  _1 = option_DOT_ x = arrow_type_parameter
    {let _1 =
  let _2 =
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( mkloc x (mklocation _symbolstartpos _endpos) )
  in
    ( let uncurried = match _1 with | Some _ -> true | None -> false in
    match _2.txt with
    | (Labelled _, _) when uncurried ->
        raise Reason_syntax_util.(Error(_2.loc, (Syntax_error "An uncurried function type with labelled arguments is not supported at the moment.")))
    | _ -> (_2, uncurried)
  )
in
      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_uncurried_arrow_type_parameter_ _2 = COMMA _1_inlined1 = option_DOT_ x = arrow_type_parameter
    {let _3 =
  let _1 = _1_inlined1 in
  let _2 =
    let _endpos = _endpos_x_ in
    let _symbolstartpos = _startpos_x_ in
      ( mkloc x (mklocation _symbolstartpos _endpos) )
  in
    ( let uncurried = match _1 with | Some _ -> true | None -> false in
    match _2.txt with
    | (Labelled _, _) when uncurried ->
        raise Reason_syntax_util.(Error(_2.loc, (Syntax_error "An uncurried function type with labelled arguments is not supported at the moment.")))
    | _ -> (_2, uncurried)
  )
in
                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_COMMA_uncurried_labeled_expr_:
  _1 = option_DOT_ _2 = labeled_expr
    {let _1 =
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                        (
    let uncurried = match _1 with | Some _ -> true | None -> false in
    if uncurried then
      let (lbl, argExpr) = _2 in
      let loc = mklocation _startpos _endpos in
      let up = uncurry_payload ~name:"uncurry" loc in
      (lbl, {argExpr with pexp_attributes = up::argExpr.pexp_attributes})
    else _2
  )
in
      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_COMMA_uncurried_labeled_expr_ _2 = COMMA _1_inlined1 = option_DOT_ _2_inlined1 = labeled_expr
    {let _3 =
  let (_endpos__2_, _startpos__1_, _2, _1) = (_endpos__2_inlined1_, _startpos__1_inlined1_, _2_inlined1, _1_inlined1) in
  let _endpos = _endpos__2_ in
  let _startpos = _startpos__1_ in
                        (
    let uncurried = match _1 with | Some _ -> true | None -> false in
    if uncurried then
      let (lbl, argExpr) = _2 in
      let loc = mklocation _startpos _endpos in
      let up = uncurry_payload ~name:"uncurry" loc in
      (lbl, {argExpr with pexp_attributes = up::argExpr.pexp_attributes})
    else _2
  )
in
                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_SEMI_class_field_:
  _1 = class_field
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_SEMI_class_field_ _2 = SEMI _3 = class_field
    {                                               ( _3 :: _1 )}

lseparated_nonempty_list_aux_SEMI_class_sig_field_:
  _1 = class_sig_field
    {      ( [_1] )}
| _1 = lseparated_nonempty_list_aux_SEMI_class_sig_field_ _2 = SEMI _3 = class_sig_field
    {                                               ( _3 :: _1 )}

%%


