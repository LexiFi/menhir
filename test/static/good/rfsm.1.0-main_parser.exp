Grammar has 59 nonterminal symbols, among which 1 start symbols.
Grammar has 50 terminal symbols.
Grammar has 131 productions.
nullable(vars) = false
nullable(var) = false
nullable(value_change) = false
nullable(type_index_expr) = false
nullable(type_decl) = false
nullable(typ) = false
nullable(transition) = false
nullable(stimuli) = false
nullable(separated_nonempty_list(SEMICOLON,action)) = false
nullable(separated_nonempty_list(DOT,guard)) = false
nullable(separated_nonempty_list(COMMA,var)) = false
nullable(separated_nonempty_list(COMMA,value_change)) = false
nullable(separated_nonempty_list(COMMA,id)) = false
nullable(separated_nonempty_list(COMMA,INT)) = false
nullable(program) = false
nullable(prio) = true
nullable(paren(separated_list(COMMA,value_change))) = false
nullable(paren(separated_list(COMMA,id))) = false
nullable(paren(separated_list(COMMA,INT))) = false
nullable(params) = false
nullable(param) = false
nullable(optional(vars)) = true
nullable(optional(params)) = true
nullable(optional(actions)) = true
nullable(option(int_range)) = true
nullable(opt_inst_params) = true
nullable(my_separated_nonempty_list(COMMA,transition)) = false
nullable(my_separated_nonempty_list(COMMA,param)) = false
nullable(my_separated_nonempty_list(COMMA,io)) = false
nullable(my_separated_nonempty_list(COMMA,UID)) = false
nullable(my_separated_list(COMMA,transition)) = true
nullable(my_separated_list(COMMA,param)) = true
nullable(my_separated_list(COMMA,io)) = true
nullable(my_separated_list(COMMA,UID)) = true
nullable(my_nonempty_list(global)) = false
nullable(my_nonempty_list(fsm_model)) = false
nullable(my_nonempty_list(fsm_inst)) = false
nullable(my_list(type_decl)) = true
nullable(loption(separated_nonempty_list(COMMA,var))) = true
nullable(loption(separated_nonempty_list(COMMA,value_change))) = true
nullable(loption(separated_nonempty_list(COMMA,id))) = true
nullable(loption(separated_nonempty_list(COMMA,INT))) = true
nullable(itransition) = false
nullable(io_desc) = false
nullable(io) = false
nullable(int_range) = false
nullable(id) = false
nullable(guard_expr) = false
nullable(guard) = false
nullable(global) = false
nullable(fsm_model) = false
nullable(fsm_inst) = false
nullable(expr) = false
nullable(const) = false
nullable(condition) = false
nullable(braced(my_separated_list(COMMA,UID))) = false
nullable(bool) = false
nullable(actions) = false
nullable(action) = false
first(vars) = VARS
first(var) = LID
first(value_change) = INT
first(type_index_expr) = LPAREN LID INT
first(type_decl) = TYPE
first(typ) = TYINT TYEVENT TYBOOL LID
first(transition) = UID TIMES
first(stimuli) = VALUE_CHANGES SPORADIC PERIODIC
first(separated_nonempty_list(SEMICOLON,action)) = LID
first(separated_nonempty_list(DOT,guard)) = UID TRUE LPAREN LID INT FALSE
first(separated_nonempty_list(COMMA,var)) = LID
first(separated_nonempty_list(COMMA,value_change)) = INT
first(separated_nonempty_list(COMMA,id)) = UID LID
first(separated_nonempty_list(COMMA,INT)) = INT
first(program) = TYPE FSM
first(prio) = TIMES
first(paren(separated_list(COMMA,value_change))) = LPAREN
first(paren(separated_list(COMMA,id))) = LPAREN
first(paren(separated_list(COMMA,INT))) = LPAREN
first(params) = LT
first(param) = LID
first(optional(vars)) = VARS
first(optional(params)) = LT
first(optional(actions)) = BAR
first(option(int_range)) = LT
first(opt_inst_params) = LT
first(my_separated_nonempty_list(COMMA,transition)) = UID TIMES
first(my_separated_nonempty_list(COMMA,param)) = LID
first(my_separated_nonempty_list(COMMA,io)) = OUT INOUT IN
first(my_separated_nonempty_list(COMMA,UID)) = UID
first(my_separated_list(COMMA,transition)) = UID TIMES
first(my_separated_list(COMMA,param)) = LID
first(my_separated_list(COMMA,io)) = OUT INOUT IN
first(my_separated_list(COMMA,UID)) = UID
first(my_nonempty_list(global)) = SHARED OUTPUT INPUT
first(my_nonempty_list(fsm_model)) = FSM
first(my_nonempty_list(fsm_inst)) = FSM
first(my_list(type_decl)) = TYPE
first(loption(separated_nonempty_list(COMMA,var))) = LID
first(loption(separated_nonempty_list(COMMA,value_change))) = INT
first(loption(separated_nonempty_list(COMMA,id))) = UID LID
first(loption(separated_nonempty_list(COMMA,INT))) = INT
first(itransition) = BAR ARROW_END
first(io_desc) = LID
first(io) = OUT INOUT IN
first(int_range) = LT
first(id) = UID LID
first(guard_expr) = UID TRUE LPAREN LID INT FALSE
first(guard) = UID TRUE LPAREN LID INT FALSE
first(global) = SHARED OUTPUT INPUT
first(fsm_model) = FSM
first(fsm_inst) = FSM
first(expr) = UID TRUE LPAREN LID INT FALSE
first(const) = UID TRUE INT FALSE
first(condition) = LID
first(braced(my_separated_list(COMMA,UID))) = LBRACE
first(bool) = TRUE FALSE
first(actions) = BAR
first(action) = LID
minimal(vars) = (* 3 *) VARS COLON SEMICOLON
minimal(var) = (* 3 *) LID COLON TYEVENT
minimal(value_change) = (* 3 *) INT COLON INT
minimal(type_index_expr) = (* 1 *) INT
minimal(type_decl) = (* 4 *) TYPE LID EQUAL TYEVENT
minimal(typ) = (* 1 *) TYEVENT
minimal(transition) = (* 5 *) UID ARROW_START LID ARROW_END UID
minimal(stimuli) = (* 3 *) SPORADIC LPAREN RPAREN
minimal(separated_nonempty_list(SEMICOLON,action)) = (* 1 *) LID
minimal(separated_nonempty_list(DOT,guard)) = (* 3 *) INT EQUAL INT
minimal(separated_nonempty_list(COMMA,var)) = (* 3 *) LID COLON TYEVENT
minimal(separated_nonempty_list(COMMA,value_change)) = (* 3 *) INT COLON INT
minimal(separated_nonempty_list(COMMA,id)) = (* 1 *) LID
minimal(separated_nonempty_list(COMMA,INT)) = (* 1 *) INT
minimal(program) = (* 29 *) FSM MODEL LID LPAREN RPAREN LBRACE STATES COLON SEMICOLON TRANS COLON SEMICOLON ITRANS COLON ARROW_END UID SEMICOLON RBRACE OUTPUT LID COLON TYEVENT FSM LID EQUAL LID LPAREN RPAREN EOF
minimal(prio) = (* 0 *)
minimal(paren(separated_list(COMMA,value_change))) = (* 2 *) LPAREN RPAREN
minimal(paren(separated_list(COMMA,id))) = (* 2 *) LPAREN RPAREN
minimal(paren(separated_list(COMMA,INT))) = (* 2 *) LPAREN RPAREN
minimal(params) = (* 2 *) LT GT
minimal(param) = (* 3 *) LID COLON TYEVENT
minimal(optional(vars)) = (* 0 *)
minimal(optional(params)) = (* 0 *)
minimal(optional(actions)) = (* 0 *)
minimal(option(int_range)) = (* 0 *)
minimal(opt_inst_params) = (* 0 *)
minimal(my_separated_nonempty_list(COMMA,transition)) = (* 5 *) UID ARROW_START LID ARROW_END UID
minimal(my_separated_nonempty_list(COMMA,param)) = (* 3 *) LID COLON TYEVENT
minimal(my_separated_nonempty_list(COMMA,io)) = (* 4 *) IN LID COLON TYEVENT
minimal(my_separated_nonempty_list(COMMA,UID)) = (* 1 *) UID
minimal(my_separated_list(COMMA,transition)) = (* 0 *)
minimal(my_separated_list(COMMA,param)) = (* 0 *)
minimal(my_separated_list(COMMA,io)) = (* 0 *)
minimal(my_separated_list(COMMA,UID)) = (* 0 *)
minimal(my_nonempty_list(global)) = (* 4 *) OUTPUT LID COLON TYEVENT
minimal(my_nonempty_list(fsm_model)) = (* 18 *) FSM MODEL LID LPAREN RPAREN LBRACE STATES COLON SEMICOLON TRANS COLON SEMICOLON ITRANS COLON ARROW_END UID SEMICOLON RBRACE
minimal(my_nonempty_list(fsm_inst)) = (* 6 *) FSM LID EQUAL LID LPAREN RPAREN
minimal(my_list(type_decl)) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,var))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,value_change))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,id))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,INT))) = (* 0 *)
minimal(itransition) = (* 2 *) ARROW_END UID
minimal(io_desc) = (* 3 *) LID COLON TYEVENT
minimal(io) = (* 4 *) IN LID COLON TYEVENT
minimal(int_range) = (* 5 *) LT INT DOTDOT INT GT
minimal(id) = (* 1 *) LID
minimal(guard_expr) = (* 3 *) INT EQUAL INT
minimal(guard) = (* 3 *) INT EQUAL INT
minimal(global) = (* 4 *) OUTPUT LID COLON TYEVENT
minimal(fsm_model) = (* 18 *) FSM MODEL LID LPAREN RPAREN LBRACE STATES COLON SEMICOLON TRANS COLON SEMICOLON ITRANS COLON ARROW_END UID SEMICOLON RBRACE
minimal(fsm_inst) = (* 6 *) FSM LID EQUAL LID LPAREN RPAREN
minimal(expr) = (* 1 *) INT
minimal(const) = (* 1 *) INT
minimal(condition) = (* 1 *) LID
minimal(braced(my_separated_list(COMMA,UID))) = (* 2 *) LBRACE RBRACE
minimal(bool) = (* 1 *) TRUE
minimal(actions) = (* 2 *) BAR LID
minimal(action) = (* 1 *) LID
follow(vars) = TRANS
follow(var) = SEMICOLON COMMA
follow(value_change) = RPAREN COMMA
follow(type_index_expr) = TIMES RPAREN PLUS MOD MINUS GT DOTDOT DIV
follow(type_decl) = TYPE FSM
follow(typ) = TYPE SHARED SEMICOLON RPAREN OUTPUT INPUT GT FSM EQUAL COMMA
follow(transition) = SEMICOLON COMMA
follow(stimuli) = SHARED OUTPUT INPUT FSM
follow(separated_nonempty_list(SEMICOLON,action)) = ARROW_END
follow(separated_nonempty_list(DOT,guard)) = BAR ARROW_END
follow(separated_nonempty_list(COMMA,var)) = SEMICOLON
follow(separated_nonempty_list(COMMA,value_change)) = RPAREN
follow(separated_nonempty_list(COMMA,id)) = RPAREN
follow(separated_nonempty_list(COMMA,INT)) = RPAREN GT
follow(program) = #
follow(prio) = UID
follow(paren(separated_list(COMMA,value_change))) = SHARED OUTPUT INPUT FSM
follow(paren(separated_list(COMMA,id))) = FSM EOF
follow(paren(separated_list(COMMA,INT))) = SHARED OUTPUT INPUT FSM
follow(params) = LPAREN
follow(param) = GT COMMA
follow(optional(vars)) = TRANS
follow(optional(params)) = LPAREN
follow(optional(actions)) = ARROW_END
follow(option(int_range)) = TYPE SHARED SEMICOLON RPAREN OUTPUT INPUT GT FSM EQUAL COMMA
follow(opt_inst_params) = LPAREN
follow(my_separated_nonempty_list(COMMA,transition)) = SEMICOLON
follow(my_separated_nonempty_list(COMMA,param)) = GT
follow(my_separated_nonempty_list(COMMA,io)) = RPAREN
follow(my_separated_nonempty_list(COMMA,UID)) = SEMICOLON RBRACE
follow(my_separated_list(COMMA,transition)) = SEMICOLON
follow(my_separated_list(COMMA,param)) = GT
follow(my_separated_list(COMMA,io)) = RPAREN
follow(my_separated_list(COMMA,UID)) = SEMICOLON RBRACE
follow(my_nonempty_list(global)) = FSM
follow(my_nonempty_list(fsm_model)) = SHARED OUTPUT INPUT
follow(my_nonempty_list(fsm_inst)) = EOF
follow(my_list(type_decl)) = FSM
follow(loption(separated_nonempty_list(COMMA,var))) = SEMICOLON
follow(loption(separated_nonempty_list(COMMA,value_change))) = RPAREN
follow(loption(separated_nonempty_list(COMMA,id))) = RPAREN
follow(loption(separated_nonempty_list(COMMA,INT))) = RPAREN
follow(itransition) = SEMICOLON
follow(io_desc) = RPAREN COMMA
follow(io) = RPAREN COMMA
follow(int_range) = TYPE SHARED SEMICOLON RPAREN OUTPUT INPUT GT FSM EQUAL COMMA
follow(id) = RPAREN LT LPAREN EQUAL COMMA COLON
follow(guard_expr) = DOT BAR ARROW_END
follow(guard) = DOT BAR ARROW_END
follow(global) = SHARED OUTPUT INPUT FSM
follow(fsm_model) = SHARED OUTPUT INPUT FSM
follow(fsm_inst) = FSM EOF
follow(expr) = TIMES SEMICOLON RPAREN QMARK PLUS NOTEQUAL MOD MINUS LTE LT GTE GT EQUAL DOT DIV COLON BAR ARROW_END
follow(const) = RPAREN COMMA
follow(condition) = BAR ARROW_END
follow(braced(my_separated_list(COMMA,UID))) = TYPE FSM
follow(bool) = TIMES SEMICOLON RPAREN QMARK PLUS NOTEQUAL MOD MINUS LTE LT GTE GT EQUAL DOT DIV COMMA COLON BAR ARROW_END
follow(actions) = ARROW_END
follow(action) = SEMICOLON ARROW_END
Built an LR(0) automaton with 254 states.
The grammar is not SLR(1) -- 23 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 254 states.
241 shift/reduce conflicts were silently solved.
84 out of 254 states have a default reduction.
78 out of 254 states are represented.
13 out of 112 symbols keep track of their start position.
25 out of 112 symbols keep track of their end position.
66 out of 132 productions exploit shiftreduce optimization.
0 out of 254 states can peek at an error.
705 functions before inlining, 105 functions after inlining.
