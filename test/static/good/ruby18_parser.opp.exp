File "ruby18_parser.mly", line 39, characters 16-19:
Warning: the token EOF is unused.
%{
  module Make (A : Ast.Annotation) = struct
    module Parser_helper = Parser_helper.Make (A)
    open Logging
    open Token
    open Ast.Generic
    open Lexer_state
    open Parser_helper

    let annot pos = A.of_pos pos
%}
%start program
%token <Lexing.position> AMPER
%token <Lexing.position> AMPER2
%token <Lexing.position> ANDOP
%token <Lexing.position> AREF
%token <Lexing.position> ASET
%token <Lexing.position> ASSOC
%token <Lexing.position> BACK_REF2
%token <Lexing.position> BANG
%token <Lexing.position> CARET
%token <Lexing.position> CMP
%token <Lexing.position> COLON
%token <Lexing.position> COLON2
%token <Lexing.position> COLON3
%token <Lexing.position> COMMA
%token <string * Lexing.position> COMMENT
%token <string * Lexing.position> CONSTANT
%token <string * Lexing.position> CVAR
%token <Lexing.position> DIVIDE
%token <Lexing.position> DOT
%token <Lexing.position> DOT2
%token <Lexing.position> DOT3
%token <Lexing.position> EH
%token EOF
%token <Lexing.position> EQ
%token <Lexing.position> EQL
%token <Lexing.position> EQQ
%token <string * Lexing.position> FID
%token <float * Lexing.position> FLOAT
%token <Lexing.position> GEQ
%token <Lexing.position> GT
%token <string * Lexing.position> GVAR
%token <string * Lexing.position> IDENTIFIER
%token <int * Lexing.position> INTEGER
%token <string * Lexing.position> IVAR
%token <Lexing.position> K_ALIAS
%token <Lexing.position> K_AND
%token <Lexing.position> K_BEGIN
%token <Lexing.position> K_BREAK
%token <Lexing.position> K_CASE
%token <Lexing.position> K_CLASS
%token <Lexing.position> K_DEF
%token <Lexing.position> K_DEFINED
%token <Lexing.position> K_DO
%token <Lexing.position> K_DO_BLOCK
%token <Lexing.position> K_DO_COND
%token <Lexing.position> K_ELSE
%token <Lexing.position> K_ELSIF
%token <Lexing.position> K_END
%token <Lexing.position> K_ENSURE
%token <Lexing.position> K_FALSE
%token <Lexing.position> K_FOR
%token <Lexing.position> K_IF
%token <Lexing.position> K_IF_MOD
%token <Lexing.position> K_IN
%token <Lexing.position> K_MODULE
%token <Lexing.position> K_NEXT
%token <Lexing.position> K_NIL
%token <Lexing.position> K_NOT
%token <Lexing.position> K_OR
%token <Lexing.position> K_REDO
%token <Lexing.position> K_RESCUE
%token <Lexing.position> K_RESCUE_MOD
%token <Lexing.position> K_RETRY
%token <Lexing.position> K_RETURN
%token <Lexing.position> K_SELF
%token <Lexing.position> K_SUPER
%token <Lexing.position> K_THEN
%token <Lexing.position> K_TRUE
%token <Lexing.position> K_UNDEF
%token <Lexing.position> K_UNLESS
%token <Lexing.position> K_UNLESS_MOD
%token <Lexing.position> K_UNTIL
%token <Lexing.position> K_UNTIL_MOD
%token <Lexing.position> K_WHEN
%token <Lexing.position> K_WHILE
%token <Lexing.position> K_WHILE_MOD
%token <Lexing.position> K_YIELD
%token <Lexing.position> K__FILE__
%token <Lexing.position> K__LINE__
%token <Lexing.position> K_lBEGIN
%token <Lexing.position> K_lEND
%token <Lexing.position> LB
%token <Lexing.position> LBRACE
%token <Lexing.position> LBRACE_ARG
%token <Lexing.position> LBRACK
%token <Lexing.position> LCURLY
%token <Lexing.position> LEQ
%token <Lexing.position> LPAREN
%token <Lexing.position> LPAREN2
%token <Lexing.position> LPAREN_ARG
%token <Lexing.position> LSHFT
%token <Lexing.position> LT
%token <Lexing.position> MATCH
%token <Lexing.position> MINUS
%token <Lexing.position> NEQ
%token NL
%token <Lexing.position> NMATCH
%token <string * Lexing.position> OP_ASGN
%token <Lexing.position> OROP
%token <Lexing.position> PERCENT
%token <Lexing.position> PIPE
%token <Lexing.position> PLUS
%token <Lexing.position> POW
%token <Lexing.position> QWORDS_BEG
%token <Lexing.position> RBRACK
%token <Lexing.position> RCURLY
%token <Lexing.position> REGEXP_BEG
%token <string * Lexing.position> REGEXP_END
%token <Lexing.position> RPAREN
%token <Lexing.position> RSHFT
%token <Lexing.position> SEMI
%token SPACE
%token <Lexing.position> STAR
%token <Lexing.position> STAR2
%token <Lexing.position> STRING_BEG
%token <string * Lexing.position> STRING_CONTENT
%token <Lexing.position> STRING_DBEG
%token <Lexing.position> STRING_DVAR
%token <Lexing.position> STRING_END
%token <Lexing.position> SYMBEG
%token <Lexing.position> TILDE
%token <Lexing.position> UMINUS
%token <Lexing.position> UMINUS_NUM
%token <Lexing.position> UPLUS
%token <Lexing.position> WORDS_BEG
%token <Lexing.position> XSTRING_BEG
%nonassoc LOWEST
%nonassoc LBRACE_ARG
%nonassoc K_IF_MOD K_UNLESS_MOD K_UNTIL_MOD K_WHILE_MOD
%left K_AND K_OR
%right K_NOT
%nonassoc K_DEFINED
%right EQL OP_ASGN
%left K_RESCUE_MOD
%right COLON EH
%nonassoc DOT2 DOT3
%left OROP
%left ANDOP
%nonassoc CMP EQ EQQ MATCH NEQ NMATCH
%left GEQ GT LEQ LT
%left CARET PIPE
%left AMPER2
%left LSHFT RSHFT
%left MINUS PLUS
%left DIVIDE PERCENT STAR2
%right UMINUS UMINUS_NUM
%right POW
%right BANG TILDE UPLUS
%type <A.t Ast.Generic.rb_stmt list> program
%%

program:
  _1 = program_e1 _2 = compstmt
    {                    ( _2 )}

program_e1:
  
    {                  ( state.lex_state <- Expr_beg )}

bodystmt:
  _1 = compstmt _2 = opt_rescue _3 = opt_else _4 = opt_ensure
    {                    ( { body = _1;
                        body_rescues = _2;
                        body_else = _3;
                        body_ensure = _4 } )}

compstmt:
  _1 = stmts _2 = opt_terms
    {                    ( _1 @ _2 )}

stmts:
  _1 = none
    {                    ( [] )}
| _1 = stmt
    {                    ( [_1] )}
| _1 = stmts _2 = terms _3 = stmt
    {                    ( _1 @ _2 @ [_3] )}
| _1 = error _2 = stmt
    {                    ( [_2] )}

stmt:
  _1 = K_ALIAS _2 = fitem _3 = stmt_e1 _4 = fitem
    {                    ( Alias (_2, _4, annot _1) )}
| _1 = K_ALIAS _2 = GVAR _3 = GVAR
    {                    ( Alias (fst _2, fst _3, annot _1) )}
| _1 = K_UNDEF _2 = undef_list
    {                    ( Undef (_2, annot _1) )}
| _1 = stmt _2 = K_IF_MOD _3 = expr_value
    {                    ( If_mod (_1, _3, annot _2) )}
| _1 = stmt _2 = K_UNLESS_MOD _3 = expr_value
    {                    ( Unless_mod (_1, _3, annot _2) )}
| _1 = stmt _2 = K_WHILE_MOD _3 = expr_value
    {                    ( While_mod (_1, _3, annot _2) )}
| _1 = stmt _2 = K_UNTIL_MOD _3 = expr_value
    {                    ( Until_mod (_1, _3, annot _2) )}
| _1 = stmt _2 = K_RESCUE_MOD _3 = stmt
    {                    ( Rescue_mod (_1, _3, annot _2) )}
| _1 = K_lBEGIN _2 = stmt_e2 _3 = LCURLY _4 = compstmt _5 = RCURLY
    {                    ( Pre_exec (_4, annot _1) )}
| _1 = K_lEND _2 = LCURLY _3 = compstmt _4 = RCURLY
    {                    ( if state.in_def > 0 || state.in_single > 0 then
                        yyerror "END in method; use at_exit";
                      Post_exec (_3, annot _1) )}
| _1 = lhs _2 = EQL _3 = command_call
    {                    ( expr_stmt (Assign (_1, _3, Asgn_single, dummy_annot)) )}
| _1 = mlhs _2 = EQL _3 = command_call
    {                    ( expr_stmt (Assign (Lhs_dstr _1, _3, Asgn_multi, annot _2)) )}
| _1 = var_lhs _2 = OP_ASGN _3 = command_call
    {                    ( expr_stmt (new_op_asgn _1 (fst _2) _3 ~annot:(annot (snd _2))) )}
| _1 = primary_value _2 = LB _3 = aref_args _4 = RBRACK _5 = OP_ASGN _6 = command_call
    {                    ( expr_stmt (new_op_asgn (Lhs_aref (_1, _3)) (fst _5) _6 ~annot:(annot (snd _5))) )}
| _1 = primary_value _2 = DOT _3 = IDENTIFIER _4 = OP_ASGN _5 = command_call
    {                    ( expr_stmt (new_op_asgn (Lhs_attr (_1, fst _3)) (fst _4) _5 ~annot:(annot (snd _4))) )}
| _1 = primary_value _2 = DOT _3 = CONSTANT _4 = OP_ASGN _5 = command_call
    {                    ( expr_stmt (new_op_asgn (Lhs_attr (_1, fst _3)) (fst _4) _5 ~annot:(annot (snd _4))) )}
| _1 = primary_value _2 = COLON2 _3 = IDENTIFIER _4 = OP_ASGN _5 = command_call
    {                    ( expr_stmt (new_op_asgn (Lhs_attr (_1, fst _3)) (fst _4) _5 ~annot:(annot (snd _4))) )}
| _1 = lhs _2 = EQL _3 = mrhs
    {                    ( expr_stmt (Assign (_1, Array (_3, dummy_annot), Asgn_svalue, dummy_annot)) )}
| _1 = mlhs _2 = EQL _3 = arg_value
    {                    ( expr_stmt (Assign (Lhs_dstr _1, _3, Asgn_multi, annot _2)) )}
| _1 = mlhs _2 = EQL _3 = mrhs
    {                    ( expr_stmt (Assign (Lhs_dstr _1, Array (_3, dummy_annot), Asgn_multi, annot _2)) )}
| _1 = expr
    {                    ( expr_stmt _1 )}

stmt_e1:
  
    {                  ( state.lex_state <- Expr_fname;
                    (*result = self.lexer.lineno*)
                    0 )}

stmt_e2:
  
    {                  ( if state.in_def > 0 || state.in_single > 0 then
                      yyerror "BEGIN in method";
                    Env.extend state.env )}

expr:
  _1 = command_call
    {                    ( _1 )}
| _1 = expr _2 = K_AND _3 = expr
    {                    ( logop `And _1 _3 )}
| _1 = expr _2 = K_OR _3 = expr
    {                    ( logop `Or _1 _3 )}
| _1 = K_NOT _2 = expr
    {                    ( Not (_2, annot _1) )}
| _1 = BANG _2 = command_call
    {                    ( Not (_2, annot _1) )}
| _1 = arg
    {                    ( _1 )}

expr_value:
  _1 = expr
    {                    ( _1 )}

command_call:
  _1 = command
    {                    ( _1 )}
| _1 = block_command
    {                    ( _1 )}
| _1 = K_RETURN _2 = call_args
    {                    ( Return (ret_args _2, annot _1) )}
| _1 = K_BREAK _2 = call_args
    {                    ( Break (ret_args _2, annot _1) )}
| _1 = K_NEXT _2 = call_args
    {                    ( Next (ret_args _2, annot _1) )}

block_command:
  _1 = block_call
    {                    ( _1 )}
| _1 = block_call _2 = DOT _3 = operation2 _4 = command_args
    {                    ( new_call _1 (fst _3) _4 ~annot:(annot (snd _3)) )}
| _1 = block_call _2 = COLON2 _3 = operation2 _4 = command_args
    {                    ( new_call _1 (fst _3) _4 ~annot:(annot (snd _3)) )}

cmd_brace_block:
  _1 = LBRACE_ARG _2 = cmd_brace_block_e1 _3 = opt_block_var _4 = compstmt _5 = RCURLY_error
    {                    ( let blk = { blk_vars = _3; blk_body = _4 } in
                        Env.unextend state.env ;
                        blk )}

cmd_brace_block_e1:
  
    {                    ( Env.extend ~dyn:true state.env;
                      (* TODO result = self.lexer.lineno*)
                      ())}

command:
  _1 = operation _2 = command_args %prec LOWEST
    {                    ( new_fcall (fst _1) _2 ~annot:(annot (snd _1)) )}
| _1 = operation _2 = command_args _3 = cmd_brace_block
    {                    ( new_fcall (fst _1) _2 ~block:(Some _3) ~annot:(annot (snd _1)) )}
| _1 = primary_value _2 = DOT _3 = operation2 _4 = command_args %prec LOWEST
    {                    ( new_call _1 (fst _3) _4 ~annot:(annot (snd _3)) )}
| _1 = primary_value _2 = DOT _3 = operation2 _4 = command_args _5 = cmd_brace_block
    {                    ( new_call _1 (fst _3) _4 ~block:(Some _5) ~annot:(annot (snd _3)) )}
| _1 = primary_value _2 = COLON2 _3 = operation2 _4 = command_args %prec LOWEST
    {                    ( new_call _1 (fst _3) _4 ~annot:(annot (snd _3)) )}
| _1 = primary_value _2 = COLON2 _3 = operation2 _4 = command_args _5 = cmd_brace_block
    {                    ( new_call _1 (fst _3) _4 ~block:(Some _5) ~annot:(annot (snd _3)) )}
| _1 = K_SUPER _2 = command_args
    {                    ( Super (Some _2, None, annot _1) )}
| _1 = K_YIELD _2 = command_args
    {                    ( new_yield _2 ~annot:(annot _1) )}

mlhs:
  _1 = mlhs_basic
    {                    ( _1 )}
| _1 = LPAREN _2 = mlhs_entry _3 = RPAREN
    {                    ( _2 )}

mlhs_entry:
  _1 = mlhs_basic
    {                    ( _1 )}
| _1 = LPAREN _2 = mlhs_entry _3 = RPAREN
    {                    ( [Lhs_dstr _2] )}

mlhs_basic:
  _1 = mlhs_head
    {                    ( _1 )}
| _1 = mlhs_head _2 = mlhs_item
    {                    ( _1 @ [_2] )}
| _1 = mlhs_head _2 = STAR _3 = mlhs_node
    {                    ( _1 @ [Lhs_rest _3] )}
| _1 = mlhs_head _2 = STAR
    {                    ( _1 @ [Lhs_star] )}
| _1 = STAR _2 = mlhs_node
    {                    ( [Lhs_rest _2] )}
| _1 = STAR
    {                    ( [Lhs_star] )}

mlhs_item:
  _1 = mlhs_node
    {                    ( _1 )}
| _1 = LPAREN _2 = mlhs_entry _3 = RPAREN
    {                    ( Lhs_dstr _2 )}

mlhs_head:
  _1 = mlhs_item _2 = COMMA
    {                    ( [_1] )}
| _1 = mlhs_head _2 = mlhs_item _3 = COMMA
    {                    ( _1 @ [_2] )}

mlhs_node:
  _1 = variable
    {                    ( assignable (fst _1) ~annot:(annot (snd _1)) )}
| _1 = primary_value _2 = LB _3 = aref_args _4 = RBRACK
    {                    ( Lhs_aref (_1, _3) )}
| _1 = primary_value _2 = DOT _3 = IDENTIFIER
    {                    ( Lhs_attr (_1, fst _3) )}
| _1 = primary_value _2 = COLON2 _3 = IDENTIFIER
    {                    ( Lhs_attr (_1, fst _3) )}
| _1 = primary_value _2 = DOT _3 = CONSTANT
    {                    ( Lhs_attr (_1, fst _3) )}
| _1 = primary_value _2 = COLON2 _3 = CONSTANT
    {                    ( if state.in_def > 0 || state.in_single > 0 then
                        yyerror "dynamic constant assignment";
                      Lhs_var (Var_const (Cpath_relative (_1, fst _3))) )}
| _1 = COLON3 _2 = CONSTANT
    {                    ( if state.in_def > 0 || state.in_single > 0 then
                        yyerror "dynamic constant assignment";
                      Lhs_var (Var_const (Cpath_absolute (Cpath_name (fst _2)))) )}

lhs:
  _1 = variable
    {                    ( assignable (fst _1) ~annot:(annot (snd _1)) )}
| _1 = primary_value _2 = LB _3 = aref_args _4 = RBRACK
    {                    ( Lhs_aref (_1, _3) )}
| _1 = primary_value _2 = DOT _3 = IDENTIFIER
    {                    ( Lhs_attr (_1, fst _3) )}
| _1 = primary_value _2 = COLON2 _3 = IDENTIFIER
    {                    ( Lhs_attr (_1, fst _3) )}
| _1 = primary_value _2 = DOT _3 = CONSTANT
    {                    ( Lhs_attr (_1, fst _3) )}
| _1 = primary_value _2 = COLON2 _3 = CONSTANT
    {                    ( if state.in_def > 0 || state.in_single > 0 then
                        yyerror "dynamic constant assignment";
                      Lhs_var (Var_const (Cpath_relative (_1, fst _3))) )}
| _1 = COLON3 _2 = CONSTANT
    {                    ( if state.in_def > 0 || state.in_single > 0 then
                        yyerror "dynamic constant assignment";
                      Lhs_var (Var_const (Cpath_absolute (Cpath_name (fst _2)))) )}

cname:
  _1 = IDENTIFIER
    {                    ( yyerror "class/module name must be CONSTANT" )}
| _1 = CONSTANT
    {                    ( _1 )}

cpath:
  _1 = COLON3 _2 = cname
    {                    ( Cpath_absolute (Cpath_name (fst _2)) )}
| _1 = cname
    {                    ( Cpath_name (fst _1) )}
| _1 = primary_value _2 = COLON2 _3 = cname
    {                    ( Cpath_relative (_1, fst _3) )}

fname:
  _1 = IDENTIFIER
    {                    ( _1 )}
| _1 = CONSTANT
    {                    ( _1 )}
| _1 = FID
    {                    ( _1 )}
| _1 = op
    {                    ( state.lex_state <- Expr_end;
                      _1 )}
| _1 = reswords
    {                    ( state.lex_state <- Expr_end;
                      _1 )}

fitem:
  _1 = fname
    {                         ( fst _1 )}
| _1 = symbol
    {                         ( fst _1 )}

undef_list:
  _1 = fitem
    {                    ( [_1] )}
| _1 = undef_list _2 = COMMA _3 = undef_list_e1 _4 = fitem
    {                    ( _1 @ [_4] )}

undef_list_e1:
  
    {                  ( state.lex_state <- Expr_fname )}

op:
  _1 = PIPE
    {                            ( "|", _1 )}
| _1 = CARET
    {                            ( "^", _1 )}
| _1 = AMPER2
    {                            ( "&", _1 )}
| _1 = CMP
    {                            ( "<=>", _1 )}
| _1 = EQ
    {                            ( "==", _1 )}
| _1 = EQQ
    {                            ( "===", _1 )}
| _1 = MATCH
    {                            ( "=~", _1 )}
| _1 = GT
    {                            ( ">", _1 )}
| _1 = GEQ
    {                            ( ">=", _1 )}
| _1 = LT
    {                            ( "<", _1 )}
| _1 = LEQ
    {                            ( "<=", _1 )}
| _1 = LSHFT
    {                            ( "<<", _1 )}
| _1 = RSHFT
    {                            ( ">>", _1 )}
| _1 = PLUS
    {                            ( "+", _1 )}
| _1 = MINUS
    {                            ( "-", _1 )}
| _1 = STAR2
    {                            ( "*", _1 )}
| _1 = STAR
    {                            ( "*", _1 )}
| _1 = DIVIDE
    {                            ( "/", _1 )}
| _1 = PERCENT
    {                            ( "%", _1 )}
| _1 = POW
    {                            ( "**", _1 )}
| _1 = TILDE
    {                            ( "~", _1 )}
| _1 = UPLUS
    {                            ( "+@", _1 )}
| _1 = UMINUS
    {                            ( "-@", _1 )}
| _1 = AREF
    {                            ( "[]", _1 )}
| _1 = ASET
    {                            ( "[]=", _1 )}
| _1 = BACK_REF2
    {                            ( "`", _1 )}

reswords:
  _1 = K__LINE__
    {                                    ( "__LINE__", _1 )}
| _1 = K__FILE__
    {                                    ( "__FILE__", _1 )}
| _1 = K_lBEGIN
    {                                    ( "BEGIN", _1 )}
| _1 = K_lEND
    {                                    ( "END", _1 )}
| _1 = K_ALIAS
    {                                    ( "alias", _1 )}
| _1 = K_AND
    {                                    ( "and", _1 )}
| _1 = K_BEGIN
    {                                    ( "begin", _1 )}
| _1 = K_BREAK
    {                                    ( "break", _1 )}
| _1 = K_CASE
    {                                    ( "case", _1 )}
| _1 = K_CLASS
    {                                    ( "class", _1 )}
| _1 = K_DEF
    {                                    ( "def", _1 )}
| _1 = K_DEFINED
    {                                    ( "defined", _1 )}
| _1 = K_DO
    {                                    ( "do", _1 )}
| _1 = K_ELSE
    {                                    ( "else", _1 )}
| _1 = K_ELSIF
    {                                    ( "elsif", _1 )}
| _1 = K_END
    {                                    ( "end", _1 )}
| _1 = K_ENSURE
    {                                    ( "ensure", _1 )}
| _1 = K_FALSE
    {                                    ( "false", _1 )}
| _1 = K_FOR
    {                                    ( "for", _1 )}
| _1 = K_IN
    {                                    ( "in", _1 )}
| _1 = K_MODULE
    {                                    ( "module", _1 )}
| _1 = K_NEXT
    {                                    ( "next", _1 )}
| _1 = K_NIL
    {                                    ( "nil", _1 )}
| _1 = K_NOT
    {                                    ( "not", _1 )}
| _1 = K_OR
    {                                    ( "or", _1 )}
| _1 = K_REDO
    {                                    ( "redo", _1 )}
| _1 = K_RESCUE
    {                                    ( "rescue", _1 )}
| _1 = K_RETRY
    {                                    ( "retry", _1 )}
| _1 = K_RETURN
    {                                    ( "return", _1 )}
| _1 = K_SELF
    {                                    ( "self", _1 )}
| _1 = K_SUPER
    {                                    ( "super", _1 )}
| _1 = K_THEN
    {                                    ( "then", _1 )}
| _1 = K_TRUE
    {                                    ( "true", _1 )}
| _1 = K_UNDEF
    {                                    ( "undef", _1 )}
| _1 = K_WHEN
    {                                    ( "when", _1 )}
| _1 = K_YIELD
    {                                    ( "yield", _1 )}
| _1 = K_IF_MOD
    {                                    ( "if", _1 )}
| _1 = K_UNLESS_MOD
    {                                    ( "unless", _1 )}
| _1 = K_WHILE_MOD
    {                                    ( "while", _1 )}
| _1 = K_UNTIL_MOD
    {                                    ( "until", _1 )}
| _1 = K_RESCUE_MOD
    {                                    ( "rescue", _1 )}

arg:
  _1 = lhs _2 = EQL _3 = arg
    {                    ( Assign (_1, _3, Asgn_single, dummy_annot) )}
| _1 = lhs _2 = EQL _3 = arg _4 = K_RESCUE_MOD _5 = arg
    {                    ( Assign (_1,
                              Begin ({ body = [expr_stmt _3];
                                       body_rescues = [[], [expr_stmt _5]];
                                       body_else = [];
                                       body_ensure = [] },
                                     annot _4),
                              Asgn_single,
                              dummy_annot) )}
| _1 = var_lhs _2 = OP_ASGN _3 = arg
    {                    ( new_op_asgn _1 (fst _2) _3 ~annot:(annot (snd _2)) )}
| _1 = primary_value _2 = LB _3 = aref_args _4 = RBRACK _5 = OP_ASGN _6 = arg
    {                    ( new_op_asgn (Lhs_aref (_1, _3)) (fst _5) _6 ~annot:(annot (snd _5)) )}
| _1 = primary_value _2 = DOT _3 = IDENTIFIER _4 = OP_ASGN _5 = arg
    {                    ( new_op_asgn (Lhs_attr (_1, fst _3)) (fst _4) _5 ~annot:(annot (snd _4)) )}
| _1 = primary_value _2 = DOT _3 = CONSTANT _4 = OP_ASGN _5 = arg
    {                    ( new_op_asgn (Lhs_attr (_1, fst _3)) (fst _4) _5 ~annot:(annot (snd _4)) )}
| _1 = primary_value _2 = COLON2 _3 = IDENTIFIER _4 = OP_ASGN _5 = arg
    {                    ( new_op_asgn (Lhs_attr (_1, fst _3)) (fst _4) _5 ~annot:(annot (snd _4)) )}
| _1 = primary_value _2 = COLON2 _3 = CONSTANT _4 = OP_ASGN _5 = arg
    {                    ( yyerror "constant re-assignment" )}
| _1 = COLON3 _2 = CONSTANT _3 = OP_ASGN _4 = arg
    {                    ( yyerror "constant re-assignment" )}
| _1 = arg _2 = DOT2 _3 = arg
    {                    (
(* TODO
                      v1, v2 = val[0], val[2]
                      if v1.node_type == :lit and v2.node_type == :lit and Fixnum === v1.last and Fixnum === v2.last then
                        result = s(:lit, (v1.last)..(v2.last))
                      else
                        result = s(:dot2, v1, v2)
                      end
*)
                      Dot2 (_1, _3, annot _2) )}
| _1 = arg _2 = DOT3 _3 = arg
    {                    (
(* TODO
                      v1, v2 = val[0], val[2]
                      if v1.node_type == :lit and v2.node_type == :lit and Fixnum === v1.last and Fixnum === v2.last then
                        result = s(:lit, (v1.last)...(v2.last))
                      else
                        result = s(:dot3, v1, v2)
                      end
*)
                      Dot3 (_1, _3, annot _2) )}
| _1 = arg _2 = PLUS _3 = arg
    {                    ( new_call _1 "+" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = MINUS _3 = arg
    {                    ( new_call _1 "-" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = STAR2 _3 = arg
    {                    ( new_call _1 "*" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = DIVIDE _3 = arg
    {                    ( new_call _1 "/" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = PERCENT _3 = arg
    {                    ( new_call _1 "%" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = POW _3 = arg
    {                    ( new_call _1 "**" [Arg_value _3] ~annot:(annot _2) )}
| _1 = UMINUS_NUM _2 = INTEGER _3 = POW _4 = arg
    {                    ( new_call (new_call (Literal (Lit_integer (fst _2), annot (snd _2))) "**" [Arg_value _4] ~annot:(annot _3)) "-@" [] ~annot:(annot _1) )}
| _1 = UMINUS_NUM _2 = FLOAT _3 = POW _4 = arg
    {                    ( new_call (new_call (Literal (Lit_float (fst _2), annot (snd _2))) "**" [Arg_value _4] ~annot:(annot _3)) "-@" [] ~annot:(annot _1) )}
| _1 = UPLUS _2 = arg
    {                    ( match _2 with
                      | Literal _ -> _2
                      | _ -> new_call _2 "+@" [] ~annot:(annot _1) )}
| _1 = UMINUS _2 = arg
    {                    ( new_call _2 "-@" [] ~annot:(annot _1) )}
| _1 = arg _2 = PIPE _3 = arg
    {                    ( new_call _1 "|" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = CARET _3 = arg
    {                    ( new_call _1 "^" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = AMPER2 _3 = arg
    {                    ( new_call _1 "&" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = CMP _3 = arg
    {                    ( new_call _1 "<=>" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = GT _3 = arg
    {                    ( new_call _1 ">" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = GEQ _3 = arg
    {                    ( new_call _1 ">=" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = LT _3 = arg
    {                    ( new_call _1 "<" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = LEQ _3 = arg
    {                    ( new_call _1 "<=" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = EQ _3 = arg
    {                    ( new_call _1 "==" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = EQQ _3 = arg
    {                    ( new_call _1 "===" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = NEQ _3 = arg
    {                    ( Not (new_call _1 "==" [Arg_value _3], dummy_annot) )}
| _1 = arg _2 = MATCH _3 = arg
    {                    ( get_match_node _1 _3 ~annot:(annot _2) )}
| _1 = arg _2 = NMATCH _3 = arg
    {                    ( Not (get_match_node _1 _3 ~annot:(annot _2), dummy_annot) )}
| _1 = BANG _2 = arg
    {                    ( Not (_2, annot _1) )}
| _1 = TILDE _2 = arg
    {                    ( new_call _2 "~" [] ~annot:(annot _1) )}
| _1 = arg _2 = LSHFT _3 = arg
    {                    ( new_call _1 "<<" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = RSHFT _3 = arg
    {                    ( new_call _1 ">>" [Arg_value _3] ~annot:(annot _2) )}
| _1 = arg _2 = ANDOP _3 = arg
    {                    ( logop `And _1 _3 )}
| _1 = arg _2 = OROP _3 = arg
    {                    ( logop `Or _1 _3 )}
| _1 = K_DEFINED _2 = opt_nl _3 = arg
    {                    ( Defined (_3, annot _1) )}
| _1 = arg _2 = EH _3 = arg _4 = COLON _5 = arg
    {                    ( Ternary (_1, _3, _5, Ast.annot_of_expr _1) )}
| _1 = primary
    {                    ( _1 )}

arg_value:
  _1 = arg
    {                    ( _1 )}

aref_args:
  _1 = none
    {                    ( [] )}
| _1 = command _2 = opt_nl
    {                    ( warning "parenthesize argument(s) for future version";
                      [Arg_value _1] )}
| _1 = args _2 = trailer
    {                    ( _1 )}
| _1 = args _2 = COMMA _3 = STAR _4 = arg _5 = opt_nl
    {                    ( _1 @ [Arg_value _4] )}
| _1 = assocs _2 = trailer
    {                    ( [Arg_hash _1] )}
| _1 = STAR _2 = arg _3 = opt_nl
    {                    ( [Arg_splat _2] )}

paren_args:
  _1 = LPAREN2 _2 = none _3 = RPAREN
    {                    ( [] )}
| _1 = LPAREN2 _2 = call_args _3 = opt_nl _4 = RPAREN
    {                    ( _2 )}
| _1 = LPAREN2 _2 = block_call _3 = opt_nl _4 = RPAREN
    {                    ( warning "parenthesize argument(s) for future version";
                      [Arg_value _2] )}
| _1 = LPAREN2 _2 = args _3 = COMMA _4 = block_call _5 = opt_nl _6 = RPAREN
    {                    ( warning "parenthesize argument(s) for future version";
                      _2 @ [Arg_value _4] )}

opt_paren_args:
  _1 = none
    {                    ( [] )}
| _1 = paren_args
    {                    ( _1 )}

call_args:
  _1 = command
    {                    ( warning "parenthesize argument(s) for future version";
                      [] )}
| _1 = args _2 = opt_block_arg
    {                    ( _1 @ _2 )}
| _1 = args _2 = COMMA _3 = STAR _4 = arg_value _5 = opt_block_arg
    {                    ( _1 @ (Arg_splat _4 :: _5) )}
| _1 = assocs _2 = opt_block_arg
    {                    ( Arg_hash _1 :: _2 )}
| _1 = assocs _2 = COMMA _3 = STAR _4 = arg_value _5 = opt_block_arg
    {                    ( Arg_hash _1 :: Arg_splat _4 :: _5 )}
| _1 = args _2 = COMMA _3 = assocs _4 = opt_block_arg
    {                    ( _1 @ (Arg_hash _3 :: _4) )}
| _1 = args _2 = COMMA _3 = assocs _4 = COMMA _5 = STAR _6 = arg _7 = opt_block_arg
    {                    ( _1 @ (Arg_hash _3 :: Arg_splat _6 :: _7) )}
| _1 = STAR _2 = arg_value _3 = opt_block_arg
    {                    ( Arg_splat _2 :: _3 )}
| _1 = block_arg
    {                    ( [_1] )}

call_args2:
  _1 = arg_value _2 = COMMA _3 = args _4 = opt_block_arg
    {                    ( (Arg_value _1 :: _3) @ _4 )}
| _1 = arg_value _2 = COMMA _3 = block_arg
    {                    ( Arg_value _1 :: [_3] )}
| _1 = arg_value _2 = COMMA _3 = STAR _4 = arg_value _5 = opt_block_arg
    {                    ( Arg_value _1 :: Arg_splat _4 :: _5 )}
| _1 = arg_value _2 = COMMA _3 = args _4 = COMMA _5 = STAR _6 = arg_value _7 = opt_block_arg
    {                    ( (Arg_value _1 :: _3) @ (Arg_splat _6 :: _7) )}
| _1 = assocs _2 = opt_block_arg
    {                    ( Arg_hash _1 :: _2 )}
| _1 = assocs _2 = COMMA _3 = STAR _4 = arg_value _5 = opt_block_arg
    {                    ( Arg_hash _1 :: Arg_splat _4 :: _5 )}
| _1 = arg_value _2 = COMMA _3 = assocs _4 = opt_block_arg
    {                    ( Arg_value _1 :: Arg_hash _3 :: _4 )}
| _1 = arg_value _2 = COMMA _3 = args _4 = COMMA _5 = assocs _6 = opt_block_arg
    {                    ( (Arg_value _1 :: _3) @ (Arg_hash _5 :: _6) )}
| _1 = arg_value _2 = COMMA _3 = assocs _4 = COMMA _5 = STAR _6 = arg_value _7 = opt_block_arg
    {                    ( Arg_value _1 :: Arg_hash _3 :: Arg_splat _6 :: _7 )}
| _1 = arg_value _2 = COMMA _3 = args _4 = COMMA _5 = assocs _6 = COMMA _7 = STAR _8 = arg_value _9 = opt_block_arg
    {                    ( (Arg_value _1 :: _3) @ (Arg_hash _5 :: Arg_splat _8 :: _9) )}
| _1 = STAR _2 = arg_value _3 = opt_block_arg
    {                    ( Arg_splat _2 :: _3 )}
| _1 = block_arg
    {                    ( [_1] )}

command_args:
  _1 = command_args_e1 _2 = open_args
    {                    ( state.cmdarg_stack <- Stack_state.of_list _1;
                      _2 )}

command_args_e1:
  
    {                    ( let list = Stack_state.to_list state.cmdarg_stack in
                        Stack_state.push state.cmdarg_stack true;
                        list )}

open_args:
  _1 = call_args
    {                    ( _1 )}
| _1 = LPAREN_ARG _2 = open_args_e1 _3 = RPAREN
    {                    ( warning "don't put space before argument parentheses";
                      [] )}
| _1 = LPAREN_ARG _2 = call_args2 _3 = open_args_e1 _4 = RPAREN
    {                    ( warning "don't put space before argument parentheses";
                      _2 )}

open_args_e1:
  
    {                  ( state.lex_state <- Expr_endarg )}

block_arg:
  _1 = AMPER _2 = arg_value
    {                    ( Arg_block _2 )}

opt_block_arg:
  _1 = COMMA _2 = block_arg
    {                    ( [_2] )}
| _1 = none_block_pass
    {                    ( [] )}

args:
  _1 = arg_value
    {                    ( [Arg_value _1] )}
| _1 = args _2 = COMMA _3 = arg_value
    {                    ( _1 @ [Arg_value _3] )}

mrhs:
  _1 = args _2 = COMMA _3 = arg_value
    {                    ( _1 @ [Arg_value _3] )}
| _1 = args _2 = COMMA _3 = STAR _4 = arg_value
    {                    ( _1 @ [Arg_splat _4] )}
| _1 = STAR _2 = arg_value
    {                    ( [Arg_splat _2] )}

primary:
  _1 = literal
    {                    ( _1 )}
| _1 = strings
    {                    ( _1 )}
| _1 = xstring
    {                    ( _1 )}
| _1 = regexp
    {                    ( _1 )}
| _1 = words
    {                    ( _1 )}
| _1 = awords
    {                    ( _1 )}
| _1 = var_ref
    {                    ( _1 )}
| _1 = FID
    {                    ( new_fcall (fst _1) [] ~annot:(annot (snd _1)) )}
| _1 = K_BEGIN _2 = bodystmt _3 = K_END
    {                    ( Begin (_2, annot _1) )}
| _1 = LPAREN_ARG _2 = expr _3 = primary_e1 _4 = opt_nl _5 = RPAREN
    {                    ( warning "(...) interpreted as grouped expression";
                      _2 )}
| _1 = LPAREN _2 = compstmt _3 = RPAREN
    {                    ( match _2 with
                      | [] -> Variable (Var_pseudo Pvar_nil, annot _1)
                      | _  -> Seq (_2, annot _1) )}
| _1 = primary_value _2 = COLON2 _3 = CONSTANT
    {                    ( Variable (Var_const (Cpath_relative (_1, fst _3)), annot (snd _3)) )}
| _1 = COLON3 _2 = CONSTANT
    {                    ( Variable (Var_const (Cpath_absolute (Cpath_name (fst _2))), annot (snd _2)) )}
| _1 = primary_value _2 = LB _3 = aref_args _4 = RBRACK
    {                    ( new_aref _1 _3 ~annot:(annot _2) )}
| _1 = LBRACK _2 = aref_args _3 = RBRACK
    {                    ( Array (_2, annot _1) )}
| _1 = LBRACE _2 = assoc_list _3 = RCURLY
    {                    ( Hash (_2, annot _1) )}
| _1 = K_RETURN
    {                    ( Return ([], annot _1) )}
| _1 = K_YIELD _2 = LPAREN2 _3 = call_args _4 = RPAREN
    {                    ( new_yield _3 ~annot:(annot _1) )}
| _1 = K_YIELD _2 = LPAREN2 _3 = RPAREN
    {                    ( new_yield [] ~annot:(annot _1) )}
| _1 = K_YIELD
    {                    ( new_yield [] ~annot:(annot _1) )}
| _1 = K_DEFINED _2 = opt_nl _3 = LPAREN2 _4 = expr _5 = RPAREN
    {                    ( Defined (_4, annot _1) )}
| _1 = operation _2 = brace_block
    {                    ( new_fcall (fst _1) [] ~block:(Some _2) ~annot:(annot (snd _1)) )}
| _1 = method_call
    {                    ( _1 )}
| _1 = method_call _2 = brace_block
    {                    ( match _1 with
                      | Call (recv, id, args, _, annot) ->
                          Call (recv, id, args, Some _2, annot)
                      | Super (args, _, annot) ->
                          Super (args, Some _2, annot)
                      | _ -> failwith "invalid method_call" )}
| _1 = K_IF _2 = expr_value _3 = then_ _4 = compstmt _5 = if_tail _6 = K_END
    {                    ( If (_2, _4, _5, annot _1) )}
| _1 = K_UNLESS _2 = expr_value _3 = then_ _4 = compstmt _5 = opt_else _6 = K_END
    {                    ( Unless (_2, _4, _5, annot _1) )}
| _1 = K_WHILE _2 = primary_e2 _3 = expr_value _4 = do_ _5 = primary_e3 _6 = compstmt _7 = K_END
    {                    ( While (_3, _6, annot _1) )}
| _1 = K_UNTIL _2 = primary_e2 _3 = expr_value _4 = do_ _5 = primary_e3 _6 = compstmt _7 = K_END
    {                    ( Until (_3, _6, annot _1) )}
| _1 = K_CASE _2 = expr_value _3 = opt_terms _4 = case_body _5 = opt_else _6 = K_END
    {                    ( new_case (Some _2) _4 _5 ~annot:(annot _1) )}
| _1 = K_CASE _2 = opt_terms _3 = case_body _4 = opt_else _5 = K_END
    {                    ( new_case None _3 _4 ~annot:(annot _1) )}
| _1 = K_CASE _2 = opt_terms _3 = K_ELSE _4 = compstmt _5 = K_END
    {                    ( new_case None [] _4 ~annot:(annot _1) )}
| _1 = K_FOR _2 = block_var _3 = K_IN _4 = primary_e2 _5 = expr_value _6 = do_ _7 = primary_e3 _8 = compstmt _9 = K_END
    {                    ( For (_2, _5, _8, annot _1) )}
| _1 = K_CLASS _2 = cpath _3 = superclass _4 = primary_e4 _5 = bodystmt _6 = K_END
    {                    ( let ret = Class (_2, _3, _5, annot _1) in
                        Env.unextend state.env;
                        ret )}
| _1 = K_CLASS _2 = LSHFT _3 = expr _4 = primary_e5 _5 = term _6 = primary_e6 _7 = bodystmt _8 = K_END
    {                    ( let ret = Sclass (_3, _7, annot _1) in
                        state.in_def <- _4;
                        state.in_single <- _6;
                        Env.unextend state.env;
                        ret )}
| _1 = K_MODULE _2 = cpath _3 = primary_e7 _4 = bodystmt _5 = K_END
    {                    ( let ret = Module (_2, _4, annot _1) in
                        Env.unextend state.env;
                        ret )}
| _1 = K_DEF _2 = fname _3 = primary_e8 _4 = f_arglist _5 = bodystmt _6 = K_END
    {                    ( let ret = Defn (fst _2, _4, _5, annot _1) in
                        Env.unextend state.env;
                        state.in_def <- pred state.in_def;
                        ret )}
| _1 = K_DEF _2 = singleton _3 = dot_or_colon _4 = primary_e9 _5 = fname _6 = primary_e10 _7 = f_arglist _8 = bodystmt _9 = K_END
    {                    ( let ret = Defs (_2, fst _5, _7, _8, annot _1) in
                        Env.unextend state.env;
                        state.in_single <- pred state.in_single;
                        ret )}
| _1 = K_BREAK
    {                    ( Break ([], annot _1) )}
| _1 = K_NEXT
    {                    ( Next ([], annot _1) )}
| _1 = K_REDO
    {                    ( Redo (annot _1) )}
| _1 = K_RETRY
    {                    ( Retry (annot _1) )}

primary_e1:
  
    {                  ( state.lex_state <- Expr_endarg )}

primary_e2:
  
    {                  ( Stack_state.push state.cond_stack true )}

primary_e3:
  
    {                  ( Stack_state.pop state.cond_stack )}

primary_e4:
  
    {                  ( if state.in_def > 0 || state.in_single > 0 then
                      yyerror "class definition in method body";
                    Env.extend state.env )}

primary_e5:
  
    {                  ( let in_def = state.in_def in
                      state.in_def <- 0;
                      in_def )}

primary_e6:
  
    {                  ( let in_single = state.in_single in
                      state.in_single <- 0;
                      Env.extend state.env;
                      in_single )}

primary_e7:
  
    {                  ( if state.in_def > 0 || state.in_single > 0 then
                      yyerror "module definition in method body";
                    Env.extend state.env )}

primary_e8:
  
    {                  ( state.in_def <- succ state.in_def;
                    Env.extend state.env )}

primary_e9:
  
    {                  ( state.lex_state <- Expr_fname )}

primary_e10:
  
    {                  ( state.in_single <- succ state.in_single;
                    Env.extend state.env;
                    state.lex_state <- Expr_end )}

primary_value:
  _1 = primary
    {                    ( _1 )}

then_:
  _1 = term
    {                              ( () )}
| _1 = COLON
    {                              ( () )}
| _1 = K_THEN
    {                              ( () )}
| _1 = term _2 = K_THEN
    {                              ( () )}

do_:
  _1 = term
    {                            ( () )}
| _1 = COLON
    {                            ( () )}
| _1 = K_DO_COND
    {                            ( () )}

if_tail:
  _1 = opt_else
    {                    ( _1 )}
| _1 = K_ELSIF _2 = expr_value _3 = then_ _4 = compstmt _5 = if_tail
    {                    ( [expr_stmt (If (_2, _4, _5, annot _1))] )}

opt_else:
  _1 = none
    {                    ( [] )}
| _1 = K_ELSE _2 = compstmt
    {                    ( _2 )}

block_var:
  _1 = lhs
    {                    ( _1 )}
| _1 = mlhs
    {                    ( Lhs_dstr _1 )}

opt_block_var:
  _1 = none
    {                    ( [] )}
| _1 = PIPE _2 = PIPE
    {                    ( [] )}
| _1 = OROP
    {                    ( [] )}
| _1 = PIPE _2 = lhs _3 = PIPE
    {                    ( [_2] )}
| _1 = PIPE _2 = mlhs _3 = PIPE
    {                    ( _2 )}

do_block:
  _1 = K_DO_BLOCK _2 = do_block_e1 _3 = opt_block_var _4 = compstmt _5 = K_END_error
    {                    ( let blk = { blk_vars = _3; blk_body = _4 } in
                        Env.unextend state.env;
                        blk )}

do_block_e1:
  
    {                  ( Env.extend ~dyn:true state.env )}

block_call:
  _1 = command _2 = do_block
    {                    ( (* TODO check for block argument *)
                      match _1 with
                      | Call (recv, id, args, _, annot) ->
                          Call (recv, id, args, Some _2, annot)
                      | Super (args, _, annot) ->
                          Super (args, Some _2, annot)
                      | Yield _ ->
                          (* TODO warning *)
                          _1
                      | _ ->
                          failwith "invalid block_call" )}
| _1 = block_call _2 = DOT _3 = operation2 _4 = opt_paren_args
    {                    ( new_call _1 (fst _3) _4 ~annot:(annot (snd _3)) )}
| _1 = block_call _2 = COLON2 _3 = operation2 _4 = opt_paren_args
    {                    ( new_call _1 (fst _3) _4 ~annot:(annot (snd _3)) )}

method_call:
  _1 = operation _2 = paren_args
    {                    ( new_fcall (fst _1) _2 ~annot:(annot (snd _1)) )}
| _1 = primary_value _2 = DOT _3 = operation2 _4 = opt_paren_args
    {                    ( new_call _1 (fst _3) _4 ~annot:(annot (snd _3)) )}
| _1 = primary_value _2 = COLON2 _3 = operation2 _4 = paren_args
    {                    ( new_call _1 (fst _3) _4 ~annot:(annot (snd _3)) )}
| _1 = primary_value _2 = COLON2 _3 = operation3
    {                    ( new_call _1 (fst _3) [] ~annot:(annot (snd _3)) )}
| _1 = K_SUPER _2 = paren_args
    {                    ( Super (Some _2, None, annot _1) )}
| _1 = K_SUPER
    {                    ( Super (None, None, annot _1) )}

brace_block:
  _1 = LCURLY _2 = brace_block_e1 _3 = opt_block_var _4 = compstmt _5 = RCURLY_error
    {                    ( let blk = { blk_vars = _3; blk_body = _4 } in
                        Env.unextend state.env;
                        blk )}
| _1 = K_DO _2 = brace_block_e1 _3 = opt_block_var _4 = compstmt _5 = K_END_error
    {                    ( let blk = { blk_vars = _3; blk_body = _4 } in
                        Env.unextend state.env;
                        blk )}

brace_block_e1:
  
    {                  ( Env.extend ~dyn:true state.env )}

case_body:
  _1 = K_WHEN _2 = when_args _3 = then_ _4 = compstmt _5 = cases
    {                    ( (_2, _4) :: _5 )}

when_args:
  _1 = args
    {                    ( _1 )}
| _1 = args _2 = COMMA _3 = STAR _4 = arg_value
    {                    ( _1 @ [Arg_splat _4] )}
| _1 = STAR _2 = arg_value
    {                    ( [Arg_splat _2] )}

cases:
  _1 = case_body
    {                    ( _1 )}
| _1 = none
    {                    ( [] )}

opt_rescue:
  _1 = K_RESCUE _2 = exc_list _3 = exc_var _4 = then_ _5 = compstmt _6 = opt_rescue
    {                    ( let body =
                        match _3 with
                        | Some lhs ->
                            let asgn = Assign (lhs, (Variable (Var_global "!", dummy_annot)), Asgn_single, dummy_annot) in
                              (expr_stmt asgn) :: _5
                        | None ->
                            _5
                      in (_2, body) :: _6 )}
| _1 = none
    {                    ( [] )}

exc_list:
  _1 = arg_value
    {                    ( [Arg_value _1] )}
| _1 = mrhs
    {                    ( _1 )}
| _1 = none
    {                    ( [] )}

exc_var:
  _1 = ASSOC _2 = lhs
    {                    ( Some _2 )}
| _1 = none
    {                    ( None )}

opt_ensure:
  _1 = K_ENSURE _2 = compstmt
    {                    ( _2 )}
| _1 = none
    {                    ( [] )}

literal:
  _1 = numeric
    {                    ( let lit_val =
                        match fst _1 with
                        | `Int num ->
                            Lit_integer num
                        | `Float num ->
                            Lit_float num
                        | _ ->
                            failwith "never reach here"
                      in Literal (lit_val, annot (snd _1)) )}
| _1 = symbol
    {                          ( Literal (Lit_symbol [Str_contents (fst _1)], annot (snd _1)) )}
| _1 = dsym
    {                          ( _1 )}

strings:
  _1 = string
    {                    ( _1 )}

string:
  _1 = string1
    {                    ( _1 )}
| _1 = string _2 = string1
    {                    ( literal_concat _1 _2 )}

string1:
  _1 = STRING_BEG _2 = string_contents _3 = STRING_END
    {                    ( Literal (Lit_string _2, annot _1) )}

xstring:
  _1 = XSTRING_BEG _2 = xstring_contents _3 = STRING_END
    {                    ( Literal (Lit_xstring _2, annot _1) )}

regexp:
  _1 = REGEXP_BEG _2 = xstring_contents _3 = REGEXP_END
    {                    ( new_regexp _2 "TODO" ~annot:(annot _1) )}

words:
  _1 = WORDS_BEG _2 = SPACE _3 = STRING_END
    {                    ( Array ([], annot _1) )}
| _1 = WORDS_BEG _2 = word_list _3 = STRING_END
    {                    ( Array (_2, annot _1) )}

word_list:
  _1 = none
    {                    ( [] )}
| _1 = word_list _2 = word _3 = SPACE
    {                    ( _1 @ [Arg_value _2] )}

word:
  _1 = string_content
    {                    ( Literal (Lit_string [fst _1], annot (snd _1)) )}
| _1 = word _2 = string_content
    {                    ( literal_concat _1 (Literal (Lit_string [fst _2], annot (snd _2))) )}

awords:
  _1 = QWORDS_BEG _2 = SPACE _3 = STRING_END
    {                    ( Array ([], annot _1) )}
| _1 = QWORDS_BEG _2 = qword_list _3 = STRING_END
    {                    ( Array (_2, annot _1) )}

qword_list:
  _1 = none
    {                    ( [] )}
| _1 = qword_list _2 = STRING_CONTENT _3 = SPACE
    {                    ( _1 @ [Arg_value (Literal (Lit_string [Str_contents (fst _2)], annot (snd _2)))] )}

string_contents:
  _1 = none
    {                    ( [] )}
| _1 = string_contents _2 = string_content
    {                    ( _1 @ [(fst _2)] )}

xstring_contents:
  _1 = none
    {                    ( [] )}
| _1 = xstring_contents _2 = string_content
    {                    ( _1 @ [(fst _2)] )}

string_content:
  _1 = STRING_CONTENT
    {                    ( Str_contents (fst _1), snd _1 )}
| _1 = STRING_DVAR _2 = string_content_e1 _3 = string_dvar
    {                    ( state.lex_strterm <- _2;
                      Str_interpol _3, _1 )}
| _1 = STRING_DBEG _2 = string_content_e2 _3 = compstmt _4 = RCURLY
    {                    ( state.lex_strterm <- _2;
                      Stack_state.lexpop state.cond_stack;
                      Stack_state.lexpop state.cmdarg_stack;
                      Str_interpol (Seq (_3, dummy_annot)), _1 )}

string_content_e1:
  
    {                   ( let ret = state.lex_strterm in
                       state.lex_strterm <- None;
                       state.lex_state <- Expr_beg;
                       ret )}

string_content_e2:
  
    {                   ( let ret = state.lex_strterm in
                       state.lex_strterm <- None;
                       state.lex_state <- Expr_beg;
                       Stack_state.push state.cond_stack false;
                       Stack_state.push state.cmdarg_stack false;
                       ret )}

string_dvar:
  _1 = GVAR
    {                       ( Variable (Var_global (fst _1), annot (snd _1)) )}
| _1 = IVAR
    {                       ( Variable (Var_instance (fst _1), annot (snd _1)) )}
| _1 = CVAR
    {                       ( Variable (Var_class (fst _1), annot (snd _1)) )}

symbol:
  _1 = SYMBEG _2 = sym
    {                    ( state.lex_state <- Expr_end;
                      _2 )}

sym:
  _1 = fname
    {                        ( _1 )}
| _1 = IVAR
    {                        ( _1 )}
| _1 = GVAR
    {                        ( _1 )}
| _1 = CVAR
    {                        ( _1 )}

dsym:
  _1 = SYMBEG _2 = xstring_contents _3 = STRING_END
    {                    ( Literal (Lit_symbol _2, annot _1) )}

numeric:
  _1 = INTEGER
    {                    ( `Int (fst _1), snd _1 )}
| _1 = FLOAT
    {                    ( `Float (fst _1), snd _1 )}
| _1 = UMINUS_NUM _2 = INTEGER %prec LOWEST
    {                    ( `Int ~-(fst _2), _1 )}
| _1 = UMINUS_NUM _2 = FLOAT %prec LOWEST
    {                    ( `Float ~-.(fst _2), _1 )}

variable:
  _1 = IDENTIFIER
    {                             ( _1 )}
| _1 = IVAR
    {                             ( _1 )}
| _1 = GVAR
    {                             ( _1 )}
| _1 = CONSTANT
    {                             ( _1 )}
| _1 = CVAR
    {                             ( _1 )}
| _1 = K_NIL
    {                             ( "nil", _1 )}
| _1 = K_SELF
    {                             ( "self", _1 )}
| _1 = K_TRUE
    {                             ( "true", _1 )}
| _1 = K_FALSE
    {                             ( "false", _1 )}
| _1 = K__FILE__
    {                             ( "__FILE__", _1 )}
| _1 = K__LINE__
    {                             ( "__LINE__", _1 )}

var_ref:
  _1 = variable
    {                    ( gettable (fst _1) ~annot:(annot (snd _1)) )}

var_lhs:
  _1 = variable
    {                    ( assignable (fst _1) ~annot:(annot (snd _1)) )}

superclass:
  _1 = term
    {                    ( None )}
| _1 = LT _2 = superclass_e1 _3 = expr_value _4 = term
    {                    ( Some _3 )}
| _1 = error _2 = term
    {                    ( None )}

superclass_e1:
  
    {                    ( state.lex_state <- Expr_beg )}

f_arglist:
  _1 = LPAREN2 _2 = f_args _3 = opt_nl _4 = RPAREN
    {                    ( state.lex_state <- Expr_beg;
                      _2 )}
| _1 = f_args _2 = term
    {                    ( _1 )}

f_args:
  _1 = f_arg _2 = COMMA _3 = f_optarg _4 = COMMA _5 = f_rest_arg _6 = opt_f_block_arg
    {                    ( formal_params _1 _3 _5 _6 )}
| _1 = f_arg _2 = COMMA _3 = f_optarg _4 = opt_f_block_arg
    {                    ( formal_params _1 _3 [] _4 )}
| _1 = f_arg _2 = COMMA _3 = f_rest_arg _4 = opt_f_block_arg
    {                    ( formal_params _1 [] _3 _4 )}
| _1 = f_arg _2 = opt_f_block_arg
    {                    ( formal_params _1 [] [] _2 )}
| _1 = f_optarg _2 = COMMA _3 = f_rest_arg _4 = opt_f_block_arg
    {                    ( formal_params [] _1 _3 _4 )}
| _1 = f_optarg _2 = opt_f_block_arg
    {                    ( formal_params [] _1 [] _2 )}
| _1 = f_rest_arg _2 = opt_f_block_arg
    {                    ( formal_params [] [] _1 _2 )}
| _1 = f_block_arg
    {                    ( formal_params [] [] [] _1 )}
| 
    {                    ( formal_params [] [] [] [] )}

f_norm_arg:
  _1 = CONSTANT
    {                    ( yyerror ("formal argument cannot be a constant: " ^ fst _1) )}
| _1 = IVAR
    {                    ( yyerror "formal argument cannot be an instance variable" )}
| _1 = CVAR
    {                    ( yyerror "formal argument cannot be a class variable" )}
| _1 = IDENTIFIER
    {                    ( Env.add state.env (fst _1) `Lvar;
                      Param_req (fst _1) )}

f_arg:
  _1 = f_norm_arg
    {                    ( [_1] )}
| _1 = f_arg _2 = COMMA _3 = f_norm_arg
    {                    ( _1 @ [_3] )}

f_opt:
  _1 = IDENTIFIER _2 = EQL _3 = arg_value
    {                    ( ignore (assignable (fst _1));
                      Param_opt (fst _1, _3) )}

f_optarg:
  _1 = f_opt
    {                    ( [_1] )}
| _1 = f_optarg _2 = COMMA _3 = f_opt
    {                    ( _1 @ [_3] )}

restarg_mark:
  _1 = STAR2
    {                        ( _1 )}
| _1 = STAR
    {                        ( _1 )}

f_rest_arg:
  _1 = restarg_mark _2 = IDENTIFIER
    {                    ( ignore (assignable (fst _2));
                      [Param_rest (fst _2)] )}
| _1 = restarg_mark
    {                    ( Env.add state.env "*" `Lvar;
                      [Param_star] )}

blkarg_mark:
  _1 = AMPER2
    {                         ( _1 )}
| _1 = AMPER
    {                         ( _1 )}

f_block_arg:
  _1 = blkarg_mark _2 = IDENTIFIER
    {                    ( let id = fst _2 in
                        Env.add state.env id `Lvar;
                        [Param_block id] )}

opt_f_block_arg:
  _1 = COMMA _2 = f_block_arg
    {                    ( _2 )}
| 
    {                    ( [] )}

singleton:
  _1 = var_ref
    {                    ( _1 )}
| _1 = LPAREN2 _2 = singleton_e1 _3 = expr _4 = opt_nl _5 = RPAREN
    {                    (
(* TODO
                      yyerror "Can't define single method for literals." if
                        result[0] == :lit
*)
                        _3 )}

singleton_e1:
  
    {                  ( state.lex_state <- Expr_beg )}

assoc_list:
  _1 = none
    {                    ( [] )}
| _1 = assocs _2 = trailer
    {                    ( _1 )}
| _1 = args _2 = trailer
    {                    ( let rec work = function
                        | [] -> []
                        | Arg_value k :: Arg_value v :: xs ->
                          (k, v) :: work xs
                        | _ -> failwith "invalid assoc"
                      in work _1 )}

assocs:
  _1 = assoc
    {                    ( _1 )}
| _1 = assocs _2 = COMMA _3 = assoc
    {                    ( _1 @ _3 )}

assoc:
  _1 = arg_value _2 = ASSOC _3 = arg_value
    {                    ( [_1, _3] )}

operation:
  _1 = IDENTIFIER
    {                             ( _1 )}
| _1 = CONSTANT
    {                             ( _1 )}
| _1 = FID
    {                             ( _1 )}

operation2:
  _1 = IDENTIFIER
    {                             ( _1 )}
| _1 = CONSTANT
    {                             ( _1 )}
| _1 = FID
    {                             ( _1 )}
| _1 = op
    {                             ( _1 )}

operation3:
  _1 = IDENTIFIER
    {                             ( _1 )}
| _1 = FID
    {                             ( _1 )}
| _1 = op
    {                             ( _1 )}

dot_or_colon:
  _1 = DOT
    {                         ( _1 )}
| _1 = COLON2
    {                         ( _1 )}

opt_terms:
  
    {                  ( [] )}
| _1 = terms
    {                          ( _1 )}

opt_nl:
  
    {                  ( () )}
| _1 = COMMENT
    {                          ( () )}
| _1 = NL
    {                          ( () )}

trailer:
  
    {                  ( () )}
| _1 = COMMENT
    {                          ( () )}
| _1 = NL
    {                          ( () )}
| _1 = COMMA
    {                          ( () )}

term:
  _1 = SEMI
    {                          ( [] )}
| _1 = COMMENT
    {                          ( [Comment (fst _1, annot (snd _1))] )}
| _1 = NL
    {                          ( [] )}

terms:
  _1 = term
    {                             ( _1 )}
| _1 = term _2 = terms
    {                             ( _1 @ _2 )}

none:
  
    {                  ( () )}

none_block_pass:
  
    {                  ( () )}

RCURLY_error:
  _1 = RCURLY
    {                         ( () )}
| _1 = error
    {                                        ( () )}

K_END_error:
  _1 = K_END
    {                        ( () )}
| _1 = error
    {                                       ( () )}

%%
end

