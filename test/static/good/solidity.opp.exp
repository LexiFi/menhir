%{
(**************************************************************************)
(*                                                                        *)
(*  Copyright 2020 Origin-Labs, Dune Network and OCamlPro                 *)
(*                                                                        *)
(*  This program is free software: you can redistribute it and/or modify  *)
(*  it under the terms of the GNU General Public License as published by  *)
(*  the Free Software Foundation, either version 3 of the License, or     *)
(*  any later version.                                                    *)
(*                                                                        *)
(*  This program is distributed in the hope that it will be useful,       *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU General Public License for more details.                          *)
(*                                                                        *)
(*  You should have received a copy of the GNU General Public License     *)
(*  along with this program.  If not, see <https://www.gnu.org/licenses/>.*)
(**************************************************************************)

  open Solidity_types

  type ambiguous_type_name_or_expression =
    | AmbiguousIdentifier of string list
    | AmbiguousArray of ambiguous_type_name_or_expression * expression option

  let rec expression_of_identifiers = function
    | [] -> assert false
    | [x] -> IdentifierExpression x
    | x :: y -> FieldExpression (expression_of_identifiers y, x)

  let rec expression_of_ambiguity = function
    | AmbiguousIdentifier l -> expression_of_identifiers (List.rev l)
    | AmbiguousArray (a, expo) -> ArrayAccess (expression_of_ambiguity a, expo)

  let rec type_name_of_ambiguity = function
    | AmbiguousIdentifier l -> UserDefinedType l
    | AmbiguousArray (a, expo) -> Array (type_name_of_ambiguity a, expo)

  let import import_from import_symbols =
    { import_from; import_symbols }

  let rec put_in_none_list l n =
    if n <= 0 then l
    else put_in_none_list (None :: l) (n-1)

  let decimal_to_rational (i, d, e) =
    let i = match i with Some i -> i | None -> Z.zero in
    let d = match d with Some d -> d | None -> Z.zero in
    let e = match e with Some e -> e | None -> 0 in
    let nb_dec =
      if Z.equal Z.zero d then 0
      else String.length (Z.to_string d)
    in
    let i = Q.make i Z.one in
    let d = Q.make d (Z.pow (Z.of_int 10) nb_dec) in
    let e = Q.make (Z.pow (Z.of_int 10) e) Z.one in
    let n = Q.mul (Q.add i d) e in
    Q.num n, Q.den n

  let ctxt_modifier = ref false
%}
%start top_module
%token ABSTRACT
%token ADDRESS
%token <string> ADDRESSLITERAL
%token AMPER
%token AMPERAMPER
%token AMPEREQUAL
%token ANONYMOUS
%token AS
%token BANG
%token BANGEQUAL
%token BOOL
%token <bool> BOOLEANLITERAL
%token BREAK
%token <int option> BYTES
%token CALLDATA
%token CATCH
%token COLON
%token COMMA
%token CONSTANT
%token CONSTRUCTOR
%token CONTINUE
%token CONTRACT
%token DELETE
%token DIV
%token DIVEQUAL
%token DO
%token DOT
%token ELSE
%token EMIT
%token ENUM
%token EOF
%token EQUAL
%token EQUALEQUAL
%token EQUALGREATER
%token EVENT
%token EXTERNAL
%token FALLBACK
%token <(int * int) option> FIXED
%token FOR
%token FROM
%token FUNCTION
%token GREATER
%token GREATEREQUAL
%token GREATERGREATER
%token GREATERGREATEREQUAL
%token <string> HEXNUMBER
%token <string> HEXSTRINGLITERAL
%token <string> IDENTIFIER
%token IF
%token IMMUTABLE
%token IMPORT
%token INDEXED
%token <int option> INT
%token INTERFACE
%token INTERNAL
%token IS
%token LBRACE
%token LBRACKET
%token LESS
%token LESSEQUAL
%token LESSLESS
%token LESSLESSEQUAL
%token LIBRARY
%token LPAREN
%token MAPPING
%token MEMORY
%token MINUS
%token MINUSEQUAL
%token MINUSMINUS
%token MODIFIER
%token NEW
%token NOT
%token <Z.t option * Z.t option * int option> NUMBER
%token <Solidity_types.number_unit> NUMBERUNIT
%token OVERRIDE
%token PAYABLE
%token PERCENT
%token PERCENTEQUAL
%token PIPE
%token PIPEEQUAL
%token PIPEPIPE
%token PLUS
%token PLUSEQUAL
%token PLUSPLUS
%token <Solidity_types.Ident.t * string> PRAGMA
%token PRIVATE
%token PUBLIC
%token PURE
%token QUESTION
%token RBRACE
%token RBRACKET
%token RECEIVE
%token RETURN
%token RETURNS
%token RPAREN
%token SEMI
%token SHARP
%token STAR
%token STAREQUAL
%token STARSTAR
%token STORAGE
%token STRING
%token <string> STRINGLITERAL
%token STRUCT
%token THROW
%token TRY
%token <(int * int) option> UFIXED
%token <int option> UINT
%token USING
%token VAR
%token VIEW
%token VIRTUAL
%token WHILE
%token XOR
%token XOREQUAL
%nonassoc below_IDENTIFIER
%nonassoc IDENTIFIER
%nonassoc CONSTRUCTOR FALLBACK FROM RECEIVE
%nonassoc below_mutability
%nonassoc CONSTANT
%nonassoc below_visibility
%nonassoc INTERNAL PRIVATE PUBLIC
%nonassoc below_SEMI
%nonassoc SEMI
%nonassoc below_RETURNS
%nonassoc RETURNS
%nonassoc below_ELSE
%nonassoc ELSE
%left COMMA
%right AMPEREQUAL DIVEQUAL EQUAL GREATERGREATEREQUAL LESSLESSEQUAL MINUSEQUAL PERCENTEQUAL PIPEEQUAL PLUSEQUAL STAREQUAL XOREQUAL
%right COLON QUESTION
%left PIPEPIPE
%left AMPERAMPER
%left BANGEQUAL EQUALEQUAL
%left GREATER GREATEREQUAL LESS LESSEQUAL
%left PIPE
%left XOR
%left AMPER
%left GREATERGREATER LESSLESS
%left MINUS PLUS
%left DIV PERCENT STAR
%left STARSTAR
%right unary_op
%left MINUSMINUS PLUSPLUS
%nonassoc below_paren
%nonassoc LPAREN RPAREN
%nonassoc below_LBRACKET
%nonassoc LBRACKET
%nonassoc below_DOT
%left DOT
%type <Solidity_types.module_> top_module
%%

top_module:
  _1 = maybe_sharp _2 = source_units
    {                             ( _2 )}

maybe_sharp:
  
    {                           ( () )}
| _1 = SHARP _2 = IDENTIFIER _3 = COLON
    {                           ( () )}
| _1 = SHARP _2 = IDENTIFIER
    {                           ( () )}

source_units:
  _1 = EOF
    {                                       ( [] )}
| _1 = PRAGMA _2 = source_units
    {                                       ( Pragma (_1) :: _2 )}
| _1 = import_directive _2 = SEMI _3 = source_units
    {                                       ( Import (_1) :: _3 )}
| _1 = contract_definition _2 = source_units
    {                                       ( ContractDefinition (_1) :: _2 )}
| _1 = type_definition _2 = source_units
    {                                       ( GlobalTypeDefinition (_1) :: _2 )}

import_directive:
  _1 = IMPORT _2 = STRINGLITERAL _3 = maybe_as_identifier
    {      ( import _2 (ImportAll (false, _3)) )}
| _1 = IMPORT _2 = STAR _3 = maybe_as_identifier _4 = FROM _5 = STRINGLITERAL
    {      ( import _5 (ImportAll (true, _3)) )}
| _1 = IMPORT _2 = identifier _3 = maybe_as_identifier _4 = FROM _5 = STRINGLITERAL
    {      ( import _5 (ImportIdents [(_2, _3)]) )}
| _1 = IMPORT _2 = LBRACE _3 = import_declarations _4 = RBRACE _5 = FROM _6 = STRINGLITERAL
    {      ( import _6 (ImportIdents _3) )}

maybe_as_identifier:
  
    {                  ( None )}
| _1 = AS _2 = identifier
    {                  ( Some (_2) )}

import_declarations:
  _1 = identifier _2 = maybe_as_identifier
    {                                                             ( [(_1, _2)] )}
| _1 = identifier _2 = maybe_as_identifier _3 = COMMA _4 = import_declarations
    {                                                             ( (_1, _2) :: _4 )}

contract_definition:
  _1 = maybe_abstract _2 = contract_kind _3 = identifier _4 = maybe_is_inheritance_specifiers _5 = LBRACE _6 = contract_parts _7 = RBRACE
    {      ( { contract_abstract = _1;
          contract_kind = _2;
          contract_name = _3;
          contract_inheritance = _4;
          contract_parts = _6; } )}

maybe_abstract:
  
    {                  ( false )}
| _1 = ABSTRACT
    {                  ( true )}

contract_kind:
  _1 = CONTRACT
    {              ( KindContract )}
| _1 = LIBRARY
    {              ( KindLibrary )}
| _1 = INTERFACE
    {              ( KindInterface )}

maybe_is_inheritance_specifiers:
  
    {                              ( [] )}
| _1 = IS _2 = inheritance_specifiers
    {                              ( _2 )}

inheritance_specifiers:
  _1 = inheritance_specifier
    {                                                       ( [_1] )}
| _1 = inheritance_specifier _2 = COMMA _3 = inheritance_specifiers
    {                                                       ( _1 :: _3 )}

inheritance_specifier:
  _1 = long_ident
    {                                             ( (_1, []) )}
| _1 = long_ident _2 = LPAREN _3 = expression_list _4 = RPAREN
    {                                             ( (_1, _3) )}

contract_parts:
  
    {                                 ( [] )}
| _1 = contract_part _2 = contract_parts
    {                                 ( _1 :: _2 )}

contract_part:
  _1 = type_name_no_function _3 = identifier _5 = SEMI
    {let _4 =                      ( None ) in
let _2 =                                     ( [] ) in
      ( StateVariableDeclaration {
            var_name = _3;
            var_type = _1;
            var_modifiers = _2;
            var_init = _4; } )}
| _1 = type_name_no_function _3 = identifier _1_inlined1 = EQUAL _2 = expression _5 = SEMI
    {let _4 =                      ( Some (_2) ) in
let _2 =                                     ( [] ) in
      ( StateVariableDeclaration {
            var_name = _3;
            var_type = _1;
            var_modifiers = _2;
            var_init = _4; } )}
| _1 = type_name_no_function _1_inlined1 = variable_modifier_nonempty_list _3 = identifier _5 = SEMI
    {let _4 =                      ( None ) in
let _2 =
  let _1 = _1_inlined1 in
                                      ( _1 )
in
      ( StateVariableDeclaration {
            var_name = _3;
            var_type = _1;
            var_modifiers = _2;
            var_init = _4; } )}
| _1 = type_name_no_function _1_inlined1 = variable_modifier_nonempty_list _3 = identifier _1_inlined2 = EQUAL _2 = expression _5 = SEMI
    {let _4 =                      ( Some (_2) ) in
let _2 =
  let _1 = _1_inlined1 in
                                      ( _1 )
in
      ( StateVariableDeclaration {
            var_name = _3;
            var_type = _1;
            var_modifiers = _2;
            var_init = _4; } )}
| _1 = FUNCTION _2_inlined1 = parameter_list _3_inlined1 = function_type_modifier_list _3 = identifier _5 = SEMI
    {let _4 =                      ( None ) in
let _2 =                                     ( [] ) in
let _1 =
  let (_3, _2) = (_3_inlined1, _2_inlined1) in
  let _4 =                         ( None ) in
       ( let (fun_params, fun_modifiers, fun_return) = (_2, _3, _4) in
        FunctionType {
            fun_type_params = fun_params;
            fun_type_modifiers = fun_modifiers;
            fun_type_returns = fun_return; } )
in
      ( StateVariableDeclaration {
            var_name = _3;
            var_type = _1;
            var_modifiers = _2;
            var_init = _4; } )}
| _1 = FUNCTION _2_inlined1 = parameter_list _3_inlined1 = function_type_modifier_list _3 = identifier _1_inlined1 = EQUAL _2 = expression _5 = SEMI
    {let _4 =                      ( Some (_2) ) in
let _2 =                                     ( [] ) in
let _1 =
  let (_3, _2) = (_3_inlined1, _2_inlined1) in
  let _4 =                         ( None ) in
       ( let (fun_params, fun_modifiers, fun_return) = (_2, _3, _4) in
        FunctionType {
            fun_type_params = fun_params;
            fun_type_modifiers = fun_modifiers;
            fun_type_returns = fun_return; } )
in
      ( StateVariableDeclaration {
            var_name = _3;
            var_type = _1;
            var_modifiers = _2;
            var_init = _4; } )}
| _1 = FUNCTION _2_inlined1 = parameter_list _3_inlined1 = function_type_modifier_list _1_inlined1 = variable_modifier_nonempty_list _3 = identifier _5 = SEMI
    {let _4 =                      ( None ) in
let _2 =
  let _1 = _1_inlined1 in
                                      ( _1 )
in
let _1 =
  let (_3, _2) = (_3_inlined1, _2_inlined1) in
  let _4 =                         ( None ) in
       ( let (fun_params, fun_modifiers, fun_return) = (_2, _3, _4) in
        FunctionType {
            fun_type_params = fun_params;
            fun_type_modifiers = fun_modifiers;
            fun_type_returns = fun_return; } )
in
      ( StateVariableDeclaration {
            var_name = _3;
            var_type = _1;
            var_modifiers = _2;
            var_init = _4; } )}
| _1 = FUNCTION _2_inlined1 = parameter_list _3_inlined1 = function_type_modifier_list _1_inlined1 = variable_modifier_nonempty_list _3 = identifier _1_inlined2 = EQUAL _2 = expression _5 = SEMI
    {let _4 =                      ( Some (_2) ) in
let _2 =
  let _1 = _1_inlined1 in
                                      ( _1 )
in
let _1 =
  let (_3, _2) = (_3_inlined1, _2_inlined1) in
  let _4 =                         ( None ) in
       ( let (fun_params, fun_modifiers, fun_return) = (_2, _3, _4) in
        FunctionType {
            fun_type_params = fun_params;
            fun_type_modifiers = fun_modifiers;
            fun_type_returns = fun_return; } )
in
      ( StateVariableDeclaration {
            var_name = _3;
            var_type = _1;
            var_modifiers = _2;
            var_init = _4; } )}
| _1 = FUNCTION _2_inlined1 = parameter_list _3_inlined1 = function_type_modifier_list _1_inlined1 = RETURNS _2_inlined2 = return_list _3 = identifier _5 = SEMI
    {let _4 =                      ( None ) in
let _2 =                                     ( [] ) in
let _1 =
  let (_2_inlined1, _3, _2) = (_2_inlined2, _3_inlined1, _2_inlined1) in
  let _4 =
    let _2 = _2_inlined1 in
                            ( Some (_2) )
  in
       ( let (fun_params, fun_modifiers, fun_return) = (_2, _3, _4) in
        FunctionType {
            fun_type_params = fun_params;
            fun_type_modifiers = fun_modifiers;
            fun_type_returns = fun_return; } )
in
      ( StateVariableDeclaration {
            var_name = _3;
            var_type = _1;
            var_modifiers = _2;
            var_init = _4; } )}
| _1 = FUNCTION _2_inlined1 = parameter_list _3_inlined1 = function_type_modifier_list _1_inlined1 = RETURNS _2_inlined2 = return_list _3 = identifier _1_inlined2 = EQUAL _2 = expression _5 = SEMI
    {let _4 =                      ( Some (_2) ) in
let _2 =                                     ( [] ) in
let _1 =
  let (_2_inlined1, _3, _2) = (_2_inlined2, _3_inlined1, _2_inlined1) in
  let _4 =
    let _2 = _2_inlined1 in
                            ( Some (_2) )
  in
       ( let (fun_params, fun_modifiers, fun_return) = (_2, _3, _4) in
        FunctionType {
            fun_type_params = fun_params;
            fun_type_modifiers = fun_modifiers;
            fun_type_returns = fun_return; } )
in
      ( StateVariableDeclaration {
            var_name = _3;
            var_type = _1;
            var_modifiers = _2;
            var_init = _4; } )}
| _1 = FUNCTION _2_inlined1 = parameter_list _3_inlined1 = function_type_modifier_list _1_inlined1 = RETURNS _2_inlined2 = return_list _1_inlined2 = variable_modifier_nonempty_list _3 = identifier _5 = SEMI
    {let _4 =                      ( None ) in
let _2 =
  let _1 = _1_inlined2 in
                                      ( _1 )
in
let _1 =
  let (_2_inlined1, _3, _2) = (_2_inlined2, _3_inlined1, _2_inlined1) in
  let _4 =
    let _2 = _2_inlined1 in
                            ( Some (_2) )
  in
       ( let (fun_params, fun_modifiers, fun_return) = (_2, _3, _4) in
        FunctionType {
            fun_type_params = fun_params;
            fun_type_modifiers = fun_modifiers;
            fun_type_returns = fun_return; } )
in
      ( StateVariableDeclaration {
            var_name = _3;
            var_type = _1;
            var_modifiers = _2;
            var_init = _4; } )}
| _1 = FUNCTION _2_inlined1 = parameter_list _3_inlined1 = function_type_modifier_list _1_inlined1 = RETURNS _2_inlined2 = return_list _1_inlined2 = variable_modifier_nonempty_list _3 = identifier _1_inlined3 = EQUAL _2 = expression _5 = SEMI
    {let _4 =                      ( Some (_2) ) in
let _2 =
  let _1 = _1_inlined2 in
                                      ( _1 )
in
let _1 =
  let (_2_inlined1, _3, _2) = (_2_inlined2, _3_inlined1, _2_inlined1) in
  let _4 =
    let _2 = _2_inlined1 in
                            ( Some (_2) )
  in
       ( let (fun_params, fun_modifiers, fun_return) = (_2, _3, _4) in
        FunctionType {
            fun_type_params = fun_params;
            fun_type_modifiers = fun_modifiers;
            fun_type_returns = fun_return; } )
in
      ( StateVariableDeclaration {
            var_name = _3;
            var_type = _1;
            var_modifiers = _2;
            var_init = _4; } )}
| _1 = USING _2 = long_ident _3 = FOR _4 = type_name_or_star _5 = SEMI
    {      ( UsingForDeclaration (_2, None) )}
| _1 = type_definition
    {      ( TypeDefinition (_1) )}
| _1 = _MODIFIER _2 = identifier _3 = maybe_parameter_list _4 = modifier_modifier_list _5 = block
    {      ( ctxt_modifier := false;
        ModifierDefinition {
            mod_name = _2;
            mod_params = _3;
            mod_modifiers = _4;
            mod_body = _5; } )}
| _1 = FUNCTION _2 = parameter_list _1_inlined1 = function_type_modifier_list _5 = maybe_function_body
    {let _4 =                         ( None ) in
let _3 =
  let _1 = _1_inlined1 in
                                  ( _1 )
in
      ( FunctionDefinition {
            fun_name = "*fallback*";
            fun_params = _2;
            fun_modifiers = _3;
            fun_return = _4;
            fun_body = _5; } )}
| _1 = FUNCTION _2 = parameter_list _1_inlined1 = function_type_modifier_list _1_inlined2 = RETURNS _2_inlined1 = return_list _5 = maybe_function_body
    {let _4 =
  let _2 = _2_inlined1 in
                          ( Some (_2) )
in
let _3 =
  let _1 = _1_inlined1 in
                                  ( _1 )
in
      ( FunctionDefinition {
            fun_name = "*fallback*";
            fun_params = _2;
            fun_modifiers = _3;
            fun_return = _4;
            fun_body = _5; } )}
| _1 = FUNCTION _2 = parameter_list _1_inlined1 = function_type_modifier_list _2_inlined1 = modifier_invocation _3 = extra_anonymous_function_modifier_list _5 = maybe_function_body
    {let _4 =                         ( None ) in
let _3 =
  let (_2, _1) = (_2_inlined1, _1_inlined1) in
        ( _1 @ (_2 :: _3) )
in
      ( FunctionDefinition {
            fun_name = "*fallback*";
            fun_params = _2;
            fun_modifiers = _3;
            fun_return = _4;
            fun_body = _5; } )}
| _1 = FUNCTION _2 = parameter_list _1_inlined1 = function_type_modifier_list _2_inlined1 = modifier_invocation _3 = extra_anonymous_function_modifier_list _1_inlined2 = RETURNS _2_inlined2 = return_list _5 = maybe_function_body
    {let _4 =
  let _2 = _2_inlined2 in
                          ( Some (_2) )
in
let _3 =
  let (_2, _1) = (_2_inlined1, _1_inlined1) in
        ( _1 @ (_2 :: _3) )
in
      ( FunctionDefinition {
            fun_name = "*fallback*";
            fun_params = _2;
            fun_modifiers = _3;
            fun_return = _4;
            fun_body = _5; } )}
| _1 = function_descriptor _2 = parameter_list _3 = function_modifier_list _5 = maybe_function_body
    {let _4 =                         ( None ) in
      ( FunctionDefinition {
            fun_name = _1;
            fun_params = _2;
            fun_modifiers = _3;
            fun_return = _4;
            fun_body = _5; } )}
| _1 = function_descriptor _2 = parameter_list _3 = function_modifier_list _1_inlined1 = RETURNS _2_inlined1 = return_list _5 = maybe_function_body
    {let _4 =
  let _2 = _2_inlined1 in
                          ( Some (_2) )
in
      ( FunctionDefinition {
            fun_name = _1;
            fun_params = _2;
            fun_modifiers = _3;
            fun_return = _4;
            fun_body = _5; } )}
| _1 = EVENT _2 = identifier _3 = event_parameter_list _4 = maybe_anonymous _5 = SEMI
    {      ( EventDefinition {
            event_name = _2;
            event_params = _3;
            event_anon = _4; } )}

_MODIFIER:
  _1 = MODIFIER
    {             ( ctxt_modifier := true )}

type_name_or_star:
  _1 = non_ambiguous_type_name
    {let _1 =                                       ( _1 ) in
              ( Some (_1) )}
| _1 = ambiguous_type_name_or_expression
    {let _1 =                                       ( type_name_of_ambiguity _1 ) in
              ( Some (_1) )}
| _1 = STAR
    {              ( None )}

type_definition:
  _1 = STRUCT _2 = identifier _3 = LBRACE _4 = variable_declaration_semi_list _5 = RBRACE
    {      ( StructDefinition (_2, _4) )}
| _1 = ENUM _2 = identifier _3 = LBRACE _4 = enum_value_list _5 = RBRACE
    {      ( EnumDefinition (_2, _4) )}

variable_declaration_semi_list:
  
    {                                                             ( [] )}
| _1 = variable_declaration _2 = SEMI _3 = variable_declaration_semi_list
    {                                                             ( _1 :: _3 )}

override_specifier:
  _1 = OVERRIDE
    {                                           ( ModifierOverride ([]) )}
| _1 = OVERRIDE _2 = LPAREN _3 = long_ident_list _4 = RPAREN
    {                                           ( ModifierOverride (_3) )}

long_ident_list:
  
    {                             ( [] )}
| _1 = long_ident_nonempty_list
    {                             ( _1 )}

long_ident_nonempty_list:
  _1 = long_ident
    {                                              ( [_1] )}
| _1 = long_ident _2 = COMMA _3 = long_ident_nonempty_list
    {                                              ( _1 :: _3 )}

function_descriptor:
  _1 = FUNCTION _2 = identifier
    {                        ( _2 )}
| _1 = CONSTRUCTOR
    {                        ( "*constructor*" )}
| _1 = RECEIVE
    {                        ( "*receive*" )}
| _1 = FALLBACK
    {                        ( "*fallback*" )}

return_list:
  _1 = LPAREN _2 = RPAREN
    {                                       ( [] )}
| _1 = LPAREN _2 = return_nonempty_list _3 = RPAREN
    {                                       ( _2 )}

return_nonempty_list:
  _1 = non_ambiguous_type_name _2 = maybe_storage
    {let _1 =                                       ( _1 ) in
                                                       ( [(_1, _2)] )}
| _1 = ambiguous_type_name_or_expression _2 = maybe_storage
    {let _1 =                                       ( type_name_of_ambiguity _1 ) in
                                                       ( [(_1, _2)] )}
| _1 = non_ambiguous_type_name _2 = maybe_storage _3 = COMMA _4 = return_nonempty_list
    {let _1 =                                       ( _1 ) in
                                                       ( (_1, _2) :: _4 )}
| _1 = ambiguous_type_name_or_expression _2 = maybe_storage _3 = COMMA _4 = return_nonempty_list
    {let _1 =                                       ( type_name_of_ambiguity _1 ) in
                                                       ( (_1, _2) :: _4 )}

maybe_function_body:
  _1 = SEMI
    {          ( None )}
| _1 = block
    {          ( Some (_1) )}

function_modifier_list:
  
    {                                             ( [] )}
| _1 = function_modifier _2 = function_modifier_list
    {                                             ( _1 :: _2 )}

function_modifier:
  _1 = modifier_invocation
    {                        ( _1 )}
| _1 = state_mutability
    {                        ( _1 )}
| _1 = internal_external
    {                        ( _1 )}
| _1 = public_private
    {                        ( _1 )}
| _1 = VIRTUAL
    {                        ( ModifierVirtual )}
| _1 = override_specifier
    {                        ( _1 )}

modifier_modifier_list:
  
    {                                             ( [] )}
| _1 = modifier_modifier _2 = modifier_modifier_list
    {                                             ( _1 :: _2 )}

modifier_modifier:
  _1 = VIRTUAL
    {                        ( ModifierVirtual )}
| _1 = override_specifier
    {                        ( _1 )}

extra_anonymous_function_modifier_list:
  
    {                  ( [] )}
| _1 = extra_anonymous_function_modifier _2 = extra_anonymous_function_modifier_list
    {      ( _1 :: _2 )}

extra_anonymous_function_modifier:
  _1 = extra_function_type_modifier
    {                                 ( _1 )}
| _1 = modifier_invocation
    {                                 ( _1 )}

variable_modifier_nonempty_list:
  _1 = variable_modifier
    {                                                      ( [_1] )}
| _1 = variable_modifier _2 = variable_modifier_nonempty_list
    {                                                      ( _1 :: _2 )}

variable_modifier:
  _1 = public_private
    {                       ( _1 )}
| _1 = INTERNAL
    {                       ( ModifierInternal )}
| _1 = CONSTANT
    {                       ( ModifierConstant )}
| _1 = IMMUTABLE
    {                       ( ModifierImmutable )}
| _1 = override_specifier
    {                       ( _1 )}

modifier_invocation:
  _1 = identifier %prec below_SEMI
    {                                ( ModifierInvocation (_1, None) )}
| _1 = identifier _2 = LPAREN _3 = expression_list _4 = RPAREN
    {      ( ModifierInvocation (_1, Some (_3)) )}

enum_value_list:
  
    {                             ( [] )}
| _1 = enum_value_nonempty_list
    {                             ( _1 )}

enum_value_nonempty_list:
  _1 = enum_value
    {                                              ( [_1] )}
| _1 = enum_value _2 = COMMA _3 = enum_value_nonempty_list
    {                                              ( _1 :: _3 )}

enum_value:
  _1 = identifier
    {               ( _1 )}

maybe_parameter_list:
  
    {                   ( None )}
| _1 = parameter_list
    {                   ( Some (_1) )}

parameter_list:
  _1 = LPAREN _2 = RPAREN
    {                                          ( [] )}
| _1 = LPAREN _2 = parameter_nonempty_list _3 = RPAREN
    {                                          ( _2 )}

parameter_nonempty_list:
  _1 = non_ambiguous_type_name _2 = maybe_storage _3 = maybe_identifier
    {let _1 =                                       ( _1 ) in
                                             ( [_1, _2, _3] )}
| _1 = ambiguous_type_name_or_expression _2 = maybe_storage _3 = maybe_identifier
    {let _1 =                                       ( type_name_of_ambiguity _1 ) in
                                             ( [_1, _2, _3] )}
| _1 = non_ambiguous_type_name _2 = maybe_storage _3 = maybe_identifier _4 = COMMA _5 = parameter_nonempty_list
    {let _1 =                                       ( _1 ) in
      ( (_1, _2, _3) :: _5 )}
| _1 = ambiguous_type_name_or_expression _2 = maybe_storage _3 = maybe_identifier _4 = COMMA _5 = parameter_nonempty_list
    {let _1 =                                       ( type_name_of_ambiguity _1 ) in
      ( (_1, _2, _3) :: _5 )}

maybe_storage:
  
    {                     ( None )}
| _1 = storage_location
    {                     ( Some (_1) )}

event_parameter_list:
  _1 = LPAREN _2 = RPAREN
    {                                                ( [] )}
| _1 = LPAREN _2 = event_parameter_nonempty_list _3 = RPAREN
    {                                                ( _2 )}

event_parameter_nonempty_list:
  _1 = non_ambiguous_type_name _2 = maybe_indexed _3 = maybe_identifier
    {let _1 =                                       ( _1 ) in
                                             ( [(_1, _2, _3)] )}
| _1 = ambiguous_type_name_or_expression _2 = maybe_indexed _3 = maybe_identifier
    {let _1 =                                       ( type_name_of_ambiguity _1 ) in
                                             ( [(_1, _2, _3)] )}
| _1 = non_ambiguous_type_name _2 = maybe_indexed _3 = maybe_identifier _4 = COMMA _5 = event_parameter_nonempty_list
    {let _1 =                                       ( _1 ) in
      ( (_1, _2, _3) :: _5 )}
| _1 = ambiguous_type_name_or_expression _2 = maybe_indexed _3 = maybe_identifier _4 = COMMA _5 = event_parameter_nonempty_list
    {let _1 =                                       ( type_name_of_ambiguity _1 ) in
      ( (_1, _2, _3) :: _5 )}

maybe_indexed:
  
    {                  ( NotIndexed )}
| _1 = INDEXED
    {                  ( Indexed )}

maybe_anonymous:
  
    {                  ( NotAnonymous )}
| _1 = ANONYMOUS
    {                  ( Anonymous )}

variable_declaration:
  _1 = non_ambiguous_type_name _2 = maybe_storage_location _3 = identifier
    {let _1 =                                       ( _1 ) in
                                                ( (_1, _2, _3) )}
| _1 = ambiguous_type_name_or_expression _2 = maybe_storage_location _3 = identifier
    {let _1 =                                       ( type_name_of_ambiguity _1 ) in
                                                ( (_1, _2, _3) )}

maybe_storage_location:
  
    {                     ( None )}
| _1 = storage_location
    {                     ( Some (_1) )}

type_name_no_function:
  _1 = non_ambiguous_type_name_no_function
    {                                        ( _1 )}
| _1 = ambiguous_type_name_or_expression
    {                                        ( type_name_of_ambiguity _1 )}

non_ambiguous_type_name:
  _1 = non_ambiguous_type_name_no_function
    {                                           ( _1 )}
| _1 = FUNCTION _2 = parameter_list _3 = function_type_modifier_list %prec below_RETURNS
    {let _1 =
  let _4 =                         ( None ) in
       ( let (fun_params, fun_modifiers, fun_return) = (_2, _3, _4) in
        FunctionType {
            fun_type_params = fun_params;
            fun_type_modifiers = fun_modifiers;
            fun_type_returns = fun_return; } )
in
                                           ( _1 )}
| _1 = FUNCTION _2 = parameter_list _3 = function_type_modifier_list _1_inlined1 = RETURNS _2_inlined1 = return_list %prec below_RETURNS
    {let _1 =
  let _4 =
    let _2 = _2_inlined1 in
                            ( Some (_2) )
  in
       ( let (fun_params, fun_modifiers, fun_return) = (_2, _3, _4) in
        FunctionType {
            fun_type_params = fun_params;
            fun_type_modifiers = fun_modifiers;
            fun_type_returns = fun_return; } )
in
                                           ( _1 )}

non_ambiguous_type_name_no_function:
  _1 = elementary_type_name
    {      ( ElementaryType (_1) )}
| _1 = MAPPING _2 = LPAREN _3 = elementary_type_name _4 = EQUALGREATER _1_inlined1 = non_ambiguous_type_name _6 = RPAREN
    {let _5 =
  let _1 = _1_inlined1 in
                                        ( _1 )
in
      ( Mapping (_3, _5) )}
| _1 = MAPPING _2 = LPAREN _3 = elementary_type_name _4 = EQUALGREATER _1_inlined1 = ambiguous_type_name_or_expression _6 = RPAREN
    {let _5 =
  let _1 = _1_inlined1 in
                                        ( type_name_of_ambiguity _1 )
in
      ( Mapping (_3, _5) )}
| _1 = non_ambiguous_type_name _2 = LBRACKET _3 = maybe_expression _4 = RBRACKET
    {      ( Array (_1, _3) )}

ambiguous_type_name_or_expression:
  _1 = long_ident
    {      ( AmbiguousIdentifier (_1) )}
| _1 = ambiguous_type_name_or_expression _2 = LBRACKET _3 = maybe_expression _4 = RBRACKET
    {      ( AmbiguousArray (_1, _3) )}

long_ident:
  _1 = identifier %prec below_DOT
    {                               ( [_1] )}
| _1 = identifier _2 = DOT _3 = long_ident
    {                               ( _1 :: _3 )}

function_type_modifier_list:
  _1 = state_mutability_list %prec below_visibility
    {                                                 ( _1 )}
| _1 = state_mutability_list _2 = internal_external _3 = state_mutability_list
    {      ( _1 @ (_2 :: _3) )}
| _1 = state_mutability_list _2 = public_private _3 = extra_function_type_modifier_list
    {      ( _1 @ (_2 :: _3) )}

state_mutability_list:
   %prec below_mutability
    {                                           ( [] )}
| _1 = state_mutability _2 = state_mutability_list
    {                                           ( _1 :: _2 )}

extra_function_type_modifier_list:
   %prec below_visibility
    {                                                                   ( [] )}
| _1 = extra_function_type_modifier _2 = extra_function_type_modifier_list
    {                                                                   ( _1 :: _2 )}

extra_function_type_modifier:
  _1 = internal_external
    {                      ( _1 )}
| _1 = public_private
    {                      ( _1 )}
| _1 = state_mutability
    {                      ( _1 )}

internal_external:
  _1 = EXTERNAL
    {             ( ModifierExternal )}
| _1 = INTERNAL
    {             ( ModifierInternal )}

public_private:
  _1 = PUBLIC
    {             ( ModifierPublic )}
| _1 = PRIVATE
    {             ( ModifierPrivate )}

storage_location:
  _1 = MEMORY
    {             ( Memory )}
| _1 = STORAGE
    {             ( Storage )}
| _1 = CALLDATA
    {             ( Calldata )}

state_mutability:
  _1 = PURE
    {              ( ModifierPure )}
| _1 = CONSTANT
    {              ( ModifierConstant )}
| _1 = VIEW
    {              ( ModifierView )}
| _1 = PAYABLE
    {              ( ModifierPayable )}

block:
  _1 = LBRACE _2 = statement_list _3 = RBRACE
    {                                 ( _2 )}

statement_list:
  
    {                             ( [] )}
| _1 = statement _2 = statement_list
    {                             ( _1 :: _2 )}

statement:
  _1 = statement_no_semi
    {                               ( _1 )}
| _1 = statement_before_semi _2 = SEMI
    {                               ( _1 )}

statement_no_semi:
  _1 = if_statement
    {                    ( _1 )}
| _1 = for_statement
    {                    ( _1 )}
| _1 = while_statement
    {                    ( _1 )}
| _1 = try_statement
    {                    ( _1 )}
| _1 = block
    {                    ( Block (_1) )}

statement_before_semi:
  _1 = simple_statement
    {                            ( _1 )}
| _1 = do_while_statement
    {                            ( _1 )}
| _1 = RETURN _2 = maybe_expression
    {                            ( Return (_2) )}
| _1 = CONTINUE
    {                            ( Continue )}
| _1 = BREAK
    {                            ( Break )}
| _1 = THROW
    {                            ( Throw )}
| _1 = EMIT _2 = function_call
    {                            ( let (f, a) = _2 in Emit (f, a) )}

if_statement:
  _1 = IF _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement %prec below_ELSE
    {      ( IfStatement (_3, _5, None) )}
| _1 = IF _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement _6 = ELSE _7 = statement
    {      ( IfStatement (_3, _5, Some (_7)) )}

for_statement:
  _1 = FOR _2 = LPAREN _3 = maybe_simple_statement _4 = SEMI _5 = maybe_expression _6 = SEMI _7 = maybe_expression _8 = RPAREN _9 = statement
    {      ( ForStatement (_3, _5, _7, _9) )}

while_statement:
  _1 = WHILE _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement
    {                                             ( WhileStatement (_3, _5) )}

try_statement:
  _1 = TRY _2 = expression _4 = block _5 = catch_clause_nonempty_list
    {let _3 =                         ( None ) in
      ( TryStatement (_2, _3, _4, _5) )}
| _1 = TRY _2 = expression _1_inlined1 = RETURNS _2_inlined1 = return_list _4 = block _5 = catch_clause_nonempty_list
    {let _3 =
  let _2 = _2_inlined1 in
                          ( Some (_2) )
in
      ( TryStatement (_2, _3, _4, _5) )}

catch_clause_nonempty_list:
  _1 = catch_clause
    {                                            ( [_1] )}
| _1 = catch_clause _2 = catch_clause_nonempty_list
    {                                            ( _1 :: _2 )}

catch_clause:
  _1 = CATCH _2 = block
    {                                                ( (None, [], _2) )}
| _1 = CATCH _2 = maybe_identifier _3 = parameter_list _4 = block
    {                                                ( (_2, _3, _4) )}

maybe_simple_statement:
  
    {                     ( None )}
| _1 = simple_statement
    {                     ( Some (_1) )}

simple_statement:
  _1 = variable_declaration_statement
    {                                   ( VariableDefinition (_1) )}
| _1 = expression
    {               (
      (* When under a modifier, a single underscore at the
         level of statements is no longer an identifier *)
      match !ctxt_modifier, _1 with
      | true, IdentifierExpression "_" -> PlaceholderStatement
      | _, s -> ExpressionStatement (s) )}

do_while_statement:
  _1 = DO _2 = statement _3 = WHILE _4 = LPAREN _5 = expression _6 = RPAREN
    {                                                ( DoWhileStatement (_2, _5) )}

variable_declaration_statement:
  _1 = VAR _2 = maybe_identifier_list
    {let _3 =                      ( None ) in
      ( VarInfer (_2, _3) )}
| _1 = VAR _2 = maybe_identifier_list _1_inlined1 = EQUAL _2_inlined1 = expression
    {let _3 =
  let _2 = _2_inlined1 in
                       ( Some (_2) )
in
      ( VarInfer (_2, _3) )}
| _1 = maybe_variable_declaration_list
    {let _2 =                      ( None ) in
      ( VarType (_1, _2) )}
| _1 = maybe_variable_declaration_list _1_inlined1 = EQUAL _2 = expression
    {let _2 =                      ( Some (_2) ) in
      ( VarType (_1, _2) )}

maybe_identifier_list:
  _1 = identifier
    {                                                 ( [Some (_1)] )}
| _1 = LPAREN _2 = RPAREN
    {                                                 ( [] )}
| _1 = LPAREN _2 = identifier _3 = RPAREN
    {                                                 ( [Some (_2)] )}
| _1 = LPAREN _2 = maybe_identifier_nonempty_list _3 = RPAREN
    {                                                 ( _2 )}

maybe_identifier_nonempty_list:
  _1 = maybe_identifier _2 = COMMA _3 = maybe_identifier
    {                                                          ( [_1; _3] )}
| _1 = maybe_identifier _2 = COMMA _3 = maybe_identifier_nonempty_list
    {                                                          ( _1 :: _3 )}

maybe_variable_declaration_list:
  _1 = variable_declaration
    {                                                            ( [Some (_1)] )}
| _1 = LPAREN _2 = maybe_variable_declaration_nonempty_list _3 = RPAREN
    {                                                            ( _2 )}

maybe_variable_declaration_nonempty_list:
  _1 = variable_declaration
    {                                             ( [Some (_1)] )}
| _1 = comma_nonempty_list _2 = variable_declaration
    {                                             ( put_in_none_list [Some (_2)] _1 )}
| _1 = maybe_variable_declaration_nonempty_list _2 = COMMA _3 = maybe_variable_declaration
    {      ( _1 @ [_3] )}

comma_nonempty_list:
  _1 = COMMA
    {                              ( 1 )}
| _1 = COMMA _2 = comma_nonempty_list
    {                              ( 1 + _2 )}

maybe_variable_declaration:
  
    {                         ( None )}
| _1 = variable_declaration
    {                         ( Some (_1) )}

elementary_type_name:
  _1 = BOOL
    {                               ( TypeBool )}
| _1 = INT
    {                               ( TypeInt (_1) )}
| _1 = UINT
    {                               ( TypeUint (_1) )}
| _1 = FIXED
    {                               ( TypeFixed (_1) )}
| _1 = UFIXED
    {                               ( TypeUfixed (_1) )}
| _1 = ADDRESS
    {                               ( TypeAddress (false) )}
| _1 = ADDRESS _2 = PAYABLE
    {                               ( TypeAddress (true) )}
| _1 = STRING
    {                               ( TypeString )}
| _1 = BYTES
    {                               ( TypeBytes (_1) )}
| _1 = VAR %prec below_IDENTIFIER
    {                               ( TypeVar )}

expression:
  _1 = non_ambiguous_expression %prec below_LBRACKET
    {                                                  ( _1 )}
| _1 = ambiguous_type_name_or_expression %prec below_LBRACKET
    {      ( expression_of_ambiguity _1 )}

maybe_expression:
  
    {                  ( None )}
| _1 = expression
    {                  ( Some (_1) )}

expression_list:
  
    {                             ( [] )}
| _1 = expression_nonempty_list
    {                             ( _1 )}

expression_nonempty_list:
  _1 = expression
    {                                              ( [_1] )}
| _1 = expression _2 = COMMA _3 = expression_nonempty_list
    {                                              ( _1 :: _3 )}

non_ambiguous_expression:
  _1 = NEW _1_inlined1 = non_ambiguous_type_name %prec below_LBRACKET
    {let _2 =
  let _1 = _1_inlined1 in
                                        ( _1 )
in
      ( NewExpression (_2) )}
| _1 = NEW _1_inlined1 = ambiguous_type_name_or_expression %prec below_LBRACKET
    {let _2 =
  let _1 = _1_inlined1 in
                                        ( type_name_of_ambiguity _1 )
in
      ( NewExpression (_2) )}
| _1 = non_ambiguous_expression _2 = LBRACKET _3 = maybe_expression _4 = RBRACKET
    {      ( ArrayAccess (_1, _3) )}
| _1 = expression _2 = LBRACKET _3 = maybe_expression _4 = COLON _5 = maybe_expression _6 = RBRACKET
    {      ( ArraySlice (_1, _3, _5) )}
| _1 = LBRACKET _2 = expression_nonempty_list _3 = RBRACKET
    {      ( ImmediateArray (_2) )}
| _1 = expression _2 = DOT _3 = identifier
    {      ( FieldExpression (_1, _3) )}
| _1 = function_call
    {      ( let (f, a) = _1 in FunctionCallExpression (f, a) )}
| _1 = LPAREN _2 = expression _3 = RPAREN
    {      ( _2 )}
| _1 = tuple_expression
    {      ( _1 )}
| _1 = literal_expression
    {      ( _1 )}
| _1 = non_ambiguous_type_name _2 = LPAREN _3 = expression _4 = RPAREN
    {      ( FunctionCallExpression (TypeExpression (_1), ExpressionList ([_3])) )}
| _1 = LPAREN _2 = non_ambiguous_type_name _3 = RPAREN _4 = LPAREN _5 = expression _6 = RPAREN
    {      ( FunctionCallExpression (TypeExpression (_2), ExpressionList ([_5])) )}
| _1 = PAYABLE _2 = LPAREN _3 = expression _4 = RPAREN
    {      ( FunctionCallExpression
          (TypeExpression (ElementaryType (TypeAddress (true))),
           ExpressionList ([_3])) )}
| _1 = inc_dec_op _2 = expression %prec unary_op
    {      ( PrefixExpression (_1, _2) )}
| _1 = expression _2 = inc_dec_op
    {      ( SuffixExpression (_1, _2) )}
| _1 = unop _2 = expression %prec unary_op
    {      ( PrefixExpression (_1, _2) )}
| _1 = expression _1_inlined1 = PLUS _3 = expression
    {let _2 =                         ( "+" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = MINUS _3 = expression
    {let _2 =                         ( "-" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = DIV _3 = expression
    {let _2 =                         ( "/" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = PERCENT _3 = expression
    {let _2 =                         ( "%" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = STAR _3 = expression
    {let _2 =                         ( "*" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = STARSTAR _3 = expression
    {let _2 =                         ( "**" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = LESSLESS _3 = expression
    {let _2 =                         ( "<<" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = GREATERGREATER _3 = expression
    {let _2 =                         ( ">>" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = AMPER _3 = expression
    {let _2 =                         ( "&" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = XOR _3 = expression
    {let _2 =                         ( "^" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = PIPE _3 = expression
    {let _2 =                         ( "|" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = LESS _3 = expression
    {let _2 =                         ( "<" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = GREATER _3 = expression
    {let _2 =                         ( ">" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = LESSEQUAL _3 = expression
    {let _2 =                         ( "<=" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = GREATEREQUAL _3 = expression
    {let _2 =                         ( ">=" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = EQUALEQUAL _3 = expression
    {let _2 =                         ( "==" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = BANGEQUAL _3 = expression
    {let _2 =                         ( "!=" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = AMPERAMPER _3 = expression
    {let _2 =                         ( "&&" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = PIPEPIPE _3 = expression
    {let _2 =                         ( "||" ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = EQUAL _3 = expression
    {let _2 =                         ( "=" ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1 with
          | TupleExpression [Some (_1)] -> TupleExpression [Some (_1); None]
          | e -> e
        in
        AssignExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = PIPEEQUAL _3 = expression
    {let _2 =                         ( "|=" ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1 with
          | TupleExpression [Some (_1)] -> TupleExpression [Some (_1); None]
          | e -> e
        in
        AssignExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = XOREQUAL _3 = expression
    {let _2 =                         ( "^=" ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1 with
          | TupleExpression [Some (_1)] -> TupleExpression [Some (_1); None]
          | e -> e
        in
        AssignExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = AMPEREQUAL _3 = expression
    {let _2 =                         ( "&=" ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1 with
          | TupleExpression [Some (_1)] -> TupleExpression [Some (_1); None]
          | e -> e
        in
        AssignExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = LESSLESSEQUAL _3 = expression
    {let _2 =                         ( "<<=" ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1 with
          | TupleExpression [Some (_1)] -> TupleExpression [Some (_1); None]
          | e -> e
        in
        AssignExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = GREATERGREATEREQUAL _3 = expression
    {let _2 =                         ( ">>=" ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1 with
          | TupleExpression [Some (_1)] -> TupleExpression [Some (_1); None]
          | e -> e
        in
        AssignExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = PLUSEQUAL _3 = expression
    {let _2 =                         ( "+=" ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1 with
          | TupleExpression [Some (_1)] -> TupleExpression [Some (_1); None]
          | e -> e
        in
        AssignExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = MINUSEQUAL _3 = expression
    {let _2 =                         ( "-=" ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1 with
          | TupleExpression [Some (_1)] -> TupleExpression [Some (_1); None]
          | e -> e
        in
        AssignExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = STAREQUAL _3 = expression
    {let _2 =                         ( "*=" ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1 with
          | TupleExpression [Some (_1)] -> TupleExpression [Some (_1); None]
          | e -> e
        in
        AssignExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = DIVEQUAL _3 = expression
    {let _2 =                         ( "/=" ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1 with
          | TupleExpression [Some (_1)] -> TupleExpression [Some (_1); None]
          | e -> e
        in
        AssignExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = PERCENTEQUAL _3 = expression
    {let _2 =                         ( "%=" ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1 with
          | TupleExpression [Some (_1)] -> TupleExpression [Some (_1); None]
          | e -> e
        in
        AssignExpression (lexp, _2, _3) )}
| _1 = expression _2 = QUESTION _3 = expression _4 = COLON _5 = expression
    {      ( IfExpression (_1, _3, _5) )}

inc_dec_op:
  _1 = PLUSPLUS
    {               ( "++" )}
| _1 = MINUSMINUS
    {               ( "--" )}

unop:
  _1 = BANG
    {           ( "!" )}
| _1 = NOT
    {           ( "~" )}
| _1 = PLUS
    {           ( "+" )}
| _1 = MINUS
    {           ( "-" )}
| _1 = DELETE
    {           ( "delete" )}

literal_expression:
  _1 = BOOLEANLITERAL
    {                      ( BooleanLiteral (_1) )}
| _1 = STRINGLITERAL
    {                      ( StringLiteral (_1) )}
| _1 = HEXSTRINGLITERAL
    {                      ( HexLiteral (_1) )}
| _1 = ADDRESSLITERAL
    {                      ( AddressLiteral (_1) )}
| _1 = NUMBER _2 = maybe_unit
    {                      ( NumberLiteral (decimal_to_rational _1, _2, None) )}
| _1 = HEXNUMBER
    {                      ( NumberLiteral ((Z.of_string _1, Z.one),
                                       None, Some (String.length _1)) )}

function_call:
  _1 = expression _2 = LPAREN _3 = function_call_arguments _4 = RPAREN
    {                                                     ( (_1, _3) )}

function_call_arguments:
  _1 = expression_list
    {                                           ( ExpressionList (_1) )}
| _1 = LBRACE _2 = name_value_nonempty_list _3 = RBRACE
    {                                           ( NameValueList (_2) )}

name_value_nonempty_list:
  _1 = identifier _2 = COLON _3 = expression
    {                                      ( [(_1, _3)] )}
| _1 = identifier _2 = COLON _3 = expression _4 = COMMA
    {                                      ( [(_1, _3)] )}
| _1 = identifier _2 = COLON _3 = expression _4 = COMMA _5 = name_value_nonempty_list
    {      ( (_1, _3) :: _5 )}

tuple_expression:
  _1 = LPAREN _2 = RPAREN
    {                                          ( TupleExpression ([]) )}
| _1 = LPAREN _2 = expression _3 = COMMA _4 = RPAREN
    {                                          ( TupleExpression ([Some (_2)]) )}
| _1 = LPAREN _2 = maybe_expression_nontrivial_list _3 = RPAREN
    {                                                   ( TupleExpression (_2) )}

maybe_expression_nontrivial_list:
  _1 = expression _2 = COMMA %prec below_paren
    {                                             ( [Some (_1); None] )}
| _1 = expression _2 = COMMA _3 = expression
    {                                             ( [Some (_1); Some (_3)] )}
| _1 = comma_nonempty_list _2 = maybe_expression
    {                                             ( put_in_none_list [_2] _1 )}
| _1 = maybe_expression_nontrivial_list _2 = COMMA _3 = maybe_expression
    {                                                            ( _1 @ [_3] )}

maybe_unit:
  
    {                  ( None )}
| _1 = NUMBERUNIT
    {                  ( Some (_1) )}

identifier:
  _1 = IDENTIFIER
    {                ( _1 )}
| _1 = FROM
    {                ( "from" )}
| _1 = CONSTRUCTOR
    {                ( "constructor" )}
| _1 = RECEIVE
    {                ( "receive" )}
| _1 = FALLBACK
    {                ( "fallback" )}

maybe_identifier:
  
    {                  ( None )}
| _1 = identifier
    {                  ( Some (_1) )}

%%




