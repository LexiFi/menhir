%{
(**************************************************************************)
(*                                                                        *)
(*  Copyright (c) 2021 OCamlPro & Origin Labs                             *)
(*                                                                        *)
(*  All rights reserved.                                                  *)
(*  This file is distributed under the terms of the GNU Lesser General    *)
(*  Public License version 2.1, with the special exception on linking     *)
(*  described in the LICENSE.md file in the root directory.               *)
(*                                                                        *)
(*                                                                        *)
(**************************************************************************)

  open Solidity_common
  open Solidity_ast
  open Solidity_exceptions

  let to_pos pos =
    let open Lexing in
    let ({ pos_lnum = l1; pos_bol = b1; pos_cnum = c1; _ },
         { pos_lnum = l2; pos_bol = b2; pos_cnum = c2; _ }) = pos in
    let c1 = c1 - b1 in
    let c2 = c2 - b2 in
    let l1 = min l1 65535 in
    let l2 = min l2 65535 in
    let c1 = min c1 255 in
    let c2 = min c2 255 in ((l1, c1), (l2, c2))

  let error pos fmt =
    Format.kasprintf (fun s -> raise (SyntaxError (s, to_pos pos))) fmt

  type modifier =
    | Visibility of visibility
    | VMutability of var_mutability
    | FMutability of fun_mutability
    | Virtual
    | Override of longident list
    | Invocation of longident * expression list option

  let add_free_var_modifiers pos var ml =
    let has_mut = ref false in
    List.fold_left (fun var m ->
      match m with
        | VMutability mut ->
            if !has_mut then
              error pos "Mutability already specified";
            has_mut := true;
            { var with var_mutability = mut }
        | _ ->
            error pos "Invalid modifier for free variable declaration"
      ) var ml

  let add_var_modifiers pos var ml =
    let has_vis = ref false in
    let has_mut = ref false in
    let has_over = ref false in
    List.fold_left (fun var m ->
      match m with
        | Visibility vis ->
            if !has_vis then
              error pos "Visibility already specified";
            if is_external vis then
              error pos "Variable visibility can't be external";
            has_vis := true;
            { var with var_visibility = vis }
        | VMutability mut ->
            if !has_mut then
              error pos "Mutability already specified";
            has_mut := true;
            { var with var_mutability = mut }
        | Override ol ->
            if !has_over then
              error pos "Override already specified";
            has_over := true;
            { var with var_override = Some ol }
        | _ ->
            error pos "Invalid modifier for variable declaration"
      ) var ml

  let add_fun_modifiers pos fct ml =
    let has_vis = ref false in
    let has_mut = ref false in
    let has_over = ref false in
    let fct = List.fold_left (fun fct m ->
      match m with
        | Visibility vis ->
            if !has_vis then
              error pos "Visibility already specified";
            has_vis := true;
            { fct with fun_visibility = vis }
        | FMutability mut ->
            if !has_mut then
              error pos "Mutability already specified";
            has_mut := true;
            { fct with fun_mutability = mut }
        | Override ol ->
            if !has_over then
              error pos "Override already specified";
            has_over := true;
            { fct with fun_override = Some ol }
        | Virtual ->
            if fct.fun_virtual then
              error pos "Virtual already specified";
            { fct with fun_virtual = true }
        | Invocation (lid, exp_list_opt) ->
            { fct with fun_modifiers =
                         (lid, exp_list_opt) :: fct.fun_modifiers }
        | _ ->
            error pos "Invalid modifier for function declaration"
      ) fct ml
    in
    { fct with fun_modifiers = List.rev fct.fun_modifiers }

  let add_fun_type_modifiers pos ft ml =
    let has_vis = ref false in
    let has_mut = ref false in
    List.fold_left (fun ft m ->
      match m with
        | Visibility vis ->
            if !has_vis then
              error pos "Visibility already specified";
            if not (is_external vis || is_internal vis) then
              error pos "Function type visibility must be internal or external";
            has_vis := true;
            { ft with fun_type_visibility = vis }
        | FMutability mut ->
            if !has_mut then
              error pos "Mutability already specified";
            has_mut := true;
            { ft with fun_type_mutability = mut }
        | _ ->
            error pos "Invalid modifier for function type"
      ) ft ml

  let add_mod_modifiers pos md ml =
    List.fold_left (fun md m ->
      match m with
        | Override ol ->
            begin match md.mod_override with
              | None -> { md with mod_override = Some ol }
              | Some _ -> error pos "Override already specified"
            end
        | Virtual ->
            begin match md.mod_virtual with
              | false -> { md with mod_virtual = true }
              | true -> error pos "Virtual already specified"
            end
        | _ ->
            error pos "Invalid modifier for function declaration"
      ) md ml

  let mk pos c =
    { contents = c; annot = ANone; pos = to_pos pos }

  type raw_ambiguous_type_name_or_expression =
    | AmbiguousIdentifier of ident list
    | AmbiguousArray of ambiguous_type_name_or_expression * expression option

  and ambiguous_type_name_or_expression =
    raw_ambiguous_type_name_or_expression node

  let rec expression_of_identifiers = function
    | [] ->
        assert false
    | [x] ->
        { contents = IdentifierExpression x; annot = ANone; pos = x.pos }
    | x :: y ->
        let e = expression_of_identifiers y in
	let pos = match x.pos, e.pos with
          | ((l1, c1), _), (_, (l2, c2)) -> ((l1, c1), (l2, c2))
        in
        { contents = FieldExpression (e, x); annot = ANone; pos }

  let rec expression_of_ambiguity a =
    match a.contents with
    | AmbiguousIdentifier l ->
        expression_of_identifiers (List.rev l)
    | AmbiguousArray (a, expo) ->
        { a with contents = ArrayAccess (expression_of_ambiguity a, expo) }

  let rec type_name_of_ambiguity a =
    match a.contents with
    | AmbiguousIdentifier l ->
        let contents =
          LongIdent.of_ident_list_rel (List.map (fun id -> id.contents) l) in
        UserDefinedType { a with contents }
    | AmbiguousArray (a, expo) ->
        Array (type_name_of_ambiguity a, expo)

  let import import_from import_symbols =
    { import_from; import_symbols }

  let rec put_in_none_list l n =
    if n <= 0 then l
    else put_in_none_list (None :: l) (n-1)

  let decimal_to_rational (i, d, e) =
    let i = match i with Some i -> i | None -> Z.zero in
    let d = match d with Some d -> d | None -> Z.zero in
    let e = match e with Some e -> e | None -> 0 in
    let nb_dec =
      if Z.equal Z.zero d then 0
      else String.length (Z.to_string d)
    in
    let i = Q.make i Z.one in
    let d = Q.make d (Z.pow (Z.of_int 10) nb_dec) in
    let e = Q.make (Z.pow (Z.of_int 10) e) Z.one in
    Q.mul (Q.add i d) e

  let is_placeholder { contents; _ } =
    String.equal (Ident.to_string contents) "_"

  let ctxt_modifier = ref false
  let ctxt_interface = ref false
%}
%start module_units
%token ABSTRACT
%token ADDRESS
%token <string> ADDRESSLITERAL
%token AMPER
%token AMPERAMPER
%token AMPEREQUAL
%token ANONYMOUS
%token AS
%token BANG
%token BANGEQUAL
%token BOOL
%token <bool> BOOLEANLITERAL
%token BREAK
%token BYTE
%token <int option> BYTES
%token CALLDATA
%token CATCH
%token COLON
%token COMMA
%token CONSTANT
%token CONSTRUCTOR
%token CONTINUE
%token CONTRACT
%token DELETE
%token DIV
%token DIVEQUAL
%token DO
%token DOT
%token ELSE
%token EMIT
%token ENUM
%token EOF
%token EQUAL
%token EQUALEQUAL
%token EQUALGREATER
%token EVENT
%token EXTERNAL
%token FALLBACK
%token <(int * int) option> FIXED
%token FOR
%token FROM
%token FUNCTION
%token GREATER
%token GREATEREQUAL
%token GREATERGREATER
%token GREATERGREATEREQUAL
%token <string> HEXNUMBER
%token <string> HEXSTRINGLITERAL
%token <Solidity_common.Ident.t> IDENTIFIER
%token IF
%token IMMUTABLE
%token IMPORT
%token INDEXED
%token <int option> INT
%token INTERFACE
%token INTERNAL
%token IS
%token LBRACE
%token LBRACKET
%token LESS
%token LESSEQUAL
%token LESSLESS
%token LESSLESSEQUAL
%token LIBRARY
%token LPAREN
%token MAPPING
%token MEMORY
%token MINUS
%token MINUSEQUAL
%token MINUSMINUS
%token MODIFIER
%token NEW
%token NOT
%token <Z.t option * Z.t option * int option> NUMBER
%token <Solidity_ast.number_unit> NUMBERUNIT
%token OVERRIDE
%token PAYABLE
%token PERCENT
%token PERCENTEQUAL
%token PIPE
%token PIPEEQUAL
%token PIPEPIPE
%token PLUS
%token PLUSEQUAL
%token PLUSPLUS
%token <Solidity_common.Ident.t * string> PRAGMA
%token PRIVATE
%token PUBLIC
%token PURE
%token QUESTION
%token RBRACE
%token RBRACKET
%token RECEIVE
%token RETURN
%token RETURNS
%token RPAREN
%token SEMI
%token STAR
%token STAREQUAL
%token STARSTAR
%token STORAGE
%token STRING
%token <string> STRINGLITERAL
%token STRUCT
%token TRY
%token <(int * int) option> UFIXED
%token <int option> UINT
%token USING
%token VAR
%token VIEW
%token VIRTUAL
%token WHILE
%token XOR
%token XOREQUAL
%nonassoc below_IDENTIFIER
%nonassoc IDENTIFIER
%nonassoc CONSTRUCTOR FALLBACK FROM RECEIVE
%nonassoc below_mutability
%nonassoc CONSTANT
%nonassoc below_visibility
%nonassoc INTERNAL PRIVATE PUBLIC
%nonassoc below_SEMI
%nonassoc SEMI
%nonassoc below_RETURNS
%nonassoc RETURNS
%nonassoc below_ELSE
%nonassoc ELSE
%left COMMA
%right AMPEREQUAL DIVEQUAL EQUAL GREATERGREATEREQUAL LESSLESSEQUAL MINUSEQUAL PERCENTEQUAL PIPEEQUAL PLUSEQUAL STAREQUAL XOREQUAL
%right COLON QUESTION
%left PIPEPIPE
%left AMPERAMPER
%left BANGEQUAL EQUALEQUAL
%left GREATER GREATEREQUAL LESS LESSEQUAL
%left PIPE
%left XOR
%left AMPER
%left GREATERGREATER LESSLESS
%left MINUS PLUS
%left DIV PERCENT STAR
%left STARSTAR
%right unary_op
%left MINUSMINUS PLUSPLUS
%nonassoc below_paren
%nonassoc LPAREN RPAREN
%nonassoc LBRACE
%nonassoc below_LBRACKET
%nonassoc LBRACKET
%nonassoc below_DOT
%left DOT
%type <Solidity_ast.module_units> module_units
%%

midrule___anonymous_0_:
  
    {let x =             ( ctxt_modifier := false; ctxt_interface := false ) in
    ( x )}

midrule___anonymous_1_:
  _1 = MODIFIER
    {let x =                      ( ctxt_modifier := true ) in
    ( x )}

option_as_identifier_:
  
    {    ( None )}
| x = as_identifier
    {    ( Some x )}

option_equal_expression_:
  
    {    ( None )}
| x = equal_expression
    {    ( Some x )}

option_expression_:
  
    {    ( None )}
| x = expression
    {    ( Some x )}

option_identifier_:
  
    {    ( None )}
| x = identifier
    {    ( Some x )}

option_simple_statement_:
  
    {    ( None )}
| x = simple_statement
    {    ( Some x )}

option_storage_location_:
  
    {    ( None )}
| x = storage_location
    {    ( Some x )}

option_variable_declaration_:
  
    {    ( None )}
| x = variable_declaration
    {    ( Some x )}

boption_ABSTRACT_:
  
    {    ( false )}
| _1 = ABSTRACT
    {    ( true )}

boption_ANONYMOUS_:
  
    {    ( false )}
| _1 = ANONYMOUS
    {    ( true )}

boption_INDEXED_:
  
    {    ( false )}
| _1 = INDEXED
    {    ( true )}

boption_PAYABLE_:
  
    {    ( false )}
| _1 = PAYABLE
    {    ( true )}

loption_delimited_LPAREN_expression_list_RPAREN__:
  
    {    ( [] )}
| _1 = LPAREN x = expression_list _3 = RPAREN
    {let x =     ( x ) in
    ( x )}

loption_is_inheritance_specifiers_:
  
    {    ( [] )}
| x = is_inheritance_specifiers
    {    ( x )}

loption_override_parameters_:
  
    {    ( [] )}
| x = override_parameters
    {    ( x )}

loption_parameters_:
  
    {    ( [] )}
| x = parameters
    {    ( x )}

loption_separated_nonempty_list_COMMA_event_parameter__:
  
    {    ( [] )}
| x = separated_nonempty_list_COMMA_event_parameter_
    {    ( x )}

loption_separated_nonempty_list_COMMA_expression__:
  
    {    ( [] )}
| x = separated_nonempty_list_COMMA_expression_
    {    ( x )}

loption_separated_nonempty_list_COMMA_identifier__:
  
    {    ( [] )}
| x = separated_nonempty_list_COMMA_identifier_
    {    ( x )}

loption_separated_nonempty_list_COMMA_long_ident__:
  
    {    ( [] )}
| x = separated_nonempty_list_COMMA_long_ident_
    {    ( x )}

loption_separated_nonempty_list_COMMA_parameter__:
  
    {    ( [] )}
| x = separated_nonempty_list_COMMA_parameter_
    {    ( x )}

list_contract_part_:
  
    {    ( [] )}
| x = contract_part xs = list_contract_part_
    {    ( x :: xs )}

list_extra_anonymous_function_modifier_:
  
    {    ( [] )}
| x = extra_anonymous_function_modifier xs = list_extra_anonymous_function_modifier_
    {    ( x :: xs )}

list_function_modifier_:
  
    {    ( [] )}
| x = function_modifier xs = list_function_modifier_
    {    ( x :: xs )}

list_modifier_modifier_:
  
    {    ( [] )}
| x = modifier_modifier xs = list_modifier_modifier_
    {    ( x :: xs )}

list_source_unit_:
  
    {    ( [] )}
| x = source_unit xs = list_source_unit_
    {    ( x :: xs )}

list_statement_:
  
    {    ( [] )}
| x = statement xs = list_statement_
    {    ( x :: xs )}

nonempty_list_catch_clause_:
  x = catch_clause
    {    ( [ x ] )}
| x = catch_clause xs = nonempty_list_catch_clause_
    {    ( x :: xs )}

nonempty_list_variable_modifier_:
  x = variable_modifier
    {    ( [ x ] )}
| x = variable_modifier xs = nonempty_list_variable_modifier_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_event_parameter_:
  x = event_parameter
    {    ( [ x ] )}
| x = event_parameter _2 = COMMA xs = separated_nonempty_list_COMMA_event_parameter_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_expression_:
  x = expression
    {    ( [ x ] )}
| x = expression _2 = COMMA xs = separated_nonempty_list_COMMA_expression_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_identifier_:
  x = identifier
    {    ( [ x ] )}
| x = identifier _2 = COMMA xs = separated_nonempty_list_COMMA_identifier_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_inheritance_specifier_:
  x = inheritance_specifier
    {    ( [ x ] )}
| x = inheritance_specifier _2 = COMMA xs = separated_nonempty_list_COMMA_inheritance_specifier_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_long_ident_:
  x = long_ident
    {    ( [ x ] )}
| x = long_ident _2 = COMMA xs = separated_nonempty_list_COMMA_long_ident_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_option_identifier__:
  x = option_identifier_
    {    ( [ x ] )}
| x = option_identifier_ _2 = COMMA xs = separated_nonempty_list_COMMA_option_identifier__
    {    ( x :: xs )}

separated_nonempty_list_COMMA_pair_identifier_option_as_identifier___:
  x = identifier y = option_as_identifier_
    {let x =     ( (x, y) ) in
    ( [ x ] )}
| x = identifier y = option_as_identifier_ _2 = COMMA xs = separated_nonempty_list_COMMA_pair_identifier_option_as_identifier___
    {let x =     ( (x, y) ) in
    ( x :: xs )}

separated_nonempty_list_COMMA_parameter_:
  x = parameter
    {    ( [ x ] )}
| x = parameter _2 = COMMA xs = separated_nonempty_list_COMMA_parameter_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_return_:
  x = return
    {    ( [ x ] )}
| x = return _2 = COMMA xs = separated_nonempty_list_COMMA_return_
    {    ( x :: xs )}

module_units:
  _1 = midrule___anonymous_0_ _2 = list_source_unit_ _3 = EOF
    {                       ( _2 )}

source_unit:
  _1 = PRAGMA
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                                 ( mk _loc (Pragma (_1)) )}
| _1 = IMPORT _2 = import_directive _3 = SEMI
    {let _endpos = _endpos__3_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                                 ( mk _loc (Import (_2)) )}
| _1 = contract_definition
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                                 ( mk _loc (ContractDefinition (_1)) )}
| _1 = type_definition
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                                 ( mk _loc (GlobalTypeDefinition (_1)) )}
| _1 = type_name_no_function _2 = variable_modifiers _3 = identifier _4 = option_equal_expression_ _5 = SEMI
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (GlobalVariableDefinition (add_free_var_modifiers _loc {
            var_name = _3;
            var_type = _1;
            var_visibility = VInternal;
            var_mutability = MMutable;
            var_override = None;
            var_init = _4; } _2)) )}
| _1 = function_descriptor _2 = parameters _3 = list_function_modifier_ _4 = returns_opt _5 = function_body_opt
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (GlobalFunctionDefinition (add_fun_modifiers _loc {
            fun_name = _1;
            fun_params = _2;
            fun_returns = _4;
            fun_modifiers = [];
            fun_visibility = VInternal;
            fun_mutability = MNonPayable;
            fun_override = None;
            fun_virtual = false;
            fun_body = _5; } _3)) )}

import_directive:
  _1 = STRINGLITERAL _2 = option_as_identifier_
    {      ( import _1 (ImportAll (_2)) )}
| _1 = STAR _2 = as_identifier _3 = FROM _4 = STRINGLITERAL
    {      ( import _4 (ImportAll (Some _2)) )}
| _1 = LBRACE _2 = import_declarations _3 = RBRACE _4 = FROM _5 = STRINGLITERAL
    {      ( import _5 (ImportIdents _2) )}

import_declarations:
  _1 = separated_nonempty_list_COMMA_pair_identifier_option_as_identifier___
    {                                                                     ( _1 )}

as_identifier:
  _1 = AS _2 = identifier
    {                  ( _2 )}

contract_definition:
  _1 = boption_ABSTRACT_ _2 = contract_kind _3 = identifier _4 = loption_is_inheritance_specifiers_ _5 = LBRACE _6 = list_contract_part_ _7 = RBRACE
    {      ( ctxt_interface := false;
        { contract_name = _3;
          contract_kind = _2;
          contract_abstract = _1;
          contract_inheritance = _4;
          contract_parts = _6; } )}

contract_kind:
  _1 = CONTRACT
    {              ( Contract )}
| _1 = LIBRARY
    {              ( Library )}
| _1 = INTERFACE
    {              ( ctxt_interface := true; Interface )}

is_inheritance_specifiers:
  _1 = IS _2 = separated_nonempty_list_COMMA_inheritance_specifier_
    {                                                             ( _2 )}

inheritance_specifier:
  _1 = long_ident _2 = loption_delimited_LPAREN_expression_list_RPAREN__
    {                                                                   ( (_1, _2) )}

contract_part:
  _1 = type_definition
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (TypeDefinition (_1)) )}
| _1 = type_name_no_function _2 = variable_modifiers _3 = identifier _4 = option_equal_expression_ _5 = SEMI
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (StateVariableDeclaration (add_var_modifiers _loc {
            var_name = _3;
            var_type = _1;
            var_visibility = VInternal;
            var_mutability = MMutable;
            var_override = None;
            var_init = _4; } _2)) )}
| _1 = FUNCTION _2_inlined1 = parameters _3_inlined1 = function_type_modifiers _1_inlined1 = identifier_raw _5 = SEMI
    {let _4 =     ( None ) in
let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                     ( mk _loc _1 )
in
let _2 =                        ( [] ) in
let _1 =
  let (_endpos__3_, _3, _2) = (_endpos__3_inlined1_, _3_inlined1, _2_inlined1) in
  let _4 =                                                                  ( [] ) in
  let _endpos__4_ = _endpos__3_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
       ( let (fun_params, fun_modifiers, fun_returns) = (_2, _3, _4) in
       let fun_returns =
         List.map (function
             | _, _, Some _ ->
                 error _loc "Return parameters in function \
                             types may not be named."
             | t, loc_opt, None -> t, loc_opt
           ) fun_returns
       in
       FunctionType (add_fun_type_modifiers _loc {
         fun_type_params = fun_params;
         fun_type_visibility = VInternal;
         fun_type_mutability = MNonPayable;
         fun_type_returns = fun_returns; } fun_modifiers) )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (StateVariableDeclaration (add_var_modifiers _loc {
            var_name = _3;
            var_type = _1;
            var_visibility = VInternal;
            var_mutability = MMutable;
            var_override = None;
            var_init = _4; } _2)) )}
| _1 = FUNCTION _2_inlined1 = parameters _3_inlined1 = function_type_modifiers _1_inlined1 = identifier_raw x = equal_expression _5 = SEMI
    {let _4 =     ( Some x ) in
let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                     ( mk _loc _1 )
in
let _2 =                        ( [] ) in
let _1 =
  let (_endpos__3_, _3, _2) = (_endpos__3_inlined1_, _3_inlined1, _2_inlined1) in
  let _4 =                                                                  ( [] ) in
  let _endpos__4_ = _endpos__3_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
       ( let (fun_params, fun_modifiers, fun_returns) = (_2, _3, _4) in
       let fun_returns =
         List.map (function
             | _, _, Some _ ->
                 error _loc "Return parameters in function \
                             types may not be named."
             | t, loc_opt, None -> t, loc_opt
           ) fun_returns
       in
       FunctionType (add_fun_type_modifiers _loc {
         fun_type_params = fun_params;
         fun_type_visibility = VInternal;
         fun_type_mutability = MNonPayable;
         fun_type_returns = fun_returns; } fun_modifiers) )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (StateVariableDeclaration (add_var_modifiers _loc {
            var_name = _3;
            var_type = _1;
            var_visibility = VInternal;
            var_mutability = MMutable;
            var_override = None;
            var_init = _4; } _2)) )}
| _1 = FUNCTION _2_inlined1 = parameters _3_inlined1 = function_type_modifiers _1_inlined1 = nonempty_list_variable_modifier_ _1_inlined2 = identifier_raw _5 = SEMI
    {let _4 =     ( None ) in
let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _1_inlined2) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                     ( mk _loc _1 )
in
let _2 =
  let _1 = _1_inlined1 in
                         ( _1 )
in
let _1 =
  let (_endpos__3_, _3, _2) = (_endpos__3_inlined1_, _3_inlined1, _2_inlined1) in
  let _4 =                                                                  ( [] ) in
  let _endpos__4_ = _endpos__3_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
       ( let (fun_params, fun_modifiers, fun_returns) = (_2, _3, _4) in
       let fun_returns =
         List.map (function
             | _, _, Some _ ->
                 error _loc "Return parameters in function \
                             types may not be named."
             | t, loc_opt, None -> t, loc_opt
           ) fun_returns
       in
       FunctionType (add_fun_type_modifiers _loc {
         fun_type_params = fun_params;
         fun_type_visibility = VInternal;
         fun_type_mutability = MNonPayable;
         fun_type_returns = fun_returns; } fun_modifiers) )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (StateVariableDeclaration (add_var_modifiers _loc {
            var_name = _3;
            var_type = _1;
            var_visibility = VInternal;
            var_mutability = MMutable;
            var_override = None;
            var_init = _4; } _2)) )}
| _1 = FUNCTION _2_inlined1 = parameters _3_inlined1 = function_type_modifiers _1_inlined1 = nonempty_list_variable_modifier_ _1_inlined2 = identifier_raw x = equal_expression _5 = SEMI
    {let _4 =     ( Some x ) in
let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _1_inlined2) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                     ( mk _loc _1 )
in
let _2 =
  let _1 = _1_inlined1 in
                         ( _1 )
in
let _1 =
  let (_endpos__3_, _3, _2) = (_endpos__3_inlined1_, _3_inlined1, _2_inlined1) in
  let _4 =                                                                  ( [] ) in
  let _endpos__4_ = _endpos__3_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
       ( let (fun_params, fun_modifiers, fun_returns) = (_2, _3, _4) in
       let fun_returns =
         List.map (function
             | _, _, Some _ ->
                 error _loc "Return parameters in function \
                             types may not be named."
             | t, loc_opt, None -> t, loc_opt
           ) fun_returns
       in
       FunctionType (add_fun_type_modifiers _loc {
         fun_type_params = fun_params;
         fun_type_visibility = VInternal;
         fun_type_mutability = MNonPayable;
         fun_type_returns = fun_returns; } fun_modifiers) )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (StateVariableDeclaration (add_var_modifiers _loc {
            var_name = _3;
            var_type = _1;
            var_visibility = VInternal;
            var_mutability = MMutable;
            var_override = None;
            var_init = _4; } _2)) )}
| _1 = FUNCTION _2_inlined1 = parameters _3_inlined1 = function_type_modifiers _1_inlined1 = RETURNS _2_inlined2 = LPAREN _3_inlined2 = separated_nonempty_list_COMMA_return_ _4_inlined1 = RPAREN _1_inlined2 = identifier_raw _5 = SEMI
    {let _4 =     ( None ) in
let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _1_inlined2) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                     ( mk _loc _1 )
in
let _2 =                        ( [] ) in
let _1 =
  let (_endpos__4_, _3_inlined1, _3, _2) = (_endpos__4_inlined1_, _3_inlined2, _3_inlined1, _2_inlined1) in
  let _4 =
    let _3 = _3_inlined1 in
                                                                     ( _3 )
  in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
       ( let (fun_params, fun_modifiers, fun_returns) = (_2, _3, _4) in
       let fun_returns =
         List.map (function
             | _, _, Some _ ->
                 error _loc "Return parameters in function \
                             types may not be named."
             | t, loc_opt, None -> t, loc_opt
           ) fun_returns
       in
       FunctionType (add_fun_type_modifiers _loc {
         fun_type_params = fun_params;
         fun_type_visibility = VInternal;
         fun_type_mutability = MNonPayable;
         fun_type_returns = fun_returns; } fun_modifiers) )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (StateVariableDeclaration (add_var_modifiers _loc {
            var_name = _3;
            var_type = _1;
            var_visibility = VInternal;
            var_mutability = MMutable;
            var_override = None;
            var_init = _4; } _2)) )}
| _1 = FUNCTION _2_inlined1 = parameters _3_inlined1 = function_type_modifiers _1_inlined1 = RETURNS _2_inlined2 = LPAREN _3_inlined2 = separated_nonempty_list_COMMA_return_ _4_inlined1 = RPAREN _1_inlined2 = identifier_raw x = equal_expression _5 = SEMI
    {let _4 =     ( Some x ) in
let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _1_inlined2) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                     ( mk _loc _1 )
in
let _2 =                        ( [] ) in
let _1 =
  let (_endpos__4_, _3_inlined1, _3, _2) = (_endpos__4_inlined1_, _3_inlined2, _3_inlined1, _2_inlined1) in
  let _4 =
    let _3 = _3_inlined1 in
                                                                     ( _3 )
  in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
       ( let (fun_params, fun_modifiers, fun_returns) = (_2, _3, _4) in
       let fun_returns =
         List.map (function
             | _, _, Some _ ->
                 error _loc "Return parameters in function \
                             types may not be named."
             | t, loc_opt, None -> t, loc_opt
           ) fun_returns
       in
       FunctionType (add_fun_type_modifiers _loc {
         fun_type_params = fun_params;
         fun_type_visibility = VInternal;
         fun_type_mutability = MNonPayable;
         fun_type_returns = fun_returns; } fun_modifiers) )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (StateVariableDeclaration (add_var_modifiers _loc {
            var_name = _3;
            var_type = _1;
            var_visibility = VInternal;
            var_mutability = MMutable;
            var_override = None;
            var_init = _4; } _2)) )}
| _1 = FUNCTION _2_inlined1 = parameters _3_inlined1 = function_type_modifiers _1_inlined1 = RETURNS _2_inlined2 = LPAREN _3_inlined2 = separated_nonempty_list_COMMA_return_ _4_inlined1 = RPAREN _1_inlined2 = nonempty_list_variable_modifier_ _1_inlined3 = identifier_raw _5 = SEMI
    {let _4 =     ( None ) in
let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined3_, _startpos__1_inlined3_, _1_inlined3) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                     ( mk _loc _1 )
in
let _2 =
  let _1 = _1_inlined2 in
                         ( _1 )
in
let _1 =
  let (_endpos__4_, _3_inlined1, _3, _2) = (_endpos__4_inlined1_, _3_inlined2, _3_inlined1, _2_inlined1) in
  let _4 =
    let _3 = _3_inlined1 in
                                                                     ( _3 )
  in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
       ( let (fun_params, fun_modifiers, fun_returns) = (_2, _3, _4) in
       let fun_returns =
         List.map (function
             | _, _, Some _ ->
                 error _loc "Return parameters in function \
                             types may not be named."
             | t, loc_opt, None -> t, loc_opt
           ) fun_returns
       in
       FunctionType (add_fun_type_modifiers _loc {
         fun_type_params = fun_params;
         fun_type_visibility = VInternal;
         fun_type_mutability = MNonPayable;
         fun_type_returns = fun_returns; } fun_modifiers) )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (StateVariableDeclaration (add_var_modifiers _loc {
            var_name = _3;
            var_type = _1;
            var_visibility = VInternal;
            var_mutability = MMutable;
            var_override = None;
            var_init = _4; } _2)) )}
| _1 = FUNCTION _2_inlined1 = parameters _3_inlined1 = function_type_modifiers _1_inlined1 = RETURNS _2_inlined2 = LPAREN _3_inlined2 = separated_nonempty_list_COMMA_return_ _4_inlined1 = RPAREN _1_inlined2 = nonempty_list_variable_modifier_ _1_inlined3 = identifier_raw x = equal_expression _5 = SEMI
    {let _4 =     ( Some x ) in
let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined3_, _startpos__1_inlined3_, _1_inlined3) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                     ( mk _loc _1 )
in
let _2 =
  let _1 = _1_inlined2 in
                         ( _1 )
in
let _1 =
  let (_endpos__4_, _3_inlined1, _3, _2) = (_endpos__4_inlined1_, _3_inlined2, _3_inlined1, _2_inlined1) in
  let _4 =
    let _3 = _3_inlined1 in
                                                                     ( _3 )
  in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
       ( let (fun_params, fun_modifiers, fun_returns) = (_2, _3, _4) in
       let fun_returns =
         List.map (function
             | _, _, Some _ ->
                 error _loc "Return parameters in function \
                             types may not be named."
             | t, loc_opt, None -> t, loc_opt
           ) fun_returns
       in
       FunctionType (add_fun_type_modifiers _loc {
         fun_type_params = fun_params;
         fun_type_visibility = VInternal;
         fun_type_mutability = MNonPayable;
         fun_type_returns = fun_returns; } fun_modifiers) )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (StateVariableDeclaration (add_var_modifiers _loc {
            var_name = _3;
            var_type = _1;
            var_visibility = VInternal;
            var_mutability = MMutable;
            var_override = None;
            var_init = _4; } _2)) )}
| _1 = midrule___anonymous_1_ _2 = identifier _3 = loption_parameters_ _4 = list_modifier_modifier_ _5 = function_body_opt
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( ctxt_modifier := false;
        mk _loc (ModifierDefinition (add_mod_modifiers _loc {
            mod_name = _2;
            mod_params = _3;
            mod_override = None;
            mod_virtual = false;
            mod_body = _5; } _4)) )}
| _1 = FUNCTION _2 = parameters _1_inlined1 = function_type_modifiers _4 = returns_opt _5 = function_body_opt
    {let _3 =
  let _1 = _1_inlined1 in
                              ( _1 )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
let _loc = (_startpos, _endpos) in
      ( mk _loc (FunctionDefinition (add_fun_modifiers _loc {
            fun_name = mk _loc__1_ (Ident.fallback);
            fun_params = _2;
            fun_returns = _4;
            fun_modifiers = [];
            fun_visibility = if !ctxt_interface then VExternal else VPublic;
            fun_mutability = MNonPayable;
            fun_override = None;
            fun_virtual = false;
            fun_body = _5; } _3)) )}
| _1 = FUNCTION _2 = parameters _1_inlined1 = function_type_modifiers _1_inlined2 = long_ident_raw _3 = list_extra_anonymous_function_modifier_ _4 = returns_opt _5 = function_body_opt
    {let _3 =
  let (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1, _1) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _1_inlined2, _1_inlined1) in
  let _2 =
    let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
                         ( mk _loc _1 )
    in
                                                 ( Invocation (_1, None) )
  in
        ( _1 @ (_2 :: _3) )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
let _loc = (_startpos, _endpos) in
      ( mk _loc (FunctionDefinition (add_fun_modifiers _loc {
            fun_name = mk _loc__1_ (Ident.fallback);
            fun_params = _2;
            fun_returns = _4;
            fun_modifiers = [];
            fun_visibility = if !ctxt_interface then VExternal else VPublic;
            fun_mutability = MNonPayable;
            fun_override = None;
            fun_virtual = false;
            fun_body = _5; } _3)) )}
| _1 = FUNCTION _2 = parameters _1_inlined1 = function_type_modifiers _1_inlined2 = long_ident _2_inlined1 = LPAREN _3_inlined1 = expression_list _4_inlined1 = RPAREN _3 = list_extra_anonymous_function_modifier_ _4 = returns_opt _5 = function_body_opt
    {let _3 =
  let (_1_inlined1, _1) = (_1_inlined2, _1_inlined1) in
  let _2 =
    let (_3, _1) = (_3_inlined1, _1_inlined1) in
                                                 ( Invocation (_1, Some (_3)) )
  in
        ( _1 @ (_2 :: _3) )
in
let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
let _loc = (_startpos, _endpos) in
      ( mk _loc (FunctionDefinition (add_fun_modifiers _loc {
            fun_name = mk _loc__1_ (Ident.fallback);
            fun_params = _2;
            fun_returns = _4;
            fun_modifiers = [];
            fun_visibility = if !ctxt_interface then VExternal else VPublic;
            fun_mutability = MNonPayable;
            fun_override = None;
            fun_virtual = false;
            fun_body = _5; } _3)) )}
| _1 = function_descriptor _2 = parameters _3 = list_function_modifier_ _4 = returns_opt _5 = function_body_opt
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (FunctionDefinition (add_fun_modifiers _loc {
            fun_name = _1;
            fun_params = _2;
            fun_returns = _4;
            fun_modifiers = [];
            fun_visibility = if !ctxt_interface then VExternal else VPublic;
            fun_mutability = MNonPayable;
            fun_override = None;
            fun_virtual = false;
            fun_body = _5; } _3)) )}
| _1 = EVENT _2 = identifier _3 = event_parameters _4 = boption_ANONYMOUS_ _5 = SEMI
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (EventDefinition {
            event_name = _2;
            event_params = _3;
            event_anonymous = _4; }) )}
| _1 = USING _2 = long_ident _3 = FOR _4 = type_name_or_star _5 = SEMI
    {let _endpos = _endpos__5_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (UsingForDeclaration (_2, None)) )}

type_name_or_star:
  _1 = type_name
    {              ( Some (_1) )}
| _1 = STAR
    {              ( None )}

type_definition:
  _1 = ENUM _2 = identifier _3 = LBRACE _4 = enum_values _5 = RBRACE
    {                                                  ( EnumDefinition (_2, _4) )}
| _1 = STRUCT _2 = identifier _3 = LBRACE _4 = struct_fields _5 = RBRACE
    {                                                  ( StructDefinition (_2, _4) )}

enum_values:
  xs = loption_separated_nonempty_list_COMMA_identifier__
    {let _1 =     ( xs ) in
                                      ( _1 )}

struct_fields:
  
    {                       ( [] )}
| _1 = separated_and_terminated_nonempty_list_SEMI_pair_type_name_identifier__
    {      ( _1 )}

function_descriptor:
  _1 = FUNCTION _2 = identifier
    {                        ( _2 )}
| _1 = CONSTRUCTOR
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                        ( mk _loc Ident.constructor )}
| _1 = RECEIVE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                        ( mk _loc Ident.receive )}
| _1 = FALLBACK
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                        ( mk _loc Ident.fallback )}

returns_opt:
  
    {let _1 =                                                                  ( [] ) in
                 ( _1 )}
| _1 = RETURNS _2 = LPAREN _3 = separated_nonempty_list_COMMA_return_ _4 = RPAREN
    {let _1 =                                                                  ( _3 ) in
                 ( _1 )}

return:
  _1 = type_name _2 = option_storage_location_ _3 = option_identifier_
    {                                            ( (_1, _2, _3) )}

function_body_opt:
  _1 = block
    {          ( Some (_1) )}
| _1 = SEMI
    {          ( None )}

function_modifier:
  _1 = modifier_invocation
    {                        ( _1 )}
| _1 = fun_mutability
    {                        ( _1 )}
| _1 = internal_external
    {                        ( _1 )}
| _1 = public_private
    {                        ( _1 )}
| _1 = VIRTUAL
    {                        ( Virtual )}
| _1 = override_specifier
    {                        ( _1 )}

modifier_modifier:
  _1 = VIRTUAL
    {                        ( Virtual )}
| _1 = override_specifier
    {                        ( _1 )}

extra_anonymous_function_modifier:
  _1 = extra_function_type_modifier
    {                                 ( _1 )}
| _1 = long_ident_raw
    {let _1 =
  let _1 =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
    let _loc = (_startpos, _endpos) in
                       ( mk _loc _1 )
  in
                                               ( Invocation (_1, None) )
in
                                 ( _1 )}
| _1 = long_ident _2 = LPAREN _3 = expression_list _4 = RPAREN
    {let _1 =                                              ( Invocation (_1, Some (_3)) ) in
                                 ( _1 )}

variable_modifiers:
  
    {let _1 =                        ( [] ) in
                        ( _1 )}
| _1 = nonempty_list_variable_modifier_
    {let _1 =                        ( _1 ) in
                        ( _1 )}

variable_modifier:
  _1 = public_private
    {                       ( _1 )}
| _1 = INTERNAL
    {                       ( Visibility VInternal )}
| _1 = CONSTANT
    {                       ( VMutability MConstant )}
| _1 = IMMUTABLE
    {                       ( VMutability MImmutable )}
| _1 = override_specifier
    {                       ( _1 )}

modifier_invocation:
  _1 = long_ident_raw
    {let _1 =
  let _1 =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
    let _loc = (_startpos, _endpos) in
                       ( mk _loc _1 )
  in
                                               ( Invocation (_1, None) )
in
                         ( _1 )}
| _1 = long_ident _2 = LPAREN _3 = expression_list _4 = RPAREN
    {let _1 =                                              ( Invocation (_1, Some (_3)) ) in
                         ( _1 )}

override_specifier:
  _1 = OVERRIDE _2 = loption_override_parameters_
    {                                          ( Override (_2) )}

override_parameters:
  _1 = LPAREN xs = loption_separated_nonempty_list_COMMA_long_ident__ _3 = RPAREN
    {let _2 =     ( xs ) in
                                                    ( _2 )}

event_parameters:
  _1 = LPAREN xs = loption_separated_nonempty_list_COMMA_event_parameter__ _3 = RPAREN
    {let _2 =     ( xs ) in
                                                         ( _2 )}

event_parameter:
  _1 = type_name _2 = boption_INDEXED_ _3 = option_identifier_
    {                                           ( (_1, _2, _3) )}

parameters:
  _1 = LPAREN xs = loption_separated_nonempty_list_COMMA_parameter__ _3 = RPAREN
    {let _2 =     ( xs ) in
                                                   ( _2 )}

parameter:
  _1 = type_name _2 = option_storage_location_ _3 = option_identifier_
    {                                            ( (_1, _2, _3) )}

variable_declaration:
  _1 = type_name _2 = option_storage_location_ _3 = identifier
    {                                           ( (_1, _2, _3) )}

type_name:
  _1 = non_ambiguous_type_name %prec below_LBRACKET
    {      ( _1 )}
| _1 = ambiguous_type_name_or_expression %prec below_LBRACKET
    {      ( type_name_of_ambiguity _1 )}

type_name_no_function:
  _1 = non_ambiguous_type_name_no_function
    {                                        ( _1 )}
| _1 = ambiguous_type_name_or_expression
    {                                        ( type_name_of_ambiguity _1 )}

non_ambiguous_type_name:
  _1 = non_ambiguous_type_name_no_function
    {                                            ( _1 )}
| _1 = FUNCTION _2 = parameters _3 = function_type_modifiers %prec below_RETURNS
    {let _1 =
  let _4 =                                                                  ( [] ) in
  let _endpos__4_ = _endpos__3_ in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
       ( let (fun_params, fun_modifiers, fun_returns) = (_2, _3, _4) in
       let fun_returns =
         List.map (function
             | _, _, Some _ ->
                 error _loc "Return parameters in function \
                             types may not be named."
             | t, loc_opt, None -> t, loc_opt
           ) fun_returns
       in
       FunctionType (add_fun_type_modifiers _loc {
         fun_type_params = fun_params;
         fun_type_visibility = VInternal;
         fun_type_mutability = MNonPayable;
         fun_type_returns = fun_returns; } fun_modifiers) )
in
                                            ( _1 )}
| _1 = FUNCTION _2 = parameters _3 = function_type_modifiers _1_inlined1 = RETURNS _2_inlined1 = LPAREN _3_inlined1 = separated_nonempty_list_COMMA_return_ _4 = RPAREN %prec below_RETURNS
    {let _1 =
  let _4 =
    let _3 = _3_inlined1 in
                                                                     ( _3 )
  in
  let _endpos = _endpos__4_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
       ( let (fun_params, fun_modifiers, fun_returns) = (_2, _3, _4) in
       let fun_returns =
         List.map (function
             | _, _, Some _ ->
                 error _loc "Return parameters in function \
                             types may not be named."
             | t, loc_opt, None -> t, loc_opt
           ) fun_returns
       in
       FunctionType (add_fun_type_modifiers _loc {
         fun_type_params = fun_params;
         fun_type_visibility = VInternal;
         fun_type_mutability = MNonPayable;
         fun_type_returns = fun_returns; } fun_modifiers) )
in
                                            ( _1 )}

non_ambiguous_type_name_no_function:
  _1 = elementary_type_name
    {      ( ElementaryType (_1) )}
| _1 = MAPPING _2 = LPAREN _3 = type_name _4 = EQUALGREATER _5 = type_name _6 = RPAREN
    {      ( Mapping (_3, _5) )}
| _1 = non_ambiguous_type_name _2 = LBRACKET _3 = option_expression_ _4 = RBRACKET
    {      ( Array (_1, _3) )}

ambiguous_type_name_or_expression:
  _1 = ident_list
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (AmbiguousIdentifier (_1)) )}
| _1 = ambiguous_type_name_or_expression _2 = LBRACKET _3 = option_expression_ _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc (AmbiguousArray (_1, _3)) )}

long_ident:
  _1 = long_ident_raw
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                     ( mk _loc _1 )
in
                    ( _1 )}

long_ident_raw:
  _1 = identifier_raw %prec below_SEMI
    {                                      ( LongIdent.of_ident_rel _1 )}
| _1 = identifier_raw _2 = DOT _3 = long_ident_raw
    {                                      ( LongIdent.prepend _1 _3 )}

ident_list:
  _1 = identifier %prec below_DOT
    {                               ( [_1] )}
| _1 = identifier _2 = DOT _3 = ident_list
    {                               ( _1 :: _3 )}

function_type_modifiers:
  _1 = fun_mutability_list %prec below_visibility
    {                                               ( _1 )}
| _1 = fun_mutability_list _2 = internal_external _3 = fun_mutability_list
    {      ( _1 @ (_2 :: _3) )}
| _1 = fun_mutability_list _2 = public_private _3 = extra_function_type_modifiers
    {      ( _1 @ (_2 :: _3) )}

fun_mutability_list:
   %prec below_mutability
    {                                         ( [] )}
| _1 = fun_mutability _2 = fun_mutability_list
    {                                         ( _1 :: _2 )}

extra_function_type_modifiers:
   %prec below_visibility
    {                                                               ( [] )}
| _1 = extra_function_type_modifier _2 = extra_function_type_modifiers
    {                                                               ( _1 :: _2 )}

extra_function_type_modifier:
  _1 = internal_external
    {                      ( _1 )}
| _1 = public_private
    {                      ( _1 )}
| _1 = fun_mutability
    {                      ( _1 )}

internal_external:
  _1 = EXTERNAL
    {             ( Visibility VExternal )}
| _1 = INTERNAL
    {             ( Visibility VInternal )}

public_private:
  _1 = PUBLIC
    {             ( Visibility VPublic )}
| _1 = PRIVATE
    {             ( Visibility VPrivate )}

storage_location:
  _1 = MEMORY
    {             ( Memory )}
| _1 = STORAGE
    {             ( Storage )}
| _1 = CALLDATA
    {             ( Calldata )}

fun_mutability:
  _1 = PURE
    {              ( FMutability MPure )}
| _1 = CONSTANT
    {              ( FMutability MView )}
| _1 = VIEW
    {              ( FMutability MView )}
| _1 = PAYABLE
    {              ( FMutability MPayable )}

block:
  _1 = LBRACE _2 = list_statement_ _3 = RBRACE
    {                             ( _2 )}

statement:
  _1 = statement_no_semi
    {                               ( _1 )}
| _1 = statement_before_semi _2 = SEMI
    {                               ( _1 )}

statement_no_semi:
  _1 = if_statement
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                    ( mk _loc (_1) )}
| _1 = for_statement
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                    ( mk _loc (_1) )}
| _1 = while_statement
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                    ( mk _loc (_1) )}
| _1 = try_statement
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                    ( mk _loc (_1) )}
| _1 = block
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                    ( mk _loc (Block (_1)) )}

statement_before_semi:
  _1 = simple_statement
    {                       ( _1 )}
| _1 = do_while_statement
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                       ( mk _loc (_1) )}
| _1 = RETURN _2 = option_expression_
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                       ( mk _loc (Return (_2)) )}
| _1 = CONTINUE
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                       ( mk _loc (Continue) )}
| _1 = BREAK
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                       ( mk _loc (Break) )}
| _1 = EMIT _2 = function_call
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                       ( let (f, a) = _2 in mk _loc (Emit (f, a)) )}

if_statement:
  _1 = IF _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement %prec below_ELSE
    {      ( IfStatement (_3, _5, None) )}
| _1 = IF _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement _6 = ELSE _7 = statement
    {      ( IfStatement (_3, _5, Some (_7)) )}

for_statement:
  _1 = FOR _2 = LPAREN _3 = option_simple_statement_ _4 = SEMI _5 = option_expression_ _6 = SEMI _7 = option_expression_ _8 = RPAREN _9 = statement
    {      ( ForStatement (_3, _5, _7, _9) )}

while_statement:
  _1 = WHILE _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement
    {                                             ( WhileStatement (_3, _5) )}

try_statement:
  _1 = TRY _2 = expression _4 = block _5 = nonempty_list_catch_clause_
    {let _3 =                                                                  ( [] ) in
      ( TryStatement (_2, _3, _4, _5) )}
| _1 = TRY _2 = expression _1_inlined1 = RETURNS _2_inlined1 = LPAREN _3 = separated_nonempty_list_COMMA_return_ _4_inlined1 = RPAREN _4 = block _5 = nonempty_list_catch_clause_
    {let _3 =                                                                  ( _3 ) in
      ( TryStatement (_2, _3, _4, _5) )}

catch_clause:
  _1 = CATCH _2 = block
    {                                       ( (None, [], _2) )}
| _1 = CATCH _2 = option_identifier_ _3 = parameters _4 = block
    {                                       ( (_2, _3, _4) )}

simple_statement:
  _1 = variable_declaration_statement
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                                   ( mk _loc (VariableDefinition (_1)) )}
| _1 = expression
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
               (
      (* When under a modifier, a single underscore at the
         level of statements is no longer an identifier *)
      match !ctxt_modifier, _1.contents with
      | true, IdentifierExpression (id_node) when is_placeholder id_node ->
          mk _loc (PlaceholderStatement)
      | _, _e ->
          mk _loc (ExpressionStatement (_1)) )}

do_while_statement:
  _1 = DO _2 = statement _3 = WHILE _4 = LPAREN _5 = expression _6 = RPAREN
    {                                                ( DoWhileStatement (_2, _5) )}

variable_declaration_statement:
  _1 = VAR _2 = identifier_opt_list
    {let _endpos = _endpos__2_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( error _loc "Assignment necessary for type detection" )}
| _1 = VAR _2 = identifier_opt_list _3 = equal_expression
    {                                                    ( VarInfer (_2, _3) )}
| _1 = variable_declaration_opt_list _2 = option_equal_expression_
    {                                                    ( VarType (_1, _2) )}

identifier_opt_list:
  _1 = identifier
    {               ( [Some (_1)] )}
| _1 = LPAREN _2 = separated_nonempty_list_COMMA_option_identifier__ _3 = RPAREN
    {      ( match _2 with [None] -> [] | l -> l )}

variable_declaration_opt_list:
  _1 = variable_declaration
    {                                                         ( [Some (_1)] )}
| _1 = LPAREN _2 = variable_declaration_opt_nonempty_list _3 = RPAREN
    {                                                         ( _2 )}

variable_declaration_opt_nonempty_list:
  _1 = variable_declaration
    {                                             ( [Some (_1)] )}
| _1 = comma_nonempty_list _2 = variable_declaration
    {                                             ( put_in_none_list [Some (_2)] _1 )}
| _1 = variable_declaration_opt_nonempty_list _2 = COMMA _3 = option_variable_declaration_
    {      ( _1 @ [_3] )}

comma_nonempty_list:
  _1 = COMMA
    {                              ( 1 )}
| _1 = COMMA _2 = comma_nonempty_list
    {                              ( 1 + _2 )}

equal_expression:
  _1 = EQUAL _2 = expression
    {                     ( _2 )}

elementary_type_name:
  _1 = VAR %prec below_IDENTIFIER
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
                               ( error _loc "Expected explicit type name" )}
| _1 = ADDRESS _2 = boption_PAYABLE_
    {                               ( TypeAddress (_2) )}
| _1 = STRING
    {                               ( TypeString )}
| _1 = BYTES
    {                               ( TypeBytes (_1) )}
| _1 = BYTE
    {                               ( TypeBytes (Some 1) )}
| _1 = BOOL
    {                               ( TypeBool )}
| _1 = INT
    {                               ( TypeInt (Option.value ~default:256 _1) )}
| _1 = UINT
    {                               ( TypeUint (Option.value ~default:256 _1) )}
| _1 = FIXED
    {      ( let (sz, dec) = Option.value ~default:(128,18) _1 in
        TypeFixed (sz, dec) )}
| _1 = UFIXED
    {      ( let (sz, dec) = Option.value ~default:(128,18) _1 in
        TypeUfixed (sz, dec) )}

expression:
  _1 = non_ambiguous_expression
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( mk _loc _1 )}
| _1 = ambiguous_type_name_or_expression %prec below_LBRACKET
    {      ( expression_of_ambiguity _1 )}

expression_list:
  xs = loption_separated_nonempty_list_COMMA_expression__
    {let _1 =     ( xs ) in
                                      ( _1 )}

expression_nonempty_list:
  _1 = separated_nonempty_list_COMMA_expression_
    {                                               ( _1 )}

non_ambiguous_expression:
  _1 = LPAREN _2 = expression _3 = RPAREN
    {      ( _2.contents )}
| _1 = literal_expression
    {      ( _1 )}
| _1 = tuple_expression
    {      ( _1 )}
| _1 = NEW _2 = type_name
    {      ( NewExpression (_2) )}
| _1 = non_ambiguous_type_name %prec below_LBRACKET
    {      ( TypeExpression _1 )}
| _1 = expression _2 = DOT _3 = identifier
    {      ( FieldExpression (_1, _3) )}
| _1 = expression _2 = LBRACKET _3 = option_expression_ _4 = RBRACKET
    {      ( ArrayAccess (_1, _3) )}
| _1 = expression _2 = LBRACKET _3 = option_expression_ _4 = COLON _5 = option_expression_ _6 = RBRACKET
    {      ( ArraySlice (_1, _3, _5) )}
| _1 = LBRACKET _2 = expression_nonempty_list _3 = RBRACKET
    {      ( ImmediateArray (_2) )}
| _1 = function_call
    {      ( let (f, a) = _1 in FunctionCallExpression (f, a) )}
| _1 = expression _2 = LBRACE _3 = name_value_nonempty_list _4 = RBRACE
    {      ( CallOptions (_1, _3) )}
| _1 = PAYABLE _2 = LPAREN _3 = expression _4 = RPAREN
    {let _loc__1_ = (_startpos__1_, _endpos__1_) in
      ( FunctionCallExpression (
            mk _loc__1_ (TypeExpression (ElementaryType (TypeAddress (true)))),
            ExpressionList ([_3])) )}
| _1 = inc_dec_op _2 = expression %prec unary_op
    {      ( PrefixExpression (_1, _2) )}
| _1 = expression _2 = inc_dec_op
    {      ( SuffixExpression (_1, _2) )}
| _1 = unop _2 = expression %prec unary_op
    {      ( PrefixExpression (_1, _2) )}
| _1 = expression _1_inlined1 = PLUS _3 = expression
    {let _2 =                         ( BPlus ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = MINUS _3 = expression
    {let _2 =                         ( BMinus ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = DIV _3 = expression
    {let _2 =                         ( BDiv ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = PERCENT _3 = expression
    {let _2 =                         ( BMod ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = STAR _3 = expression
    {let _2 =                         ( BTimes ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = STARSTAR _3 = expression
    {let _2 =                         ( BExp ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = LESSLESS _3 = expression
    {let _2 =                         ( BLShift ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = GREATERGREATER _3 = expression
    {let _2 =                         ( BRShift ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = AMPER _3 = expression
    {let _2 =                         ( BAnd ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = XOR _3 = expression
    {let _2 =                         ( BXor ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = PIPE _3 = expression
    {let _2 =                         ( BOr ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = AMPERAMPER _3 = expression
    {let _2 =                         ( BLAnd ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = PIPEPIPE _3 = expression
    {let _2 =                         ( BLOr ) in
      ( BinaryExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = EQUALEQUAL _3 = expression
    {let _2 =                         ( CEq ) in
      ( CompareExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = BANGEQUAL _3 = expression
    {let _2 =                         ( CNeq ) in
      ( CompareExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = LESS _3 = expression
    {let _2 =                         ( CLt ) in
      ( CompareExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = GREATER _3 = expression
    {let _2 =                         ( CGt ) in
      ( CompareExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = LESSEQUAL _3 = expression
    {let _2 =                         ( CLeq ) in
      ( CompareExpression (_1, _2, _3) )}
| _1 = expression _1_inlined1 = GREATEREQUAL _3 = expression
    {let _2 =                         ( CGeq ) in
      ( CompareExpression (_1, _2, _3) )}
| _1 = expression _2 = EQUAL _3 = expression
    {      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1.contents with
          | TupleExpression [Some (e)] ->
              { _1 with contents = TupleExpression [Some (e); None] }
          | _e ->
              _1
        in
        AssignExpression (lexp, _3) )}
| _1 = expression _1_inlined1 = PIPEEQUAL _3 = expression
    {let _2 =                         ( BOr ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1.contents with
          | TupleExpression [Some (e)] ->
              { _1 with contents = TupleExpression [Some (e); None] }
          | _e ->
              _1
        in
        AssignBinaryExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = XOREQUAL _3 = expression
    {let _2 =                         ( BXor ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1.contents with
          | TupleExpression [Some (e)] ->
              { _1 with contents = TupleExpression [Some (e); None] }
          | _e ->
              _1
        in
        AssignBinaryExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = AMPEREQUAL _3 = expression
    {let _2 =                         ( BAnd ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1.contents with
          | TupleExpression [Some (e)] ->
              { _1 with contents = TupleExpression [Some (e); None] }
          | _e ->
              _1
        in
        AssignBinaryExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = LESSLESSEQUAL _3 = expression
    {let _2 =                         ( BLShift ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1.contents with
          | TupleExpression [Some (e)] ->
              { _1 with contents = TupleExpression [Some (e); None] }
          | _e ->
              _1
        in
        AssignBinaryExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = GREATERGREATEREQUAL _3 = expression
    {let _2 =                         ( BRShift ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1.contents with
          | TupleExpression [Some (e)] ->
              { _1 with contents = TupleExpression [Some (e); None] }
          | _e ->
              _1
        in
        AssignBinaryExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = PLUSEQUAL _3 = expression
    {let _2 =                         ( BPlus ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1.contents with
          | TupleExpression [Some (e)] ->
              { _1 with contents = TupleExpression [Some (e); None] }
          | _e ->
              _1
        in
        AssignBinaryExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = MINUSEQUAL _3 = expression
    {let _2 =                         ( BMinus ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1.contents with
          | TupleExpression [Some (e)] ->
              { _1 with contents = TupleExpression [Some (e); None] }
          | _e ->
              _1
        in
        AssignBinaryExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = STAREQUAL _3 = expression
    {let _2 =                         ( BTimes ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1.contents with
          | TupleExpression [Some (e)] ->
              { _1 with contents = TupleExpression [Some (e); None] }
          | _e ->
              _1
        in
        AssignBinaryExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = DIVEQUAL _3 = expression
    {let _2 =                         ( BDiv ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1.contents with
          | TupleExpression [Some (e)] ->
              { _1 with contents = TupleExpression [Some (e); None] }
          | _e ->
              _1
        in
        AssignBinaryExpression (lexp, _2, _3) )}
| _1 = expression _1_inlined1 = PERCENTEQUAL _3 = expression
    {let _2 =                         ( BMod ) in
      ( (* When used on the left side of an assignment,
           (exp,) is understood as a 2-element tuple,
           so we undo the 1-element tuple trick *)
        let lexp = match _1.contents with
          | TupleExpression [Some (e)] ->
              { _1 with contents = TupleExpression [Some (e); None] }
          | _e ->
              _1
        in
        AssignBinaryExpression (lexp, _2, _3) )}
| _1 = expression _2 = QUESTION _3 = expression _4 = COLON _5 = expression
    {      ( IfExpression (_1, _3, _5) )}

inc_dec_op:
  _1 = PLUSPLUS
    {               ( UInc )}
| _1 = MINUSMINUS
    {               ( UDec )}

unop:
  _1 = BANG
    {           ( UNot )}
| _1 = NOT
    {           ( ULNot )}
| _1 = PLUS
    {           ( UPlus )}
| _1 = MINUS
    {           ( UMinus )}
| _1 = DELETE
    {           ( UDelete )}

literal_expression:
  _1 = BOOLEANLITERAL
    {                       ( BooleanLiteral (_1) )}
| _1 = ADDRESSLITERAL
    {                       ( AddressLiteral (_1) )}
| _1 = STRINGLITERAL
    {                       ( StringLiteral (_1) )}
| _1 = HEXSTRINGLITERAL
    {                       ( StringLiteral (_1) )}
| _1 = NUMBER
    {                       ( NumberLiteral (decimal_to_rational _1, Unit, None) )}
| _1 = NUMBER _2 = NUMBERUNIT
    {                       ( NumberLiteral (decimal_to_rational _1, _2, None) )}
| _1 = HEXNUMBER
    {                       ( NumberLiteral (Q.make (Z.of_string ("0x" ^ _1)) Z.one,
                                        Unit, Some (String.length _1)) )}

function_call:
  _1 = expression _2 = LPAREN _3 = function_call_arguments _4 = RPAREN
    {                                                     ( (_1, _3) )}

function_call_arguments:
  _1 = expression_list
    {                                           ( ExpressionList (_1) )}
| _1 = LBRACE _2 = name_value_nonempty_list _3 = RBRACE
    {                                           ( NameValueList (_2) )}

name_value_nonempty_list:
  _1 = separated_or_terminated_nonempty_list_COMMA_name_value_
    {                                                             ( _1 )}

name_value:
  _1 = identifier _2 = COLON _3 = expression
    {                                ( (_1, _3) )}

tuple_expression:
  _1 = LPAREN _2 = RPAREN
    {                                        ( TupleExpression ([]) )}
| _1 = LPAREN _2 = expression _3 = COMMA _4 = RPAREN
    {                                        ( TupleExpression ([Some (_2)]) )}
| _1 = LPAREN _2 = expression_opt_nontrivial_list _3 = RPAREN
    {                                                 ( TupleExpression (_2) )}

expression_opt_nontrivial_list:
  _1 = expression _2 = COMMA %prec below_paren
    {                                       ( [Some (_1); None] )}
| _1 = expression _2 = COMMA _3 = expression
    {                                       ( [Some (_1); Some (_3)] )}
| _1 = comma_nonempty_list _2 = option_expression_
    {                                       ( put_in_none_list [_2] _1 )}
| _1 = expression_opt_nontrivial_list _2 = COMMA _3 = option_expression_
    {                                                     ( _1 @ [_3] )}

identifier:
  _1 = identifier_raw
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                     ( mk _loc _1 )
in
                   ( _1 )}

identifier_raw:
  _1 = IDENTIFIER
    {                ( _1 )}
| _1 = FROM
    {                ( Ident.of_string "from" )}
| _1 = CONSTRUCTOR
    {                ( Ident.of_string "constructor" )}
| _1 = RECEIVE
    {                ( Ident.of_string "receive" )}
| _1 = FALLBACK
    {                ( Ident.of_string "fallback" )}

separated_or_terminated_nonempty_list_COMMA_name_value_:
  x = name_value
    {      ( [x] )}
| x = name_value _2 = COMMA
    {      ( [x] )}
| x = name_value _2 = COMMA xs = separated_or_terminated_nonempty_list_COMMA_name_value_
    {      ( x :: xs )}

separated_and_terminated_nonempty_list_SEMI_pair_type_name_identifier__:
  x = type_name y = identifier _2 = SEMI
    {let x =     ( (x, y) ) in
      ( [x] )}
| x = type_name y = identifier _2 = SEMI xs = separated_and_terminated_nonempty_list_SEMI_pair_type_name_identifier__
    {let x =     ( (x, y) ) in
      ( x :: xs )}

%%


