State 0:
## Known stack suffix:
##
## LR(1) items:
input' -> . input [ # ]
## Transitions:
-- On UPDATE shift to state 1
-- On SET shift to state 6
-- On SELECT shift to state 26
-- On REPLACE shift to state 302
-- On INSERT shift to state 304
-- On DROP shift to state 312
-- On DELETE shift to state 319
-- On CREATE shift to state 323
-- On ALTER shift to state 551
-- On update_cmd shift to state 605
-- On statement shift to state 701
-- On select_stmt shift to state 629
-- On select_core shift to state 58
-- On insert_cmd shift to state 631
-- On input shift to state 703
## Reductions:

State 1:
## Known stack suffix:
## UPDATE
## LR(1) items:
update_cmd -> UPDATE . [ LPAREN IDENT ]
update_cmd -> UPDATE . OR conflict_algo [ LPAREN IDENT ]
## Transitions:
-- On OR shift to state 2
## Reductions:
-- On LPAREN reduce production update_cmd -> UPDATE
-- On IDENT reduce production update_cmd -> UPDATE

State 2:
## Known stack suffix:
## UPDATE OR
## LR(1) items:
update_cmd -> UPDATE OR . conflict_algo [ LPAREN IDENT ]
## Transitions:
-- On REPLACE shift to state 3
-- On CONFLICT_ALGO shift to state 4
-- On conflict_algo shift to state 5
## Reductions:

State 3:
## Known stack suffix:
## REPLACE
## LR(1) items:
conflict_algo -> REPLACE . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN INTO INSERT IDENT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production conflict_algo -> REPLACE

State 4:
## Known stack suffix:
## CONFLICT_ALGO
## LR(1) items:
conflict_algo -> CONFLICT_ALGO . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN INTO INSERT IDENT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production conflict_algo -> CONFLICT_ALGO

State 5:
## Known stack suffix:
## UPDATE OR conflict_algo
## LR(1) items:
update_cmd -> UPDATE OR conflict_algo . [ LPAREN IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production update_cmd -> UPDATE OR conflict_algo

State 6:
## Known stack suffix:
## SET
## LR(1) items:
statement -> SET . IDENT EQUAL expr [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 7
## Reductions:

State 7:
## Known stack suffix:
## SET IDENT
## LR(1) items:
statement -> SET IDENT . EQUAL expr [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On EQUAL shift to state 8
## Reductions:

State 8:
## Known stack suffix:
## SET IDENT EQUAL
## LR(1) items:
statement -> SET IDENT EQUAL . expr [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 301
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 9:
## Known stack suffix:
## VALUES
## LR(1) items:
expr -> VALUES . LPAREN IDENT RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On LPAREN shift to state 10
## Reductions:

State 10:
## Known stack suffix:
## VALUES LPAREN
## LR(1) items:
expr -> VALUES LPAREN . IDENT RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On IDENT shift to state 11
## Reductions:

State 11:
## Known stack suffix:
## VALUES LPAREN IDENT
## LR(1) items:
expr -> VALUES LPAREN IDENT . RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On RPAREN shift to state 12
## Reductions:

State 12:
## Known stack suffix:
## VALUES LPAREN IDENT RPAREN
## LR(1) items:
expr -> VALUES LPAREN IDENT RPAREN . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> VALUES LPAREN IDENT RPAREN

State 13:
## Known stack suffix:
## TRUE
## LR(1) items:
literal_value -> TRUE . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal_value -> TRUE

State 14:
## Known stack suffix:
## TIMESTAMP
## LR(1) items:
literal_value -> TIMESTAMP . TEXT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
-- On TEXT shift to state 15
## Reductions:

State 15:
## Known stack suffix:
## TIMESTAMP TEXT
## LR(1) items:
literal_value -> TIMESTAMP TEXT . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal_value -> TIMESTAMP TEXT

State 16:
## Known stack suffix:
## TIME
## LR(1) items:
literal_value -> TIME . TEXT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
-- On TEXT shift to state 17
## Reductions:

State 17:
## Known stack suffix:
## TIME TEXT
## LR(1) items:
literal_value -> TIME TEXT . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal_value -> TIME TEXT

State 18:
## Known stack suffix:
## TILDE
## LR(1) items:
unary_op -> TILDE . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_op -> TILDE

State 19:
## Known stack suffix:
## TEXT
## LR(1) items:
literal_value -> TEXT . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal_value -> TEXT

State 20:
## Known stack suffix:
## PARAM
## LR(1) items:
expr -> PARAM . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> PARAM

State 21:
## Known stack suffix:
## NULL
## LR(1) items:
literal_value -> NULL . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal_value -> NULL

State 22:
## Known stack suffix:
## NOT
## LR(1) items:
mnot(EXISTS) -> NOT . EXISTS [ LPAREN ]
unary_op -> NOT . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
-- On EXISTS shift to state 23
## Reductions:
-- On VALUES reduce production unary_op -> NOT
-- On TRUE reduce production unary_op -> NOT
-- On TIMESTAMP reduce production unary_op -> NOT
-- On TIME reduce production unary_op -> NOT
-- On TILDE reduce production unary_op -> NOT
-- On TEXT reduce production unary_op -> NOT
-- On PARAM reduce production unary_op -> NOT
-- On NULL reduce production unary_op -> NOT
-- On NOT reduce production unary_op -> NOT
-- On MINUS reduce production unary_op -> NOT
-- On LPAREN reduce production unary_op -> NOT
-- On INTERVAL reduce production unary_op -> NOT
-- On INTEGER reduce production unary_op -> NOT
-- On IF reduce production unary_op -> NOT
-- On IDENT reduce production unary_op -> NOT
-- On FLOAT reduce production unary_op -> NOT
-- On FALSE reduce production unary_op -> NOT
-- On EXCL reduce production unary_op -> NOT
-- On DATETIME_FUNC reduce production unary_op -> NOT
-- On DATE reduce production unary_op -> NOT
-- On CASE reduce production unary_op -> NOT
-- On BLOB reduce production unary_op -> NOT

State 23:
## Known stack suffix:
## NOT EXISTS
## LR(1) items:
mnot(EXISTS) -> NOT EXISTS . [ LPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mnot(EXISTS) -> NOT EXISTS

State 24:
## Known stack suffix:
## MINUS
## LR(1) items:
expr -> MINUS . expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 300
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 25:
## Known stack suffix:
## LPAREN
## LR(1) items:
expr -> LPAREN . expr RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> LPAREN . select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On SELECT shift to state 26
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On select_stmt shift to state 296
-- On select_core shift to state 58
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 298
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 26:
## Known stack suffix:
## SELECT
## LR(1) items:
select_core -> SELECT . option(select_type) separated_nonempty_list(COMMA,column1) option(from) option(where) loption(group) option(having) [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On DISTINCT shift to state 27
-- On ALL shift to state 28
-- On select_type shift to state 29
-- On option(select_type) shift to state 30
## Reductions:
-- On VALUES reduce production option(select_type) ->
-- On TRUE reduce production option(select_type) ->
-- On TIMESTAMP reduce production option(select_type) ->
-- On TIME reduce production option(select_type) ->
-- On TILDE reduce production option(select_type) ->
-- On TEXT reduce production option(select_type) ->
-- On PARAM reduce production option(select_type) ->
-- On NULL reduce production option(select_type) ->
-- On NOT reduce production option(select_type) ->
-- On MINUS reduce production option(select_type) ->
-- On LPAREN reduce production option(select_type) ->
-- On INTERVAL reduce production option(select_type) ->
-- On INTEGER reduce production option(select_type) ->
-- On IF reduce production option(select_type) ->
-- On IDENT reduce production option(select_type) ->
-- On FLOAT reduce production option(select_type) ->
-- On FALSE reduce production option(select_type) ->
-- On EXISTS reduce production option(select_type) ->
-- On EXCL reduce production option(select_type) ->
-- On DATETIME_FUNC reduce production option(select_type) ->
-- On DATE reduce production option(select_type) ->
-- On CASE reduce production option(select_type) ->
-- On BLOB reduce production option(select_type) ->
-- On ASTERISK reduce production option(select_type) ->

State 27:
## Known stack suffix:
## DISTINCT
## LR(1) items:
select_type -> DISTINCT . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ASTERISK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production select_type -> DISTINCT

State 28:
## Known stack suffix:
## ALL
## LR(1) items:
select_type -> ALL . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ASTERISK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production select_type -> ALL

State 29:
## Known stack suffix:
## select_type
## LR(1) items:
option(select_type) -> select_type . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ASTERISK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(select_type) -> select_type

State 30:
## Known stack suffix:
## SELECT option(select_type)
## LR(1) items:
select_core -> SELECT option(select_type) . separated_nonempty_list(COMMA,column1) option(from) option(where) loption(group) option(having) [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 233
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On ASTERISK shift to state 236
-- On unary_op shift to state 53
-- On separated_nonempty_list(COMMA,column1) shift to state 237
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 291
-- On datetime_value shift to state 115
-- On column1 shift to state 293
-- On attr_name shift to state 116
## Reductions:

State 31:
## Known stack suffix:
## INTERVAL
## LR(1) items:
expr -> INTERVAL . expr interval_unit [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 211
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 32:
## Known stack suffix:
## INTEGER
## LR(1) items:
literal_value -> INTEGER . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal_value -> INTEGER

State 33:
## Known stack suffix:
## IF
## LR(1) items:
expr -> IF . LPAREN expr COMMA expr COMMA expr RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On LPAREN shift to state 34
## Reductions:

State 34:
## Known stack suffix:
## IF LPAREN
## LR(1) items:
expr -> IF LPAREN . expr COMMA expr COMMA expr RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 205
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 35:
## Known stack suffix:
## IDENT
## LR(1) items:
attr_name -> IDENT . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
attr_name -> IDENT . DOT IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
attr_name -> IDENT . DOT IDENT DOT IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> IDENT . LPAREN func_params RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On LPAREN shift to state 36
-- On DOT shift to state 201
## Reductions:
-- On YEAR_MONTH reduce production attr_name -> IDENT
-- On YEAR reduce production attr_name -> IDENT
-- On WHERE reduce production attr_name -> IDENT
-- On WHEN reduce production attr_name -> IDENT
-- On WEEK reduce production attr_name -> IDENT
-- On UPDATE reduce production attr_name -> IDENT
-- On UNION reduce production attr_name -> IDENT
-- On THEN reduce production attr_name -> IDENT
-- On SET reduce production attr_name -> IDENT
-- On SELECT reduce production attr_name -> IDENT
-- On SECOND_MICROSECOND reduce production attr_name -> IDENT
-- On SECOND reduce production attr_name -> IDENT
-- On RPAREN reduce production attr_name -> IDENT
-- On REPLACE reduce production attr_name -> IDENT
-- On QUARTER reduce production attr_name -> IDENT
-- On PLUS reduce production attr_name -> IDENT
-- On ORDER reduce production attr_name -> IDENT
-- On OR reduce production attr_name -> IDENT
-- On ON reduce production attr_name -> IDENT
-- On NUM_EQ_OP reduce production attr_name -> IDENT
-- On NUM_DIV_OP reduce production attr_name -> IDENT
-- On NUM_CMP_OP reduce production attr_name -> IDENT
-- On NUM_BIT_OP reduce production attr_name -> IDENT
-- On NOT_DISTINCT_OP reduce production attr_name -> IDENT
-- On NOT reduce production attr_name -> IDENT
-- On NATURAL reduce production attr_name -> IDENT
-- On MONTH reduce production attr_name -> IDENT
-- On MINUTE_SECOND reduce production attr_name -> IDENT
-- On MINUTE_MICROSECOND reduce production attr_name -> IDENT
-- On MINUTE reduce production attr_name -> IDENT
-- On MINUS reduce production attr_name -> IDENT
-- On MICROSECOND reduce production attr_name -> IDENT
-- On LOCK reduce production attr_name -> IDENT
-- On LIMIT reduce production attr_name -> IDENT
-- On LIKE_OP reduce production attr_name -> IDENT
-- On LIKE reduce production attr_name -> IDENT
-- On JOIN_TYPE2 reduce production attr_name -> IDENT
-- On JOIN_TYPE1 reduce production attr_name -> IDENT
-- On JOIN reduce production attr_name -> IDENT
-- On IS reduce production attr_name -> IDENT
-- On INTERSECT reduce production attr_name -> IDENT
-- On INSERT reduce production attr_name -> IDENT
-- On IN reduce production attr_name -> IDENT
-- On IDENT reduce production attr_name -> IDENT
-- On HOUR_SECOND reduce production attr_name -> IDENT
-- On HOUR_MINUTE reduce production attr_name -> IDENT
-- On HOUR_MICROSECOND reduce production attr_name -> IDENT
-- On HOUR reduce production attr_name -> IDENT
-- On HAVING reduce production attr_name -> IDENT
-- On GROUP reduce production attr_name -> IDENT
-- On FROM reduce production attr_name -> IDENT
-- On FOR reduce production attr_name -> IDENT
-- On EXCEPT reduce production attr_name -> IDENT
-- On ESCAPE reduce production attr_name -> IDENT
-- On EQUAL reduce production attr_name -> IDENT
-- On EOF reduce production attr_name -> IDENT
-- On END reduce production attr_name -> IDENT
-- On ELSE reduce production attr_name -> IDENT
-- On DROP reduce production attr_name -> IDENT
-- On DESC reduce production attr_name -> IDENT
-- On DELETE reduce production attr_name -> IDENT
-- On DAY_SECOND reduce production attr_name -> IDENT
-- On DAY_MINUTE reduce production attr_name -> IDENT
-- On DAY_MICROSECOND reduce production attr_name -> IDENT
-- On DAY_HOUR reduce production attr_name -> IDENT
-- On DAY reduce production attr_name -> IDENT
-- On CROSS reduce production attr_name -> IDENT
-- On CREATE reduce production attr_name -> IDENT
-- On CONCAT_OP reduce production attr_name -> IDENT
-- On COMMA reduce production attr_name -> IDENT
-- On BETWEEN reduce production attr_name -> IDENT
-- On ASTERISK reduce production attr_name -> IDENT
-- On ASC reduce production attr_name -> IDENT
-- On AS reduce production attr_name -> IDENT
-- On AND reduce production attr_name -> IDENT
-- On ALTER reduce production attr_name -> IDENT

State 36:
## Known stack suffix:
## IDENT LPAREN
## LR(1) items:
expr -> IDENT LPAREN . func_params RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On DISTINCT shift to state 37
-- On ASTERISK shift to state 38
-- On option(DISTINCT) shift to state 39
-- On func_params shift to state 199
## Reductions:
-- On VALUES reduce production option(DISTINCT) ->
-- On TRUE reduce production option(DISTINCT) ->
-- On TIMESTAMP reduce production option(DISTINCT) ->
-- On TIME reduce production option(DISTINCT) ->
-- On TILDE reduce production option(DISTINCT) ->
-- On TEXT reduce production option(DISTINCT) ->
-- On RPAREN reduce production func_params ->
-- On PARAM reduce production option(DISTINCT) ->
-- On NULL reduce production option(DISTINCT) ->
-- On NOT reduce production option(DISTINCT) ->
-- On MINUS reduce production option(DISTINCT) ->
-- On LPAREN reduce production option(DISTINCT) ->
-- On INTERVAL reduce production option(DISTINCT) ->
-- On INTEGER reduce production option(DISTINCT) ->
-- On IF reduce production option(DISTINCT) ->
-- On IDENT reduce production option(DISTINCT) ->
-- On FLOAT reduce production option(DISTINCT) ->
-- On FALSE reduce production option(DISTINCT) ->
-- On EXISTS reduce production option(DISTINCT) ->
-- On EXCL reduce production option(DISTINCT) ->
-- On DATETIME_FUNC reduce production option(DISTINCT) ->
-- On DATE reduce production option(DISTINCT) ->
-- On CASE reduce production option(DISTINCT) ->
-- On BLOB reduce production option(DISTINCT) ->

State 37:
## Known stack suffix:
## DISTINCT
## LR(1) items:
option(DISTINCT) -> DISTINCT . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(DISTINCT) -> DISTINCT

State 38:
## Known stack suffix:
## ASTERISK
## LR(1) items:
func_params -> ASTERISK . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production func_params -> ASTERISK

State 39:
## Known stack suffix:
## option(DISTINCT)
## LR(1) items:
func_params -> option(DISTINCT) . expr_list [ RPAREN ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On separated_nonempty_list(COMMA,expr) shift to state 197
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr_list shift to state 198
-- On expr shift to state 112
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 40:
## Known stack suffix:
## FLOAT
## LR(1) items:
literal_value -> FLOAT . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal_value -> FLOAT

State 41:
## Known stack suffix:
## FALSE
## LR(1) items:
literal_value -> FALSE . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal_value -> FALSE

State 42:
## Known stack suffix:
## EXISTS
## LR(1) items:
mnot(EXISTS) -> EXISTS . [ LPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mnot(EXISTS) -> EXISTS

State 43:
## Known stack suffix:
## EXCL
## LR(1) items:
unary_op -> EXCL . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production unary_op -> EXCL

State 44:
## Known stack suffix:
## DATETIME_FUNC
## LR(1) items:
datetime_value -> DATETIME_FUNC . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
datetime_value -> DATETIME_FUNC . LPAREN option(INTEGER) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
-- On LPAREN shift to state 45
## Reductions:
-- On YEAR_MONTH reduce production datetime_value -> DATETIME_FUNC
-- On YEAR reduce production datetime_value -> DATETIME_FUNC
-- On WHERE reduce production datetime_value -> DATETIME_FUNC
-- On WHEN reduce production datetime_value -> DATETIME_FUNC
-- On WEEK reduce production datetime_value -> DATETIME_FUNC
-- On UPDATE reduce production datetime_value -> DATETIME_FUNC
-- On UNIQUE reduce production datetime_value -> DATETIME_FUNC
-- On UNION reduce production datetime_value -> DATETIME_FUNC
-- On THEN reduce production datetime_value -> DATETIME_FUNC
-- On SET reduce production datetime_value -> DATETIME_FUNC
-- On SELECT reduce production datetime_value -> DATETIME_FUNC
-- On SECOND_MICROSECOND reduce production datetime_value -> DATETIME_FUNC
-- On SECOND reduce production datetime_value -> DATETIME_FUNC
-- On RPAREN reduce production datetime_value -> DATETIME_FUNC
-- On REPLACE reduce production datetime_value -> DATETIME_FUNC
-- On QUARTER reduce production datetime_value -> DATETIME_FUNC
-- On PRIMARY reduce production datetime_value -> DATETIME_FUNC
-- On PLUS reduce production datetime_value -> DATETIME_FUNC
-- On ORDER reduce production datetime_value -> DATETIME_FUNC
-- On OR reduce production datetime_value -> DATETIME_FUNC
-- On ON reduce production datetime_value -> DATETIME_FUNC
-- On NUM_EQ_OP reduce production datetime_value -> DATETIME_FUNC
-- On NUM_DIV_OP reduce production datetime_value -> DATETIME_FUNC
-- On NUM_CMP_OP reduce production datetime_value -> DATETIME_FUNC
-- On NUM_BIT_OP reduce production datetime_value -> DATETIME_FUNC
-- On NULL reduce production datetime_value -> DATETIME_FUNC
-- On NOT_DISTINCT_OP reduce production datetime_value -> DATETIME_FUNC
-- On NOT reduce production datetime_value -> DATETIME_FUNC
-- On NATURAL reduce production datetime_value -> DATETIME_FUNC
-- On MONTH reduce production datetime_value -> DATETIME_FUNC
-- On MINUTE_SECOND reduce production datetime_value -> DATETIME_FUNC
-- On MINUTE_MICROSECOND reduce production datetime_value -> DATETIME_FUNC
-- On MINUTE reduce production datetime_value -> DATETIME_FUNC
-- On MINUS reduce production datetime_value -> DATETIME_FUNC
-- On MICROSECOND reduce production datetime_value -> DATETIME_FUNC
-- On LOCK reduce production datetime_value -> DATETIME_FUNC
-- On LIMIT reduce production datetime_value -> DATETIME_FUNC
-- On LIKE_OP reduce production datetime_value -> DATETIME_FUNC
-- On LIKE reduce production datetime_value -> DATETIME_FUNC
-- On JOIN_TYPE2 reduce production datetime_value -> DATETIME_FUNC
-- On JOIN_TYPE1 reduce production datetime_value -> DATETIME_FUNC
-- On JOIN reduce production datetime_value -> DATETIME_FUNC
-- On IS reduce production datetime_value -> DATETIME_FUNC
-- On INTERSECT reduce production datetime_value -> DATETIME_FUNC
-- On INSERT reduce production datetime_value -> DATETIME_FUNC
-- On IN reduce production datetime_value -> DATETIME_FUNC
-- On IDENT reduce production datetime_value -> DATETIME_FUNC
-- On HOUR_SECOND reduce production datetime_value -> DATETIME_FUNC
-- On HOUR_MINUTE reduce production datetime_value -> DATETIME_FUNC
-- On HOUR_MICROSECOND reduce production datetime_value -> DATETIME_FUNC
-- On HOUR reduce production datetime_value -> DATETIME_FUNC
-- On HAVING reduce production datetime_value -> DATETIME_FUNC
-- On GROUP reduce production datetime_value -> DATETIME_FUNC
-- On FROM reduce production datetime_value -> DATETIME_FUNC
-- On FOR reduce production datetime_value -> DATETIME_FUNC
-- On FIRST reduce production datetime_value -> DATETIME_FUNC
-- On EXCEPT reduce production datetime_value -> DATETIME_FUNC
-- On ESCAPE reduce production datetime_value -> DATETIME_FUNC
-- On EQUAL reduce production datetime_value -> DATETIME_FUNC
-- On EOF reduce production datetime_value -> DATETIME_FUNC
-- On END reduce production datetime_value -> DATETIME_FUNC
-- On ELSE reduce production datetime_value -> DATETIME_FUNC
-- On DROP reduce production datetime_value -> DATETIME_FUNC
-- On DESC reduce production datetime_value -> DATETIME_FUNC
-- On DELETE reduce production datetime_value -> DATETIME_FUNC
-- On DEFAULT reduce production datetime_value -> DATETIME_FUNC
-- On DAY_SECOND reduce production datetime_value -> DATETIME_FUNC
-- On DAY_MINUTE reduce production datetime_value -> DATETIME_FUNC
-- On DAY_MICROSECOND reduce production datetime_value -> DATETIME_FUNC
-- On DAY_HOUR reduce production datetime_value -> DATETIME_FUNC
-- On DAY reduce production datetime_value -> DATETIME_FUNC
-- On CROSS reduce production datetime_value -> DATETIME_FUNC
-- On CREATE reduce production datetime_value -> DATETIME_FUNC
-- On CONCAT_OP reduce production datetime_value -> DATETIME_FUNC
-- On COMMA reduce production datetime_value -> DATETIME_FUNC
-- On COLLATE reduce production datetime_value -> DATETIME_FUNC
-- On CHECK reduce production datetime_value -> DATETIME_FUNC
-- On BETWEEN reduce production datetime_value -> DATETIME_FUNC
-- On AUTOINCREMENT reduce production datetime_value -> DATETIME_FUNC
-- On ASTERISK reduce production datetime_value -> DATETIME_FUNC
-- On ASC reduce production datetime_value -> DATETIME_FUNC
-- On AS reduce production datetime_value -> DATETIME_FUNC
-- On AND reduce production datetime_value -> DATETIME_FUNC
-- On ALTER reduce production datetime_value -> DATETIME_FUNC
-- On AFTER reduce production datetime_value -> DATETIME_FUNC

State 45:
## Known stack suffix:
## DATETIME_FUNC LPAREN
## LR(1) items:
datetime_value -> DATETIME_FUNC LPAREN . option(INTEGER) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
-- On INTEGER shift to state 46
-- On option(INTEGER) shift to state 47
## Reductions:
-- On RPAREN reduce production option(INTEGER) ->

State 46:
## Known stack suffix:
## INTEGER
## LR(1) items:
option(INTEGER) -> INTEGER . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(INTEGER) -> INTEGER

State 47:
## Known stack suffix:
## DATETIME_FUNC LPAREN option(INTEGER)
## LR(1) items:
datetime_value -> DATETIME_FUNC LPAREN option(INTEGER) . RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
-- On RPAREN shift to state 48
## Reductions:

State 48:
## Known stack suffix:
## DATETIME_FUNC LPAREN option(INTEGER) RPAREN
## LR(1) items:
datetime_value -> DATETIME_FUNC LPAREN option(INTEGER) RPAREN . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production datetime_value -> DATETIME_FUNC LPAREN option(INTEGER) RPAREN

State 49:
## Known stack suffix:
## DATE
## LR(1) items:
literal_value -> DATE . TEXT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
-- On TEXT shift to state 50
## Reductions:

State 50:
## Known stack suffix:
## DATE TEXT
## LR(1) items:
literal_value -> DATE TEXT . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal_value -> DATE TEXT

State 51:
## Known stack suffix:
## CASE
## LR(1) items:
expr -> CASE . option(expr) nonempty_list(case_branch) option(preceded(ELSE,expr)) END [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On option(expr) shift to state 184
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 196
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:
-- On WHEN reduce production option(expr) ->

State 52:
## Known stack suffix:
## BLOB
## LR(1) items:
literal_value -> BLOB . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNIQUE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PRIMARY PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NULL NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR FIRST EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DEFAULT DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA COLLATE CHECK BETWEEN AUTOINCREMENT ASTERISK ASC AS AND ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production literal_value -> BLOB

State 53:
## Known stack suffix:
## unary_op
## LR(1) items:
expr -> unary_op . expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 183
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 54:
## Known stack suffix:
## mnot(EXISTS)
## LR(1) items:
expr -> mnot(EXISTS) . LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On LPAREN shift to state 55
## Reductions:

State 55:
## Known stack suffix:
## mnot(EXISTS) LPAREN
## LR(1) items:
expr -> mnot(EXISTS) LPAREN . select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On SELECT shift to state 26
-- On select_stmt shift to state 56
-- On select_core shift to state 58
## Reductions:

State 56:
## Known stack suffix:
## mnot(EXISTS) LPAREN select_stmt
## LR(1) items:
expr -> mnot(EXISTS) LPAREN select_stmt . RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On RPAREN shift to state 57
## Reductions:

State 57:
## Known stack suffix:
## mnot(EXISTS) LPAREN select_stmt RPAREN
## LR(1) items:
expr -> mnot(EXISTS) LPAREN select_stmt RPAREN . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> mnot(EXISTS) LPAREN select_stmt RPAREN

State 58:
## Known stack suffix:
## select_core
## LR(1) items:
select_stmt -> select_core . list(preceded(compound_op,select_core)) loption(order) option(limit_t) option(select_row_locking) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On UNION shift to state 59
-- On INTERSECT shift to state 62
-- On EXCEPT shift to state 63
-- On list(preceded(compound_op,select_core)) shift to state 64
-- On compound_op shift to state 180
## Reductions:
-- On UPDATE reduce production list(preceded(compound_op,select_core)) ->
-- On SET reduce production list(preceded(compound_op,select_core)) ->
-- On SELECT reduce production list(preceded(compound_op,select_core)) ->
-- On RPAREN reduce production list(preceded(compound_op,select_core)) ->
-- On REPLACE reduce production list(preceded(compound_op,select_core)) ->
-- On ORDER reduce production list(preceded(compound_op,select_core)) ->
-- On ON reduce production list(preceded(compound_op,select_core)) ->
-- On LOCK reduce production list(preceded(compound_op,select_core)) ->
-- On LIMIT reduce production list(preceded(compound_op,select_core)) ->
-- On INSERT reduce production list(preceded(compound_op,select_core)) ->
-- On FOR reduce production list(preceded(compound_op,select_core)) ->
-- On EOF reduce production list(preceded(compound_op,select_core)) ->
-- On END reduce production list(preceded(compound_op,select_core)) ->
-- On DROP reduce production list(preceded(compound_op,select_core)) ->
-- On DELETE reduce production list(preceded(compound_op,select_core)) ->
-- On CREATE reduce production list(preceded(compound_op,select_core)) ->
-- On ALTER reduce production list(preceded(compound_op,select_core)) ->

State 59:
## Known stack suffix:
## UNION
## LR(1) items:
compound_op -> UNION . option(ALL) [ SELECT ]
## Transitions:
-- On ALL shift to state 60
-- On option(ALL) shift to state 61
## Reductions:
-- On SELECT reduce production option(ALL) ->

State 60:
## Known stack suffix:
## ALL
## LR(1) items:
option(ALL) -> ALL . [ SELECT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(ALL) -> ALL

State 61:
## Known stack suffix:
## UNION option(ALL)
## LR(1) items:
compound_op -> UNION option(ALL) . [ SELECT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production compound_op -> UNION option(ALL)

State 62:
## Known stack suffix:
## INTERSECT
## LR(1) items:
compound_op -> INTERSECT . [ SELECT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production compound_op -> INTERSECT

State 63:
## Known stack suffix:
## EXCEPT
## LR(1) items:
compound_op -> EXCEPT . [ SELECT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production compound_op -> EXCEPT

State 64:
## Known stack suffix:
## select_core list(preceded(compound_op,select_core))
## LR(1) items:
select_stmt -> select_core list(preceded(compound_op,select_core)) . loption(order) option(limit_t) option(select_row_locking) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On ORDER shift to state 65
-- On order shift to state 140
-- On loption(order) shift to state 141
## Reductions:
-- On UPDATE reduce production loption(order) ->
-- On SET reduce production loption(order) ->
-- On SELECT reduce production loption(order) ->
-- On RPAREN reduce production loption(order) ->
-- On REPLACE reduce production loption(order) ->
-- On ON reduce production loption(order) ->
-- On LOCK reduce production loption(order) ->
-- On LIMIT reduce production loption(order) ->
-- On INSERT reduce production loption(order) ->
-- On FOR reduce production loption(order) ->
-- On EOF reduce production loption(order) ->
-- On END reduce production loption(order) ->
-- On DROP reduce production loption(order) ->
-- On DELETE reduce production loption(order) ->
-- On CREATE reduce production loption(order) ->
-- On ALTER reduce production loption(order) ->

State 65:
## Known stack suffix:
## ORDER
## LR(1) items:
order -> ORDER . BY separated_nonempty_list(COMMA,terminated(expr,option(order_type))) [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On BY shift to state 66
## Reductions:

State 66:
## Known stack suffix:
## ORDER BY
## LR(1) items:
order -> ORDER BY . separated_nonempty_list(COMMA,terminated(expr,option(order_type))) [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On separated_nonempty_list(COMMA,terminated(expr,option(order_type))) shift to state 67
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 69
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 67:
## Known stack suffix:
## ORDER BY separated_nonempty_list(COMMA,terminated(expr,option(order_type)))
## LR(1) items:
order -> ORDER BY separated_nonempty_list(COMMA,terminated(expr,option(order_type))) . [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production order -> ORDER BY separated_nonempty_list(COMMA,terminated(expr,option(order_type)))

State 68:
## Known stack suffix:
## literal_value
## LR(1) items:
expr -> literal_value . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> literal_value

State 69:
## Known stack suffix:
## expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ UPDATE SET SELECT RPAREN REPLACE PLUS OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INSERT IN FOR EQUAL EOF END DROP DESC DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AND ALTER ]
expr -> expr . boolean_bin_op expr [ UPDATE SET SELECT RPAREN REPLACE PLUS OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INSERT IN FOR EQUAL EOF END DROP DESC DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ UPDATE SET SELECT RPAREN REPLACE PLUS OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INSERT IN FOR EQUAL EOF END DROP DESC DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AND ALTER ]
expr -> expr . CONCAT_OP expr [ UPDATE SET SELECT RPAREN REPLACE PLUS OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INSERT IN FOR EQUAL EOF END DROP DESC DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ UPDATE SET SELECT RPAREN REPLACE PLUS OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INSERT IN FOR EQUAL EOF END DROP DESC DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ UPDATE SET SELECT RPAREN REPLACE PLUS OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INSERT IN FOR EQUAL EOF END DROP DESC DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ UPDATE SET SELECT RPAREN REPLACE PLUS OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INSERT IN FOR EQUAL EOF END DROP DESC DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AND ALTER ]
expr -> expr . IN IDENT [ UPDATE SET SELECT RPAREN REPLACE PLUS OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INSERT IN FOR EQUAL EOF END DROP DESC DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AND ALTER ]
expr -> expr . IS option(NOT) NULL [ UPDATE SET SELECT RPAREN REPLACE PLUS OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INSERT IN FOR EQUAL EOF END DROP DESC DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ UPDATE SET SELECT RPAREN REPLACE PLUS OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INSERT IN FOR EQUAL EOF END DROP DESC DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ UPDATE SET SELECT RPAREN REPLACE PLUS OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INSERT IN FOR EQUAL EOF END DROP DESC DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AND ALTER ]
separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr . option(order_type) [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr . option(order_type) COMMA separated_nonempty_list(COMMA,terminated(expr,option(order_type))) [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On DESC shift to state 134
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On ASC shift to state 135
-- On AND shift to state 105
-- On order_type shift to state 136
-- On option(order_type) shift to state 137
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On UPDATE reduce production option(order_type) ->
-- On SET reduce production option(order_type) ->
-- On SELECT reduce production option(order_type) ->
-- On RPAREN reduce production option(order_type) ->
-- On REPLACE reduce production option(order_type) ->
-- On ON reduce production option(order_type) ->
-- On LOCK reduce production option(order_type) ->
-- On LIMIT reduce production option(order_type) ->
-- On INSERT reduce production option(order_type) ->
-- On FOR reduce production option(order_type) ->
-- On EOF reduce production option(order_type) ->
-- On END reduce production option(order_type) ->
-- On DROP reduce production option(order_type) ->
-- On DELETE reduce production option(order_type) ->
-- On CREATE reduce production option(order_type) ->
-- On COMMA reduce production option(order_type) ->
-- On ALTER reduce production option(order_type) ->

State 70:
## Known stack suffix:
## PLUS
## LR(1) items:
numeric_bin_op -> PLUS . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production numeric_bin_op -> PLUS

State 71:
## Known stack suffix:
## OR
## LR(1) items:
boolean_bin_op -> OR . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production boolean_bin_op -> OR

State 72:
## Known stack suffix:
## NUM_EQ_OP
## LR(1) items:
comparison_op -> NUM_EQ_OP . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT SOME PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ANY ALL ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comparison_op -> NUM_EQ_OP

State 73:
## Known stack suffix:
## NUM_DIV_OP
## LR(1) items:
numeric_bin_op -> NUM_DIV_OP . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production numeric_bin_op -> NUM_DIV_OP

State 74:
## Known stack suffix:
## NUM_CMP_OP
## LR(1) items:
comparison_op -> NUM_CMP_OP . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT SOME PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ANY ALL ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comparison_op -> NUM_CMP_OP

State 75:
## Known stack suffix:
## NUM_BIT_OP
## LR(1) items:
numeric_bin_op -> NUM_BIT_OP . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production numeric_bin_op -> NUM_BIT_OP

State 76:
## Known stack suffix:
## NOT_DISTINCT_OP
## LR(1) items:
comparison_op -> NOT_DISTINCT_OP . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT SOME PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ANY ALL ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comparison_op -> NOT_DISTINCT_OP

State 77:
## Known stack suffix:
## NOT
## LR(1) items:
mnot(BETWEEN) -> NOT . BETWEEN [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
mnot(IN) -> NOT . IN [ LPAREN ]
mnot(like) -> NOT . like [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IN shift to state 80
-- On BETWEEN shift to state 81
-- On like shift to state 82
## Reductions:

State 78:
## Known stack suffix:
## LIKE_OP
## LR(1) items:
like -> LIKE_OP . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production like -> LIKE_OP

State 79:
## Known stack suffix:
## LIKE
## LR(1) items:
like -> LIKE . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production like -> LIKE

State 80:
## Known stack suffix:
## NOT IN
## LR(1) items:
mnot(IN) -> NOT IN . [ LPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mnot(IN) -> NOT IN

State 81:
## Known stack suffix:
## NOT BETWEEN
## LR(1) items:
mnot(BETWEEN) -> NOT BETWEEN . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mnot(BETWEEN) -> NOT BETWEEN

State 82:
## Known stack suffix:
## NOT like
## LR(1) items:
mnot(like) -> NOT like . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mnot(like) -> NOT like

State 83:
## Known stack suffix:
## MINUS
## LR(1) items:
numeric_bin_op -> MINUS . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production numeric_bin_op -> MINUS

State 84:
## Known stack suffix:
## expr IS
## LR(1) items:
expr -> expr IS . option(NOT) NULL [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr IS . option(NOT) option(distinct_from) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On NOT shift to state 85
-- On option(NOT) shift to state 86
## Reductions:
-- On VALUES reduce production option(NOT) ->
-- On TRUE reduce production option(NOT) ->
-- On TIMESTAMP reduce production option(NOT) ->
-- On TIME reduce production option(NOT) ->
-- On TILDE reduce production option(NOT) ->
-- On TEXT reduce production option(NOT) ->
-- On PARAM reduce production option(NOT) ->
-- On NULL reduce production option(NOT) ->
-- On MINUS reduce production option(NOT) ->
-- On LPAREN reduce production option(NOT) ->
-- On INTERVAL reduce production option(NOT) ->
-- On INTEGER reduce production option(NOT) ->
-- On IF reduce production option(NOT) ->
-- On IDENT reduce production option(NOT) ->
-- On FLOAT reduce production option(NOT) ->
-- On FALSE reduce production option(NOT) ->
-- On EXISTS reduce production option(NOT) ->
-- On EXCL reduce production option(NOT) ->
-- On DISTINCT reduce production option(NOT) ->
-- On DATETIME_FUNC reduce production option(NOT) ->
-- On DATE reduce production option(NOT) ->
-- On CASE reduce production option(NOT) ->
-- On BLOB reduce production option(NOT) ->

State 85:
## Known stack suffix:
## NOT
## LR(1) items:
option(NOT) -> NOT . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DISTINCT DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(NOT) -> NOT

State 86:
## Known stack suffix:
## expr IS option(NOT)
## LR(1) items:
expr -> expr IS option(NOT) . NULL [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr IS option(NOT) . option(distinct_from) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On NULL shift to state 87
-- On DISTINCT shift to state 88
-- On option(distinct_from) shift to state 90
-- On distinct_from shift to state 133
## Reductions:
-- On VALUES reduce production option(distinct_from) ->
-- On TRUE reduce production option(distinct_from) ->
-- On TIMESTAMP reduce production option(distinct_from) ->
-- On TIME reduce production option(distinct_from) ->
-- On TILDE reduce production option(distinct_from) ->
-- On TEXT reduce production option(distinct_from) ->
-- On PARAM reduce production option(distinct_from) ->
-- On NOT reduce production option(distinct_from) ->
-- On MINUS reduce production option(distinct_from) ->
-- On LPAREN reduce production option(distinct_from) ->
-- On INTERVAL reduce production option(distinct_from) ->
-- On INTEGER reduce production option(distinct_from) ->
-- On IF reduce production option(distinct_from) ->
-- On IDENT reduce production option(distinct_from) ->
-- On FLOAT reduce production option(distinct_from) ->
-- On FALSE reduce production option(distinct_from) ->
-- On EXISTS reduce production option(distinct_from) ->
-- On EXCL reduce production option(distinct_from) ->
-- On DATETIME_FUNC reduce production option(distinct_from) ->
-- On DATE reduce production option(distinct_from) ->
-- On CASE reduce production option(distinct_from) ->
-- On BLOB reduce production option(distinct_from) ->

State 87:
## Known stack suffix:
## expr IS option(NOT) NULL
## LR(1) items:
expr -> expr IS option(NOT) NULL . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> expr IS option(NOT) NULL

State 88:
## Known stack suffix:
## DISTINCT
## LR(1) items:
distinct_from -> DISTINCT . FROM [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
-- On FROM shift to state 89
## Reductions:

State 89:
## Known stack suffix:
## DISTINCT FROM
## LR(1) items:
distinct_from -> DISTINCT FROM . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production distinct_from -> DISTINCT FROM

State 90:
## Known stack suffix:
## expr IS option(NOT) option(distinct_from)
## LR(1) items:
expr -> expr IS option(NOT) option(distinct_from) . expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 91
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 91:
## Known stack suffix:
## expr IS option(NOT) option(distinct_from) expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . boolean_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . CONCAT_OP expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IN IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) NULL [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr IS option(NOT) option(distinct_from) expr . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On YEAR_MONTH reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On YEAR reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On WHERE reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On WHEN reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On WEEK reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On UPDATE reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On UNION reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On THEN reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On SET reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On SELECT reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On SECOND_MICROSECOND reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On SECOND reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On RPAREN reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On REPLACE reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On QUARTER reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On ORDER reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On ON reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On NATURAL reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On MONTH reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On MINUTE_SECOND reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On MINUTE_MICROSECOND reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On MINUTE reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On MICROSECOND reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On LOCK reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On LIMIT reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On JOIN_TYPE2 reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On JOIN_TYPE1 reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On JOIN reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On INTERSECT reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On INSERT reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On IDENT reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On HOUR_SECOND reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On HOUR_MINUTE reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On HOUR_MICROSECOND reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On HOUR reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On HAVING reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On GROUP reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On FROM reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On FOR reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On EXCEPT reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On ESCAPE reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On EOF reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On END reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On ELSE reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On DROP reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On DESC reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On DELETE reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On DAY_SECOND reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On DAY_MINUTE reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On DAY_MICROSECOND reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On DAY_HOUR reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On DAY reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On CROSS reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On CREATE reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On COMMA reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On ASC reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On AS reduce production expr -> expr IS option(NOT) option(distinct_from) expr
-- On ALTER reduce production expr -> expr IS option(NOT) option(distinct_from) expr

State 92:
## Known stack suffix:
## expr IN
## LR(1) items:
expr -> expr IN . IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
mnot(IN) -> IN . [ LPAREN ]
## Transitions:
-- On IDENT shift to state 93
## Reductions:
-- On LPAREN reduce production mnot(IN) -> IN

State 93:
## Known stack suffix:
## expr IN IDENT
## LR(1) items:
expr -> expr IN IDENT . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> expr IN IDENT

State 94:
## Known stack suffix:
## EQUAL
## LR(1) items:
comparison_op -> EQUAL . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT SOME PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ANY ALL ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comparison_op -> EQUAL

State 95:
## Known stack suffix:
## expr CONCAT_OP
## LR(1) items:
expr -> expr CONCAT_OP . expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 96
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 96:
## Known stack suffix:
## expr CONCAT_OP expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . boolean_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . CONCAT_OP expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr CONCAT_OP expr . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IN IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) NULL [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On NOT shift to state 77
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On BETWEEN shift to state 97
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On YEAR_MONTH reduce production expr -> expr CONCAT_OP expr
-- On YEAR reduce production expr -> expr CONCAT_OP expr
-- On WHERE reduce production expr -> expr CONCAT_OP expr
-- On WHEN reduce production expr -> expr CONCAT_OP expr
-- On WEEK reduce production expr -> expr CONCAT_OP expr
-- On UPDATE reduce production expr -> expr CONCAT_OP expr
-- On UNION reduce production expr -> expr CONCAT_OP expr
-- On THEN reduce production expr -> expr CONCAT_OP expr
-- On SET reduce production expr -> expr CONCAT_OP expr
-- On SELECT reduce production expr -> expr CONCAT_OP expr
-- On SECOND_MICROSECOND reduce production expr -> expr CONCAT_OP expr
-- On SECOND reduce production expr -> expr CONCAT_OP expr
-- On RPAREN reduce production expr -> expr CONCAT_OP expr
-- On REPLACE reduce production expr -> expr CONCAT_OP expr
-- On QUARTER reduce production expr -> expr CONCAT_OP expr
-- On PLUS reduce production expr -> expr CONCAT_OP expr
-- On ORDER reduce production expr -> expr CONCAT_OP expr
-- On OR reduce production expr -> expr CONCAT_OP expr
-- On ON reduce production expr -> expr CONCAT_OP expr
-- On NUM_EQ_OP reduce production expr -> expr CONCAT_OP expr
-- On NUM_DIV_OP reduce production expr -> expr CONCAT_OP expr
-- On NUM_CMP_OP reduce production expr -> expr CONCAT_OP expr
-- On NUM_BIT_OP reduce production expr -> expr CONCAT_OP expr
-- On NOT_DISTINCT_OP reduce production expr -> expr CONCAT_OP expr
-- On NATURAL reduce production expr -> expr CONCAT_OP expr
-- On MONTH reduce production expr -> expr CONCAT_OP expr
-- On MINUTE_SECOND reduce production expr -> expr CONCAT_OP expr
-- On MINUTE_MICROSECOND reduce production expr -> expr CONCAT_OP expr
-- On MINUTE reduce production expr -> expr CONCAT_OP expr
-- On MINUS reduce production expr -> expr CONCAT_OP expr
-- On MICROSECOND reduce production expr -> expr CONCAT_OP expr
-- On LOCK reduce production expr -> expr CONCAT_OP expr
-- On LIMIT reduce production expr -> expr CONCAT_OP expr
-- On JOIN_TYPE2 reduce production expr -> expr CONCAT_OP expr
-- On JOIN_TYPE1 reduce production expr -> expr CONCAT_OP expr
-- On JOIN reduce production expr -> expr CONCAT_OP expr
-- On INTERSECT reduce production expr -> expr CONCAT_OP expr
-- On INSERT reduce production expr -> expr CONCAT_OP expr
-- On IDENT reduce production expr -> expr CONCAT_OP expr
-- On HOUR_SECOND reduce production expr -> expr CONCAT_OP expr
-- On HOUR_MINUTE reduce production expr -> expr CONCAT_OP expr
-- On HOUR_MICROSECOND reduce production expr -> expr CONCAT_OP expr
-- On HOUR reduce production expr -> expr CONCAT_OP expr
-- On HAVING reduce production expr -> expr CONCAT_OP expr
-- On GROUP reduce production expr -> expr CONCAT_OP expr
-- On FROM reduce production expr -> expr CONCAT_OP expr
-- On FOR reduce production expr -> expr CONCAT_OP expr
-- On EXCEPT reduce production expr -> expr CONCAT_OP expr
-- On ESCAPE reduce production expr -> expr CONCAT_OP expr
-- On EQUAL reduce production expr -> expr CONCAT_OP expr
-- On EOF reduce production expr -> expr CONCAT_OP expr
-- On END reduce production expr -> expr CONCAT_OP expr
-- On ELSE reduce production expr -> expr CONCAT_OP expr
-- On DROP reduce production expr -> expr CONCAT_OP expr
-- On DESC reduce production expr -> expr CONCAT_OP expr
-- On DELETE reduce production expr -> expr CONCAT_OP expr
-- On DAY_SECOND reduce production expr -> expr CONCAT_OP expr
-- On DAY_MINUTE reduce production expr -> expr CONCAT_OP expr
-- On DAY_MICROSECOND reduce production expr -> expr CONCAT_OP expr
-- On DAY_HOUR reduce production expr -> expr CONCAT_OP expr
-- On DAY reduce production expr -> expr CONCAT_OP expr
-- On CROSS reduce production expr -> expr CONCAT_OP expr
-- On CREATE reduce production expr -> expr CONCAT_OP expr
-- On CONCAT_OP reduce production expr -> expr CONCAT_OP expr
-- On COMMA reduce production expr -> expr CONCAT_OP expr
-- On ASTERISK reduce production expr -> expr CONCAT_OP expr
-- On ASC reduce production expr -> expr CONCAT_OP expr
-- On AS reduce production expr -> expr CONCAT_OP expr
-- On AND reduce production expr -> expr CONCAT_OP expr
-- On ALTER reduce production expr -> expr CONCAT_OP expr

State 97:
## Known stack suffix:
## BETWEEN
## LR(1) items:
mnot(BETWEEN) -> BETWEEN . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mnot(BETWEEN) -> BETWEEN

State 98:
## Known stack suffix:
## expr numeric_bin_op
## LR(1) items:
expr -> expr numeric_bin_op . expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 99
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 99:
## Known stack suffix:
## expr numeric_bin_op expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr numeric_bin_op expr . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . boolean_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . CONCAT_OP expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IN IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) NULL [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On NUM_DIV_OP shift to state 73
-- On NOT shift to state 77
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On YEAR_MONTH reduce production expr -> expr numeric_bin_op expr
-- On YEAR reduce production expr -> expr numeric_bin_op expr
-- On WHERE reduce production expr -> expr numeric_bin_op expr
-- On WHEN reduce production expr -> expr numeric_bin_op expr
-- On WEEK reduce production expr -> expr numeric_bin_op expr
-- On UPDATE reduce production expr -> expr numeric_bin_op expr
-- On UNION reduce production expr -> expr numeric_bin_op expr
-- On THEN reduce production expr -> expr numeric_bin_op expr
-- On SET reduce production expr -> expr numeric_bin_op expr
-- On SELECT reduce production expr -> expr numeric_bin_op expr
-- On SECOND_MICROSECOND reduce production expr -> expr numeric_bin_op expr
-- On SECOND reduce production expr -> expr numeric_bin_op expr
-- On RPAREN reduce production expr -> expr numeric_bin_op expr
-- On REPLACE reduce production expr -> expr numeric_bin_op expr
-- On QUARTER reduce production expr -> expr numeric_bin_op expr
-- On PLUS reduce production expr -> expr numeric_bin_op expr
-- On ORDER reduce production expr -> expr numeric_bin_op expr
-- On OR reduce production expr -> expr numeric_bin_op expr
-- On ON reduce production expr -> expr numeric_bin_op expr
-- On NUM_EQ_OP reduce production expr -> expr numeric_bin_op expr
-- On NUM_CMP_OP reduce production expr -> expr numeric_bin_op expr
-- On NUM_BIT_OP reduce production expr -> expr numeric_bin_op expr
-- On NOT_DISTINCT_OP reduce production expr -> expr numeric_bin_op expr
-- On NATURAL reduce production expr -> expr numeric_bin_op expr
-- On MONTH reduce production expr -> expr numeric_bin_op expr
-- On MINUTE_SECOND reduce production expr -> expr numeric_bin_op expr
-- On MINUTE_MICROSECOND reduce production expr -> expr numeric_bin_op expr
-- On MINUTE reduce production expr -> expr numeric_bin_op expr
-- On MINUS reduce production expr -> expr numeric_bin_op expr
-- On MICROSECOND reduce production expr -> expr numeric_bin_op expr
-- On LOCK reduce production expr -> expr numeric_bin_op expr
-- On LIMIT reduce production expr -> expr numeric_bin_op expr
-- On JOIN_TYPE2 reduce production expr -> expr numeric_bin_op expr
-- On JOIN_TYPE1 reduce production expr -> expr numeric_bin_op expr
-- On JOIN reduce production expr -> expr numeric_bin_op expr
-- On INTERSECT reduce production expr -> expr numeric_bin_op expr
-- On INSERT reduce production expr -> expr numeric_bin_op expr
-- On IDENT reduce production expr -> expr numeric_bin_op expr
-- On HOUR_SECOND reduce production expr -> expr numeric_bin_op expr
-- On HOUR_MINUTE reduce production expr -> expr numeric_bin_op expr
-- On HOUR_MICROSECOND reduce production expr -> expr numeric_bin_op expr
-- On HOUR reduce production expr -> expr numeric_bin_op expr
-- On HAVING reduce production expr -> expr numeric_bin_op expr
-- On GROUP reduce production expr -> expr numeric_bin_op expr
-- On FROM reduce production expr -> expr numeric_bin_op expr
-- On FOR reduce production expr -> expr numeric_bin_op expr
-- On EXCEPT reduce production expr -> expr numeric_bin_op expr
-- On ESCAPE reduce production expr -> expr numeric_bin_op expr
-- On EQUAL reduce production expr -> expr numeric_bin_op expr
-- On EOF reduce production expr -> expr numeric_bin_op expr
-- On END reduce production expr -> expr numeric_bin_op expr
-- On ELSE reduce production expr -> expr numeric_bin_op expr
-- On DROP reduce production expr -> expr numeric_bin_op expr
-- On DESC reduce production expr -> expr numeric_bin_op expr
-- On DELETE reduce production expr -> expr numeric_bin_op expr
-- On DAY_SECOND reduce production expr -> expr numeric_bin_op expr
-- On DAY_MINUTE reduce production expr -> expr numeric_bin_op expr
-- On DAY_MICROSECOND reduce production expr -> expr numeric_bin_op expr
-- On DAY_HOUR reduce production expr -> expr numeric_bin_op expr
-- On DAY reduce production expr -> expr numeric_bin_op expr
-- On CROSS reduce production expr -> expr numeric_bin_op expr
-- On CREATE reduce production expr -> expr numeric_bin_op expr
-- On COMMA reduce production expr -> expr numeric_bin_op expr
-- On ASC reduce production expr -> expr numeric_bin_op expr
-- On AS reduce production expr -> expr numeric_bin_op expr
-- On AND reduce production expr -> expr numeric_bin_op expr
-- On ALTER reduce production expr -> expr numeric_bin_op expr

State 100:
## Known stack suffix:
## ASTERISK
## LR(1) items:
numeric_bin_op -> ASTERISK . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production numeric_bin_op -> ASTERISK

State 101:
## Known stack suffix:
## expr mnot(like)
## LR(1) items:
expr -> expr mnot(like) . expr option(escape) [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 102
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 102:
## Known stack suffix:
## expr mnot(like) expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . boolean_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . CONCAT_OP expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr mnot(like) expr . option(escape) [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IN IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) NULL [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On ESCAPE shift to state 103
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On option(escape) shift to state 131
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On escape shift to state 132
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On YEAR_MONTH reduce production option(escape) ->
-- On YEAR reduce production option(escape) ->
-- On WHERE reduce production option(escape) ->
-- On WHEN reduce production option(escape) ->
-- On WEEK reduce production option(escape) ->
-- On UPDATE reduce production option(escape) ->
-- On UNION reduce production option(escape) ->
-- On THEN reduce production option(escape) ->
-- On SET reduce production option(escape) ->
-- On SELECT reduce production option(escape) ->
-- On SECOND_MICROSECOND reduce production option(escape) ->
-- On SECOND reduce production option(escape) ->
-- On RPAREN reduce production option(escape) ->
-- On REPLACE reduce production option(escape) ->
-- On QUARTER reduce production option(escape) ->
-- On ORDER reduce production option(escape) ->
-- On ON reduce production option(escape) ->
-- On NATURAL reduce production option(escape) ->
-- On MONTH reduce production option(escape) ->
-- On MINUTE_SECOND reduce production option(escape) ->
-- On MINUTE_MICROSECOND reduce production option(escape) ->
-- On MINUTE reduce production option(escape) ->
-- On MICROSECOND reduce production option(escape) ->
-- On LOCK reduce production option(escape) ->
-- On LIMIT reduce production option(escape) ->
-- On JOIN_TYPE2 reduce production option(escape) ->
-- On JOIN_TYPE1 reduce production option(escape) ->
-- On JOIN reduce production option(escape) ->
-- On INTERSECT reduce production option(escape) ->
-- On INSERT reduce production option(escape) ->
-- On IDENT reduce production option(escape) ->
-- On HOUR_SECOND reduce production option(escape) ->
-- On HOUR_MINUTE reduce production option(escape) ->
-- On HOUR_MICROSECOND reduce production option(escape) ->
-- On HOUR reduce production option(escape) ->
-- On HAVING reduce production option(escape) ->
-- On GROUP reduce production option(escape) ->
-- On FROM reduce production option(escape) ->
-- On FOR reduce production option(escape) ->
-- On EXCEPT reduce production option(escape) ->
-- On EOF reduce production option(escape) ->
-- On END reduce production option(escape) ->
-- On ELSE reduce production option(escape) ->
-- On DROP reduce production option(escape) ->
-- On DESC reduce production option(escape) ->
-- On DELETE reduce production option(escape) ->
-- On DAY_SECOND reduce production option(escape) ->
-- On DAY_MINUTE reduce production option(escape) ->
-- On DAY_MICROSECOND reduce production option(escape) ->
-- On DAY_HOUR reduce production option(escape) ->
-- On DAY reduce production option(escape) ->
-- On CROSS reduce production option(escape) ->
-- On CREATE reduce production option(escape) ->
-- On COMMA reduce production option(escape) ->
-- On ASC reduce production option(escape) ->
-- On AS reduce production option(escape) ->
-- On ALTER reduce production option(escape) ->

State 103:
## Known stack suffix:
## ESCAPE
## LR(1) items:
escape -> ESCAPE . expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 104
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 104:
## Known stack suffix:
## ESCAPE expr
## LR(1) items:
escape -> ESCAPE expr . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . numeric_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . boolean_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . CONCAT_OP expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IN IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) NULL [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On YEAR_MONTH reduce production escape -> ESCAPE expr
-- On YEAR reduce production escape -> ESCAPE expr
-- On WHERE reduce production escape -> ESCAPE expr
-- On WHEN reduce production escape -> ESCAPE expr
-- On WEEK reduce production escape -> ESCAPE expr
-- On UPDATE reduce production escape -> ESCAPE expr
-- On UNION reduce production escape -> ESCAPE expr
-- On THEN reduce production escape -> ESCAPE expr
-- On SET reduce production escape -> ESCAPE expr
-- On SELECT reduce production escape -> ESCAPE expr
-- On SECOND_MICROSECOND reduce production escape -> ESCAPE expr
-- On SECOND reduce production escape -> ESCAPE expr
-- On RPAREN reduce production escape -> ESCAPE expr
-- On REPLACE reduce production escape -> ESCAPE expr
-- On QUARTER reduce production escape -> ESCAPE expr
-- On ORDER reduce production escape -> ESCAPE expr
-- On ON reduce production escape -> ESCAPE expr
-- On NATURAL reduce production escape -> ESCAPE expr
-- On MONTH reduce production escape -> ESCAPE expr
-- On MINUTE_SECOND reduce production escape -> ESCAPE expr
-- On MINUTE_MICROSECOND reduce production escape -> ESCAPE expr
-- On MINUTE reduce production escape -> ESCAPE expr
-- On MICROSECOND reduce production escape -> ESCAPE expr
-- On LOCK reduce production escape -> ESCAPE expr
-- On LIMIT reduce production escape -> ESCAPE expr
-- On JOIN_TYPE2 reduce production escape -> ESCAPE expr
-- On JOIN_TYPE1 reduce production escape -> ESCAPE expr
-- On JOIN reduce production escape -> ESCAPE expr
-- On INTERSECT reduce production escape -> ESCAPE expr
-- On INSERT reduce production escape -> ESCAPE expr
-- On IDENT reduce production escape -> ESCAPE expr
-- On HOUR_SECOND reduce production escape -> ESCAPE expr
-- On HOUR_MINUTE reduce production escape -> ESCAPE expr
-- On HOUR_MICROSECOND reduce production escape -> ESCAPE expr
-- On HOUR reduce production escape -> ESCAPE expr
-- On HAVING reduce production escape -> ESCAPE expr
-- On GROUP reduce production escape -> ESCAPE expr
-- On FROM reduce production escape -> ESCAPE expr
-- On FOR reduce production escape -> ESCAPE expr
-- On EXCEPT reduce production escape -> ESCAPE expr
-- On ESCAPE reduce production escape -> ESCAPE expr
-- On EOF reduce production escape -> ESCAPE expr
-- On END reduce production escape -> ESCAPE expr
-- On ELSE reduce production escape -> ESCAPE expr
-- On DROP reduce production escape -> ESCAPE expr
-- On DESC reduce production escape -> ESCAPE expr
-- On DELETE reduce production escape -> ESCAPE expr
-- On DAY_SECOND reduce production escape -> ESCAPE expr
-- On DAY_MINUTE reduce production escape -> ESCAPE expr
-- On DAY_MICROSECOND reduce production escape -> ESCAPE expr
-- On DAY_HOUR reduce production escape -> ESCAPE expr
-- On DAY reduce production escape -> ESCAPE expr
-- On CROSS reduce production escape -> ESCAPE expr
-- On CREATE reduce production escape -> ESCAPE expr
-- On COMMA reduce production escape -> ESCAPE expr
-- On ASC reduce production escape -> ESCAPE expr
-- On AS reduce production escape -> ESCAPE expr
-- On ALTER reduce production escape -> ESCAPE expr

State 105:
## Known stack suffix:
## AND
## LR(1) items:
boolean_bin_op -> AND . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production boolean_bin_op -> AND

State 106:
## Known stack suffix:
## expr mnot(IN)
## LR(1) items:
expr -> expr mnot(IN) . LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr mnot(IN) . LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On LPAREN shift to state 107
## Reductions:

State 107:
## Known stack suffix:
## expr mnot(IN) LPAREN
## LR(1) items:
expr -> expr mnot(IN) LPAREN . separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr mnot(IN) LPAREN . select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On SELECT shift to state 26
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On separated_nonempty_list(COMMA,expr) shift to state 108
-- On select_stmt shift to state 110
-- On select_core shift to state 58
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 112
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 108:
## Known stack suffix:
## expr mnot(IN) LPAREN separated_nonempty_list(COMMA,expr)
## LR(1) items:
expr -> expr mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) . RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On RPAREN shift to state 109
## Reductions:

State 109:
## Known stack suffix:
## expr mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN
## LR(1) items:
expr -> expr mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> expr mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN

State 110:
## Known stack suffix:
## expr mnot(IN) LPAREN select_stmt
## LR(1) items:
expr -> expr mnot(IN) LPAREN select_stmt . RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On RPAREN shift to state 111
## Reductions:

State 111:
## Known stack suffix:
## expr mnot(IN) LPAREN select_stmt RPAREN
## LR(1) items:
expr -> expr mnot(IN) LPAREN select_stmt RPAREN . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> expr mnot(IN) LPAREN select_stmt RPAREN

State 112:
## Known stack suffix:
## expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . boolean_bin_op expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . CONCAT_OP expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . IN IDENT [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . IS option(NOT) NULL [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
separated_nonempty_list(COMMA,expr) -> expr . [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On COMMA shift to state 113
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On UPDATE reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On UNION reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On SET reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On SELECT reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On RPAREN reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On REPLACE reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On ORDER reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On ON reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On LOCK reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On LIMIT reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On INTERSECT reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On INSERT reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On HAVING reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On FOR reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On EXCEPT reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On EOF reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On END reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On DROP reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On DELETE reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On CREATE reduce production separated_nonempty_list(COMMA,expr) -> expr
-- On ALTER reduce production separated_nonempty_list(COMMA,expr) -> expr

State 113:
## Known stack suffix:
## expr COMMA
## LR(1) items:
separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On separated_nonempty_list(COMMA,expr) shift to state 114
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 112
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 114:
## Known stack suffix:
## expr COMMA separated_nonempty_list(COMMA,expr)
## LR(1) items:
separated_nonempty_list(COMMA,expr) -> expr COMMA separated_nonempty_list(COMMA,expr) . [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,expr) -> expr COMMA separated_nonempty_list(COMMA,expr)

State 115:
## Known stack suffix:
## datetime_value
## LR(1) items:
expr -> datetime_value . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> datetime_value

State 116:
## Known stack suffix:
## attr_name
## LR(1) items:
expr -> attr_name . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> attr_name

State 117:
## Known stack suffix:
## expr mnot(BETWEEN)
## LR(1) items:
expr -> expr mnot(BETWEEN) . expr AND expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 118
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 118:
## Known stack suffix:
## expr mnot(BETWEEN) expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr mnot(BETWEEN) expr . AND expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 119
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:

State 119:
## Known stack suffix:
## expr mnot(BETWEEN) expr AND
## LR(1) items:
boolean_bin_op -> AND . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
expr -> expr mnot(BETWEEN) expr AND . expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 120
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 120:
## Known stack suffix:
## expr mnot(BETWEEN) expr AND expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . boolean_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . CONCAT_OP expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IN IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) NULL [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr mnot(BETWEEN) expr AND expr . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On YEAR_MONTH reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On YEAR reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On WHERE reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On WHEN reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On WEEK reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On UPDATE reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On UNION reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On THEN reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On SET reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On SELECT reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On SECOND_MICROSECOND reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On SECOND reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On RPAREN reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On REPLACE reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On QUARTER reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On ORDER reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On OR reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On ON reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On NATURAL reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On MONTH reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On MINUTE_SECOND reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On MINUTE_MICROSECOND reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On MINUTE reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On MICROSECOND reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On LOCK reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On LIMIT reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On JOIN_TYPE2 reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On JOIN_TYPE1 reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On JOIN reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On INTERSECT reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On INSERT reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On IDENT reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On HOUR_SECOND reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On HOUR_MINUTE reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On HOUR_MICROSECOND reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On HOUR reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On HAVING reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On GROUP reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On FROM reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On FOR reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On EXCEPT reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On ESCAPE reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On EOF reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On END reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On ELSE reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On DROP reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On DESC reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On DELETE reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On DAY_SECOND reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On DAY_MINUTE reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On DAY_MICROSECOND reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On DAY_HOUR reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On DAY reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On CROSS reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On CREATE reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On COMMA reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On ASC reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On AS reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On AND reduce production expr -> expr mnot(BETWEEN) expr AND expr
-- On ALTER reduce production expr -> expr mnot(BETWEEN) expr AND expr

State 121:
## Known stack suffix:
## like
## LR(1) items:
mnot(like) -> like . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production mnot(like) -> like

State 122:
## Known stack suffix:
## expr comparison_op
## LR(1) items:
expr -> expr comparison_op . option(anyall) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On SOME shift to state 123
-- On ANY shift to state 124
-- On ALL shift to state 125
-- On option(anyall) shift to state 126
-- On anyall shift to state 130
## Reductions:
-- On VALUES reduce production option(anyall) ->
-- On TRUE reduce production option(anyall) ->
-- On TIMESTAMP reduce production option(anyall) ->
-- On TIME reduce production option(anyall) ->
-- On TILDE reduce production option(anyall) ->
-- On TEXT reduce production option(anyall) ->
-- On PARAM reduce production option(anyall) ->
-- On NULL reduce production option(anyall) ->
-- On NOT reduce production option(anyall) ->
-- On MINUS reduce production option(anyall) ->
-- On LPAREN reduce production option(anyall) ->
-- On INTERVAL reduce production option(anyall) ->
-- On INTEGER reduce production option(anyall) ->
-- On IF reduce production option(anyall) ->
-- On IDENT reduce production option(anyall) ->
-- On FLOAT reduce production option(anyall) ->
-- On FALSE reduce production option(anyall) ->
-- On EXISTS reduce production option(anyall) ->
-- On EXCL reduce production option(anyall) ->
-- On DATETIME_FUNC reduce production option(anyall) ->
-- On DATE reduce production option(anyall) ->
-- On CASE reduce production option(anyall) ->
-- On BLOB reduce production option(anyall) ->

State 123:
## Known stack suffix:
## SOME
## LR(1) items:
anyall -> SOME . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production anyall -> SOME

State 124:
## Known stack suffix:
## ANY
## LR(1) items:
anyall -> ANY . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production anyall -> ANY

State 125:
## Known stack suffix:
## ALL
## LR(1) items:
anyall -> ALL . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production anyall -> ALL

State 126:
## Known stack suffix:
## expr comparison_op option(anyall)
## LR(1) items:
expr -> expr comparison_op option(anyall) . expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 127
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 127:
## Known stack suffix:
## expr comparison_op option(anyall) expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . boolean_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr comparison_op option(anyall) expr . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . CONCAT_OP expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IN IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) NULL [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On YEAR_MONTH reduce production expr -> expr comparison_op option(anyall) expr
-- On YEAR reduce production expr -> expr comparison_op option(anyall) expr
-- On WHERE reduce production expr -> expr comparison_op option(anyall) expr
-- On WHEN reduce production expr -> expr comparison_op option(anyall) expr
-- On WEEK reduce production expr -> expr comparison_op option(anyall) expr
-- On UPDATE reduce production expr -> expr comparison_op option(anyall) expr
-- On UNION reduce production expr -> expr comparison_op option(anyall) expr
-- On THEN reduce production expr -> expr comparison_op option(anyall) expr
-- On SET reduce production expr -> expr comparison_op option(anyall) expr
-- On SELECT reduce production expr -> expr comparison_op option(anyall) expr
-- On SECOND_MICROSECOND reduce production expr -> expr comparison_op option(anyall) expr
-- On SECOND reduce production expr -> expr comparison_op option(anyall) expr
-- On RPAREN reduce production expr -> expr comparison_op option(anyall) expr
-- On REPLACE reduce production expr -> expr comparison_op option(anyall) expr
-- On QUARTER reduce production expr -> expr comparison_op option(anyall) expr
-- On ORDER reduce production expr -> expr comparison_op option(anyall) expr
-- On OR reduce production expr -> expr comparison_op option(anyall) expr
-- On ON reduce production expr -> expr comparison_op option(anyall) expr
-- On NATURAL reduce production expr -> expr comparison_op option(anyall) expr
-- On MONTH reduce production expr -> expr comparison_op option(anyall) expr
-- On MINUTE_SECOND reduce production expr -> expr comparison_op option(anyall) expr
-- On MINUTE_MICROSECOND reduce production expr -> expr comparison_op option(anyall) expr
-- On MINUTE reduce production expr -> expr comparison_op option(anyall) expr
-- On MICROSECOND reduce production expr -> expr comparison_op option(anyall) expr
-- On LOCK reduce production expr -> expr comparison_op option(anyall) expr
-- On LIMIT reduce production expr -> expr comparison_op option(anyall) expr
-- On JOIN_TYPE2 reduce production expr -> expr comparison_op option(anyall) expr
-- On JOIN_TYPE1 reduce production expr -> expr comparison_op option(anyall) expr
-- On JOIN reduce production expr -> expr comparison_op option(anyall) expr
-- On INTERSECT reduce production expr -> expr comparison_op option(anyall) expr
-- On INSERT reduce production expr -> expr comparison_op option(anyall) expr
-- On IDENT reduce production expr -> expr comparison_op option(anyall) expr
-- On HOUR_SECOND reduce production expr -> expr comparison_op option(anyall) expr
-- On HOUR_MINUTE reduce production expr -> expr comparison_op option(anyall) expr
-- On HOUR_MICROSECOND reduce production expr -> expr comparison_op option(anyall) expr
-- On HOUR reduce production expr -> expr comparison_op option(anyall) expr
-- On HAVING reduce production expr -> expr comparison_op option(anyall) expr
-- On GROUP reduce production expr -> expr comparison_op option(anyall) expr
-- On FROM reduce production expr -> expr comparison_op option(anyall) expr
-- On FOR reduce production expr -> expr comparison_op option(anyall) expr
-- On EXCEPT reduce production expr -> expr comparison_op option(anyall) expr
-- On ESCAPE reduce production expr -> expr comparison_op option(anyall) expr
-- On EOF reduce production expr -> expr comparison_op option(anyall) expr
-- On END reduce production expr -> expr comparison_op option(anyall) expr
-- On ELSE reduce production expr -> expr comparison_op option(anyall) expr
-- On DROP reduce production expr -> expr comparison_op option(anyall) expr
-- On DESC reduce production expr -> expr comparison_op option(anyall) expr
-- On DELETE reduce production expr -> expr comparison_op option(anyall) expr
-- On DAY_SECOND reduce production expr -> expr comparison_op option(anyall) expr
-- On DAY_MINUTE reduce production expr -> expr comparison_op option(anyall) expr
-- On DAY_MICROSECOND reduce production expr -> expr comparison_op option(anyall) expr
-- On DAY_HOUR reduce production expr -> expr comparison_op option(anyall) expr
-- On DAY reduce production expr -> expr comparison_op option(anyall) expr
-- On CROSS reduce production expr -> expr comparison_op option(anyall) expr
-- On CREATE reduce production expr -> expr comparison_op option(anyall) expr
-- On COMMA reduce production expr -> expr comparison_op option(anyall) expr
-- On ASC reduce production expr -> expr comparison_op option(anyall) expr
-- On AS reduce production expr -> expr comparison_op option(anyall) expr
-- On AND reduce production expr -> expr comparison_op option(anyall) expr
-- On ALTER reduce production expr -> expr comparison_op option(anyall) expr

State 128:
## Known stack suffix:
## expr boolean_bin_op
## LR(1) items:
expr -> expr boolean_bin_op . expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 129
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 129:
## Known stack suffix:
## expr boolean_bin_op expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . boolean_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr boolean_bin_op expr . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . CONCAT_OP expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IN IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) NULL [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On YEAR_MONTH reduce production expr -> expr boolean_bin_op expr
-- On YEAR reduce production expr -> expr boolean_bin_op expr
-- On WHERE reduce production expr -> expr boolean_bin_op expr
-- On WHEN reduce production expr -> expr boolean_bin_op expr
-- On WEEK reduce production expr -> expr boolean_bin_op expr
-- On UPDATE reduce production expr -> expr boolean_bin_op expr
-- On UNION reduce production expr -> expr boolean_bin_op expr
-- On THEN reduce production expr -> expr boolean_bin_op expr
-- On SET reduce production expr -> expr boolean_bin_op expr
-- On SELECT reduce production expr -> expr boolean_bin_op expr
-- On SECOND_MICROSECOND reduce production expr -> expr boolean_bin_op expr
-- On SECOND reduce production expr -> expr boolean_bin_op expr
-- On RPAREN reduce production expr -> expr boolean_bin_op expr
-- On REPLACE reduce production expr -> expr boolean_bin_op expr
-- On QUARTER reduce production expr -> expr boolean_bin_op expr
-- On ORDER reduce production expr -> expr boolean_bin_op expr
-- On OR reduce production expr -> expr boolean_bin_op expr
-- On ON reduce production expr -> expr boolean_bin_op expr
-- On NATURAL reduce production expr -> expr boolean_bin_op expr
-- On MONTH reduce production expr -> expr boolean_bin_op expr
-- On MINUTE_SECOND reduce production expr -> expr boolean_bin_op expr
-- On MINUTE_MICROSECOND reduce production expr -> expr boolean_bin_op expr
-- On MINUTE reduce production expr -> expr boolean_bin_op expr
-- On MICROSECOND reduce production expr -> expr boolean_bin_op expr
-- On LOCK reduce production expr -> expr boolean_bin_op expr
-- On LIMIT reduce production expr -> expr boolean_bin_op expr
-- On JOIN_TYPE2 reduce production expr -> expr boolean_bin_op expr
-- On JOIN_TYPE1 reduce production expr -> expr boolean_bin_op expr
-- On JOIN reduce production expr -> expr boolean_bin_op expr
-- On INTERSECT reduce production expr -> expr boolean_bin_op expr
-- On INSERT reduce production expr -> expr boolean_bin_op expr
-- On IDENT reduce production expr -> expr boolean_bin_op expr
-- On HOUR_SECOND reduce production expr -> expr boolean_bin_op expr
-- On HOUR_MINUTE reduce production expr -> expr boolean_bin_op expr
-- On HOUR_MICROSECOND reduce production expr -> expr boolean_bin_op expr
-- On HOUR reduce production expr -> expr boolean_bin_op expr
-- On HAVING reduce production expr -> expr boolean_bin_op expr
-- On GROUP reduce production expr -> expr boolean_bin_op expr
-- On FROM reduce production expr -> expr boolean_bin_op expr
-- On FOR reduce production expr -> expr boolean_bin_op expr
-- On EXCEPT reduce production expr -> expr boolean_bin_op expr
-- On ESCAPE reduce production expr -> expr boolean_bin_op expr
-- On EOF reduce production expr -> expr boolean_bin_op expr
-- On END reduce production expr -> expr boolean_bin_op expr
-- On ELSE reduce production expr -> expr boolean_bin_op expr
-- On DROP reduce production expr -> expr boolean_bin_op expr
-- On DESC reduce production expr -> expr boolean_bin_op expr
-- On DELETE reduce production expr -> expr boolean_bin_op expr
-- On DAY_SECOND reduce production expr -> expr boolean_bin_op expr
-- On DAY_MINUTE reduce production expr -> expr boolean_bin_op expr
-- On DAY_MICROSECOND reduce production expr -> expr boolean_bin_op expr
-- On DAY_HOUR reduce production expr -> expr boolean_bin_op expr
-- On DAY reduce production expr -> expr boolean_bin_op expr
-- On CROSS reduce production expr -> expr boolean_bin_op expr
-- On CREATE reduce production expr -> expr boolean_bin_op expr
-- On COMMA reduce production expr -> expr boolean_bin_op expr
-- On ASC reduce production expr -> expr boolean_bin_op expr
-- On AS reduce production expr -> expr boolean_bin_op expr
-- On AND reduce production expr -> expr boolean_bin_op expr
-- On ALTER reduce production expr -> expr boolean_bin_op expr

State 130:
## Known stack suffix:
## anyall
## LR(1) items:
option(anyall) -> anyall . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(anyall) -> anyall

State 131:
## Known stack suffix:
## expr mnot(like) expr option(escape)
## LR(1) items:
expr -> expr mnot(like) expr option(escape) . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> expr mnot(like) expr option(escape)

State 132:
## Known stack suffix:
## escape
## LR(1) items:
option(escape) -> escape . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(escape) -> escape

State 133:
## Known stack suffix:
## distinct_from
## LR(1) items:
option(distinct_from) -> distinct_from . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(distinct_from) -> distinct_from

State 134:
## Known stack suffix:
## DESC
## LR(1) items:
order_type -> DESC . [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production order_type -> DESC

State 135:
## Known stack suffix:
## ASC
## LR(1) items:
order_type -> ASC . [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production order_type -> ASC

State 136:
## Known stack suffix:
## order_type
## LR(1) items:
option(order_type) -> order_type . [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(order_type) -> order_type

State 137:
## Known stack suffix:
## expr option(order_type)
## LR(1) items:
separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type) . [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type) . COMMA separated_nonempty_list(COMMA,terminated(expr,option(order_type))) [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On COMMA shift to state 138
## Reductions:
-- On UPDATE reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On SET reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On SELECT reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On RPAREN reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On REPLACE reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On ON reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On LOCK reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On LIMIT reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On INSERT reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On FOR reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On EOF reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On END reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On DROP reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On DELETE reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On CREATE reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)
-- On ALTER reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type)

State 138:
## Known stack suffix:
## expr option(order_type) COMMA
## LR(1) items:
separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type) COMMA . separated_nonempty_list(COMMA,terminated(expr,option(order_type))) [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On separated_nonempty_list(COMMA,terminated(expr,option(order_type))) shift to state 139
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 69
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 139:
## Known stack suffix:
## expr option(order_type) COMMA separated_nonempty_list(COMMA,terminated(expr,option(order_type)))
## LR(1) items:
separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type) COMMA separated_nonempty_list(COMMA,terminated(expr,option(order_type))) . [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,terminated(expr,option(order_type))) -> expr option(order_type) COMMA separated_nonempty_list(COMMA,terminated(expr,option(order_type)))

State 140:
## Known stack suffix:
## order
## LR(1) items:
loption(order) -> order . [ UPDATE SET SELECT RPAREN REPLACE ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production loption(order) -> order

State 141:
## Known stack suffix:
## select_core list(preceded(compound_op,select_core)) loption(order)
## LR(1) items:
select_stmt -> select_core list(preceded(compound_op,select_core)) loption(order) . option(limit_t) option(select_row_locking) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LIMIT shift to state 142
-- On option(limit_t) shift to state 150
-- On limit_t shift to state 179
## Reductions:
-- On UPDATE reduce production option(limit_t) ->
-- On SET reduce production option(limit_t) ->
-- On SELECT reduce production option(limit_t) ->
-- On RPAREN reduce production option(limit_t) ->
-- On REPLACE reduce production option(limit_t) ->
-- On ON reduce production option(limit_t) ->
-- On LOCK reduce production option(limit_t) ->
-- On INSERT reduce production option(limit_t) ->
-- On FOR reduce production option(limit_t) ->
-- On EOF reduce production option(limit_t) ->
-- On END reduce production option(limit_t) ->
-- On DROP reduce production option(limit_t) ->
-- On DELETE reduce production option(limit_t) ->
-- On CREATE reduce production option(limit_t) ->
-- On ALTER reduce production option(limit_t) ->

State 142:
## Known stack suffix:
## LIMIT
## LR(1) items:
limit_t -> LIMIT . int_or_param [ UPDATE SET SELECT RPAREN REPLACE ON LOCK INSERT FOR EOF END DROP DELETE CREATE ALTER ]
limit_t -> LIMIT . int_or_param COMMA int_or_param [ UPDATE SET SELECT RPAREN REPLACE ON LOCK INSERT FOR EOF END DROP DELETE CREATE ALTER ]
limit_t -> LIMIT . int_or_param OFFSET int_or_param [ UPDATE SET SELECT RPAREN REPLACE ON LOCK INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On PARAM shift to state 143
-- On INTEGER shift to state 144
-- On int_or_param shift to state 145
## Reductions:

State 143:
## Known stack suffix:
## PARAM
## LR(1) items:
int_or_param -> PARAM . [ UPDATE SET SELECT RPAREN REPLACE ON OFFSET LOCK INSERT FOR EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production int_or_param -> PARAM

State 144:
## Known stack suffix:
## INTEGER
## LR(1) items:
int_or_param -> INTEGER . [ UPDATE SET SELECT RPAREN REPLACE ON OFFSET LOCK INSERT FOR EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production int_or_param -> INTEGER

State 145:
## Known stack suffix:
## LIMIT int_or_param
## LR(1) items:
limit_t -> LIMIT int_or_param . [ UPDATE SET SELECT RPAREN REPLACE ON LOCK INSERT FOR EOF END DROP DELETE CREATE ALTER ]
limit_t -> LIMIT int_or_param . COMMA int_or_param [ UPDATE SET SELECT RPAREN REPLACE ON LOCK INSERT FOR EOF END DROP DELETE CREATE ALTER ]
limit_t -> LIMIT int_or_param . OFFSET int_or_param [ UPDATE SET SELECT RPAREN REPLACE ON LOCK INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On OFFSET shift to state 146
-- On COMMA shift to state 148
## Reductions:
-- On UPDATE reduce production limit_t -> LIMIT int_or_param
-- On SET reduce production limit_t -> LIMIT int_or_param
-- On SELECT reduce production limit_t -> LIMIT int_or_param
-- On RPAREN reduce production limit_t -> LIMIT int_or_param
-- On REPLACE reduce production limit_t -> LIMIT int_or_param
-- On ON reduce production limit_t -> LIMIT int_or_param
-- On LOCK reduce production limit_t -> LIMIT int_or_param
-- On INSERT reduce production limit_t -> LIMIT int_or_param
-- On FOR reduce production limit_t -> LIMIT int_or_param
-- On EOF reduce production limit_t -> LIMIT int_or_param
-- On END reduce production limit_t -> LIMIT int_or_param
-- On DROP reduce production limit_t -> LIMIT int_or_param
-- On DELETE reduce production limit_t -> LIMIT int_or_param
-- On CREATE reduce production limit_t -> LIMIT int_or_param
-- On ALTER reduce production limit_t -> LIMIT int_or_param

State 146:
## Known stack suffix:
## LIMIT int_or_param OFFSET
## LR(1) items:
limit_t -> LIMIT int_or_param OFFSET . int_or_param [ UPDATE SET SELECT RPAREN REPLACE ON LOCK INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On PARAM shift to state 143
-- On INTEGER shift to state 144
-- On int_or_param shift to state 147
## Reductions:

State 147:
## Known stack suffix:
## LIMIT int_or_param OFFSET int_or_param
## LR(1) items:
limit_t -> LIMIT int_or_param OFFSET int_or_param . [ UPDATE SET SELECT RPAREN REPLACE ON LOCK INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production limit_t -> LIMIT int_or_param OFFSET int_or_param

State 148:
## Known stack suffix:
## LIMIT int_or_param COMMA
## LR(1) items:
limit_t -> LIMIT int_or_param COMMA . int_or_param [ UPDATE SET SELECT RPAREN REPLACE ON LOCK INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On PARAM shift to state 143
-- On INTEGER shift to state 144
-- On int_or_param shift to state 149
## Reductions:

State 149:
## Known stack suffix:
## LIMIT int_or_param COMMA int_or_param
## LR(1) items:
limit_t -> LIMIT int_or_param COMMA int_or_param . [ UPDATE SET SELECT RPAREN REPLACE ON LOCK INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production limit_t -> LIMIT int_or_param COMMA int_or_param

State 150:
## Known stack suffix:
## select_core list(preceded(compound_op,select_core)) loption(order) option(limit_t)
## LR(1) items:
select_stmt -> select_core list(preceded(compound_op,select_core)) loption(order) option(limit_t) . option(select_row_locking) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LOCK shift to state 151
-- On FOR shift to state 155
-- On select_row_locking shift to state 174
-- On option(select_row_locking) shift to state 175
-- On nonempty_list(for_update_or_share) shift to state 176
-- On for_update_or_share shift to state 177
## Reductions:
-- On UPDATE reduce production option(select_row_locking) ->
-- On SET reduce production option(select_row_locking) ->
-- On SELECT reduce production option(select_row_locking) ->
-- On RPAREN reduce production option(select_row_locking) ->
-- On REPLACE reduce production option(select_row_locking) ->
-- On ON reduce production option(select_row_locking) ->
-- On INSERT reduce production option(select_row_locking) ->
-- On EOF reduce production option(select_row_locking) ->
-- On END reduce production option(select_row_locking) ->
-- On DROP reduce production option(select_row_locking) ->
-- On DELETE reduce production option(select_row_locking) ->
-- On CREATE reduce production option(select_row_locking) ->
-- On ALTER reduce production option(select_row_locking) ->

State 151:
## Known stack suffix:
## LOCK
## LR(1) items:
select_row_locking -> LOCK . IN SHARE MODE [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IN shift to state 152
## Reductions:

State 152:
## Known stack suffix:
## LOCK IN
## LR(1) items:
select_row_locking -> LOCK IN . SHARE MODE [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On SHARE shift to state 153
## Reductions:

State 153:
## Known stack suffix:
## LOCK IN SHARE
## LR(1) items:
select_row_locking -> LOCK IN SHARE . MODE [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On MODE shift to state 154
## Reductions:

State 154:
## Known stack suffix:
## LOCK IN SHARE MODE
## LR(1) items:
select_row_locking -> LOCK IN SHARE MODE . [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production select_row_locking -> LOCK IN SHARE MODE

State 155:
## Known stack suffix:
## FOR
## LR(1) items:
for_update_or_share -> FOR . UPDATE option(update_or_share_of) option(NOWAIT) option(with_lock) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
for_update_or_share -> FOR . SHARE option(update_or_share_of) option(NOWAIT) option(with_lock) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On UPDATE shift to state 156
-- On SHARE shift to state 170
## Reductions:

State 156:
## Known stack suffix:
## FOR UPDATE
## LR(1) items:
for_update_or_share -> FOR UPDATE . option(update_or_share_of) option(NOWAIT) option(with_lock) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On OF shift to state 157
-- On update_or_share_of shift to state 162
-- On option(update_or_share_of) shift to state 163
## Reductions:
-- On WITH reduce production option(update_or_share_of) ->
-- On UPDATE reduce production option(update_or_share_of) ->
-- On SET reduce production option(update_or_share_of) ->
-- On SELECT reduce production option(update_or_share_of) ->
-- On RPAREN reduce production option(update_or_share_of) ->
-- On REPLACE reduce production option(update_or_share_of) ->
-- On ON reduce production option(update_or_share_of) ->
-- On NOWAIT reduce production option(update_or_share_of) ->
-- On INSERT reduce production option(update_or_share_of) ->
-- On FOR reduce production option(update_or_share_of) ->
-- On EOF reduce production option(update_or_share_of) ->
-- On END reduce production option(update_or_share_of) ->
-- On DROP reduce production option(update_or_share_of) ->
-- On DELETE reduce production option(update_or_share_of) ->
-- On CREATE reduce production option(update_or_share_of) ->
-- On ALTER reduce production option(update_or_share_of) ->

State 157:
## Known stack suffix:
## OF
## LR(1) items:
update_or_share_of -> OF . separated_nonempty_list(COMMA,IDENT) [ WITH UPDATE SET SELECT RPAREN REPLACE ON NOWAIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 158
-- On separated_nonempty_list(COMMA,IDENT) shift to state 161
## Reductions:

State 158:
## Known stack suffix:
## IDENT
## LR(1) items:
separated_nonempty_list(COMMA,IDENT) -> IDENT . [ WITH UPDATE SET SELECT RPAREN REPLACE ON NOWAIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
separated_nonempty_list(COMMA,IDENT) -> IDENT . COMMA separated_nonempty_list(COMMA,IDENT) [ WITH UPDATE SET SELECT RPAREN REPLACE ON NOWAIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On COMMA shift to state 159
## Reductions:
-- On WITH reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On UPDATE reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On SET reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On SELECT reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On RPAREN reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On REPLACE reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On ON reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On NOWAIT reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On INSERT reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On FOR reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On EOF reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On END reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On DROP reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On DELETE reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On CREATE reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT
-- On ALTER reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT

State 159:
## Known stack suffix:
## IDENT COMMA
## LR(1) items:
separated_nonempty_list(COMMA,IDENT) -> IDENT COMMA . separated_nonempty_list(COMMA,IDENT) [ WITH UPDATE SET SELECT RPAREN REPLACE ON NOWAIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 158
-- On separated_nonempty_list(COMMA,IDENT) shift to state 160
## Reductions:

State 160:
## Known stack suffix:
## IDENT COMMA separated_nonempty_list(COMMA,IDENT)
## LR(1) items:
separated_nonempty_list(COMMA,IDENT) -> IDENT COMMA separated_nonempty_list(COMMA,IDENT) . [ WITH UPDATE SET SELECT RPAREN REPLACE ON NOWAIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,IDENT) -> IDENT COMMA separated_nonempty_list(COMMA,IDENT)

State 161:
## Known stack suffix:
## OF separated_nonempty_list(COMMA,IDENT)
## LR(1) items:
update_or_share_of -> OF separated_nonempty_list(COMMA,IDENT) . [ WITH UPDATE SET SELECT RPAREN REPLACE ON NOWAIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production update_or_share_of -> OF separated_nonempty_list(COMMA,IDENT)

State 162:
## Known stack suffix:
## update_or_share_of
## LR(1) items:
option(update_or_share_of) -> update_or_share_of . [ WITH UPDATE SET SELECT RPAREN REPLACE ON NOWAIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(update_or_share_of) -> update_or_share_of

State 163:
## Known stack suffix:
## FOR UPDATE option(update_or_share_of)
## LR(1) items:
for_update_or_share -> FOR UPDATE option(update_or_share_of) . option(NOWAIT) option(with_lock) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On NOWAIT shift to state 164
-- On option(NOWAIT) shift to state 165
## Reductions:
-- On WITH reduce production option(NOWAIT) ->
-- On UPDATE reduce production option(NOWAIT) ->
-- On SET reduce production option(NOWAIT) ->
-- On SELECT reduce production option(NOWAIT) ->
-- On RPAREN reduce production option(NOWAIT) ->
-- On REPLACE reduce production option(NOWAIT) ->
-- On ON reduce production option(NOWAIT) ->
-- On INSERT reduce production option(NOWAIT) ->
-- On FOR reduce production option(NOWAIT) ->
-- On EOF reduce production option(NOWAIT) ->
-- On END reduce production option(NOWAIT) ->
-- On DROP reduce production option(NOWAIT) ->
-- On DELETE reduce production option(NOWAIT) ->
-- On CREATE reduce production option(NOWAIT) ->
-- On ALTER reduce production option(NOWAIT) ->

State 164:
## Known stack suffix:
## NOWAIT
## LR(1) items:
option(NOWAIT) -> NOWAIT . [ WITH UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(NOWAIT) -> NOWAIT

State 165:
## Known stack suffix:
## FOR UPDATE option(update_or_share_of) option(NOWAIT)
## LR(1) items:
for_update_or_share -> FOR UPDATE option(update_or_share_of) option(NOWAIT) . option(with_lock) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On WITH shift to state 166
-- On with_lock shift to state 168
-- On option(with_lock) shift to state 169
## Reductions:
-- On UPDATE reduce production option(with_lock) ->
-- On SET reduce production option(with_lock) ->
-- On SELECT reduce production option(with_lock) ->
-- On RPAREN reduce production option(with_lock) ->
-- On REPLACE reduce production option(with_lock) ->
-- On ON reduce production option(with_lock) ->
-- On INSERT reduce production option(with_lock) ->
-- On FOR reduce production option(with_lock) ->
-- On EOF reduce production option(with_lock) ->
-- On END reduce production option(with_lock) ->
-- On DROP reduce production option(with_lock) ->
-- On DELETE reduce production option(with_lock) ->
-- On CREATE reduce production option(with_lock) ->
-- On ALTER reduce production option(with_lock) ->

State 166:
## Known stack suffix:
## WITH
## LR(1) items:
with_lock -> WITH . LOCK [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LOCK shift to state 167
## Reductions:

State 167:
## Known stack suffix:
## WITH LOCK
## LR(1) items:
with_lock -> WITH LOCK . [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production with_lock -> WITH LOCK

State 168:
## Known stack suffix:
## with_lock
## LR(1) items:
option(with_lock) -> with_lock . [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(with_lock) -> with_lock

State 169:
## Known stack suffix:
## FOR UPDATE option(update_or_share_of) option(NOWAIT) option(with_lock)
## LR(1) items:
for_update_or_share -> FOR UPDATE option(update_or_share_of) option(NOWAIT) option(with_lock) . [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production for_update_or_share -> FOR UPDATE option(update_or_share_of) option(NOWAIT) option(with_lock)

State 170:
## Known stack suffix:
## FOR SHARE
## LR(1) items:
for_update_or_share -> FOR SHARE . option(update_or_share_of) option(NOWAIT) option(with_lock) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On OF shift to state 157
-- On update_or_share_of shift to state 162
-- On option(update_or_share_of) shift to state 171
## Reductions:
-- On WITH reduce production option(update_or_share_of) ->
-- On UPDATE reduce production option(update_or_share_of) ->
-- On SET reduce production option(update_or_share_of) ->
-- On SELECT reduce production option(update_or_share_of) ->
-- On RPAREN reduce production option(update_or_share_of) ->
-- On REPLACE reduce production option(update_or_share_of) ->
-- On ON reduce production option(update_or_share_of) ->
-- On NOWAIT reduce production option(update_or_share_of) ->
-- On INSERT reduce production option(update_or_share_of) ->
-- On FOR reduce production option(update_or_share_of) ->
-- On EOF reduce production option(update_or_share_of) ->
-- On END reduce production option(update_or_share_of) ->
-- On DROP reduce production option(update_or_share_of) ->
-- On DELETE reduce production option(update_or_share_of) ->
-- On CREATE reduce production option(update_or_share_of) ->
-- On ALTER reduce production option(update_or_share_of) ->

State 171:
## Known stack suffix:
## FOR SHARE option(update_or_share_of)
## LR(1) items:
for_update_or_share -> FOR SHARE option(update_or_share_of) . option(NOWAIT) option(with_lock) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On NOWAIT shift to state 164
-- On option(NOWAIT) shift to state 172
## Reductions:
-- On WITH reduce production option(NOWAIT) ->
-- On UPDATE reduce production option(NOWAIT) ->
-- On SET reduce production option(NOWAIT) ->
-- On SELECT reduce production option(NOWAIT) ->
-- On RPAREN reduce production option(NOWAIT) ->
-- On REPLACE reduce production option(NOWAIT) ->
-- On ON reduce production option(NOWAIT) ->
-- On INSERT reduce production option(NOWAIT) ->
-- On FOR reduce production option(NOWAIT) ->
-- On EOF reduce production option(NOWAIT) ->
-- On END reduce production option(NOWAIT) ->
-- On DROP reduce production option(NOWAIT) ->
-- On DELETE reduce production option(NOWAIT) ->
-- On CREATE reduce production option(NOWAIT) ->
-- On ALTER reduce production option(NOWAIT) ->

State 172:
## Known stack suffix:
## FOR SHARE option(update_or_share_of) option(NOWAIT)
## LR(1) items:
for_update_or_share -> FOR SHARE option(update_or_share_of) option(NOWAIT) . option(with_lock) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On WITH shift to state 166
-- On with_lock shift to state 168
-- On option(with_lock) shift to state 173
## Reductions:
-- On UPDATE reduce production option(with_lock) ->
-- On SET reduce production option(with_lock) ->
-- On SELECT reduce production option(with_lock) ->
-- On RPAREN reduce production option(with_lock) ->
-- On REPLACE reduce production option(with_lock) ->
-- On ON reduce production option(with_lock) ->
-- On INSERT reduce production option(with_lock) ->
-- On FOR reduce production option(with_lock) ->
-- On EOF reduce production option(with_lock) ->
-- On END reduce production option(with_lock) ->
-- On DROP reduce production option(with_lock) ->
-- On DELETE reduce production option(with_lock) ->
-- On CREATE reduce production option(with_lock) ->
-- On ALTER reduce production option(with_lock) ->

State 173:
## Known stack suffix:
## FOR SHARE option(update_or_share_of) option(NOWAIT) option(with_lock)
## LR(1) items:
for_update_or_share -> FOR SHARE option(update_or_share_of) option(NOWAIT) option(with_lock) . [ UPDATE SET SELECT RPAREN REPLACE ON INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production for_update_or_share -> FOR SHARE option(update_or_share_of) option(NOWAIT) option(with_lock)

State 174:
## Known stack suffix:
## select_row_locking
## LR(1) items:
option(select_row_locking) -> select_row_locking . [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(select_row_locking) -> select_row_locking

State 175:
## Known stack suffix:
## select_core list(preceded(compound_op,select_core)) loption(order) option(limit_t) option(select_row_locking)
## LR(1) items:
select_stmt -> select_core list(preceded(compound_op,select_core)) loption(order) option(limit_t) option(select_row_locking) . [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production select_stmt -> select_core list(preceded(compound_op,select_core)) loption(order) option(limit_t) option(select_row_locking)

State 176:
## Known stack suffix:
## nonempty_list(for_update_or_share)
## LR(1) items:
select_row_locking -> nonempty_list(for_update_or_share) . [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production select_row_locking -> nonempty_list(for_update_or_share)

State 177:
## Known stack suffix:
## for_update_or_share
## LR(1) items:
nonempty_list(for_update_or_share) -> for_update_or_share . [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
nonempty_list(for_update_or_share) -> for_update_or_share . nonempty_list(for_update_or_share) [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On FOR shift to state 155
-- On nonempty_list(for_update_or_share) shift to state 178
-- On for_update_or_share shift to state 177
## Reductions:
-- On UPDATE reduce production nonempty_list(for_update_or_share) -> for_update_or_share
-- On SET reduce production nonempty_list(for_update_or_share) -> for_update_or_share
-- On SELECT reduce production nonempty_list(for_update_or_share) -> for_update_or_share
-- On RPAREN reduce production nonempty_list(for_update_or_share) -> for_update_or_share
-- On REPLACE reduce production nonempty_list(for_update_or_share) -> for_update_or_share
-- On ON reduce production nonempty_list(for_update_or_share) -> for_update_or_share
-- On INSERT reduce production nonempty_list(for_update_or_share) -> for_update_or_share
-- On EOF reduce production nonempty_list(for_update_or_share) -> for_update_or_share
-- On END reduce production nonempty_list(for_update_or_share) -> for_update_or_share
-- On DROP reduce production nonempty_list(for_update_or_share) -> for_update_or_share
-- On DELETE reduce production nonempty_list(for_update_or_share) -> for_update_or_share
-- On CREATE reduce production nonempty_list(for_update_or_share) -> for_update_or_share
-- On ALTER reduce production nonempty_list(for_update_or_share) -> for_update_or_share

State 178:
## Known stack suffix:
## for_update_or_share nonempty_list(for_update_or_share)
## LR(1) items:
nonempty_list(for_update_or_share) -> for_update_or_share nonempty_list(for_update_or_share) . [ UPDATE SET SELECT RPAREN REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(for_update_or_share) -> for_update_or_share nonempty_list(for_update_or_share)

State 179:
## Known stack suffix:
## limit_t
## LR(1) items:
option(limit_t) -> limit_t . [ UPDATE SET SELECT RPAREN REPLACE ON LOCK INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(limit_t) -> limit_t

State 180:
## Known stack suffix:
## compound_op
## LR(1) items:
list(preceded(compound_op,select_core)) -> compound_op . select_core list(preceded(compound_op,select_core)) [ UPDATE SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On SELECT shift to state 26
-- On select_core shift to state 181
## Reductions:

State 181:
## Known stack suffix:
## compound_op select_core
## LR(1) items:
list(preceded(compound_op,select_core)) -> compound_op select_core . list(preceded(compound_op,select_core)) [ UPDATE SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On UNION shift to state 59
-- On INTERSECT shift to state 62
-- On EXCEPT shift to state 63
-- On list(preceded(compound_op,select_core)) shift to state 182
-- On compound_op shift to state 180
## Reductions:
-- On UPDATE reduce production list(preceded(compound_op,select_core)) ->
-- On SET reduce production list(preceded(compound_op,select_core)) ->
-- On SELECT reduce production list(preceded(compound_op,select_core)) ->
-- On RPAREN reduce production list(preceded(compound_op,select_core)) ->
-- On REPLACE reduce production list(preceded(compound_op,select_core)) ->
-- On ORDER reduce production list(preceded(compound_op,select_core)) ->
-- On ON reduce production list(preceded(compound_op,select_core)) ->
-- On LOCK reduce production list(preceded(compound_op,select_core)) ->
-- On LIMIT reduce production list(preceded(compound_op,select_core)) ->
-- On INSERT reduce production list(preceded(compound_op,select_core)) ->
-- On FOR reduce production list(preceded(compound_op,select_core)) ->
-- On EOF reduce production list(preceded(compound_op,select_core)) ->
-- On END reduce production list(preceded(compound_op,select_core)) ->
-- On DROP reduce production list(preceded(compound_op,select_core)) ->
-- On DELETE reduce production list(preceded(compound_op,select_core)) ->
-- On CREATE reduce production list(preceded(compound_op,select_core)) ->
-- On ALTER reduce production list(preceded(compound_op,select_core)) ->

State 182:
## Known stack suffix:
## compound_op select_core list(preceded(compound_op,select_core))
## LR(1) items:
list(preceded(compound_op,select_core)) -> compound_op select_core list(preceded(compound_op,select_core)) . [ UPDATE SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INSERT FOR EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(preceded(compound_op,select_core)) -> compound_op select_core list(preceded(compound_op,select_core))

State 183:
## Known stack suffix:
## unary_op expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . boolean_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . CONCAT_OP expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> unary_op expr . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IN IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) NULL [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On YEAR_MONTH reduce production expr -> unary_op expr
-- On YEAR reduce production expr -> unary_op expr
-- On WHERE reduce production expr -> unary_op expr
-- On WHEN reduce production expr -> unary_op expr
-- On WEEK reduce production expr -> unary_op expr
-- On UPDATE reduce production expr -> unary_op expr
-- On UNION reduce production expr -> unary_op expr
-- On THEN reduce production expr -> unary_op expr
-- On SET reduce production expr -> unary_op expr
-- On SELECT reduce production expr -> unary_op expr
-- On SECOND_MICROSECOND reduce production expr -> unary_op expr
-- On SECOND reduce production expr -> unary_op expr
-- On RPAREN reduce production expr -> unary_op expr
-- On REPLACE reduce production expr -> unary_op expr
-- On QUARTER reduce production expr -> unary_op expr
-- On ORDER reduce production expr -> unary_op expr
-- On ON reduce production expr -> unary_op expr
-- On NATURAL reduce production expr -> unary_op expr
-- On MONTH reduce production expr -> unary_op expr
-- On MINUTE_SECOND reduce production expr -> unary_op expr
-- On MINUTE_MICROSECOND reduce production expr -> unary_op expr
-- On MINUTE reduce production expr -> unary_op expr
-- On MICROSECOND reduce production expr -> unary_op expr
-- On LOCK reduce production expr -> unary_op expr
-- On LIMIT reduce production expr -> unary_op expr
-- On JOIN_TYPE2 reduce production expr -> unary_op expr
-- On JOIN_TYPE1 reduce production expr -> unary_op expr
-- On JOIN reduce production expr -> unary_op expr
-- On INTERSECT reduce production expr -> unary_op expr
-- On INSERT reduce production expr -> unary_op expr
-- On IDENT reduce production expr -> unary_op expr
-- On HOUR_SECOND reduce production expr -> unary_op expr
-- On HOUR_MINUTE reduce production expr -> unary_op expr
-- On HOUR_MICROSECOND reduce production expr -> unary_op expr
-- On HOUR reduce production expr -> unary_op expr
-- On HAVING reduce production expr -> unary_op expr
-- On GROUP reduce production expr -> unary_op expr
-- On FROM reduce production expr -> unary_op expr
-- On FOR reduce production expr -> unary_op expr
-- On EXCEPT reduce production expr -> unary_op expr
-- On ESCAPE reduce production expr -> unary_op expr
-- On EOF reduce production expr -> unary_op expr
-- On END reduce production expr -> unary_op expr
-- On ELSE reduce production expr -> unary_op expr
-- On DROP reduce production expr -> unary_op expr
-- On DESC reduce production expr -> unary_op expr
-- On DELETE reduce production expr -> unary_op expr
-- On DAY_SECOND reduce production expr -> unary_op expr
-- On DAY_MINUTE reduce production expr -> unary_op expr
-- On DAY_MICROSECOND reduce production expr -> unary_op expr
-- On DAY_HOUR reduce production expr -> unary_op expr
-- On DAY reduce production expr -> unary_op expr
-- On CROSS reduce production expr -> unary_op expr
-- On CREATE reduce production expr -> unary_op expr
-- On COMMA reduce production expr -> unary_op expr
-- On ASC reduce production expr -> unary_op expr
-- On AS reduce production expr -> unary_op expr
-- On ALTER reduce production expr -> unary_op expr

State 184:
## Known stack suffix:
## CASE option(expr)
## LR(1) items:
expr -> CASE option(expr) . nonempty_list(case_branch) option(preceded(ELSE,expr)) END [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On WHEN shift to state 185
-- On nonempty_list(case_branch) shift to state 189
-- On case_branch shift to state 194
## Reductions:

State 185:
## Known stack suffix:
## WHEN
## LR(1) items:
case_branch -> WHEN . expr THEN expr [ WHEN END ELSE ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 186
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 186:
## Known stack suffix:
## WHEN expr
## LR(1) items:
case_branch -> WHEN expr . THEN expr [ WHEN END ELSE ]
expr -> expr . numeric_bin_op expr [ THEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ THEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ THEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ THEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ THEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ THEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ THEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ THEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ THEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ THEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ THEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
## Transitions:
-- On THEN shift to state 187
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:

State 187:
## Known stack suffix:
## WHEN expr THEN
## LR(1) items:
case_branch -> WHEN expr THEN . expr [ WHEN END ELSE ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 188
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 188:
## Known stack suffix:
## WHEN expr THEN expr
## LR(1) items:
case_branch -> WHEN expr THEN expr . [ WHEN END ELSE ]
expr -> expr . numeric_bin_op expr [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END ELSE CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END ELSE CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END ELSE CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END ELSE CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END ELSE CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END ELSE CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END ELSE CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END ELSE CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END ELSE CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END ELSE CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END ELSE CONCAT_OP BETWEEN ASTERISK AND ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On WHEN reduce production case_branch -> WHEN expr THEN expr
-- On END reduce production case_branch -> WHEN expr THEN expr
-- On ELSE reduce production case_branch -> WHEN expr THEN expr

State 189:
## Known stack suffix:
## CASE option(expr) nonempty_list(case_branch)
## LR(1) items:
expr -> CASE option(expr) nonempty_list(case_branch) . option(preceded(ELSE,expr)) END [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On ELSE shift to state 190
-- On option(preceded(ELSE,expr)) shift to state 192
## Reductions:
-- On END reduce production option(preceded(ELSE,expr)) ->

State 190:
## Known stack suffix:
## ELSE
## LR(1) items:
option(preceded(ELSE,expr)) -> ELSE . expr [ END ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 191
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 191:
## Known stack suffix:
## ELSE expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL END CONCAT_OP BETWEEN ASTERISK AND ]
option(preceded(ELSE,expr)) -> ELSE expr . [ END ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On END reduce production option(preceded(ELSE,expr)) -> ELSE expr

State 192:
## Known stack suffix:
## CASE option(expr) nonempty_list(case_branch) option(preceded(ELSE,expr))
## LR(1) items:
expr -> CASE option(expr) nonempty_list(case_branch) option(preceded(ELSE,expr)) . END [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On END shift to state 193
## Reductions:

State 193:
## Known stack suffix:
## CASE option(expr) nonempty_list(case_branch) option(preceded(ELSE,expr)) END
## LR(1) items:
expr -> CASE option(expr) nonempty_list(case_branch) option(preceded(ELSE,expr)) END . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> CASE option(expr) nonempty_list(case_branch) option(preceded(ELSE,expr)) END

State 194:
## Known stack suffix:
## case_branch
## LR(1) items:
nonempty_list(case_branch) -> case_branch . [ END ELSE ]
nonempty_list(case_branch) -> case_branch . nonempty_list(case_branch) [ END ELSE ]
## Transitions:
-- On WHEN shift to state 185
-- On nonempty_list(case_branch) shift to state 195
-- On case_branch shift to state 194
## Reductions:
-- On END reduce production nonempty_list(case_branch) -> case_branch
-- On ELSE reduce production nonempty_list(case_branch) -> case_branch

State 195:
## Known stack suffix:
## case_branch nonempty_list(case_branch)
## LR(1) items:
nonempty_list(case_branch) -> case_branch nonempty_list(case_branch) . [ END ELSE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(case_branch) -> case_branch nonempty_list(case_branch)

State 196:
## Known stack suffix:
## expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ WHEN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
option(expr) -> expr . [ WHEN ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On WHEN reduce production option(expr) -> expr

State 197:
## Known stack suffix:
## separated_nonempty_list(COMMA,expr)
## LR(1) items:
expr_list -> separated_nonempty_list(COMMA,expr) . [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr_list -> separated_nonempty_list(COMMA,expr)

State 198:
## Known stack suffix:
## option(DISTINCT) expr_list
## LR(1) items:
func_params -> option(DISTINCT) expr_list . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production func_params -> option(DISTINCT) expr_list

State 199:
## Known stack suffix:
## IDENT LPAREN func_params
## LR(1) items:
expr -> IDENT LPAREN func_params . RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On RPAREN shift to state 200
## Reductions:

State 200:
## Known stack suffix:
## IDENT LPAREN func_params RPAREN
## LR(1) items:
expr -> IDENT LPAREN func_params RPAREN . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> IDENT LPAREN func_params RPAREN

State 201:
## Known stack suffix:
## IDENT DOT
## LR(1) items:
attr_name -> IDENT DOT . IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
attr_name -> IDENT DOT . IDENT DOT IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On IDENT shift to state 202
## Reductions:

State 202:
## Known stack suffix:
## IDENT DOT IDENT
## LR(1) items:
attr_name -> IDENT DOT IDENT . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
attr_name -> IDENT DOT IDENT . DOT IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On DOT shift to state 203
## Reductions:
-- On YEAR_MONTH reduce production attr_name -> IDENT DOT IDENT
-- On YEAR reduce production attr_name -> IDENT DOT IDENT
-- On WHERE reduce production attr_name -> IDENT DOT IDENT
-- On WHEN reduce production attr_name -> IDENT DOT IDENT
-- On WEEK reduce production attr_name -> IDENT DOT IDENT
-- On UPDATE reduce production attr_name -> IDENT DOT IDENT
-- On UNION reduce production attr_name -> IDENT DOT IDENT
-- On THEN reduce production attr_name -> IDENT DOT IDENT
-- On SET reduce production attr_name -> IDENT DOT IDENT
-- On SELECT reduce production attr_name -> IDENT DOT IDENT
-- On SECOND_MICROSECOND reduce production attr_name -> IDENT DOT IDENT
-- On SECOND reduce production attr_name -> IDENT DOT IDENT
-- On RPAREN reduce production attr_name -> IDENT DOT IDENT
-- On REPLACE reduce production attr_name -> IDENT DOT IDENT
-- On QUARTER reduce production attr_name -> IDENT DOT IDENT
-- On PLUS reduce production attr_name -> IDENT DOT IDENT
-- On ORDER reduce production attr_name -> IDENT DOT IDENT
-- On OR reduce production attr_name -> IDENT DOT IDENT
-- On ON reduce production attr_name -> IDENT DOT IDENT
-- On NUM_EQ_OP reduce production attr_name -> IDENT DOT IDENT
-- On NUM_DIV_OP reduce production attr_name -> IDENT DOT IDENT
-- On NUM_CMP_OP reduce production attr_name -> IDENT DOT IDENT
-- On NUM_BIT_OP reduce production attr_name -> IDENT DOT IDENT
-- On NOT_DISTINCT_OP reduce production attr_name -> IDENT DOT IDENT
-- On NOT reduce production attr_name -> IDENT DOT IDENT
-- On NATURAL reduce production attr_name -> IDENT DOT IDENT
-- On MONTH reduce production attr_name -> IDENT DOT IDENT
-- On MINUTE_SECOND reduce production attr_name -> IDENT DOT IDENT
-- On MINUTE_MICROSECOND reduce production attr_name -> IDENT DOT IDENT
-- On MINUTE reduce production attr_name -> IDENT DOT IDENT
-- On MINUS reduce production attr_name -> IDENT DOT IDENT
-- On MICROSECOND reduce production attr_name -> IDENT DOT IDENT
-- On LOCK reduce production attr_name -> IDENT DOT IDENT
-- On LIMIT reduce production attr_name -> IDENT DOT IDENT
-- On LIKE_OP reduce production attr_name -> IDENT DOT IDENT
-- On LIKE reduce production attr_name -> IDENT DOT IDENT
-- On JOIN_TYPE2 reduce production attr_name -> IDENT DOT IDENT
-- On JOIN_TYPE1 reduce production attr_name -> IDENT DOT IDENT
-- On JOIN reduce production attr_name -> IDENT DOT IDENT
-- On IS reduce production attr_name -> IDENT DOT IDENT
-- On INTERSECT reduce production attr_name -> IDENT DOT IDENT
-- On INSERT reduce production attr_name -> IDENT DOT IDENT
-- On IN reduce production attr_name -> IDENT DOT IDENT
-- On IDENT reduce production attr_name -> IDENT DOT IDENT
-- On HOUR_SECOND reduce production attr_name -> IDENT DOT IDENT
-- On HOUR_MINUTE reduce production attr_name -> IDENT DOT IDENT
-- On HOUR_MICROSECOND reduce production attr_name -> IDENT DOT IDENT
-- On HOUR reduce production attr_name -> IDENT DOT IDENT
-- On HAVING reduce production attr_name -> IDENT DOT IDENT
-- On GROUP reduce production attr_name -> IDENT DOT IDENT
-- On FROM reduce production attr_name -> IDENT DOT IDENT
-- On FOR reduce production attr_name -> IDENT DOT IDENT
-- On EXCEPT reduce production attr_name -> IDENT DOT IDENT
-- On ESCAPE reduce production attr_name -> IDENT DOT IDENT
-- On EQUAL reduce production attr_name -> IDENT DOT IDENT
-- On EOF reduce production attr_name -> IDENT DOT IDENT
-- On END reduce production attr_name -> IDENT DOT IDENT
-- On ELSE reduce production attr_name -> IDENT DOT IDENT
-- On DROP reduce production attr_name -> IDENT DOT IDENT
-- On DESC reduce production attr_name -> IDENT DOT IDENT
-- On DELETE reduce production attr_name -> IDENT DOT IDENT
-- On DAY_SECOND reduce production attr_name -> IDENT DOT IDENT
-- On DAY_MINUTE reduce production attr_name -> IDENT DOT IDENT
-- On DAY_MICROSECOND reduce production attr_name -> IDENT DOT IDENT
-- On DAY_HOUR reduce production attr_name -> IDENT DOT IDENT
-- On DAY reduce production attr_name -> IDENT DOT IDENT
-- On CROSS reduce production attr_name -> IDENT DOT IDENT
-- On CREATE reduce production attr_name -> IDENT DOT IDENT
-- On CONCAT_OP reduce production attr_name -> IDENT DOT IDENT
-- On COMMA reduce production attr_name -> IDENT DOT IDENT
-- On BETWEEN reduce production attr_name -> IDENT DOT IDENT
-- On ASTERISK reduce production attr_name -> IDENT DOT IDENT
-- On ASC reduce production attr_name -> IDENT DOT IDENT
-- On AS reduce production attr_name -> IDENT DOT IDENT
-- On AND reduce production attr_name -> IDENT DOT IDENT
-- On ALTER reduce production attr_name -> IDENT DOT IDENT

State 203:
## Known stack suffix:
## IDENT DOT IDENT DOT
## LR(1) items:
attr_name -> IDENT DOT IDENT DOT . IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On IDENT shift to state 204
## Reductions:

State 204:
## Known stack suffix:
## IDENT DOT IDENT DOT IDENT
## LR(1) items:
attr_name -> IDENT DOT IDENT DOT IDENT . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production attr_name -> IDENT DOT IDENT DOT IDENT

State 205:
## Known stack suffix:
## IF LPAREN expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> IF LPAREN expr . COMMA expr COMMA expr RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On COMMA shift to state 206
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:

State 206:
## Known stack suffix:
## IF LPAREN expr COMMA
## LR(1) items:
expr -> IF LPAREN expr COMMA . expr COMMA expr RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 207
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 207:
## Known stack suffix:
## IF LPAREN expr COMMA expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> IF LPAREN expr COMMA expr . COMMA expr RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On COMMA shift to state 208
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:

State 208:
## Known stack suffix:
## IF LPAREN expr COMMA expr COMMA
## LR(1) items:
expr -> IF LPAREN expr COMMA expr COMMA . expr RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 209
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 209:
## Known stack suffix:
## IF LPAREN expr COMMA expr COMMA expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> IF LPAREN expr COMMA expr COMMA expr . RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On RPAREN shift to state 210
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:

State 210:
## Known stack suffix:
## IF LPAREN expr COMMA expr COMMA expr RPAREN
## LR(1) items:
expr -> IF LPAREN expr COMMA expr COMMA expr RPAREN . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> IF LPAREN expr COMMA expr COMMA expr RPAREN

State 211:
## Known stack suffix:
## INTERVAL expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ YEAR_MONTH YEAR WEEK SECOND_MICROSECOND SECOND QUARTER PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LIKE_OP LIKE IS IN HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR EQUAL DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ YEAR_MONTH YEAR WEEK SECOND_MICROSECOND SECOND QUARTER PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LIKE_OP LIKE IS IN HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR EQUAL DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ YEAR_MONTH YEAR WEEK SECOND_MICROSECOND SECOND QUARTER PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LIKE_OP LIKE IS IN HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR EQUAL DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ YEAR_MONTH YEAR WEEK SECOND_MICROSECOND SECOND QUARTER PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LIKE_OP LIKE IS IN HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR EQUAL DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ YEAR_MONTH YEAR WEEK SECOND_MICROSECOND SECOND QUARTER PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LIKE_OP LIKE IS IN HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR EQUAL DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CONCAT_OP BETWEEN ASTERISK AND ]
expr -> INTERVAL expr . interval_unit [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WEEK SECOND_MICROSECOND SECOND QUARTER PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LIKE_OP LIKE IS IN HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR EQUAL DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WEEK SECOND_MICROSECOND SECOND QUARTER PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LIKE_OP LIKE IS IN HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR EQUAL DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ YEAR_MONTH YEAR WEEK SECOND_MICROSECOND SECOND QUARTER PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LIKE_OP LIKE IS IN HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR EQUAL DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ YEAR_MONTH YEAR WEEK SECOND_MICROSECOND SECOND QUARTER PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LIKE_OP LIKE IS IN HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR EQUAL DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ YEAR_MONTH YEAR WEEK SECOND_MICROSECOND SECOND QUARTER PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LIKE_OP LIKE IS IN HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR EQUAL DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ YEAR_MONTH YEAR WEEK SECOND_MICROSECOND SECOND QUARTER PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LIKE_OP LIKE IS IN HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR EQUAL DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CONCAT_OP BETWEEN ASTERISK AND ]
## Transitions:
-- On YEAR_MONTH shift to state 212
-- On YEAR shift to state 213
-- On WEEK shift to state 214
-- On SECOND_MICROSECOND shift to state 215
-- On SECOND shift to state 216
-- On QUARTER shift to state 217
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MONTH shift to state 218
-- On MINUTE_SECOND shift to state 219
-- On MINUTE_MICROSECOND shift to state 220
-- On MINUTE shift to state 221
-- On MINUS shift to state 83
-- On MICROSECOND shift to state 222
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On HOUR_SECOND shift to state 223
-- On HOUR_MINUTE shift to state 224
-- On HOUR_MICROSECOND shift to state 225
-- On HOUR shift to state 226
-- On EQUAL shift to state 94
-- On DAY_SECOND shift to state 227
-- On DAY_MINUTE shift to state 228
-- On DAY_MICROSECOND shift to state 229
-- On DAY_HOUR shift to state 230
-- On DAY shift to state 231
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On interval_unit shift to state 232
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:

State 212:
## Known stack suffix:
## YEAR_MONTH
## LR(1) items:
interval_unit -> YEAR_MONTH . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> YEAR_MONTH

State 213:
## Known stack suffix:
## YEAR
## LR(1) items:
interval_unit -> YEAR . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> YEAR

State 214:
## Known stack suffix:
## WEEK
## LR(1) items:
interval_unit -> WEEK . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> WEEK

State 215:
## Known stack suffix:
## SECOND_MICROSECOND
## LR(1) items:
interval_unit -> SECOND_MICROSECOND . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> SECOND_MICROSECOND

State 216:
## Known stack suffix:
## SECOND
## LR(1) items:
interval_unit -> SECOND . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> SECOND

State 217:
## Known stack suffix:
## QUARTER
## LR(1) items:
interval_unit -> QUARTER . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> QUARTER

State 218:
## Known stack suffix:
## MONTH
## LR(1) items:
interval_unit -> MONTH . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> MONTH

State 219:
## Known stack suffix:
## MINUTE_SECOND
## LR(1) items:
interval_unit -> MINUTE_SECOND . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> MINUTE_SECOND

State 220:
## Known stack suffix:
## MINUTE_MICROSECOND
## LR(1) items:
interval_unit -> MINUTE_MICROSECOND . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> MINUTE_MICROSECOND

State 221:
## Known stack suffix:
## MINUTE
## LR(1) items:
interval_unit -> MINUTE . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> MINUTE

State 222:
## Known stack suffix:
## MICROSECOND
## LR(1) items:
interval_unit -> MICROSECOND . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> MICROSECOND

State 223:
## Known stack suffix:
## HOUR_SECOND
## LR(1) items:
interval_unit -> HOUR_SECOND . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> HOUR_SECOND

State 224:
## Known stack suffix:
## HOUR_MINUTE
## LR(1) items:
interval_unit -> HOUR_MINUTE . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> HOUR_MINUTE

State 225:
## Known stack suffix:
## HOUR_MICROSECOND
## LR(1) items:
interval_unit -> HOUR_MICROSECOND . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> HOUR_MICROSECOND

State 226:
## Known stack suffix:
## HOUR
## LR(1) items:
interval_unit -> HOUR . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> HOUR

State 227:
## Known stack suffix:
## DAY_SECOND
## LR(1) items:
interval_unit -> DAY_SECOND . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> DAY_SECOND

State 228:
## Known stack suffix:
## DAY_MINUTE
## LR(1) items:
interval_unit -> DAY_MINUTE . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> DAY_MINUTE

State 229:
## Known stack suffix:
## DAY_MICROSECOND
## LR(1) items:
interval_unit -> DAY_MICROSECOND . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> DAY_MICROSECOND

State 230:
## Known stack suffix:
## DAY_HOUR
## LR(1) items:
interval_unit -> DAY_HOUR . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> DAY_HOUR

State 231:
## Known stack suffix:
## DAY
## LR(1) items:
interval_unit -> DAY . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production interval_unit -> DAY

State 232:
## Known stack suffix:
## INTERVAL expr interval_unit
## LR(1) items:
expr -> INTERVAL expr interval_unit . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> INTERVAL expr interval_unit

State 233:
## Known stack suffix:
## IDENT
## LR(1) items:
attr_name -> IDENT . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
attr_name -> IDENT . DOT IDENT [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
attr_name -> IDENT . DOT IDENT DOT IDENT [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
column1 -> IDENT . DOT ASTERISK [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FROM FOR EXCEPT EOF END DROP DELETE CREATE COMMA ALTER ]
expr -> IDENT . LPAREN func_params RPAREN [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
## Transitions:
-- On LPAREN shift to state 36
-- On DOT shift to state 234
## Reductions:
-- On WHERE reduce production attr_name -> IDENT
-- On UPDATE reduce production attr_name -> IDENT
-- On UNION reduce production attr_name -> IDENT
-- On SET reduce production attr_name -> IDENT
-- On SELECT reduce production attr_name -> IDENT
-- On RPAREN reduce production attr_name -> IDENT
-- On REPLACE reduce production attr_name -> IDENT
-- On PLUS reduce production attr_name -> IDENT
-- On ORDER reduce production attr_name -> IDENT
-- On OR reduce production attr_name -> IDENT
-- On ON reduce production attr_name -> IDENT
-- On NUM_EQ_OP reduce production attr_name -> IDENT
-- On NUM_DIV_OP reduce production attr_name -> IDENT
-- On NUM_CMP_OP reduce production attr_name -> IDENT
-- On NUM_BIT_OP reduce production attr_name -> IDENT
-- On NOT_DISTINCT_OP reduce production attr_name -> IDENT
-- On NOT reduce production attr_name -> IDENT
-- On MINUS reduce production attr_name -> IDENT
-- On LOCK reduce production attr_name -> IDENT
-- On LIMIT reduce production attr_name -> IDENT
-- On LIKE_OP reduce production attr_name -> IDENT
-- On LIKE reduce production attr_name -> IDENT
-- On IS reduce production attr_name -> IDENT
-- On INTERSECT reduce production attr_name -> IDENT
-- On INSERT reduce production attr_name -> IDENT
-- On IN reduce production attr_name -> IDENT
-- On IDENT reduce production attr_name -> IDENT
-- On HAVING reduce production attr_name -> IDENT
-- On GROUP reduce production attr_name -> IDENT
-- On FROM reduce production attr_name -> IDENT
-- On FOR reduce production attr_name -> IDENT
-- On EXCEPT reduce production attr_name -> IDENT
-- On EQUAL reduce production attr_name -> IDENT
-- On EOF reduce production attr_name -> IDENT
-- On END reduce production attr_name -> IDENT
-- On DROP reduce production attr_name -> IDENT
-- On DELETE reduce production attr_name -> IDENT
-- On CREATE reduce production attr_name -> IDENT
-- On CONCAT_OP reduce production attr_name -> IDENT
-- On COMMA reduce production attr_name -> IDENT
-- On BETWEEN reduce production attr_name -> IDENT
-- On ASTERISK reduce production attr_name -> IDENT
-- On AS reduce production attr_name -> IDENT
-- On AND reduce production attr_name -> IDENT
-- On ALTER reduce production attr_name -> IDENT

State 234:
## Known stack suffix:
## IDENT DOT
## LR(1) items:
attr_name -> IDENT DOT . IDENT [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
attr_name -> IDENT DOT . IDENT DOT IDENT [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
column1 -> IDENT DOT . ASTERISK [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FROM FOR EXCEPT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 202
-- On ASTERISK shift to state 235
## Reductions:

State 235:
## Known stack suffix:
## IDENT DOT ASTERISK
## LR(1) items:
column1 -> IDENT DOT ASTERISK . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FROM FOR EXCEPT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column1 -> IDENT DOT ASTERISK

State 236:
## Known stack suffix:
## ASTERISK
## LR(1) items:
column1 -> ASTERISK . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FROM FOR EXCEPT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column1 -> ASTERISK

State 237:
## Known stack suffix:
## SELECT option(select_type) separated_nonempty_list(COMMA,column1)
## LR(1) items:
select_core -> SELECT option(select_type) separated_nonempty_list(COMMA,column1) . option(from) option(where) loption(group) option(having) [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On FROM shift to state 238
-- On option(from) shift to state 276
-- On from shift to state 290
## Reductions:
-- On WHERE reduce production option(from) ->
-- On UPDATE reduce production option(from) ->
-- On UNION reduce production option(from) ->
-- On SET reduce production option(from) ->
-- On SELECT reduce production option(from) ->
-- On RPAREN reduce production option(from) ->
-- On REPLACE reduce production option(from) ->
-- On ORDER reduce production option(from) ->
-- On ON reduce production option(from) ->
-- On LOCK reduce production option(from) ->
-- On LIMIT reduce production option(from) ->
-- On INTERSECT reduce production option(from) ->
-- On INSERT reduce production option(from) ->
-- On HAVING reduce production option(from) ->
-- On GROUP reduce production option(from) ->
-- On FOR reduce production option(from) ->
-- On EXCEPT reduce production option(from) ->
-- On EOF reduce production option(from) ->
-- On END reduce production option(from) ->
-- On DROP reduce production option(from) ->
-- On DELETE reduce production option(from) ->
-- On CREATE reduce production option(from) ->
-- On ALTER reduce production option(from) ->

State 238:
## Known stack suffix:
## FROM
## LR(1) items:
from -> FROM . table_list [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LPAREN shift to state 239
-- On IDENT shift to state 242
-- On table_list shift to state 243
-- On source1 shift to state 244
-- On source shift to state 249
## Reductions:

State 239:
## Known stack suffix:
## LPAREN
## LR(1) items:
source1 -> LPAREN . select_core RPAREN [ WHERE USING UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT IDENT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA AS ALTER ]
## Transitions:
-- On SELECT shift to state 26
-- On select_core shift to state 240
## Reductions:

State 240:
## Known stack suffix:
## LPAREN select_core
## LR(1) items:
source1 -> LPAREN select_core . RPAREN [ WHERE USING UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT IDENT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA AS ALTER ]
## Transitions:
-- On RPAREN shift to state 241
## Reductions:

State 241:
## Known stack suffix:
## LPAREN select_core RPAREN
## LR(1) items:
source1 -> LPAREN select_core RPAREN . [ WHERE USING UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT IDENT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA AS ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production source1 -> LPAREN select_core RPAREN

State 242:
## Known stack suffix:
## IDENT
## LR(1) items:
source1 -> IDENT . [ WHERE USING UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT IDENT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA AS ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production source1 -> IDENT

State 243:
## Known stack suffix:
## FROM table_list
## LR(1) items:
from -> FROM table_list . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production from -> FROM table_list

State 244:
## Known stack suffix:
## source1
## LR(1) items:
source -> source1 . maybe_as [ WHERE USING UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On AS shift to state 245
-- On option(AS) shift to state 246
-- On maybe_as shift to state 248
## Reductions:
-- On WHERE reduce production maybe_as ->
-- On USING reduce production maybe_as ->
-- On UPDATE reduce production maybe_as ->
-- On UNION reduce production maybe_as ->
-- On SET reduce production maybe_as ->
-- On SELECT reduce production maybe_as ->
-- On RPAREN reduce production maybe_as ->
-- On REPLACE reduce production maybe_as ->
-- On ORDER reduce production maybe_as ->
-- On ON reduce production maybe_as ->
-- On NATURAL reduce production maybe_as ->
-- On LOCK reduce production maybe_as ->
-- On LIMIT reduce production maybe_as ->
-- On JOIN_TYPE2 reduce production maybe_as ->
-- On JOIN_TYPE1 reduce production maybe_as ->
-- On JOIN reduce production maybe_as ->
-- On INTERSECT reduce production maybe_as ->
-- On INSERT reduce production maybe_as ->
-- On IDENT reduce production option(AS) ->
-- On HAVING reduce production maybe_as ->
-- On GROUP reduce production maybe_as ->
-- On FOR reduce production maybe_as ->
-- On EXCEPT reduce production maybe_as ->
-- On EOF reduce production maybe_as ->
-- On END reduce production maybe_as ->
-- On DROP reduce production maybe_as ->
-- On DELETE reduce production maybe_as ->
-- On CROSS reduce production maybe_as ->
-- On CREATE reduce production maybe_as ->
-- On COMMA reduce production maybe_as ->
-- On ALTER reduce production maybe_as ->

State 245:
## Known stack suffix:
## AS
## LR(1) items:
option(AS) -> AS . [ YEAR T_UUID T_TEXT T_INTEGER T_FLOAT T_DATETIME T_BOOLEAN T_BLOB TIMESTAMP TIME TEXT NATIONAL IDENT ENUM DATE CHARACTER BINARY BEGIN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(AS) -> AS

State 246:
## Known stack suffix:
## option(AS)
## LR(1) items:
maybe_as -> option(AS) . IDENT [ WHERE USING UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FROM FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 247
## Reductions:

State 247:
## Known stack suffix:
## option(AS) IDENT
## LR(1) items:
maybe_as -> option(AS) IDENT . [ WHERE USING UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FROM FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybe_as -> option(AS) IDENT

State 248:
## Known stack suffix:
## source1 maybe_as
## LR(1) items:
source -> source1 maybe_as . [ WHERE USING UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production source -> source1 maybe_as

State 249:
## Known stack suffix:
## source
## LR(1) items:
table_list -> source . list(join_source) [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On NATURAL shift to state 250
-- On JOIN_TYPE1 shift to state 251
-- On CROSS shift to state 258
-- On COMMA shift to state 261
-- On qualified_join shift to state 262
-- On option(JOIN_TYPE1) shift to state 252
-- On maybe_join_type shift to state 271
-- On list(join_source) shift to state 273
-- On join_source shift to state 274
## Reductions:
-- On WHERE reduce production list(join_source) ->
-- On UPDATE reduce production list(join_source) ->
-- On UNION reduce production list(join_source) ->
-- On SET reduce production list(join_source) ->
-- On SELECT reduce production list(join_source) ->
-- On RPAREN reduce production list(join_source) ->
-- On REPLACE reduce production list(join_source) ->
-- On ORDER reduce production list(join_source) ->
-- On ON reduce production list(join_source) ->
-- On LOCK reduce production list(join_source) ->
-- On LIMIT reduce production list(join_source) ->
-- On JOIN_TYPE2 reduce production option(JOIN_TYPE1) ->
-- On JOIN reduce production option(JOIN_TYPE1) ->
-- On INTERSECT reduce production list(join_source) ->
-- On INSERT reduce production list(join_source) ->
-- On HAVING reduce production list(join_source) ->
-- On GROUP reduce production list(join_source) ->
-- On FOR reduce production list(join_source) ->
-- On EXCEPT reduce production list(join_source) ->
-- On EOF reduce production list(join_source) ->
-- On END reduce production list(join_source) ->
-- On DROP reduce production list(join_source) ->
-- On DELETE reduce production list(join_source) ->
-- On CREATE reduce production list(join_source) ->
-- On ALTER reduce production list(join_source) ->

State 250:
## Known stack suffix:
## NATURAL
## LR(1) items:
join_source -> NATURAL . maybe_join_type JOIN source [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On JOIN_TYPE1 shift to state 251
-- On option(JOIN_TYPE1) shift to state 252
-- On maybe_join_type shift to state 255
## Reductions:
-- On JOIN_TYPE2 reduce production option(JOIN_TYPE1) ->
-- On JOIN reduce production option(JOIN_TYPE1) ->

State 251:
## Known stack suffix:
## JOIN_TYPE1
## LR(1) items:
option(JOIN_TYPE1) -> JOIN_TYPE1 . [ JOIN_TYPE2 JOIN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(JOIN_TYPE1) -> JOIN_TYPE1

State 252:
## Known stack suffix:
## option(JOIN_TYPE1)
## LR(1) items:
maybe_join_type -> option(JOIN_TYPE1) . option(JOIN_TYPE2) [ JOIN ]
## Transitions:
-- On JOIN_TYPE2 shift to state 253
-- On option(JOIN_TYPE2) shift to state 254
## Reductions:
-- On JOIN reduce production option(JOIN_TYPE2) ->

State 253:
## Known stack suffix:
## JOIN_TYPE2
## LR(1) items:
option(JOIN_TYPE2) -> JOIN_TYPE2 . [ JOIN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(JOIN_TYPE2) -> JOIN_TYPE2

State 254:
## Known stack suffix:
## option(JOIN_TYPE1) option(JOIN_TYPE2)
## LR(1) items:
maybe_join_type -> option(JOIN_TYPE1) option(JOIN_TYPE2) . [ JOIN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybe_join_type -> option(JOIN_TYPE1) option(JOIN_TYPE2)

State 255:
## Known stack suffix:
## NATURAL maybe_join_type
## LR(1) items:
join_source -> NATURAL maybe_join_type . JOIN source [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On JOIN shift to state 256
## Reductions:

State 256:
## Known stack suffix:
## NATURAL maybe_join_type JOIN
## LR(1) items:
join_source -> NATURAL maybe_join_type JOIN . source [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On LPAREN shift to state 239
-- On IDENT shift to state 242
-- On source1 shift to state 244
-- On source shift to state 257
## Reductions:

State 257:
## Known stack suffix:
## NATURAL maybe_join_type JOIN source
## LR(1) items:
join_source -> NATURAL maybe_join_type JOIN source . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production join_source -> NATURAL maybe_join_type JOIN source

State 258:
## Known stack suffix:
## CROSS
## LR(1) items:
join_source -> CROSS . JOIN source [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On JOIN shift to state 259
## Reductions:

State 259:
## Known stack suffix:
## CROSS JOIN
## LR(1) items:
join_source -> CROSS JOIN . source [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On LPAREN shift to state 239
-- On IDENT shift to state 242
-- On source1 shift to state 244
-- On source shift to state 260
## Reductions:

State 260:
## Known stack suffix:
## CROSS JOIN source
## LR(1) items:
join_source -> CROSS JOIN source . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production join_source -> CROSS JOIN source

State 261:
## Known stack suffix:
## COMMA
## LR(1) items:
qualified_join -> COMMA . [ LPAREN IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production qualified_join -> COMMA

State 262:
## Known stack suffix:
## qualified_join
## LR(1) items:
join_source -> qualified_join . source join_cond [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On LPAREN shift to state 239
-- On IDENT shift to state 242
-- On source1 shift to state 244
-- On source shift to state 263
## Reductions:

State 263:
## Known stack suffix:
## qualified_join source
## LR(1) items:
join_source -> qualified_join source . join_cond [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On USING shift to state 264
-- On ON shift to state 268
-- On join_cond shift to state 270
## Reductions:
-- On WHERE reduce production join_cond ->
-- On UPDATE reduce production join_cond ->
-- On UNION reduce production join_cond ->
-- On SET reduce production join_cond ->
-- On SELECT reduce production join_cond ->
-- On RPAREN reduce production join_cond ->
-- On REPLACE reduce production join_cond ->
-- On ORDER reduce production join_cond ->
-- On NATURAL reduce production join_cond ->
-- On LOCK reduce production join_cond ->
-- On LIMIT reduce production join_cond ->
-- On JOIN_TYPE2 reduce production join_cond ->
-- On JOIN_TYPE1 reduce production join_cond ->
-- On JOIN reduce production join_cond ->
-- On INTERSECT reduce production join_cond ->
-- On INSERT reduce production join_cond ->
-- On HAVING reduce production join_cond ->
-- On GROUP reduce production join_cond ->
-- On FOR reduce production join_cond ->
-- On EXCEPT reduce production join_cond ->
-- On EOF reduce production join_cond ->
-- On END reduce production join_cond ->
-- On DROP reduce production join_cond ->
-- On DELETE reduce production join_cond ->
-- On CROSS reduce production join_cond ->
-- On CREATE reduce production join_cond ->
-- On COMMA reduce production join_cond ->
-- On ALTER reduce production join_cond ->

State 264:
## Known stack suffix:
## USING
## LR(1) items:
join_cond -> USING . LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On LPAREN shift to state 265
## Reductions:

State 265:
## Known stack suffix:
## USING LPAREN
## LR(1) items:
join_cond -> USING LPAREN . separated_nonempty_list(COMMA,IDENT) RPAREN [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 158
-- On separated_nonempty_list(COMMA,IDENT) shift to state 266
## Reductions:

State 266:
## Known stack suffix:
## USING LPAREN separated_nonempty_list(COMMA,IDENT)
## LR(1) items:
join_cond -> USING LPAREN separated_nonempty_list(COMMA,IDENT) . RPAREN [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On RPAREN shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## USING LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN
## LR(1) items:
join_cond -> USING LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production join_cond -> USING LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN

State 268:
## Known stack suffix:
## ON
## LR(1) items:
join_cond -> ON . expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 269
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 269:
## Known stack suffix:
## ON expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MINUS LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . boolean_bin_op expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MINUS LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MINUS LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . CONCAT_OP expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MINUS LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MINUS LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MINUS LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MINUS LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . IN IDENT [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MINUS LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . IS option(NOT) NULL [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MINUS LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MINUS LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MINUS LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
join_cond -> ON expr . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On WHERE reduce production join_cond -> ON expr
-- On UPDATE reduce production join_cond -> ON expr
-- On UNION reduce production join_cond -> ON expr
-- On SET reduce production join_cond -> ON expr
-- On SELECT reduce production join_cond -> ON expr
-- On RPAREN reduce production join_cond -> ON expr
-- On REPLACE reduce production join_cond -> ON expr
-- On ORDER reduce production join_cond -> ON expr
-- On ON reduce production join_cond -> ON expr
-- On NATURAL reduce production join_cond -> ON expr
-- On LOCK reduce production join_cond -> ON expr
-- On LIMIT reduce production join_cond -> ON expr
-- On JOIN_TYPE2 reduce production join_cond -> ON expr
-- On JOIN_TYPE1 reduce production join_cond -> ON expr
-- On JOIN reduce production join_cond -> ON expr
-- On INTERSECT reduce production join_cond -> ON expr
-- On INSERT reduce production join_cond -> ON expr
-- On HAVING reduce production join_cond -> ON expr
-- On GROUP reduce production join_cond -> ON expr
-- On FOR reduce production join_cond -> ON expr
-- On EXCEPT reduce production join_cond -> ON expr
-- On EOF reduce production join_cond -> ON expr
-- On END reduce production join_cond -> ON expr
-- On DROP reduce production join_cond -> ON expr
-- On DELETE reduce production join_cond -> ON expr
-- On CROSS reduce production join_cond -> ON expr
-- On CREATE reduce production join_cond -> ON expr
-- On COMMA reduce production join_cond -> ON expr
-- On ALTER reduce production join_cond -> ON expr

State 270:
## Known stack suffix:
## qualified_join source join_cond
## LR(1) items:
join_source -> qualified_join source join_cond . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON NATURAL LOCK LIMIT JOIN_TYPE2 JOIN_TYPE1 JOIN INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CROSS CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production join_source -> qualified_join source join_cond

State 271:
## Known stack suffix:
## maybe_join_type
## LR(1) items:
qualified_join -> maybe_join_type . JOIN [ LPAREN IDENT ]
## Transitions:
-- On JOIN shift to state 272
## Reductions:

State 272:
## Known stack suffix:
## maybe_join_type JOIN
## LR(1) items:
qualified_join -> maybe_join_type JOIN . [ LPAREN IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production qualified_join -> maybe_join_type JOIN

State 273:
## Known stack suffix:
## source list(join_source)
## LR(1) items:
table_list -> source list(join_source) . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production table_list -> source list(join_source)

State 274:
## Known stack suffix:
## join_source
## LR(1) items:
list(join_source) -> join_source . list(join_source) [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On NATURAL shift to state 250
-- On JOIN_TYPE1 shift to state 251
-- On CROSS shift to state 258
-- On COMMA shift to state 261
-- On qualified_join shift to state 262
-- On option(JOIN_TYPE1) shift to state 252
-- On maybe_join_type shift to state 271
-- On list(join_source) shift to state 275
-- On join_source shift to state 274
## Reductions:
-- On WHERE reduce production list(join_source) ->
-- On UPDATE reduce production list(join_source) ->
-- On UNION reduce production list(join_source) ->
-- On SET reduce production list(join_source) ->
-- On SELECT reduce production list(join_source) ->
-- On RPAREN reduce production list(join_source) ->
-- On REPLACE reduce production list(join_source) ->
-- On ORDER reduce production list(join_source) ->
-- On ON reduce production list(join_source) ->
-- On LOCK reduce production list(join_source) ->
-- On LIMIT reduce production list(join_source) ->
-- On JOIN_TYPE2 reduce production option(JOIN_TYPE1) ->
-- On JOIN reduce production option(JOIN_TYPE1) ->
-- On INTERSECT reduce production list(join_source) ->
-- On INSERT reduce production list(join_source) ->
-- On HAVING reduce production list(join_source) ->
-- On GROUP reduce production list(join_source) ->
-- On FOR reduce production list(join_source) ->
-- On EXCEPT reduce production list(join_source) ->
-- On EOF reduce production list(join_source) ->
-- On END reduce production list(join_source) ->
-- On DROP reduce production list(join_source) ->
-- On DELETE reduce production list(join_source) ->
-- On CREATE reduce production list(join_source) ->
-- On ALTER reduce production list(join_source) ->

State 275:
## Known stack suffix:
## join_source list(join_source)
## LR(1) items:
list(join_source) -> join_source list(join_source) . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(join_source) -> join_source list(join_source)

State 276:
## Known stack suffix:
## SELECT option(select_type) separated_nonempty_list(COMMA,column1) option(from)
## LR(1) items:
select_core -> SELECT option(select_type) separated_nonempty_list(COMMA,column1) option(from) . option(where) loption(group) option(having) [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On WHERE shift to state 277
-- On where shift to state 279
-- On option(where) shift to state 280
## Reductions:
-- On UPDATE reduce production option(where) ->
-- On UNION reduce production option(where) ->
-- On SET reduce production option(where) ->
-- On SELECT reduce production option(where) ->
-- On RPAREN reduce production option(where) ->
-- On REPLACE reduce production option(where) ->
-- On ORDER reduce production option(where) ->
-- On ON reduce production option(where) ->
-- On LOCK reduce production option(where) ->
-- On LIMIT reduce production option(where) ->
-- On INTERSECT reduce production option(where) ->
-- On INSERT reduce production option(where) ->
-- On HAVING reduce production option(where) ->
-- On GROUP reduce production option(where) ->
-- On FOR reduce production option(where) ->
-- On EXCEPT reduce production option(where) ->
-- On EOF reduce production option(where) ->
-- On END reduce production option(where) ->
-- On DROP reduce production option(where) ->
-- On DELETE reduce production option(where) ->
-- On CREATE reduce production option(where) ->
-- On ALTER reduce production option(where) ->

State 277:
## Known stack suffix:
## WHERE
## LR(1) items:
where -> WHERE . expr [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 278
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 278:
## Known stack suffix:
## WHERE expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . boolean_bin_op expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . CONCAT_OP expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . IN IDENT [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . IS option(NOT) NULL [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN HAVING GROUP FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
where -> WHERE expr . [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On UPDATE reduce production where -> WHERE expr
-- On UNION reduce production where -> WHERE expr
-- On SET reduce production where -> WHERE expr
-- On SELECT reduce production where -> WHERE expr
-- On RPAREN reduce production where -> WHERE expr
-- On REPLACE reduce production where -> WHERE expr
-- On ORDER reduce production where -> WHERE expr
-- On ON reduce production where -> WHERE expr
-- On LOCK reduce production where -> WHERE expr
-- On LIMIT reduce production where -> WHERE expr
-- On INTERSECT reduce production where -> WHERE expr
-- On INSERT reduce production where -> WHERE expr
-- On HAVING reduce production where -> WHERE expr
-- On GROUP reduce production where -> WHERE expr
-- On FOR reduce production where -> WHERE expr
-- On EXCEPT reduce production where -> WHERE expr
-- On EOF reduce production where -> WHERE expr
-- On END reduce production where -> WHERE expr
-- On DROP reduce production where -> WHERE expr
-- On DELETE reduce production where -> WHERE expr
-- On CREATE reduce production where -> WHERE expr
-- On ALTER reduce production where -> WHERE expr

State 279:
## Known stack suffix:
## where
## LR(1) items:
option(where) -> where . [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(where) -> where

State 280:
## Known stack suffix:
## SELECT option(select_type) separated_nonempty_list(COMMA,column1) option(from) option(where)
## LR(1) items:
select_core -> SELECT option(select_type) separated_nonempty_list(COMMA,column1) option(from) option(where) . loption(group) option(having) [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On GROUP shift to state 281
-- On loption(group) shift to state 284
-- On group shift to state 289
## Reductions:
-- On UPDATE reduce production loption(group) ->
-- On UNION reduce production loption(group) ->
-- On SET reduce production loption(group) ->
-- On SELECT reduce production loption(group) ->
-- On RPAREN reduce production loption(group) ->
-- On REPLACE reduce production loption(group) ->
-- On ORDER reduce production loption(group) ->
-- On ON reduce production loption(group) ->
-- On LOCK reduce production loption(group) ->
-- On LIMIT reduce production loption(group) ->
-- On INTERSECT reduce production loption(group) ->
-- On INSERT reduce production loption(group) ->
-- On HAVING reduce production loption(group) ->
-- On FOR reduce production loption(group) ->
-- On EXCEPT reduce production loption(group) ->
-- On EOF reduce production loption(group) ->
-- On END reduce production loption(group) ->
-- On DROP reduce production loption(group) ->
-- On DELETE reduce production loption(group) ->
-- On CREATE reduce production loption(group) ->
-- On ALTER reduce production loption(group) ->

State 281:
## Known stack suffix:
## GROUP
## LR(1) items:
group -> GROUP . BY expr_list [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On BY shift to state 282
## Reductions:

State 282:
## Known stack suffix:
## GROUP BY
## LR(1) items:
group -> GROUP BY . expr_list [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On separated_nonempty_list(COMMA,expr) shift to state 197
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr_list shift to state 283
-- On expr shift to state 112
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 283:
## Known stack suffix:
## GROUP BY expr_list
## LR(1) items:
group -> GROUP BY expr_list . [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production group -> GROUP BY expr_list

State 284:
## Known stack suffix:
## SELECT option(select_type) separated_nonempty_list(COMMA,column1) option(from) option(where) loption(group)
## LR(1) items:
select_core -> SELECT option(select_type) separated_nonempty_list(COMMA,column1) option(from) option(where) loption(group) . option(having) [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On HAVING shift to state 285
-- On option(having) shift to state 287
-- On having shift to state 288
## Reductions:
-- On UPDATE reduce production option(having) ->
-- On UNION reduce production option(having) ->
-- On SET reduce production option(having) ->
-- On SELECT reduce production option(having) ->
-- On RPAREN reduce production option(having) ->
-- On REPLACE reduce production option(having) ->
-- On ORDER reduce production option(having) ->
-- On ON reduce production option(having) ->
-- On LOCK reduce production option(having) ->
-- On LIMIT reduce production option(having) ->
-- On INTERSECT reduce production option(having) ->
-- On INSERT reduce production option(having) ->
-- On FOR reduce production option(having) ->
-- On EXCEPT reduce production option(having) ->
-- On EOF reduce production option(having) ->
-- On END reduce production option(having) ->
-- On DROP reduce production option(having) ->
-- On DELETE reduce production option(having) ->
-- On CREATE reduce production option(having) ->
-- On ALTER reduce production option(having) ->

State 285:
## Known stack suffix:
## HAVING
## LR(1) items:
having -> HAVING . expr [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 286
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 286:
## Known stack suffix:
## HAVING expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . boolean_bin_op expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . CONCAT_OP expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . IN IDENT [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . IS option(NOT) NULL [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
having -> HAVING expr . [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On UPDATE reduce production having -> HAVING expr
-- On UNION reduce production having -> HAVING expr
-- On SET reduce production having -> HAVING expr
-- On SELECT reduce production having -> HAVING expr
-- On RPAREN reduce production having -> HAVING expr
-- On REPLACE reduce production having -> HAVING expr
-- On ORDER reduce production having -> HAVING expr
-- On ON reduce production having -> HAVING expr
-- On LOCK reduce production having -> HAVING expr
-- On LIMIT reduce production having -> HAVING expr
-- On INTERSECT reduce production having -> HAVING expr
-- On INSERT reduce production having -> HAVING expr
-- On FOR reduce production having -> HAVING expr
-- On EXCEPT reduce production having -> HAVING expr
-- On EOF reduce production having -> HAVING expr
-- On END reduce production having -> HAVING expr
-- On DROP reduce production having -> HAVING expr
-- On DELETE reduce production having -> HAVING expr
-- On CREATE reduce production having -> HAVING expr
-- On ALTER reduce production having -> HAVING expr

State 287:
## Known stack suffix:
## SELECT option(select_type) separated_nonempty_list(COMMA,column1) option(from) option(where) loption(group) option(having)
## LR(1) items:
select_core -> SELECT option(select_type) separated_nonempty_list(COMMA,column1) option(from) option(where) loption(group) option(having) . [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production select_core -> SELECT option(select_type) separated_nonempty_list(COMMA,column1) option(from) option(where) loption(group) option(having)

State 288:
## Known stack suffix:
## having
## LR(1) items:
option(having) -> having . [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(having) -> having

State 289:
## Known stack suffix:
## group
## LR(1) items:
loption(group) -> group . [ UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production loption(group) -> group

State 290:
## Known stack suffix:
## from
## LR(1) items:
option(from) -> from . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(from) -> from

State 291:
## Known stack suffix:
## expr
## LR(1) items:
column1 -> expr . maybe_as [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FROM FOR EXCEPT EOF END DROP DELETE CREATE COMMA ALTER ]
expr -> expr . numeric_bin_op expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
expr -> expr . boolean_bin_op expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
expr -> expr . CONCAT_OP expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
expr -> expr . IN IDENT [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
expr -> expr . IS option(NOT) NULL [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LOCK LIMIT LIKE_OP LIKE IS INTERSECT INSERT IN IDENT HAVING GROUP FROM FOR EXCEPT EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AS AND ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AS shift to state 245
-- On AND shift to state 105
-- On option(AS) shift to state 246
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On maybe_as shift to state 292
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On WHERE reduce production maybe_as ->
-- On UPDATE reduce production maybe_as ->
-- On UNION reduce production maybe_as ->
-- On SET reduce production maybe_as ->
-- On SELECT reduce production maybe_as ->
-- On RPAREN reduce production maybe_as ->
-- On REPLACE reduce production maybe_as ->
-- On ORDER reduce production maybe_as ->
-- On ON reduce production maybe_as ->
-- On LOCK reduce production maybe_as ->
-- On LIMIT reduce production maybe_as ->
-- On INTERSECT reduce production maybe_as ->
-- On INSERT reduce production maybe_as ->
-- On IDENT reduce production option(AS) ->
-- On HAVING reduce production maybe_as ->
-- On GROUP reduce production maybe_as ->
-- On FROM reduce production maybe_as ->
-- On FOR reduce production maybe_as ->
-- On EXCEPT reduce production maybe_as ->
-- On EOF reduce production maybe_as ->
-- On END reduce production maybe_as ->
-- On DROP reduce production maybe_as ->
-- On DELETE reduce production maybe_as ->
-- On CREATE reduce production maybe_as ->
-- On COMMA reduce production maybe_as ->
-- On ALTER reduce production maybe_as ->

State 292:
## Known stack suffix:
## expr maybe_as
## LR(1) items:
column1 -> expr maybe_as . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FROM FOR EXCEPT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column1 -> expr maybe_as

State 293:
## Known stack suffix:
## column1
## LR(1) items:
separated_nonempty_list(COMMA,column1) -> column1 . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FROM FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
separated_nonempty_list(COMMA,column1) -> column1 . COMMA separated_nonempty_list(COMMA,column1) [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FROM FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On COMMA shift to state 294
## Reductions:
-- On WHERE reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On UPDATE reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On UNION reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On SET reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On SELECT reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On RPAREN reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On REPLACE reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On ORDER reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On ON reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On LOCK reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On LIMIT reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On INTERSECT reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On INSERT reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On HAVING reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On GROUP reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On FROM reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On FOR reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On EXCEPT reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On EOF reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On END reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On DROP reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On DELETE reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On CREATE reduce production separated_nonempty_list(COMMA,column1) -> column1
-- On ALTER reduce production separated_nonempty_list(COMMA,column1) -> column1

State 294:
## Known stack suffix:
## column1 COMMA
## LR(1) items:
separated_nonempty_list(COMMA,column1) -> column1 COMMA . separated_nonempty_list(COMMA,column1) [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FROM FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 233
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On ASTERISK shift to state 236
-- On unary_op shift to state 53
-- On separated_nonempty_list(COMMA,column1) shift to state 295
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 291
-- On datetime_value shift to state 115
-- On column1 shift to state 293
-- On attr_name shift to state 116
## Reductions:

State 295:
## Known stack suffix:
## column1 COMMA separated_nonempty_list(COMMA,column1)
## LR(1) items:
separated_nonempty_list(COMMA,column1) -> column1 COMMA separated_nonempty_list(COMMA,column1) . [ WHERE UPDATE UNION SET SELECT RPAREN REPLACE ORDER ON LOCK LIMIT INTERSECT INSERT HAVING GROUP FROM FOR EXCEPT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,column1) -> column1 COMMA separated_nonempty_list(COMMA,column1)

State 296:
## Known stack suffix:
## LPAREN select_stmt
## LR(1) items:
expr -> LPAREN select_stmt . RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On RPAREN shift to state 297
## Reductions:

State 297:
## Known stack suffix:
## LPAREN select_stmt RPAREN
## LR(1) items:
expr -> LPAREN select_stmt RPAREN . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> LPAREN select_stmt RPAREN

State 298:
## Known stack suffix:
## LPAREN expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> LPAREN expr . RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
## Transitions:
-- On RPAREN shift to state 299
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:

State 299:
## Known stack suffix:
## LPAREN expr RPAREN
## LR(1) items:
expr -> LPAREN expr RPAREN . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> LPAREN expr RPAREN

State 300:
## Known stack suffix:
## MINUS expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . boolean_bin_op expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . CONCAT_OP expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> MINUS expr . [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IN IDENT [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) NULL [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ YEAR_MONTH YEAR WHERE WHEN WEEK UPDATE UNION THEN SET SELECT SECOND_MICROSECOND SECOND RPAREN REPLACE QUARTER PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT NATURAL MONTH MINUTE_SECOND MINUTE_MICROSECOND MINUTE MINUS MICROSECOND LOCK LIMIT LIKE_OP LIKE JOIN_TYPE2 JOIN_TYPE1 JOIN IS INTERSECT INSERT IN IDENT HOUR_SECOND HOUR_MINUTE HOUR_MICROSECOND HOUR HAVING GROUP FROM FOR EXCEPT ESCAPE EQUAL EOF END ELSE DROP DESC DELETE DAY_SECOND DAY_MINUTE DAY_MICROSECOND DAY_HOUR DAY CROSS CREATE CONCAT_OP COMMA BETWEEN ASTERISK ASC AS AND ALTER ]
## Transitions:
-- On NOT shift to state 77
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On BETWEEN shift to state 97
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On YEAR_MONTH reduce production expr -> MINUS expr
-- On YEAR reduce production expr -> MINUS expr
-- On WHERE reduce production expr -> MINUS expr
-- On WHEN reduce production expr -> MINUS expr
-- On WEEK reduce production expr -> MINUS expr
-- On UPDATE reduce production expr -> MINUS expr
-- On UNION reduce production expr -> MINUS expr
-- On THEN reduce production expr -> MINUS expr
-- On SET reduce production expr -> MINUS expr
-- On SELECT reduce production expr -> MINUS expr
-- On SECOND_MICROSECOND reduce production expr -> MINUS expr
-- On SECOND reduce production expr -> MINUS expr
-- On RPAREN reduce production expr -> MINUS expr
-- On REPLACE reduce production expr -> MINUS expr
-- On QUARTER reduce production expr -> MINUS expr
-- On PLUS reduce production expr -> MINUS expr
-- On ORDER reduce production expr -> MINUS expr
-- On OR reduce production expr -> MINUS expr
-- On ON reduce production expr -> MINUS expr
-- On NUM_EQ_OP reduce production expr -> MINUS expr
-- On NUM_DIV_OP reduce production expr -> MINUS expr
-- On NUM_CMP_OP reduce production expr -> MINUS expr
-- On NUM_BIT_OP reduce production expr -> MINUS expr
-- On NOT_DISTINCT_OP reduce production expr -> MINUS expr
-- On NATURAL reduce production expr -> MINUS expr
-- On MONTH reduce production expr -> MINUS expr
-- On MINUTE_SECOND reduce production expr -> MINUS expr
-- On MINUTE_MICROSECOND reduce production expr -> MINUS expr
-- On MINUTE reduce production expr -> MINUS expr
-- On MINUS reduce production expr -> MINUS expr
-- On MICROSECOND reduce production expr -> MINUS expr
-- On LOCK reduce production expr -> MINUS expr
-- On LIMIT reduce production expr -> MINUS expr
-- On JOIN_TYPE2 reduce production expr -> MINUS expr
-- On JOIN_TYPE1 reduce production expr -> MINUS expr
-- On JOIN reduce production expr -> MINUS expr
-- On INTERSECT reduce production expr -> MINUS expr
-- On INSERT reduce production expr -> MINUS expr
-- On IDENT reduce production expr -> MINUS expr
-- On HOUR_SECOND reduce production expr -> MINUS expr
-- On HOUR_MINUTE reduce production expr -> MINUS expr
-- On HOUR_MICROSECOND reduce production expr -> MINUS expr
-- On HOUR reduce production expr -> MINUS expr
-- On HAVING reduce production expr -> MINUS expr
-- On GROUP reduce production expr -> MINUS expr
-- On FROM reduce production expr -> MINUS expr
-- On FOR reduce production expr -> MINUS expr
-- On EXCEPT reduce production expr -> MINUS expr
-- On ESCAPE reduce production expr -> MINUS expr
-- On EQUAL reduce production expr -> MINUS expr
-- On EOF reduce production expr -> MINUS expr
-- On END reduce production expr -> MINUS expr
-- On ELSE reduce production expr -> MINUS expr
-- On DROP reduce production expr -> MINUS expr
-- On DESC reduce production expr -> MINUS expr
-- On DELETE reduce production expr -> MINUS expr
-- On DAY_SECOND reduce production expr -> MINUS expr
-- On DAY_MINUTE reduce production expr -> MINUS expr
-- On DAY_MICROSECOND reduce production expr -> MINUS expr
-- On DAY_HOUR reduce production expr -> MINUS expr
-- On DAY reduce production expr -> MINUS expr
-- On CROSS reduce production expr -> MINUS expr
-- On CREATE reduce production expr -> MINUS expr
-- On CONCAT_OP reduce production expr -> MINUS expr
-- On COMMA reduce production expr -> MINUS expr
-- On ASTERISK reduce production expr -> MINUS expr
-- On ASC reduce production expr -> MINUS expr
-- On AS reduce production expr -> MINUS expr
-- On AND reduce production expr -> MINUS expr
-- On ALTER reduce production expr -> MINUS expr

State 301:
## Known stack suffix:
## SET IDENT EQUAL expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ UPDATE SET SELECT REPLACE PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . boolean_bin_op expr [ UPDATE SET SELECT REPLACE PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ UPDATE SET SELECT REPLACE PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . CONCAT_OP expr [ UPDATE SET SELECT REPLACE PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ UPDATE SET SELECT REPLACE PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ UPDATE SET SELECT REPLACE PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ UPDATE SET SELECT REPLACE PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . IN IDENT [ UPDATE SET SELECT REPLACE PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . IS option(NOT) NULL [ UPDATE SET SELECT REPLACE PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ UPDATE SET SELECT REPLACE PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ UPDATE SET SELECT REPLACE PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP BETWEEN ASTERISK AND ALTER ]
statement -> SET IDENT EQUAL expr . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On UPDATE reduce production statement -> SET IDENT EQUAL expr
-- On SET reduce production statement -> SET IDENT EQUAL expr
-- On SELECT reduce production statement -> SET IDENT EQUAL expr
-- On REPLACE reduce production statement -> SET IDENT EQUAL expr
-- On INSERT reduce production statement -> SET IDENT EQUAL expr
-- On EOF reduce production statement -> SET IDENT EQUAL expr
-- On END reduce production statement -> SET IDENT EQUAL expr
-- On DROP reduce production statement -> SET IDENT EQUAL expr
-- On DELETE reduce production statement -> SET IDENT EQUAL expr
-- On CREATE reduce production statement -> SET IDENT EQUAL expr
-- On ALTER reduce production statement -> SET IDENT EQUAL expr

State 302:
## Known stack suffix:
## REPLACE
## LR(1) items:
insert_cmd -> REPLACE . INTO [ IDENT ]
## Transitions:
-- On INTO shift to state 303
## Reductions:

State 303:
## Known stack suffix:
## REPLACE INTO
## LR(1) items:
insert_cmd -> REPLACE INTO . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production insert_cmd -> REPLACE INTO

State 304:
## Known stack suffix:
## INSERT
## LR(1) items:
insert_cmd -> INSERT . option(DELAYED) option(OR) conflict_algo INTO [ IDENT ]
insert_cmd -> INSERT . INTO [ IDENT ]
## Transitions:
-- On INTO shift to state 305
-- On DELAYED shift to state 306
-- On option(DELAYED) shift to state 307
## Reductions:
-- On REPLACE reduce production option(DELAYED) ->
-- On OR reduce production option(DELAYED) ->
-- On CONFLICT_ALGO reduce production option(DELAYED) ->

State 305:
## Known stack suffix:
## INSERT INTO
## LR(1) items:
insert_cmd -> INSERT INTO . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production insert_cmd -> INSERT INTO

State 306:
## Known stack suffix:
## DELAYED
## LR(1) items:
option(DELAYED) -> DELAYED . [ REPLACE OR CONFLICT_ALGO ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(DELAYED) -> DELAYED

State 307:
## Known stack suffix:
## INSERT option(DELAYED)
## LR(1) items:
insert_cmd -> INSERT option(DELAYED) . option(OR) conflict_algo INTO [ IDENT ]
## Transitions:
-- On OR shift to state 308
-- On option(OR) shift to state 309
## Reductions:
-- On REPLACE reduce production option(OR) ->
-- On CONFLICT_ALGO reduce production option(OR) ->

State 308:
## Known stack suffix:
## OR
## LR(1) items:
option(OR) -> OR . [ REPLACE CONFLICT_ALGO ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(OR) -> OR

State 309:
## Known stack suffix:
## INSERT option(DELAYED) option(OR)
## LR(1) items:
insert_cmd -> INSERT option(DELAYED) option(OR) . conflict_algo INTO [ IDENT ]
## Transitions:
-- On REPLACE shift to state 3
-- On CONFLICT_ALGO shift to state 4
-- On conflict_algo shift to state 310
## Reductions:

State 310:
## Known stack suffix:
## INSERT option(DELAYED) option(OR) conflict_algo
## LR(1) items:
insert_cmd -> INSERT option(DELAYED) option(OR) conflict_algo . INTO [ IDENT ]
## Transitions:
-- On INTO shift to state 311
## Reductions:

State 311:
## Known stack suffix:
## INSERT option(DELAYED) option(OR) conflict_algo INTO
## LR(1) items:
insert_cmd -> INSERT option(DELAYED) option(OR) conflict_algo INTO . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production insert_cmd -> INSERT option(DELAYED) option(OR) conflict_algo INTO

State 312:
## Known stack suffix:
## DROP
## LR(1) items:
statement -> DROP . TABLE option(if_exists) IDENT [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On TABLE shift to state 313
## Reductions:

State 313:
## Known stack suffix:
## DROP TABLE
## LR(1) items:
statement -> DROP TABLE . option(if_exists) IDENT [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IF shift to state 314
-- On option(if_exists) shift to state 316
-- On if_exists shift to state 318
## Reductions:
-- On IDENT reduce production option(if_exists) ->

State 314:
## Known stack suffix:
## IF
## LR(1) items:
if_exists -> IF . EXISTS [ IDENT ]
## Transitions:
-- On EXISTS shift to state 315
## Reductions:

State 315:
## Known stack suffix:
## IF EXISTS
## LR(1) items:
if_exists -> IF EXISTS . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production if_exists -> IF EXISTS

State 316:
## Known stack suffix:
## DROP TABLE option(if_exists)
## LR(1) items:
statement -> DROP TABLE option(if_exists) . IDENT [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 317
## Reductions:

State 317:
## Known stack suffix:
## DROP TABLE option(if_exists) IDENT
## LR(1) items:
statement -> DROP TABLE option(if_exists) IDENT . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> DROP TABLE option(if_exists) IDENT

State 318:
## Known stack suffix:
## if_exists
## LR(1) items:
option(if_exists) -> if_exists . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(if_exists) -> if_exists

State 319:
## Known stack suffix:
## DELETE
## LR(1) items:
statement -> DELETE . FROM IDENT option(where) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On FROM shift to state 320
## Reductions:

State 320:
## Known stack suffix:
## DELETE FROM
## LR(1) items:
statement -> DELETE FROM . IDENT option(where) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 321
## Reductions:

State 321:
## Known stack suffix:
## DELETE FROM IDENT
## LR(1) items:
statement -> DELETE FROM IDENT . option(where) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On WHERE shift to state 277
-- On where shift to state 279
-- On option(where) shift to state 322
## Reductions:
-- On UPDATE reduce production option(where) ->
-- On SET reduce production option(where) ->
-- On SELECT reduce production option(where) ->
-- On REPLACE reduce production option(where) ->
-- On INSERT reduce production option(where) ->
-- On EOF reduce production option(where) ->
-- On END reduce production option(where) ->
-- On DROP reduce production option(where) ->
-- On DELETE reduce production option(where) ->
-- On CREATE reduce production option(where) ->
-- On ALTER reduce production option(where) ->

State 322:
## Known stack suffix:
## DELETE FROM IDENT option(where)
## LR(1) items:
statement -> DELETE FROM IDENT option(where) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> DELETE FROM IDENT option(where)

State 323:
## Known stack suffix:
## CREATE
## LR(1) items:
statement -> CREATE . TABLE IDENT table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE . TABLE if_not_exists IDENT table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE . temporary TABLE IDENT table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE . temporary TABLE if_not_exists IDENT table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE . TABLE IDENT AS maybe_parenth(select_stmt) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE . VIEW IDENT AS maybe_parenth(select_stmt) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE . option(UNIQUE) INDEX option(if_not_exists) table_name ON table_name LPAREN separated_nonempty_list(COMMA,index_column) RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE . option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE . option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On VIEW shift to state 324
-- On UNIQUE shift to state 332
-- On TABLE shift to state 333
-- On OR shift to state 521
-- On LOCAL shift to state 523
-- On GLOBAL shift to state 524
-- On temporary shift to state 525
-- On or_replace shift to state 532
-- On option(or_replace) shift to state 533
-- On option(either(GLOBAL,LOCAL)) shift to state 689
-- On option(UNIQUE) shift to state 691
## Reductions:
-- On TEMPORARY reduce production option(either(GLOBAL,LOCAL)) ->
-- On PROCEDURE reduce production option(or_replace) ->
-- On INDEX reduce production option(UNIQUE) ->
-- On FUNCTION reduce production option(or_replace) ->

State 324:
## Known stack suffix:
## CREATE VIEW
## LR(1) items:
statement -> CREATE VIEW . IDENT AS maybe_parenth(select_stmt) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 325
## Reductions:

State 325:
## Known stack suffix:
## CREATE VIEW IDENT
## LR(1) items:
statement -> CREATE VIEW IDENT . AS maybe_parenth(select_stmt) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On AS shift to state 326
## Reductions:

State 326:
## Known stack suffix:
## CREATE VIEW IDENT AS
## LR(1) items:
statement -> CREATE VIEW IDENT AS . maybe_parenth(select_stmt) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On SELECT shift to state 26
-- On LPAREN shift to state 327
-- On select_stmt shift to state 330
-- On select_core shift to state 58
-- On maybe_parenth(select_stmt) shift to state 331
## Reductions:

State 327:
## Known stack suffix:
## LPAREN
## LR(1) items:
maybe_parenth(select_stmt) -> LPAREN . select_stmt RPAREN [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On SELECT shift to state 26
-- On select_stmt shift to state 328
-- On select_core shift to state 58
## Reductions:

State 328:
## Known stack suffix:
## LPAREN select_stmt
## LR(1) items:
maybe_parenth(select_stmt) -> LPAREN select_stmt . RPAREN [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On RPAREN shift to state 329
## Reductions:

State 329:
## Known stack suffix:
## LPAREN select_stmt RPAREN
## LR(1) items:
maybe_parenth(select_stmt) -> LPAREN select_stmt RPAREN . [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybe_parenth(select_stmt) -> LPAREN select_stmt RPAREN

State 330:
## Known stack suffix:
## select_stmt
## LR(1) items:
maybe_parenth(select_stmt) -> select_stmt . [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybe_parenth(select_stmt) -> select_stmt

State 331:
## Known stack suffix:
## CREATE VIEW IDENT AS maybe_parenth(select_stmt)
## LR(1) items:
statement -> CREATE VIEW IDENT AS maybe_parenth(select_stmt) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> CREATE VIEW IDENT AS maybe_parenth(select_stmt)

State 332:
## Known stack suffix:
## UNIQUE
## LR(1) items:
option(UNIQUE) -> UNIQUE . [ INDEX ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(UNIQUE) -> UNIQUE

State 333:
## Known stack suffix:
## CREATE TABLE
## LR(1) items:
statement -> CREATE TABLE . IDENT table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE TABLE . if_not_exists IDENT table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE TABLE . IDENT AS maybe_parenth(select_stmt) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IF shift to state 334
-- On IDENT shift to state 337
-- On if_not_exists shift to state 518
## Reductions:

State 334:
## Known stack suffix:
## IF
## LR(1) items:
if_not_exists -> IF . NOT EXISTS [ IDENT ]
## Transitions:
-- On NOT shift to state 335
## Reductions:

State 335:
## Known stack suffix:
## IF NOT
## LR(1) items:
if_not_exists -> IF NOT . EXISTS [ IDENT ]
## Transitions:
-- On EXISTS shift to state 336
## Reductions:

State 336:
## Known stack suffix:
## IF NOT EXISTS
## LR(1) items:
if_not_exists -> IF NOT EXISTS . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production if_not_exists -> IF NOT EXISTS

State 337:
## Known stack suffix:
## CREATE TABLE IDENT
## LR(1) items:
statement -> CREATE TABLE IDENT . table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE TABLE IDENT . AS maybe_parenth(select_stmt) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LPAREN shift to state 338
-- On LIKE shift to state 509
-- On AS shift to state 515
-- On table_definition shift to state 517
## Reductions:

State 338:
## Known stack suffix:
## LPAREN
## LR(1) items:
table_definition -> LPAREN . separated_nonempty_list(COMMA,column_def1) table_def_done [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On INDEX shift to state 339
-- On IDENT shift to state 357
-- On CONSTRAINT shift to state 446
-- On separated_nonempty_list(COMMA,column_def1) shift to state 448
-- On option(pair(CONSTRAINT,IDENT)) shift to state 455
-- On column_def1 shift to state 505
-- On column_def shift to state 508
## Reductions:
-- On UNIQUE reduce production option(pair(CONSTRAINT,IDENT)) ->
-- On PRIMARY reduce production option(pair(CONSTRAINT,IDENT)) ->
-- On KEY reduce production option(pair(CONSTRAINT,IDENT)) ->
-- On FULLTEXT reduce production option(pair(CONSTRAINT,IDENT)) ->
-- On FOREIGN reduce production option(pair(CONSTRAINT,IDENT)) ->
-- On CHECK reduce production option(pair(CONSTRAINT,IDENT)) ->

State 339:
## Known stack suffix:
## INDEX
## LR(1) items:
column_def1 -> INDEX . LPAREN separated_nonempty_list(COMMA,index_column) RPAREN [ RPAREN COMMA ]
## Transitions:
-- On LPAREN shift to state 340
## Reductions:

State 340:
## Known stack suffix:
## INDEX LPAREN
## LR(1) items:
column_def1 -> INDEX LPAREN . separated_nonempty_list(COMMA,index_column) RPAREN [ RPAREN COMMA ]
## Transitions:
-- On IDENT shift to state 341
-- On separated_nonempty_list(COMMA,index_column) shift to state 352
-- On index_column shift to state 354
## Reductions:

State 341:
## Known stack suffix:
## IDENT
## LR(1) items:
index_column -> IDENT . option(index_prefix) option(collate) option(order_type) [ RPAREN COMMA ]
## Transitions:
-- On LPAREN shift to state 342
-- On option(index_prefix) shift to state 345
-- On index_prefix shift to state 351
## Reductions:
-- On RPAREN reduce production option(index_prefix) ->
-- On DESC reduce production option(index_prefix) ->
-- On COMMA reduce production option(index_prefix) ->
-- On COLLATE reduce production option(index_prefix) ->
-- On ASC reduce production option(index_prefix) ->

State 342:
## Known stack suffix:
## LPAREN
## LR(1) items:
index_prefix -> LPAREN . INTEGER RPAREN [ RPAREN DESC COMMA COLLATE ASC ]
## Transitions:
-- On INTEGER shift to state 343
## Reductions:

State 343:
## Known stack suffix:
## LPAREN INTEGER
## LR(1) items:
index_prefix -> LPAREN INTEGER . RPAREN [ RPAREN DESC COMMA COLLATE ASC ]
## Transitions:
-- On RPAREN shift to state 344
## Reductions:

State 344:
## Known stack suffix:
## LPAREN INTEGER RPAREN
## LR(1) items:
index_prefix -> LPAREN INTEGER RPAREN . [ RPAREN DESC COMMA COLLATE ASC ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production index_prefix -> LPAREN INTEGER RPAREN

State 345:
## Known stack suffix:
## IDENT option(index_prefix)
## LR(1) items:
index_column -> IDENT option(index_prefix) . option(collate) option(order_type) [ RPAREN COMMA ]
## Transitions:
-- On COLLATE shift to state 346
-- On option(collate) shift to state 348
-- On collate shift to state 350
## Reductions:
-- On RPAREN reduce production option(collate) ->
-- On DESC reduce production option(collate) ->
-- On COMMA reduce production option(collate) ->
-- On ASC reduce production option(collate) ->

State 346:
## Known stack suffix:
## COLLATE
## LR(1) items:
collate -> COLLATE . IDENT [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DESC DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT ASC AS ALTER AFTER ]
## Transitions:
-- On IDENT shift to state 347
## Reductions:

State 347:
## Known stack suffix:
## COLLATE IDENT
## LR(1) items:
collate -> COLLATE IDENT . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DESC DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT ASC AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production collate -> COLLATE IDENT

State 348:
## Known stack suffix:
## IDENT option(index_prefix) option(collate)
## LR(1) items:
index_column -> IDENT option(index_prefix) option(collate) . option(order_type) [ RPAREN COMMA ]
## Transitions:
-- On DESC shift to state 134
-- On ASC shift to state 135
-- On order_type shift to state 136
-- On option(order_type) shift to state 349
## Reductions:
-- On RPAREN reduce production option(order_type) ->
-- On COMMA reduce production option(order_type) ->

State 349:
## Known stack suffix:
## IDENT option(index_prefix) option(collate) option(order_type)
## LR(1) items:
index_column -> IDENT option(index_prefix) option(collate) option(order_type) . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production index_column -> IDENT option(index_prefix) option(collate) option(order_type)

State 350:
## Known stack suffix:
## collate
## LR(1) items:
option(collate) -> collate . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DESC DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT ASC AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(collate) -> collate

State 351:
## Known stack suffix:
## index_prefix
## LR(1) items:
option(index_prefix) -> index_prefix . [ RPAREN DESC COMMA COLLATE ASC ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(index_prefix) -> index_prefix

State 352:
## Known stack suffix:
## INDEX LPAREN separated_nonempty_list(COMMA,index_column)
## LR(1) items:
column_def1 -> INDEX LPAREN separated_nonempty_list(COMMA,index_column) . RPAREN [ RPAREN COMMA ]
## Transitions:
-- On RPAREN shift to state 353
## Reductions:

State 353:
## Known stack suffix:
## INDEX LPAREN separated_nonempty_list(COMMA,index_column) RPAREN
## LR(1) items:
column_def1 -> INDEX LPAREN separated_nonempty_list(COMMA,index_column) RPAREN . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def1 -> INDEX LPAREN separated_nonempty_list(COMMA,index_column) RPAREN

State 354:
## Known stack suffix:
## index_column
## LR(1) items:
separated_nonempty_list(COMMA,index_column) -> index_column . [ RPAREN ]
separated_nonempty_list(COMMA,index_column) -> index_column . COMMA separated_nonempty_list(COMMA,index_column) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 355
## Reductions:
-- On RPAREN reduce production separated_nonempty_list(COMMA,index_column) -> index_column

State 355:
## Known stack suffix:
## index_column COMMA
## LR(1) items:
separated_nonempty_list(COMMA,index_column) -> index_column COMMA . separated_nonempty_list(COMMA,index_column) [ RPAREN ]
## Transitions:
-- On IDENT shift to state 341
-- On separated_nonempty_list(COMMA,index_column) shift to state 356
-- On index_column shift to state 354
## Reductions:

State 356:
## Known stack suffix:
## index_column COMMA separated_nonempty_list(COMMA,index_column)
## LR(1) items:
separated_nonempty_list(COMMA,index_column) -> index_column COMMA separated_nonempty_list(COMMA,index_column) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,index_column) -> index_column COMMA separated_nonempty_list(COMMA,index_column)

State 357:
## Known stack suffix:
## IDENT
## LR(1) items:
column_def -> IDENT . option(sql_type) list(column_def_extra) [ UPDATE SET SELECT RPAREN REPLACE INSERT FIRST EOF END DROP DELETE CREATE COMMA ALTER AFTER ]
## Transitions:
-- On YEAR shift to state 358
-- On T_UUID shift to state 359
-- On T_INTEGER shift to state 360
-- On T_FLOAT shift to state 365
-- On T_DATETIME shift to state 368
-- On T_BOOLEAN shift to state 369
-- On T_BLOB shift to state 370
-- On TIMESTAMP shift to state 371
-- On TIME shift to state 372
-- On NATIONAL shift to state 373
-- On ENUM shift to state 374
-- On DATE shift to state 393
-- On BINARY shift to state 394
-- On sql_type_flavor shift to state 396
-- On sql_type shift to state 404
-- On option(sql_type) shift to state 405
-- On option(NATIONAL) shift to state 434
-- On binary shift to state 445
## Reductions:
-- On UPDATE reduce production option(sql_type) ->
-- On UNIQUE reduce production option(sql_type) ->
-- On T_TEXT reduce production option(NATIONAL) ->
-- On SET reduce production option(sql_type) ->
-- On SELECT reduce production option(sql_type) ->
-- On RPAREN reduce production option(sql_type) ->
-- On REPLACE reduce production option(sql_type) ->
-- On PRIMARY reduce production option(sql_type) ->
-- On ON reduce production option(sql_type) ->
-- On NULL reduce production option(sql_type) ->
-- On NOT reduce production option(sql_type) ->
-- On INSERT reduce production option(sql_type) ->
-- On FIRST reduce production option(sql_type) ->
-- On EOF reduce production option(sql_type) ->
-- On END reduce production option(sql_type) ->
-- On DROP reduce production option(sql_type) ->
-- On DELETE reduce production option(sql_type) ->
-- On DEFAULT reduce production option(sql_type) ->
-- On CREATE reduce production option(sql_type) ->
-- On COMMA reduce production option(sql_type) ->
-- On COLLATE reduce production option(sql_type) ->
-- On CHECK reduce production option(sql_type) ->
-- On CHARACTER reduce production option(NATIONAL) ->
-- On AUTOINCREMENT reduce production option(sql_type) ->
-- On ALTER reduce production option(sql_type) ->
-- On AFTER reduce production option(sql_type) ->

State 358:
## Known stack suffix:
## YEAR
## LR(1) items:
sql_type_flavor -> YEAR . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type_flavor -> YEAR

State 359:
## Known stack suffix:
## T_UUID
## LR(1) items:
sql_type_flavor -> T_UUID . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type_flavor -> T_UUID

State 360:
## Known stack suffix:
## T_INTEGER
## LR(1) items:
sql_type_flavor -> T_INTEGER . option(UNSIGNED) option(ZEROFILL) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On UNSIGNED shift to state 361
-- On option(UNSIGNED) shift to state 362
## Reductions:
-- On ZEROFILL reduce production option(UNSIGNED) ->
-- On UPDATE reduce production option(UNSIGNED) ->
-- On UNIQUE reduce production option(UNSIGNED) ->
-- On TEXT reduce production option(UNSIGNED) ->
-- On SET reduce production option(UNSIGNED) ->
-- On SELECT reduce production option(UNSIGNED) ->
-- On RPAREN reduce production option(UNSIGNED) ->
-- On REPLACE reduce production option(UNSIGNED) ->
-- On PRIMARY reduce production option(UNSIGNED) ->
-- On ON reduce production option(UNSIGNED) ->
-- On NULL reduce production option(UNSIGNED) ->
-- On NOT reduce production option(UNSIGNED) ->
-- On LPAREN reduce production option(UNSIGNED) ->
-- On LANGUAGE reduce production option(UNSIGNED) ->
-- On INSERT reduce production option(UNSIGNED) ->
-- On FIRST reduce production option(UNSIGNED) ->
-- On EQUAL reduce production option(UNSIGNED) ->
-- On EOF reduce production option(UNSIGNED) ->
-- On END reduce production option(UNSIGNED) ->
-- On DROP reduce production option(UNSIGNED) ->
-- On DELETE reduce production option(UNSIGNED) ->
-- On DEFAULT reduce production option(UNSIGNED) ->
-- On CREATE reduce production option(UNSIGNED) ->
-- On COMMENT reduce production option(UNSIGNED) ->
-- On COMMA reduce production option(UNSIGNED) ->
-- On COLLATE reduce production option(UNSIGNED) ->
-- On CHECK reduce production option(UNSIGNED) ->
-- On BEGIN reduce production option(UNSIGNED) ->
-- On AUTOINCREMENT reduce production option(UNSIGNED) ->
-- On AS reduce production option(UNSIGNED) ->
-- On ALTER reduce production option(UNSIGNED) ->
-- On AFTER reduce production option(UNSIGNED) ->

State 361:
## Known stack suffix:
## UNSIGNED
## LR(1) items:
option(UNSIGNED) -> UNSIGNED . [ ZEROFILL UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(UNSIGNED) -> UNSIGNED

State 362:
## Known stack suffix:
## T_INTEGER option(UNSIGNED)
## LR(1) items:
sql_type_flavor -> T_INTEGER option(UNSIGNED) . option(ZEROFILL) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On ZEROFILL shift to state 363
-- On option(ZEROFILL) shift to state 364
## Reductions:
-- On UPDATE reduce production option(ZEROFILL) ->
-- On UNIQUE reduce production option(ZEROFILL) ->
-- On TEXT reduce production option(ZEROFILL) ->
-- On SET reduce production option(ZEROFILL) ->
-- On SELECT reduce production option(ZEROFILL) ->
-- On RPAREN reduce production option(ZEROFILL) ->
-- On REPLACE reduce production option(ZEROFILL) ->
-- On PRIMARY reduce production option(ZEROFILL) ->
-- On ON reduce production option(ZEROFILL) ->
-- On NULL reduce production option(ZEROFILL) ->
-- On NOT reduce production option(ZEROFILL) ->
-- On LPAREN reduce production option(ZEROFILL) ->
-- On LANGUAGE reduce production option(ZEROFILL) ->
-- On INSERT reduce production option(ZEROFILL) ->
-- On FIRST reduce production option(ZEROFILL) ->
-- On EQUAL reduce production option(ZEROFILL) ->
-- On EOF reduce production option(ZEROFILL) ->
-- On END reduce production option(ZEROFILL) ->
-- On DROP reduce production option(ZEROFILL) ->
-- On DELETE reduce production option(ZEROFILL) ->
-- On DEFAULT reduce production option(ZEROFILL) ->
-- On CREATE reduce production option(ZEROFILL) ->
-- On COMMENT reduce production option(ZEROFILL) ->
-- On COMMA reduce production option(ZEROFILL) ->
-- On COLLATE reduce production option(ZEROFILL) ->
-- On CHECK reduce production option(ZEROFILL) ->
-- On BEGIN reduce production option(ZEROFILL) ->
-- On AUTOINCREMENT reduce production option(ZEROFILL) ->
-- On AS reduce production option(ZEROFILL) ->
-- On ALTER reduce production option(ZEROFILL) ->
-- On AFTER reduce production option(ZEROFILL) ->

State 363:
## Known stack suffix:
## ZEROFILL
## LR(1) items:
option(ZEROFILL) -> ZEROFILL . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(ZEROFILL) -> ZEROFILL

State 364:
## Known stack suffix:
## T_INTEGER option(UNSIGNED) option(ZEROFILL)
## LR(1) items:
sql_type_flavor -> T_INTEGER option(UNSIGNED) option(ZEROFILL) . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type_flavor -> T_INTEGER option(UNSIGNED) option(ZEROFILL)

State 365:
## Known stack suffix:
## T_FLOAT
## LR(1) items:
sql_type_flavor -> T_FLOAT . option(PRECISION) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On PRECISION shift to state 366
-- On option(PRECISION) shift to state 367
## Reductions:
-- On UPDATE reduce production option(PRECISION) ->
-- On UNIQUE reduce production option(PRECISION) ->
-- On TEXT reduce production option(PRECISION) ->
-- On SET reduce production option(PRECISION) ->
-- On SELECT reduce production option(PRECISION) ->
-- On RPAREN reduce production option(PRECISION) ->
-- On REPLACE reduce production option(PRECISION) ->
-- On PRIMARY reduce production option(PRECISION) ->
-- On ON reduce production option(PRECISION) ->
-- On NULL reduce production option(PRECISION) ->
-- On NOT reduce production option(PRECISION) ->
-- On LPAREN reduce production option(PRECISION) ->
-- On LANGUAGE reduce production option(PRECISION) ->
-- On INSERT reduce production option(PRECISION) ->
-- On FIRST reduce production option(PRECISION) ->
-- On EQUAL reduce production option(PRECISION) ->
-- On EOF reduce production option(PRECISION) ->
-- On END reduce production option(PRECISION) ->
-- On DROP reduce production option(PRECISION) ->
-- On DELETE reduce production option(PRECISION) ->
-- On DEFAULT reduce production option(PRECISION) ->
-- On CREATE reduce production option(PRECISION) ->
-- On COMMENT reduce production option(PRECISION) ->
-- On COMMA reduce production option(PRECISION) ->
-- On COLLATE reduce production option(PRECISION) ->
-- On CHECK reduce production option(PRECISION) ->
-- On BEGIN reduce production option(PRECISION) ->
-- On AUTOINCREMENT reduce production option(PRECISION) ->
-- On AS reduce production option(PRECISION) ->
-- On ALTER reduce production option(PRECISION) ->
-- On AFTER reduce production option(PRECISION) ->

State 366:
## Known stack suffix:
## PRECISION
## LR(1) items:
option(PRECISION) -> PRECISION . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(PRECISION) -> PRECISION

State 367:
## Known stack suffix:
## T_FLOAT option(PRECISION)
## LR(1) items:
sql_type_flavor -> T_FLOAT option(PRECISION) . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type_flavor -> T_FLOAT option(PRECISION)

State 368:
## Known stack suffix:
## T_DATETIME
## LR(1) items:
sql_type_flavor -> T_DATETIME . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type_flavor -> T_DATETIME

State 369:
## Known stack suffix:
## T_BOOLEAN
## LR(1) items:
sql_type_flavor -> T_BOOLEAN . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type_flavor -> T_BOOLEAN

State 370:
## Known stack suffix:
## T_BLOB
## LR(1) items:
binary -> T_BLOB . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binary -> T_BLOB

State 371:
## Known stack suffix:
## TIMESTAMP
## LR(1) items:
sql_type_flavor -> TIMESTAMP . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type_flavor -> TIMESTAMP

State 372:
## Known stack suffix:
## TIME
## LR(1) items:
sql_type_flavor -> TIME . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type_flavor -> TIME

State 373:
## Known stack suffix:
## NATIONAL
## LR(1) items:
option(NATIONAL) -> NATIONAL . [ T_TEXT CHARACTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(NATIONAL) -> NATIONAL

State 374:
## Known stack suffix:
## ENUM
## LR(1) items:
sql_type_flavor -> ENUM . LPAREN separated_nonempty_list(COMMA,TEXT) RPAREN option(charset) option(collate) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On LPAREN shift to state 375
## Reductions:

State 375:
## Known stack suffix:
## ENUM LPAREN
## LR(1) items:
sql_type_flavor -> ENUM LPAREN . separated_nonempty_list(COMMA,TEXT) RPAREN option(charset) option(collate) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On TEXT shift to state 376
-- On separated_nonempty_list(COMMA,TEXT) shift to state 379
## Reductions:

State 376:
## Known stack suffix:
## TEXT
## LR(1) items:
separated_nonempty_list(COMMA,TEXT) -> TEXT . [ RPAREN ]
separated_nonempty_list(COMMA,TEXT) -> TEXT . COMMA separated_nonempty_list(COMMA,TEXT) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 377
## Reductions:
-- On RPAREN reduce production separated_nonempty_list(COMMA,TEXT) -> TEXT

State 377:
## Known stack suffix:
## TEXT COMMA
## LR(1) items:
separated_nonempty_list(COMMA,TEXT) -> TEXT COMMA . separated_nonempty_list(COMMA,TEXT) [ RPAREN ]
## Transitions:
-- On TEXT shift to state 376
-- On separated_nonempty_list(COMMA,TEXT) shift to state 378
## Reductions:

State 378:
## Known stack suffix:
## TEXT COMMA separated_nonempty_list(COMMA,TEXT)
## LR(1) items:
separated_nonempty_list(COMMA,TEXT) -> TEXT COMMA separated_nonempty_list(COMMA,TEXT) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,TEXT) -> TEXT COMMA separated_nonempty_list(COMMA,TEXT)

State 379:
## Known stack suffix:
## ENUM LPAREN separated_nonempty_list(COMMA,TEXT)
## LR(1) items:
sql_type_flavor -> ENUM LPAREN separated_nonempty_list(COMMA,TEXT) . RPAREN option(charset) option(collate) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On RPAREN shift to state 380
## Reductions:

State 380:
## Known stack suffix:
## ENUM LPAREN separated_nonempty_list(COMMA,TEXT) RPAREN
## LR(1) items:
sql_type_flavor -> ENUM LPAREN separated_nonempty_list(COMMA,TEXT) RPAREN . option(charset) option(collate) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On UNICODE shift to state 381
-- On CHARSET shift to state 382
-- On CHARACTER shift to state 385
-- On ASCII shift to state 389
-- On option(charset) shift to state 390
-- On charset shift to state 392
## Reductions:
-- On UPDATE reduce production option(charset) ->
-- On UNIQUE reduce production option(charset) ->
-- On TEXT reduce production option(charset) ->
-- On SET reduce production option(charset) ->
-- On SELECT reduce production option(charset) ->
-- On RPAREN reduce production option(charset) ->
-- On REPLACE reduce production option(charset) ->
-- On PRIMARY reduce production option(charset) ->
-- On ON reduce production option(charset) ->
-- On NULL reduce production option(charset) ->
-- On NOT reduce production option(charset) ->
-- On LPAREN reduce production option(charset) ->
-- On LANGUAGE reduce production option(charset) ->
-- On INSERT reduce production option(charset) ->
-- On FIRST reduce production option(charset) ->
-- On EQUAL reduce production option(charset) ->
-- On EOF reduce production option(charset) ->
-- On END reduce production option(charset) ->
-- On DROP reduce production option(charset) ->
-- On DELETE reduce production option(charset) ->
-- On DEFAULT reduce production option(charset) ->
-- On CREATE reduce production option(charset) ->
-- On COMMENT reduce production option(charset) ->
-- On COMMA reduce production option(charset) ->
-- On COLLATE reduce production option(charset) ->
-- On CHECK reduce production option(charset) ->
-- On BEGIN reduce production option(charset) ->
-- On AUTOINCREMENT reduce production option(charset) ->
-- On AS reduce production option(charset) ->
-- On ALTER reduce production option(charset) ->
-- On AFTER reduce production option(charset) ->

State 381:
## Known stack suffix:
## UNICODE
## LR(1) items:
charset -> UNICODE . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production charset -> UNICODE

State 382:
## Known stack suffix:
## CHARSET
## LR(1) items:
charset -> CHARSET . IDENT [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
charset -> CHARSET . BINARY [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On IDENT shift to state 383
-- On BINARY shift to state 384
## Reductions:

State 383:
## Known stack suffix:
## CHARSET IDENT
## LR(1) items:
charset -> CHARSET IDENT . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production charset -> CHARSET IDENT

State 384:
## Known stack suffix:
## CHARSET BINARY
## LR(1) items:
charset -> CHARSET BINARY . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production charset -> CHARSET BINARY

State 385:
## Known stack suffix:
## CHARACTER
## LR(1) items:
charset -> CHARACTER . SET IDENT [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
charset -> CHARACTER . SET BINARY [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On SET shift to state 386
## Reductions:

State 386:
## Known stack suffix:
## CHARACTER SET
## LR(1) items:
charset -> CHARACTER SET . IDENT [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
charset -> CHARACTER SET . BINARY [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On IDENT shift to state 387
-- On BINARY shift to state 388
## Reductions:

State 387:
## Known stack suffix:
## CHARACTER SET IDENT
## LR(1) items:
charset -> CHARACTER SET IDENT . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production charset -> CHARACTER SET IDENT

State 388:
## Known stack suffix:
## CHARACTER SET BINARY
## LR(1) items:
charset -> CHARACTER SET BINARY . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production charset -> CHARACTER SET BINARY

State 389:
## Known stack suffix:
## ASCII
## LR(1) items:
charset -> ASCII . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production charset -> ASCII

State 390:
## Known stack suffix:
## ENUM LPAREN separated_nonempty_list(COMMA,TEXT) RPAREN option(charset)
## LR(1) items:
sql_type_flavor -> ENUM LPAREN separated_nonempty_list(COMMA,TEXT) RPAREN option(charset) . option(collate) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On COLLATE shift to state 346
-- On option(collate) shift to state 391
-- On collate shift to state 350
## Reductions:
-- On UPDATE reduce production option(collate) ->
-- On UNIQUE reduce production option(collate) ->
-- On TEXT reduce production option(collate) ->
-- On SET reduce production option(collate) ->
-- On SELECT reduce production option(collate) ->
-- On RPAREN reduce production option(collate) ->
-- On REPLACE reduce production option(collate) ->
-- On PRIMARY reduce production option(collate) ->
-- On ON reduce production option(collate) ->
-- On NULL reduce production option(collate) ->
-- On NOT reduce production option(collate) ->
-- On LPAREN reduce production option(collate) ->
-- On LANGUAGE reduce production option(collate) ->
-- On INSERT reduce production option(collate) ->
-- On FIRST reduce production option(collate) ->
-- On EQUAL reduce production option(collate) ->
-- On EOF reduce production option(collate) ->
-- On END reduce production option(collate) ->
-- On DROP reduce production option(collate) ->
-- On DELETE reduce production option(collate) ->
-- On DEFAULT reduce production option(collate) ->
-- On CREATE reduce production option(collate) ->
-- On COMMENT reduce production option(collate) ->
-- On COMMA reduce production option(collate) ->
-- On CHECK reduce production option(collate) ->
-- On BEGIN reduce production option(collate) ->
-- On AUTOINCREMENT reduce production option(collate) ->
-- On AS reduce production option(collate) ->
-- On ALTER reduce production option(collate) ->
-- On AFTER reduce production option(collate) ->

State 391:
## Known stack suffix:
## ENUM LPAREN separated_nonempty_list(COMMA,TEXT) RPAREN option(charset) option(collate)
## LR(1) items:
sql_type_flavor -> ENUM LPAREN separated_nonempty_list(COMMA,TEXT) RPAREN option(charset) option(collate) . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type_flavor -> ENUM LPAREN separated_nonempty_list(COMMA,TEXT) RPAREN option(charset) option(collate)

State 392:
## Known stack suffix:
## charset
## LR(1) items:
option(charset) -> charset . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(charset) -> charset

State 393:
## Known stack suffix:
## DATE
## LR(1) items:
sql_type_flavor -> DATE . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type_flavor -> DATE

State 394:
## Known stack suffix:
## BINARY
## LR(1) items:
binary -> BINARY . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
binary -> BINARY . VARYING [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On VARYING shift to state 395
## Reductions:
-- On UPDATE reduce production binary -> BINARY
-- On UNIQUE reduce production binary -> BINARY
-- On TEXT reduce production binary -> BINARY
-- On SET reduce production binary -> BINARY
-- On SELECT reduce production binary -> BINARY
-- On RPAREN reduce production binary -> BINARY
-- On REPLACE reduce production binary -> BINARY
-- On PRIMARY reduce production binary -> BINARY
-- On ON reduce production binary -> BINARY
-- On NULL reduce production binary -> BINARY
-- On NOT reduce production binary -> BINARY
-- On LPAREN reduce production binary -> BINARY
-- On LANGUAGE reduce production binary -> BINARY
-- On INSERT reduce production binary -> BINARY
-- On FIRST reduce production binary -> BINARY
-- On EQUAL reduce production binary -> BINARY
-- On EOF reduce production binary -> BINARY
-- On END reduce production binary -> BINARY
-- On DROP reduce production binary -> BINARY
-- On DELETE reduce production binary -> BINARY
-- On DEFAULT reduce production binary -> BINARY
-- On CREATE reduce production binary -> BINARY
-- On COMMENT reduce production binary -> BINARY
-- On COMMA reduce production binary -> BINARY
-- On COLLATE reduce production binary -> BINARY
-- On CHECK reduce production binary -> BINARY
-- On BEGIN reduce production binary -> BINARY
-- On AUTOINCREMENT reduce production binary -> BINARY
-- On AS reduce production binary -> BINARY
-- On ALTER reduce production binary -> BINARY
-- On AFTER reduce production binary -> BINARY

State 395:
## Known stack suffix:
## BINARY VARYING
## LR(1) items:
binary -> BINARY VARYING . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production binary -> BINARY VARYING

State 396:
## Known stack suffix:
## sql_type_flavor
## LR(1) items:
sql_type -> sql_type_flavor . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
sql_type -> sql_type_flavor . LPAREN INTEGER RPAREN option(UNSIGNED) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
sql_type -> sql_type_flavor . LPAREN INTEGER COMMA INTEGER RPAREN [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On LPAREN shift to state 397
## Reductions:
-- On UPDATE reduce production sql_type -> sql_type_flavor
-- On UNIQUE reduce production sql_type -> sql_type_flavor
-- On TEXT reduce production sql_type -> sql_type_flavor
-- On SET reduce production sql_type -> sql_type_flavor
-- On SELECT reduce production sql_type -> sql_type_flavor
-- On RPAREN reduce production sql_type -> sql_type_flavor
-- On REPLACE reduce production sql_type -> sql_type_flavor
-- On PRIMARY reduce production sql_type -> sql_type_flavor
-- On ON reduce production sql_type -> sql_type_flavor
-- On NULL reduce production sql_type -> sql_type_flavor
-- On NOT reduce production sql_type -> sql_type_flavor
-- On LANGUAGE reduce production sql_type -> sql_type_flavor
-- On INSERT reduce production sql_type -> sql_type_flavor
-- On FIRST reduce production sql_type -> sql_type_flavor
-- On EQUAL reduce production sql_type -> sql_type_flavor
-- On EOF reduce production sql_type -> sql_type_flavor
-- On END reduce production sql_type -> sql_type_flavor
-- On DROP reduce production sql_type -> sql_type_flavor
-- On DELETE reduce production sql_type -> sql_type_flavor
-- On DEFAULT reduce production sql_type -> sql_type_flavor
-- On CREATE reduce production sql_type -> sql_type_flavor
-- On COMMENT reduce production sql_type -> sql_type_flavor
-- On COMMA reduce production sql_type -> sql_type_flavor
-- On COLLATE reduce production sql_type -> sql_type_flavor
-- On CHECK reduce production sql_type -> sql_type_flavor
-- On BEGIN reduce production sql_type -> sql_type_flavor
-- On AUTOINCREMENT reduce production sql_type -> sql_type_flavor
-- On AS reduce production sql_type -> sql_type_flavor
-- On ALTER reduce production sql_type -> sql_type_flavor
-- On AFTER reduce production sql_type -> sql_type_flavor

State 397:
## Known stack suffix:
## sql_type_flavor LPAREN
## LR(1) items:
sql_type -> sql_type_flavor LPAREN . INTEGER RPAREN option(UNSIGNED) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
sql_type -> sql_type_flavor LPAREN . INTEGER COMMA INTEGER RPAREN [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On INTEGER shift to state 398
## Reductions:

State 398:
## Known stack suffix:
## sql_type_flavor LPAREN INTEGER
## LR(1) items:
sql_type -> sql_type_flavor LPAREN INTEGER . RPAREN option(UNSIGNED) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
sql_type -> sql_type_flavor LPAREN INTEGER . COMMA INTEGER RPAREN [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On RPAREN shift to state 399
-- On COMMA shift to state 401
## Reductions:

State 399:
## Known stack suffix:
## sql_type_flavor LPAREN INTEGER RPAREN
## LR(1) items:
sql_type -> sql_type_flavor LPAREN INTEGER RPAREN . option(UNSIGNED) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On UNSIGNED shift to state 361
-- On option(UNSIGNED) shift to state 400
## Reductions:
-- On UPDATE reduce production option(UNSIGNED) ->
-- On UNIQUE reduce production option(UNSIGNED) ->
-- On TEXT reduce production option(UNSIGNED) ->
-- On SET reduce production option(UNSIGNED) ->
-- On SELECT reduce production option(UNSIGNED) ->
-- On RPAREN reduce production option(UNSIGNED) ->
-- On REPLACE reduce production option(UNSIGNED) ->
-- On PRIMARY reduce production option(UNSIGNED) ->
-- On ON reduce production option(UNSIGNED) ->
-- On NULL reduce production option(UNSIGNED) ->
-- On NOT reduce production option(UNSIGNED) ->
-- On LANGUAGE reduce production option(UNSIGNED) ->
-- On INSERT reduce production option(UNSIGNED) ->
-- On FIRST reduce production option(UNSIGNED) ->
-- On EQUAL reduce production option(UNSIGNED) ->
-- On EOF reduce production option(UNSIGNED) ->
-- On END reduce production option(UNSIGNED) ->
-- On DROP reduce production option(UNSIGNED) ->
-- On DELETE reduce production option(UNSIGNED) ->
-- On DEFAULT reduce production option(UNSIGNED) ->
-- On CREATE reduce production option(UNSIGNED) ->
-- On COMMENT reduce production option(UNSIGNED) ->
-- On COMMA reduce production option(UNSIGNED) ->
-- On COLLATE reduce production option(UNSIGNED) ->
-- On CHECK reduce production option(UNSIGNED) ->
-- On BEGIN reduce production option(UNSIGNED) ->
-- On AUTOINCREMENT reduce production option(UNSIGNED) ->
-- On AS reduce production option(UNSIGNED) ->
-- On ALTER reduce production option(UNSIGNED) ->
-- On AFTER reduce production option(UNSIGNED) ->

State 400:
## Known stack suffix:
## sql_type_flavor LPAREN INTEGER RPAREN option(UNSIGNED)
## LR(1) items:
sql_type -> sql_type_flavor LPAREN INTEGER RPAREN option(UNSIGNED) . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type -> sql_type_flavor LPAREN INTEGER RPAREN option(UNSIGNED)

State 401:
## Known stack suffix:
## sql_type_flavor LPAREN INTEGER COMMA
## LR(1) items:
sql_type -> sql_type_flavor LPAREN INTEGER COMMA . INTEGER RPAREN [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On INTEGER shift to state 402
## Reductions:

State 402:
## Known stack suffix:
## sql_type_flavor LPAREN INTEGER COMMA INTEGER
## LR(1) items:
sql_type -> sql_type_flavor LPAREN INTEGER COMMA INTEGER . RPAREN [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On RPAREN shift to state 403
## Reductions:

State 403:
## Known stack suffix:
## sql_type_flavor LPAREN INTEGER COMMA INTEGER RPAREN
## LR(1) items:
sql_type -> sql_type_flavor LPAREN INTEGER COMMA INTEGER RPAREN . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type -> sql_type_flavor LPAREN INTEGER COMMA INTEGER RPAREN

State 404:
## Known stack suffix:
## sql_type
## LR(1) items:
option(sql_type) -> sql_type . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(sql_type) -> sql_type

State 405:
## Known stack suffix:
## IDENT option(sql_type)
## LR(1) items:
column_def -> IDENT option(sql_type) . list(column_def_extra) [ UPDATE SET SELECT RPAREN REPLACE INSERT FIRST EOF END DROP DELETE CREATE COMMA ALTER AFTER ]
## Transitions:
-- On UNIQUE shift to state 406
-- On PRIMARY shift to state 407
-- On ON shift to state 409
-- On NULL shift to state 412
-- On NOT shift to state 413
-- On DEFAULT shift to state 415
-- On COLLATE shift to state 423
-- On CHECK shift to state 425
-- On AUTOINCREMENT shift to state 429
-- On on_conflict shift to state 430
-- On list(column_def_extra) shift to state 431
-- On column_def_extra shift to state 432
## Reductions:
-- On UPDATE reduce production list(column_def_extra) ->
-- On SET reduce production list(column_def_extra) ->
-- On SELECT reduce production list(column_def_extra) ->
-- On RPAREN reduce production list(column_def_extra) ->
-- On REPLACE reduce production list(column_def_extra) ->
-- On INSERT reduce production list(column_def_extra) ->
-- On FIRST reduce production list(column_def_extra) ->
-- On EOF reduce production list(column_def_extra) ->
-- On END reduce production list(column_def_extra) ->
-- On DROP reduce production list(column_def_extra) ->
-- On DELETE reduce production list(column_def_extra) ->
-- On CREATE reduce production list(column_def_extra) ->
-- On COMMA reduce production list(column_def_extra) ->
-- On ALTER reduce production list(column_def_extra) ->
-- On AFTER reduce production list(column_def_extra) ->

State 406:
## Known stack suffix:
## UNIQUE
## LR(1) items:
column_def_extra -> UNIQUE . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def_extra -> UNIQUE

State 407:
## Known stack suffix:
## PRIMARY
## LR(1) items:
column_def_extra -> PRIMARY . KEY [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
-- On KEY shift to state 408
## Reductions:

State 408:
## Known stack suffix:
## PRIMARY KEY
## LR(1) items:
column_def_extra -> PRIMARY KEY . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def_extra -> PRIMARY KEY

State 409:
## Known stack suffix:
## ON
## LR(1) items:
on_conflict -> ON . CONFLICT conflict_algo [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
-- On CONFLICT shift to state 410
## Reductions:

State 410:
## Known stack suffix:
## ON CONFLICT
## LR(1) items:
on_conflict -> ON CONFLICT . conflict_algo [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
-- On REPLACE shift to state 3
-- On CONFLICT_ALGO shift to state 4
-- On conflict_algo shift to state 411
## Reductions:

State 411:
## Known stack suffix:
## ON CONFLICT conflict_algo
## LR(1) items:
on_conflict -> ON CONFLICT conflict_algo . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production on_conflict -> ON CONFLICT conflict_algo

State 412:
## Known stack suffix:
## NULL
## LR(1) items:
column_def_extra -> NULL . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def_extra -> NULL

State 413:
## Known stack suffix:
## NOT
## LR(1) items:
column_def_extra -> NOT . NULL [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
-- On NULL shift to state 414
## Reductions:

State 414:
## Known stack suffix:
## NOT NULL
## LR(1) items:
column_def_extra -> NOT NULL . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def_extra -> NOT NULL

State 415:
## Known stack suffix:
## DEFAULT
## LR(1) items:
column_def_extra -> DEFAULT . default_value [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TEXT shift to state 19
-- On NULL shift to state 21
-- On MINUS shift to state 416
-- On INTEGER shift to state 32
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On BLOB shift to state 52
-- On single_literal_value shift to state 419
-- On literal_value shift to state 420
-- On default_value shift to state 421
-- On datetime_value shift to state 422
## Reductions:

State 416:
## Known stack suffix:
## MINUS
## LR(1) items:
single_literal_value -> MINUS . INTEGER [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
single_literal_value -> MINUS . FLOAT [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
-- On INTEGER shift to state 417
-- On FLOAT shift to state 418
## Reductions:

State 417:
## Known stack suffix:
## MINUS INTEGER
## LR(1) items:
single_literal_value -> MINUS INTEGER . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production single_literal_value -> MINUS INTEGER

State 418:
## Known stack suffix:
## MINUS FLOAT
## LR(1) items:
single_literal_value -> MINUS FLOAT . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production single_literal_value -> MINUS FLOAT

State 419:
## Known stack suffix:
## single_literal_value
## LR(1) items:
default_value -> single_literal_value . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production default_value -> single_literal_value

State 420:
## Known stack suffix:
## literal_value
## LR(1) items:
single_literal_value -> literal_value . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production single_literal_value -> literal_value

State 421:
## Known stack suffix:
## DEFAULT default_value
## LR(1) items:
column_def_extra -> DEFAULT default_value . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def_extra -> DEFAULT default_value

State 422:
## Known stack suffix:
## datetime_value
## LR(1) items:
default_value -> datetime_value . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production default_value -> datetime_value

State 423:
## Known stack suffix:
## COLLATE
## LR(1) items:
column_def_extra -> COLLATE . IDENT [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
-- On IDENT shift to state 424
## Reductions:

State 424:
## Known stack suffix:
## COLLATE IDENT
## LR(1) items:
column_def_extra -> COLLATE IDENT . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def_extra -> COLLATE IDENT

State 425:
## Known stack suffix:
## CHECK
## LR(1) items:
column_def_extra -> CHECK . LPAREN expr RPAREN [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
-- On LPAREN shift to state 426
## Reductions:

State 426:
## Known stack suffix:
## CHECK LPAREN
## LR(1) items:
column_def_extra -> CHECK LPAREN . expr RPAREN [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 427
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 427:
## Known stack suffix:
## CHECK LPAREN expr
## LR(1) items:
column_def_extra -> CHECK LPAREN expr . RPAREN [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
expr -> expr . numeric_bin_op expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
## Transitions:
-- On RPAREN shift to state 428
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:

State 428:
## Known stack suffix:
## CHECK LPAREN expr RPAREN
## LR(1) items:
column_def_extra -> CHECK LPAREN expr RPAREN . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def_extra -> CHECK LPAREN expr RPAREN

State 429:
## Known stack suffix:
## AUTOINCREMENT
## LR(1) items:
column_def_extra -> AUTOINCREMENT . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def_extra -> AUTOINCREMENT

State 430:
## Known stack suffix:
## on_conflict
## LR(1) items:
column_def_extra -> on_conflict . [ UPDATE UNIQUE SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT INSERT FIRST EOF END DROP DELETE DEFAULT CREATE COMMA COLLATE CHECK AUTOINCREMENT ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def_extra -> on_conflict

State 431:
## Known stack suffix:
## IDENT option(sql_type) list(column_def_extra)
## LR(1) items:
column_def -> IDENT option(sql_type) list(column_def_extra) . [ UPDATE SET SELECT RPAREN REPLACE INSERT FIRST EOF END DROP DELETE CREATE COMMA ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def -> IDENT option(sql_type) list(column_def_extra)

State 432:
## Known stack suffix:
## column_def_extra
## LR(1) items:
list(column_def_extra) -> column_def_extra . list(column_def_extra) [ UPDATE SET SELECT RPAREN REPLACE INSERT FIRST EOF END DROP DELETE CREATE COMMA ALTER AFTER ]
## Transitions:
-- On UNIQUE shift to state 406
-- On PRIMARY shift to state 407
-- On ON shift to state 409
-- On NULL shift to state 412
-- On NOT shift to state 413
-- On DEFAULT shift to state 415
-- On COLLATE shift to state 423
-- On CHECK shift to state 425
-- On AUTOINCREMENT shift to state 429
-- On on_conflict shift to state 430
-- On list(column_def_extra) shift to state 433
-- On column_def_extra shift to state 432
## Reductions:
-- On UPDATE reduce production list(column_def_extra) ->
-- On SET reduce production list(column_def_extra) ->
-- On SELECT reduce production list(column_def_extra) ->
-- On RPAREN reduce production list(column_def_extra) ->
-- On REPLACE reduce production list(column_def_extra) ->
-- On INSERT reduce production list(column_def_extra) ->
-- On FIRST reduce production list(column_def_extra) ->
-- On EOF reduce production list(column_def_extra) ->
-- On END reduce production list(column_def_extra) ->
-- On DROP reduce production list(column_def_extra) ->
-- On DELETE reduce production list(column_def_extra) ->
-- On CREATE reduce production list(column_def_extra) ->
-- On COMMA reduce production list(column_def_extra) ->
-- On ALTER reduce production list(column_def_extra) ->
-- On AFTER reduce production list(column_def_extra) ->

State 433:
## Known stack suffix:
## column_def_extra list(column_def_extra)
## LR(1) items:
list(column_def_extra) -> column_def_extra list(column_def_extra) . [ UPDATE SET SELECT RPAREN REPLACE INSERT FIRST EOF END DROP DELETE CREATE COMMA ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(column_def_extra) -> column_def_extra list(column_def_extra)

State 434:
## Known stack suffix:
## option(NATIONAL)
## LR(1) items:
sql_type_flavor -> option(NATIONAL) . text option(VARYING) option(charset) option(collate) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On T_TEXT shift to state 435
-- On CHARACTER shift to state 439
-- On text shift to state 440
## Reductions:

State 435:
## Known stack suffix:
## T_TEXT
## LR(1) items:
text -> T_TEXT . [ VARYING UPDATE UNIQUE UNICODE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK CHARSET CHARACTER BEGIN AUTOINCREMENT ASCII AS ALTER AFTER ]
text -> T_TEXT . LPAREN INTEGER RPAREN [ VARYING UPDATE UNIQUE UNICODE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK CHARSET CHARACTER BEGIN AUTOINCREMENT ASCII AS ALTER AFTER ]
## Transitions:
-- On LPAREN shift to state 436
## Reductions:
-- On VARYING reduce production text -> T_TEXT
-- On UPDATE reduce production text -> T_TEXT
-- On UNIQUE reduce production text -> T_TEXT
-- On UNICODE reduce production text -> T_TEXT
-- On TEXT reduce production text -> T_TEXT
-- On SET reduce production text -> T_TEXT
-- On SELECT reduce production text -> T_TEXT
-- On RPAREN reduce production text -> T_TEXT
-- On REPLACE reduce production text -> T_TEXT
-- On PRIMARY reduce production text -> T_TEXT
-- On ON reduce production text -> T_TEXT
-- On NULL reduce production text -> T_TEXT
-- On NOT reduce production text -> T_TEXT
-- On LANGUAGE reduce production text -> T_TEXT
-- On INSERT reduce production text -> T_TEXT
-- On FIRST reduce production text -> T_TEXT
-- On EQUAL reduce production text -> T_TEXT
-- On EOF reduce production text -> T_TEXT
-- On END reduce production text -> T_TEXT
-- On DROP reduce production text -> T_TEXT
-- On DELETE reduce production text -> T_TEXT
-- On DEFAULT reduce production text -> T_TEXT
-- On CREATE reduce production text -> T_TEXT
-- On COMMENT reduce production text -> T_TEXT
-- On COMMA reduce production text -> T_TEXT
-- On COLLATE reduce production text -> T_TEXT
-- On CHECK reduce production text -> T_TEXT
-- On CHARSET reduce production text -> T_TEXT
-- On CHARACTER reduce production text -> T_TEXT
-- On BEGIN reduce production text -> T_TEXT
-- On AUTOINCREMENT reduce production text -> T_TEXT
-- On ASCII reduce production text -> T_TEXT
-- On AS reduce production text -> T_TEXT
-- On ALTER reduce production text -> T_TEXT
-- On AFTER reduce production text -> T_TEXT

State 436:
## Known stack suffix:
## T_TEXT LPAREN
## LR(1) items:
text -> T_TEXT LPAREN . INTEGER RPAREN [ VARYING UPDATE UNIQUE UNICODE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK CHARSET CHARACTER BEGIN AUTOINCREMENT ASCII AS ALTER AFTER ]
## Transitions:
-- On INTEGER shift to state 437
## Reductions:

State 437:
## Known stack suffix:
## T_TEXT LPAREN INTEGER
## LR(1) items:
text -> T_TEXT LPAREN INTEGER . RPAREN [ VARYING UPDATE UNIQUE UNICODE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK CHARSET CHARACTER BEGIN AUTOINCREMENT ASCII AS ALTER AFTER ]
## Transitions:
-- On RPAREN shift to state 438
## Reductions:

State 438:
## Known stack suffix:
## T_TEXT LPAREN INTEGER RPAREN
## LR(1) items:
text -> T_TEXT LPAREN INTEGER RPAREN . [ VARYING UPDATE UNIQUE UNICODE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK CHARSET CHARACTER BEGIN AUTOINCREMENT ASCII AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production text -> T_TEXT LPAREN INTEGER RPAREN

State 439:
## Known stack suffix:
## CHARACTER
## LR(1) items:
text -> CHARACTER . [ VARYING UPDATE UNIQUE UNICODE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK CHARSET CHARACTER BEGIN AUTOINCREMENT ASCII AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production text -> CHARACTER

State 440:
## Known stack suffix:
## option(NATIONAL) text
## LR(1) items:
sql_type_flavor -> option(NATIONAL) text . option(VARYING) option(charset) option(collate) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On VARYING shift to state 441
-- On option(VARYING) shift to state 442
## Reductions:
-- On UPDATE reduce production option(VARYING) ->
-- On UNIQUE reduce production option(VARYING) ->
-- On UNICODE reduce production option(VARYING) ->
-- On TEXT reduce production option(VARYING) ->
-- On SET reduce production option(VARYING) ->
-- On SELECT reduce production option(VARYING) ->
-- On RPAREN reduce production option(VARYING) ->
-- On REPLACE reduce production option(VARYING) ->
-- On PRIMARY reduce production option(VARYING) ->
-- On ON reduce production option(VARYING) ->
-- On NULL reduce production option(VARYING) ->
-- On NOT reduce production option(VARYING) ->
-- On LPAREN reduce production option(VARYING) ->
-- On LANGUAGE reduce production option(VARYING) ->
-- On INSERT reduce production option(VARYING) ->
-- On FIRST reduce production option(VARYING) ->
-- On EQUAL reduce production option(VARYING) ->
-- On EOF reduce production option(VARYING) ->
-- On END reduce production option(VARYING) ->
-- On DROP reduce production option(VARYING) ->
-- On DELETE reduce production option(VARYING) ->
-- On DEFAULT reduce production option(VARYING) ->
-- On CREATE reduce production option(VARYING) ->
-- On COMMENT reduce production option(VARYING) ->
-- On COMMA reduce production option(VARYING) ->
-- On COLLATE reduce production option(VARYING) ->
-- On CHECK reduce production option(VARYING) ->
-- On CHARSET reduce production option(VARYING) ->
-- On CHARACTER reduce production option(VARYING) ->
-- On BEGIN reduce production option(VARYING) ->
-- On AUTOINCREMENT reduce production option(VARYING) ->
-- On ASCII reduce production option(VARYING) ->
-- On AS reduce production option(VARYING) ->
-- On ALTER reduce production option(VARYING) ->
-- On AFTER reduce production option(VARYING) ->

State 441:
## Known stack suffix:
## VARYING
## LR(1) items:
option(VARYING) -> VARYING . [ UPDATE UNIQUE UNICODE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK CHARSET CHARACTER BEGIN AUTOINCREMENT ASCII AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(VARYING) -> VARYING

State 442:
## Known stack suffix:
## option(NATIONAL) text option(VARYING)
## LR(1) items:
sql_type_flavor -> option(NATIONAL) text option(VARYING) . option(charset) option(collate) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On UNICODE shift to state 381
-- On CHARSET shift to state 382
-- On CHARACTER shift to state 385
-- On ASCII shift to state 389
-- On option(charset) shift to state 443
-- On charset shift to state 392
## Reductions:
-- On UPDATE reduce production option(charset) ->
-- On UNIQUE reduce production option(charset) ->
-- On TEXT reduce production option(charset) ->
-- On SET reduce production option(charset) ->
-- On SELECT reduce production option(charset) ->
-- On RPAREN reduce production option(charset) ->
-- On REPLACE reduce production option(charset) ->
-- On PRIMARY reduce production option(charset) ->
-- On ON reduce production option(charset) ->
-- On NULL reduce production option(charset) ->
-- On NOT reduce production option(charset) ->
-- On LPAREN reduce production option(charset) ->
-- On LANGUAGE reduce production option(charset) ->
-- On INSERT reduce production option(charset) ->
-- On FIRST reduce production option(charset) ->
-- On EQUAL reduce production option(charset) ->
-- On EOF reduce production option(charset) ->
-- On END reduce production option(charset) ->
-- On DROP reduce production option(charset) ->
-- On DELETE reduce production option(charset) ->
-- On DEFAULT reduce production option(charset) ->
-- On CREATE reduce production option(charset) ->
-- On COMMENT reduce production option(charset) ->
-- On COMMA reduce production option(charset) ->
-- On COLLATE reduce production option(charset) ->
-- On CHECK reduce production option(charset) ->
-- On BEGIN reduce production option(charset) ->
-- On AUTOINCREMENT reduce production option(charset) ->
-- On AS reduce production option(charset) ->
-- On ALTER reduce production option(charset) ->
-- On AFTER reduce production option(charset) ->

State 443:
## Known stack suffix:
## option(NATIONAL) text option(VARYING) option(charset)
## LR(1) items:
sql_type_flavor -> option(NATIONAL) text option(VARYING) option(charset) . option(collate) [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
-- On COLLATE shift to state 346
-- On option(collate) shift to state 444
-- On collate shift to state 350
## Reductions:
-- On UPDATE reduce production option(collate) ->
-- On UNIQUE reduce production option(collate) ->
-- On TEXT reduce production option(collate) ->
-- On SET reduce production option(collate) ->
-- On SELECT reduce production option(collate) ->
-- On RPAREN reduce production option(collate) ->
-- On REPLACE reduce production option(collate) ->
-- On PRIMARY reduce production option(collate) ->
-- On ON reduce production option(collate) ->
-- On NULL reduce production option(collate) ->
-- On NOT reduce production option(collate) ->
-- On LPAREN reduce production option(collate) ->
-- On LANGUAGE reduce production option(collate) ->
-- On INSERT reduce production option(collate) ->
-- On FIRST reduce production option(collate) ->
-- On EQUAL reduce production option(collate) ->
-- On EOF reduce production option(collate) ->
-- On END reduce production option(collate) ->
-- On DROP reduce production option(collate) ->
-- On DELETE reduce production option(collate) ->
-- On DEFAULT reduce production option(collate) ->
-- On CREATE reduce production option(collate) ->
-- On COMMENT reduce production option(collate) ->
-- On COMMA reduce production option(collate) ->
-- On CHECK reduce production option(collate) ->
-- On BEGIN reduce production option(collate) ->
-- On AUTOINCREMENT reduce production option(collate) ->
-- On AS reduce production option(collate) ->
-- On ALTER reduce production option(collate) ->
-- On AFTER reduce production option(collate) ->

State 444:
## Known stack suffix:
## option(NATIONAL) text option(VARYING) option(charset) option(collate)
## LR(1) items:
sql_type_flavor -> option(NATIONAL) text option(VARYING) option(charset) option(collate) . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type_flavor -> option(NATIONAL) text option(VARYING) option(charset) option(collate)

State 445:
## Known stack suffix:
## binary
## LR(1) items:
sql_type_flavor -> binary . [ UPDATE UNIQUE TEXT SET SELECT RPAREN REPLACE PRIMARY ON NULL NOT LPAREN LANGUAGE INSERT FIRST EQUAL EOF END DROP DELETE DEFAULT CREATE COMMENT COMMA COLLATE CHECK BEGIN AUTOINCREMENT AS ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production sql_type_flavor -> binary

State 446:
## Known stack suffix:
## CONSTRAINT
## LR(1) items:
option(pair(CONSTRAINT,IDENT)) -> CONSTRAINT . IDENT [ UNIQUE PRIMARY KEY FULLTEXT FOREIGN CHECK ]
## Transitions:
-- On IDENT shift to state 447
## Reductions:

State 447:
## Known stack suffix:
## CONSTRAINT IDENT
## LR(1) items:
option(pair(CONSTRAINT,IDENT)) -> CONSTRAINT IDENT . [ UNIQUE PRIMARY KEY FULLTEXT FOREIGN CHECK ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(pair(CONSTRAINT,IDENT)) -> CONSTRAINT IDENT

State 448:
## Known stack suffix:
## LPAREN separated_nonempty_list(COMMA,column_def1)
## LR(1) items:
table_definition -> LPAREN separated_nonempty_list(COMMA,column_def1) . table_def_done [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On table_def_done1 shift to state 449
-- On table_def_done shift to state 454
## Default reduction:
-- After reading the next token, reduce production table_def_done1 ->

State 449:
## Known stack suffix:
## table_def_done1
## LR(1) items:
table_def_done -> table_def_done1 . RPAREN list(IGNORED) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On RPAREN shift to state 450
## Reductions:

State 450:
## Known stack suffix:
## table_def_done1 RPAREN
## LR(1) items:
table_def_done -> table_def_done1 RPAREN . list(IGNORED) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IGNORED shift to state 451
-- On list(IGNORED) shift to state 453
## Reductions:
-- On UPDATE reduce production list(IGNORED) ->
-- On SET reduce production list(IGNORED) ->
-- On SELECT reduce production list(IGNORED) ->
-- On REPLACE reduce production list(IGNORED) ->
-- On INSERT reduce production list(IGNORED) ->
-- On EOF reduce production list(IGNORED) ->
-- On END reduce production list(IGNORED) ->
-- On DROP reduce production list(IGNORED) ->
-- On DELETE reduce production list(IGNORED) ->
-- On CREATE reduce production list(IGNORED) ->
-- On ALTER reduce production list(IGNORED) ->

State 451:
## Known stack suffix:
## IGNORED
## LR(1) items:
list(IGNORED) -> IGNORED . list(IGNORED) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IGNORED shift to state 451
-- On list(IGNORED) shift to state 452
## Reductions:
-- On UPDATE reduce production list(IGNORED) ->
-- On SET reduce production list(IGNORED) ->
-- On SELECT reduce production list(IGNORED) ->
-- On REPLACE reduce production list(IGNORED) ->
-- On INSERT reduce production list(IGNORED) ->
-- On EOF reduce production list(IGNORED) ->
-- On END reduce production list(IGNORED) ->
-- On DROP reduce production list(IGNORED) ->
-- On DELETE reduce production list(IGNORED) ->
-- On CREATE reduce production list(IGNORED) ->
-- On ALTER reduce production list(IGNORED) ->

State 452:
## Known stack suffix:
## IGNORED list(IGNORED)
## LR(1) items:
list(IGNORED) -> IGNORED list(IGNORED) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(IGNORED) -> IGNORED list(IGNORED)

State 453:
## Known stack suffix:
## table_def_done1 RPAREN list(IGNORED)
## LR(1) items:
table_def_done -> table_def_done1 RPAREN list(IGNORED) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production table_def_done -> table_def_done1 RPAREN list(IGNORED)

State 454:
## Known stack suffix:
## LPAREN separated_nonempty_list(COMMA,column_def1) table_def_done
## LR(1) items:
table_definition -> LPAREN separated_nonempty_list(COMMA,column_def1) table_def_done . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production table_definition -> LPAREN separated_nonempty_list(COMMA,column_def1) table_def_done

State 455:
## Known stack suffix:
## option(pair(CONSTRAINT,IDENT))
## LR(1) items:
column_def1 -> option(pair(CONSTRAINT,IDENT)) . table_constraint_1 [ RPAREN COMMA ]
## Transitions:
-- On UNIQUE shift to state 456
-- On PRIMARY shift to state 459
-- On FULLTEXT shift to state 460
-- On FOREIGN shift to state 462
-- On CHECK shift to state 490
-- On table_constraint_1 shift to state 494
-- On some_key shift to state 495
-- On option(PRIMARY) shift to state 503
## Reductions:
-- On KEY reduce production option(PRIMARY) ->

State 456:
## Known stack suffix:
## UNIQUE
## LR(1) items:
some_key -> UNIQUE . option(KEY) [ LPAREN IDENT ]
## Transitions:
-- On KEY shift to state 457
-- On option(KEY) shift to state 458
## Reductions:
-- On LPAREN reduce production option(KEY) ->
-- On IDENT reduce production option(KEY) ->

State 457:
## Known stack suffix:
## KEY
## LR(1) items:
option(KEY) -> KEY . [ LPAREN IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(KEY) -> KEY

State 458:
## Known stack suffix:
## UNIQUE option(KEY)
## LR(1) items:
some_key -> UNIQUE option(KEY) . [ LPAREN IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production some_key -> UNIQUE option(KEY)

State 459:
## Known stack suffix:
## PRIMARY
## LR(1) items:
option(PRIMARY) -> PRIMARY . [ KEY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(PRIMARY) -> PRIMARY

State 460:
## Known stack suffix:
## FULLTEXT
## LR(1) items:
some_key -> FULLTEXT . KEY [ LPAREN IDENT ]
## Transitions:
-- On KEY shift to state 461
## Reductions:

State 461:
## Known stack suffix:
## FULLTEXT KEY
## LR(1) items:
some_key -> FULLTEXT KEY . [ LPAREN IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production some_key -> FULLTEXT KEY

State 462:
## Known stack suffix:
## FOREIGN
## LR(1) items:
table_constraint_1 -> FOREIGN . KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES IDENT option(sequence(IDENT)) list(reference_action_clause) [ RPAREN COMMA ]
## Transitions:
-- On KEY shift to state 463
## Reductions:

State 463:
## Known stack suffix:
## FOREIGN KEY
## LR(1) items:
table_constraint_1 -> FOREIGN KEY . option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES IDENT option(sequence(IDENT)) list(reference_action_clause) [ RPAREN COMMA ]
## Transitions:
-- On IDENT shift to state 464
-- On option(IDENT) shift to state 465
## Reductions:
-- On LPAREN reduce production option(IDENT) ->

State 464:
## Known stack suffix:
## IDENT
## LR(1) items:
option(IDENT) -> IDENT . [ LPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(IDENT) -> IDENT

State 465:
## Known stack suffix:
## FOREIGN KEY option(IDENT)
## LR(1) items:
table_constraint_1 -> FOREIGN KEY option(IDENT) . LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES IDENT option(sequence(IDENT)) list(reference_action_clause) [ RPAREN COMMA ]
## Transitions:
-- On LPAREN shift to state 466
## Reductions:

State 466:
## Known stack suffix:
## FOREIGN KEY option(IDENT) LPAREN
## LR(1) items:
table_constraint_1 -> FOREIGN KEY option(IDENT) LPAREN . separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES IDENT option(sequence(IDENT)) list(reference_action_clause) [ RPAREN COMMA ]
## Transitions:
-- On IDENT shift to state 158
-- On separated_nonempty_list(COMMA,IDENT) shift to state 467
## Reductions:

State 467:
## Known stack suffix:
## FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT)
## LR(1) items:
table_constraint_1 -> FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) . RPAREN REFERENCES IDENT option(sequence(IDENT)) list(reference_action_clause) [ RPAREN COMMA ]
## Transitions:
-- On RPAREN shift to state 468
## Reductions:

State 468:
## Known stack suffix:
## FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN
## LR(1) items:
table_constraint_1 -> FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN . REFERENCES IDENT option(sequence(IDENT)) list(reference_action_clause) [ RPAREN COMMA ]
## Transitions:
-- On REFERENCES shift to state 469
## Reductions:

State 469:
## Known stack suffix:
## FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES
## LR(1) items:
table_constraint_1 -> FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES . IDENT option(sequence(IDENT)) list(reference_action_clause) [ RPAREN COMMA ]
## Transitions:
-- On IDENT shift to state 470
## Reductions:

State 470:
## Known stack suffix:
## FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES IDENT
## LR(1) items:
table_constraint_1 -> FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES IDENT . option(sequence(IDENT)) list(reference_action_clause) [ RPAREN COMMA ]
## Transitions:
-- On LPAREN shift to state 471
-- On option(sequence(IDENT)) shift to state 474
## Reductions:
-- On RPAREN reduce production option(sequence(IDENT)) ->
-- On ON reduce production option(sequence(IDENT)) ->
-- On COMMA reduce production option(sequence(IDENT)) ->

State 471:
## Known stack suffix:
## LPAREN
## LR(1) items:
option(sequence(IDENT)) -> LPAREN . separated_nonempty_list(COMMA,IDENT) RPAREN [ VALUES SELECT RPAREN ON LPAREN COMMA ]
## Transitions:
-- On IDENT shift to state 158
-- On separated_nonempty_list(COMMA,IDENT) shift to state 472
## Reductions:

State 472:
## Known stack suffix:
## LPAREN separated_nonempty_list(COMMA,IDENT)
## LR(1) items:
option(sequence(IDENT)) -> LPAREN separated_nonempty_list(COMMA,IDENT) . RPAREN [ VALUES SELECT RPAREN ON LPAREN COMMA ]
## Transitions:
-- On RPAREN shift to state 473
## Reductions:

State 473:
## Known stack suffix:
## LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN
## LR(1) items:
option(sequence(IDENT)) -> LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN . [ VALUES SELECT RPAREN ON LPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(sequence(IDENT)) -> LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN

State 474:
## Known stack suffix:
## FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES IDENT option(sequence(IDENT))
## LR(1) items:
table_constraint_1 -> FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES IDENT option(sequence(IDENT)) . list(reference_action_clause) [ RPAREN COMMA ]
## Transitions:
-- On ON shift to state 475
-- On reference_action_clause shift to state 487
-- On list(reference_action_clause) shift to state 489
## Reductions:
-- On RPAREN reduce production list(reference_action_clause) ->
-- On COMMA reduce production list(reference_action_clause) ->

State 475:
## Known stack suffix:
## ON
## LR(1) items:
reference_action_clause -> ON . DELETE reference_action [ RPAREN ON COMMA ]
reference_action_clause -> ON . UPDATE reference_action [ RPAREN ON COMMA ]
## Transitions:
-- On UPDATE shift to state 476
-- On DELETE shift to state 485
## Reductions:

State 476:
## Known stack suffix:
## ON UPDATE
## LR(1) items:
reference_action_clause -> ON UPDATE . reference_action [ RPAREN ON COMMA ]
## Transitions:
-- On SET shift to state 477
-- On RESTRICT shift to state 480
-- On NO shift to state 481
-- On CASCADE shift to state 483
-- On reference_action shift to state 484
## Reductions:

State 477:
## Known stack suffix:
## SET
## LR(1) items:
reference_action -> SET . NULL [ RPAREN ON COMMA ]
reference_action -> SET . DEFAULT [ RPAREN ON COMMA ]
## Transitions:
-- On NULL shift to state 478
-- On DEFAULT shift to state 479
## Reductions:

State 478:
## Known stack suffix:
## SET NULL
## LR(1) items:
reference_action -> SET NULL . [ RPAREN ON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_action -> SET NULL

State 479:
## Known stack suffix:
## SET DEFAULT
## LR(1) items:
reference_action -> SET DEFAULT . [ RPAREN ON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_action -> SET DEFAULT

State 480:
## Known stack suffix:
## RESTRICT
## LR(1) items:
reference_action -> RESTRICT . [ RPAREN ON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_action -> RESTRICT

State 481:
## Known stack suffix:
## NO
## LR(1) items:
reference_action -> NO . ACTION [ RPAREN ON COMMA ]
## Transitions:
-- On ACTION shift to state 482
## Reductions:

State 482:
## Known stack suffix:
## NO ACTION
## LR(1) items:
reference_action -> NO ACTION . [ RPAREN ON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_action -> NO ACTION

State 483:
## Known stack suffix:
## CASCADE
## LR(1) items:
reference_action -> CASCADE . [ RPAREN ON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_action -> CASCADE

State 484:
## Known stack suffix:
## ON UPDATE reference_action
## LR(1) items:
reference_action_clause -> ON UPDATE reference_action . [ RPAREN ON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_action_clause -> ON UPDATE reference_action

State 485:
## Known stack suffix:
## ON DELETE
## LR(1) items:
reference_action_clause -> ON DELETE . reference_action [ RPAREN ON COMMA ]
## Transitions:
-- On SET shift to state 477
-- On RESTRICT shift to state 480
-- On NO shift to state 481
-- On CASCADE shift to state 483
-- On reference_action shift to state 486
## Reductions:

State 486:
## Known stack suffix:
## ON DELETE reference_action
## LR(1) items:
reference_action_clause -> ON DELETE reference_action . [ RPAREN ON COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production reference_action_clause -> ON DELETE reference_action

State 487:
## Known stack suffix:
## reference_action_clause
## LR(1) items:
list(reference_action_clause) -> reference_action_clause . list(reference_action_clause) [ RPAREN COMMA ]
## Transitions:
-- On ON shift to state 475
-- On reference_action_clause shift to state 487
-- On list(reference_action_clause) shift to state 488
## Reductions:
-- On RPAREN reduce production list(reference_action_clause) ->
-- On COMMA reduce production list(reference_action_clause) ->

State 488:
## Known stack suffix:
## reference_action_clause list(reference_action_clause)
## LR(1) items:
list(reference_action_clause) -> reference_action_clause list(reference_action_clause) . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production list(reference_action_clause) -> reference_action_clause list(reference_action_clause)

State 489:
## Known stack suffix:
## FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES IDENT option(sequence(IDENT)) list(reference_action_clause)
## LR(1) items:
table_constraint_1 -> FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES IDENT option(sequence(IDENT)) list(reference_action_clause) . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production table_constraint_1 -> FOREIGN KEY option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN REFERENCES IDENT option(sequence(IDENT)) list(reference_action_clause)

State 490:
## Known stack suffix:
## CHECK
## LR(1) items:
table_constraint_1 -> CHECK . LPAREN expr RPAREN [ RPAREN COMMA ]
## Transitions:
-- On LPAREN shift to state 491
## Reductions:

State 491:
## Known stack suffix:
## CHECK LPAREN
## LR(1) items:
table_constraint_1 -> CHECK LPAREN . expr RPAREN [ RPAREN COMMA ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 492
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 492:
## Known stack suffix:
## CHECK LPAREN expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP BETWEEN ASTERISK AND ]
table_constraint_1 -> CHECK LPAREN expr . RPAREN [ RPAREN COMMA ]
## Transitions:
-- On RPAREN shift to state 493
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:

State 493:
## Known stack suffix:
## CHECK LPAREN expr RPAREN
## LR(1) items:
table_constraint_1 -> CHECK LPAREN expr RPAREN . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production table_constraint_1 -> CHECK LPAREN expr RPAREN

State 494:
## Known stack suffix:
## option(pair(CONSTRAINT,IDENT)) table_constraint_1
## LR(1) items:
column_def1 -> option(pair(CONSTRAINT,IDENT)) table_constraint_1 . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def1 -> option(pair(CONSTRAINT,IDENT)) table_constraint_1

State 495:
## Known stack suffix:
## some_key
## LR(1) items:
table_constraint_1 -> some_key . option(IDENT) key_arg [ RPAREN COMMA ]
## Transitions:
-- On IDENT shift to state 464
-- On option(IDENT) shift to state 496
## Reductions:
-- On LPAREN reduce production option(IDENT) ->

State 496:
## Known stack suffix:
## some_key option(IDENT)
## LR(1) items:
table_constraint_1 -> some_key option(IDENT) . key_arg [ RPAREN COMMA ]
## Transitions:
-- On LPAREN shift to state 497
-- On key_arg shift to state 502
## Reductions:

State 497:
## Known stack suffix:
## LPAREN
## LR(1) items:
key_arg -> LPAREN . VALUE RPAREN [ RPAREN COMMA ]
key_arg -> LPAREN . separated_nonempty_list(COMMA,IDENT) RPAREN [ RPAREN COMMA ]
## Transitions:
-- On VALUE shift to state 498
-- On IDENT shift to state 158
-- On separated_nonempty_list(COMMA,IDENT) shift to state 500
## Reductions:

State 498:
## Known stack suffix:
## LPAREN VALUE
## LR(1) items:
key_arg -> LPAREN VALUE . RPAREN [ RPAREN COMMA ]
## Transitions:
-- On RPAREN shift to state 499
## Reductions:

State 499:
## Known stack suffix:
## LPAREN VALUE RPAREN
## LR(1) items:
key_arg -> LPAREN VALUE RPAREN . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production key_arg -> LPAREN VALUE RPAREN

State 500:
## Known stack suffix:
## LPAREN separated_nonempty_list(COMMA,IDENT)
## LR(1) items:
key_arg -> LPAREN separated_nonempty_list(COMMA,IDENT) . RPAREN [ RPAREN COMMA ]
## Transitions:
-- On RPAREN shift to state 501
## Reductions:

State 501:
## Known stack suffix:
## LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN
## LR(1) items:
key_arg -> LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production key_arg -> LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN

State 502:
## Known stack suffix:
## some_key option(IDENT) key_arg
## LR(1) items:
table_constraint_1 -> some_key option(IDENT) key_arg . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production table_constraint_1 -> some_key option(IDENT) key_arg

State 503:
## Known stack suffix:
## option(PRIMARY)
## LR(1) items:
some_key -> option(PRIMARY) . KEY [ LPAREN IDENT ]
## Transitions:
-- On KEY shift to state 504
## Reductions:

State 504:
## Known stack suffix:
## option(PRIMARY) KEY
## LR(1) items:
some_key -> option(PRIMARY) KEY . [ LPAREN IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production some_key -> option(PRIMARY) KEY

State 505:
## Known stack suffix:
## column_def1
## LR(1) items:
separated_nonempty_list(COMMA,column_def1) -> column_def1 . [ RPAREN ]
separated_nonempty_list(COMMA,column_def1) -> column_def1 . COMMA separated_nonempty_list(COMMA,column_def1) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 506
## Reductions:
-- On RPAREN reduce production separated_nonempty_list(COMMA,column_def1) -> column_def1

State 506:
## Known stack suffix:
## column_def1 COMMA
## LR(1) items:
separated_nonempty_list(COMMA,column_def1) -> column_def1 COMMA . separated_nonempty_list(COMMA,column_def1) [ RPAREN ]
## Transitions:
-- On INDEX shift to state 339
-- On IDENT shift to state 357
-- On CONSTRAINT shift to state 446
-- On separated_nonempty_list(COMMA,column_def1) shift to state 507
-- On option(pair(CONSTRAINT,IDENT)) shift to state 455
-- On column_def1 shift to state 505
-- On column_def shift to state 508
## Reductions:
-- On UNIQUE reduce production option(pair(CONSTRAINT,IDENT)) ->
-- On PRIMARY reduce production option(pair(CONSTRAINT,IDENT)) ->
-- On KEY reduce production option(pair(CONSTRAINT,IDENT)) ->
-- On FULLTEXT reduce production option(pair(CONSTRAINT,IDENT)) ->
-- On FOREIGN reduce production option(pair(CONSTRAINT,IDENT)) ->
-- On CHECK reduce production option(pair(CONSTRAINT,IDENT)) ->

State 507:
## Known stack suffix:
## column_def1 COMMA separated_nonempty_list(COMMA,column_def1)
## LR(1) items:
separated_nonempty_list(COMMA,column_def1) -> column_def1 COMMA separated_nonempty_list(COMMA,column_def1) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,column_def1) -> column_def1 COMMA separated_nonempty_list(COMMA,column_def1)

State 508:
## Known stack suffix:
## column_def
## LR(1) items:
column_def1 -> column_def . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production column_def1 -> column_def

State 509:
## Known stack suffix:
## LIKE
## LR(1) items:
table_definition -> LIKE . maybe_parenth(IDENT) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LPAREN shift to state 510
-- On IDENT shift to state 513
-- On maybe_parenth(IDENT) shift to state 514
## Reductions:

State 510:
## Known stack suffix:
## LPAREN
## LR(1) items:
maybe_parenth(IDENT) -> LPAREN . IDENT RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 511
## Reductions:

State 511:
## Known stack suffix:
## LPAREN IDENT
## LR(1) items:
maybe_parenth(IDENT) -> LPAREN IDENT . RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On RPAREN shift to state 512
## Reductions:

State 512:
## Known stack suffix:
## LPAREN IDENT RPAREN
## LR(1) items:
maybe_parenth(IDENT) -> LPAREN IDENT RPAREN . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybe_parenth(IDENT) -> LPAREN IDENT RPAREN

State 513:
## Known stack suffix:
## IDENT
## LR(1) items:
maybe_parenth(IDENT) -> IDENT . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybe_parenth(IDENT) -> IDENT

State 514:
## Known stack suffix:
## LIKE maybe_parenth(IDENT)
## LR(1) items:
table_definition -> LIKE maybe_parenth(IDENT) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production table_definition -> LIKE maybe_parenth(IDENT)

State 515:
## Known stack suffix:
## CREATE TABLE IDENT AS
## LR(1) items:
statement -> CREATE TABLE IDENT AS . maybe_parenth(select_stmt) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On SELECT shift to state 26
-- On LPAREN shift to state 327
-- On select_stmt shift to state 330
-- On select_core shift to state 58
-- On maybe_parenth(select_stmt) shift to state 516
## Reductions:

State 516:
## Known stack suffix:
## CREATE TABLE IDENT AS maybe_parenth(select_stmt)
## LR(1) items:
statement -> CREATE TABLE IDENT AS maybe_parenth(select_stmt) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> CREATE TABLE IDENT AS maybe_parenth(select_stmt)

State 517:
## Known stack suffix:
## CREATE TABLE IDENT table_definition
## LR(1) items:
statement -> CREATE TABLE IDENT table_definition . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> CREATE TABLE IDENT table_definition

State 518:
## Known stack suffix:
## CREATE TABLE if_not_exists
## LR(1) items:
statement -> CREATE TABLE if_not_exists . IDENT table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 519
## Reductions:

State 519:
## Known stack suffix:
## CREATE TABLE if_not_exists IDENT
## LR(1) items:
statement -> CREATE TABLE if_not_exists IDENT . table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LPAREN shift to state 338
-- On LIKE shift to state 509
-- On table_definition shift to state 520
## Reductions:

State 520:
## Known stack suffix:
## CREATE TABLE if_not_exists IDENT table_definition
## LR(1) items:
statement -> CREATE TABLE if_not_exists IDENT table_definition . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> CREATE TABLE if_not_exists IDENT table_definition

State 521:
## Known stack suffix:
## OR
## LR(1) items:
or_replace -> OR . REPLACE [ PROCEDURE FUNCTION ]
## Transitions:
-- On REPLACE shift to state 522
## Reductions:

State 522:
## Known stack suffix:
## OR REPLACE
## LR(1) items:
or_replace -> OR REPLACE . [ PROCEDURE FUNCTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production or_replace -> OR REPLACE

State 523:
## Known stack suffix:
## LOCAL
## LR(1) items:
option(either(GLOBAL,LOCAL)) -> LOCAL . [ TEMPORARY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(either(GLOBAL,LOCAL)) -> LOCAL

State 524:
## Known stack suffix:
## GLOBAL
## LR(1) items:
option(either(GLOBAL,LOCAL)) -> GLOBAL . [ TEMPORARY ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(either(GLOBAL,LOCAL)) -> GLOBAL

State 525:
## Known stack suffix:
## CREATE temporary
## LR(1) items:
statement -> CREATE temporary . TABLE IDENT table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE temporary . TABLE if_not_exists IDENT table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On TABLE shift to state 526
## Reductions:

State 526:
## Known stack suffix:
## CREATE temporary TABLE
## LR(1) items:
statement -> CREATE temporary TABLE . IDENT table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE temporary TABLE . if_not_exists IDENT table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IF shift to state 334
-- On IDENT shift to state 527
-- On if_not_exists shift to state 529
## Reductions:

State 527:
## Known stack suffix:
## CREATE temporary TABLE IDENT
## LR(1) items:
statement -> CREATE temporary TABLE IDENT . table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LPAREN shift to state 338
-- On LIKE shift to state 509
-- On table_definition shift to state 528
## Reductions:

State 528:
## Known stack suffix:
## CREATE temporary TABLE IDENT table_definition
## LR(1) items:
statement -> CREATE temporary TABLE IDENT table_definition . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> CREATE temporary TABLE IDENT table_definition

State 529:
## Known stack suffix:
## CREATE temporary TABLE if_not_exists
## LR(1) items:
statement -> CREATE temporary TABLE if_not_exists . IDENT table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 530
## Reductions:

State 530:
## Known stack suffix:
## CREATE temporary TABLE if_not_exists IDENT
## LR(1) items:
statement -> CREATE temporary TABLE if_not_exists IDENT . table_definition [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LPAREN shift to state 338
-- On LIKE shift to state 509
-- On table_definition shift to state 531
## Reductions:

State 531:
## Known stack suffix:
## CREATE temporary TABLE if_not_exists IDENT table_definition
## LR(1) items:
statement -> CREATE temporary TABLE if_not_exists IDENT table_definition . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> CREATE temporary TABLE if_not_exists IDENT table_definition

State 532:
## Known stack suffix:
## or_replace
## LR(1) items:
option(or_replace) -> or_replace . [ PROCEDURE FUNCTION ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(or_replace) -> or_replace

State 533:
## Known stack suffix:
## CREATE option(or_replace)
## LR(1) items:
statement -> CREATE option(or_replace) . FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> CREATE option(or_replace) . PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On PROCEDURE shift to state 534
-- On FUNCTION shift to state 675
## Reductions:

State 534:
## Known stack suffix:
## CREATE option(or_replace) PROCEDURE
## LR(1) items:
statement -> CREATE option(or_replace) PROCEDURE . IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 535
## Reductions:

State 535:
## Known stack suffix:
## CREATE option(or_replace) PROCEDURE IDENT
## LR(1) items:
statement -> CREATE option(or_replace) PROCEDURE IDENT . LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LPAREN shift to state 536
## Reductions:

State 536:
## Known stack suffix:
## CREATE option(or_replace) PROCEDURE IDENT LPAREN
## LR(1) items:
statement -> CREATE option(or_replace) PROCEDURE IDENT LPAREN . separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On OUT shift to state 537
-- On INOUT shift to state 538
-- On IN shift to state 539
-- On separated_nonempty_list(COMMA,proc_parameter) shift to state 540
-- On proc_parameter shift to state 660
-- On parameter_mode shift to state 663
-- On option(parameter_mode) shift to state 664
## Reductions:
-- On IDENT reduce production option(parameter_mode) ->

State 537:
## Known stack suffix:
## OUT
## LR(1) items:
parameter_mode -> OUT . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parameter_mode -> OUT

State 538:
## Known stack suffix:
## INOUT
## LR(1) items:
parameter_mode -> INOUT . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parameter_mode -> INOUT

State 539:
## Known stack suffix:
## IN
## LR(1) items:
parameter_mode -> IN . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parameter_mode -> IN

State 540:
## Known stack suffix:
## CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter)
## LR(1) items:
statement -> CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) . RPAREN option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On RPAREN shift to state 541
## Reductions:

State 541:
## Known stack suffix:
## CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN
## LR(1) items:
statement -> CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN . option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LANGUAGE shift to state 542
-- On COMMENT shift to state 544
-- On routine_extra shift to state 546
-- On option(routine_extra) shift to state 547
## Reductions:
-- On TEXT reduce production option(routine_extra) ->
-- On BEGIN reduce production option(routine_extra) ->
-- On AS reduce production option(routine_extra) ->

State 542:
## Known stack suffix:
## LANGUAGE
## LR(1) items:
routine_extra -> LANGUAGE . IDENT [ UPDATE TEXT SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE BEGIN AS ALTER ]
## Transitions:
-- On IDENT shift to state 543
## Reductions:

State 543:
## Known stack suffix:
## LANGUAGE IDENT
## LR(1) items:
routine_extra -> LANGUAGE IDENT . [ UPDATE TEXT SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE BEGIN AS ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production routine_extra -> LANGUAGE IDENT

State 544:
## Known stack suffix:
## COMMENT
## LR(1) items:
routine_extra -> COMMENT . TEXT [ UPDATE TEXT SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE BEGIN AS ALTER ]
## Transitions:
-- On TEXT shift to state 545
## Reductions:

State 545:
## Known stack suffix:
## COMMENT TEXT
## LR(1) items:
routine_extra -> COMMENT TEXT . [ UPDATE TEXT SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE BEGIN AS ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production routine_extra -> COMMENT TEXT

State 546:
## Known stack suffix:
## routine_extra
## LR(1) items:
option(routine_extra) -> routine_extra . [ UPDATE TEXT SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE BEGIN AS ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(routine_extra) -> routine_extra

State 547:
## Known stack suffix:
## CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra)
## LR(1) items:
statement -> CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) . option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On AS shift to state 245
-- On option(AS) shift to state 548
## Reductions:
-- On TEXT reduce production option(AS) ->
-- On BEGIN reduce production option(AS) ->

State 548:
## Known stack suffix:
## CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) option(AS)
## LR(1) items:
statement -> CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) option(AS) . routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On TEXT shift to state 549
-- On BEGIN shift to state 550
-- On routine_body shift to state 657
-- On compound_stmt shift to state 659
## Reductions:

State 549:
## Known stack suffix:
## TEXT
## LR(1) items:
routine_body -> TEXT . [ UPDATE SET SELECT REPLACE LANGUAGE INSERT EOF END DROP DELETE CREATE COMMENT ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production routine_body -> TEXT

State 550:
## Known stack suffix:
## BEGIN
## LR(1) items:
compound_stmt -> BEGIN . nonempty_list(statement) END [ UPDATE SET SELECT REPLACE LANGUAGE INSERT EOF END DROP DELETE CREATE COMMENT ALTER ]
## Transitions:
-- On UPDATE shift to state 1
-- On SET shift to state 6
-- On SELECT shift to state 26
-- On REPLACE shift to state 302
-- On INSERT shift to state 304
-- On DROP shift to state 312
-- On DELETE shift to state 319
-- On CREATE shift to state 323
-- On ALTER shift to state 551
-- On update_cmd shift to state 605
-- On statement shift to state 628
-- On select_stmt shift to state 629
-- On select_core shift to state 58
-- On nonempty_list(statement) shift to state 655
-- On insert_cmd shift to state 631
## Reductions:

State 551:
## Known stack suffix:
## ALTER
## LR(1) items:
statement -> ALTER . TABLE table_name separated_nonempty_list(COMMA,alter_action) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On TABLE shift to state 552
## Reductions:

State 552:
## Known stack suffix:
## ALTER TABLE
## LR(1) items:
statement -> ALTER TABLE . table_name separated_nonempty_list(COMMA,alter_action) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 553
-- On table_name shift to state 556
## Reductions:

State 553:
## Known stack suffix:
## IDENT
## LR(1) items:
table_name -> IDENT . [ SET ON MODIFY LPAREN DROP CHANGE ADD ]
table_name -> IDENT . DOT IDENT [ SET ON MODIFY LPAREN DROP CHANGE ADD ]
## Transitions:
-- On DOT shift to state 554
## Reductions:
-- On SET reduce production table_name -> IDENT
-- On ON reduce production table_name -> IDENT
-- On MODIFY reduce production table_name -> IDENT
-- On LPAREN reduce production table_name -> IDENT
-- On DROP reduce production table_name -> IDENT
-- On CHANGE reduce production table_name -> IDENT
-- On ADD reduce production table_name -> IDENT

State 554:
## Known stack suffix:
## IDENT DOT
## LR(1) items:
table_name -> IDENT DOT . IDENT [ SET ON MODIFY LPAREN DROP CHANGE ADD ]
## Transitions:
-- On IDENT shift to state 555
## Reductions:

State 555:
## Known stack suffix:
## IDENT DOT IDENT
## LR(1) items:
table_name -> IDENT DOT IDENT . [ SET ON MODIFY LPAREN DROP CHANGE ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production table_name -> IDENT DOT IDENT

State 556:
## Known stack suffix:
## ALTER TABLE table_name
## LR(1) items:
statement -> ALTER TABLE table_name . separated_nonempty_list(COMMA,alter_action) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On SET shift to state 557
-- On MODIFY shift to state 560
-- On DROP shift to state 568
-- On CHANGE shift to state 579
-- On ADD shift to state 584
-- On separated_nonempty_list(COMMA,alter_action) shift to state 601
-- On alter_action shift to state 602
## Reductions:

State 557:
## Known stack suffix:
## SET
## LR(1) items:
alter_action -> SET . IDENT IDENT [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 558
## Reductions:

State 558:
## Known stack suffix:
## SET IDENT
## LR(1) items:
alter_action -> SET IDENT . IDENT [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 559
## Reductions:

State 559:
## Known stack suffix:
## SET IDENT IDENT
## LR(1) items:
alter_action -> SET IDENT IDENT . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production alter_action -> SET IDENT IDENT

State 560:
## Known stack suffix:
## MODIFY
## LR(1) items:
alter_action -> MODIFY . option(COLUMN) column_def alter_pos [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On COLUMN shift to state 561
-- On option(COLUMN) shift to state 562
## Reductions:
-- On IDENT reduce production option(COLUMN) ->

State 561:
## Known stack suffix:
## COLUMN
## LR(1) items:
option(COLUMN) -> COLUMN . [ LPAREN IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(COLUMN) -> COLUMN

State 562:
## Known stack suffix:
## MODIFY option(COLUMN)
## LR(1) items:
alter_action -> MODIFY option(COLUMN) . column_def alter_pos [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 357
-- On column_def shift to state 563
## Reductions:

State 563:
## Known stack suffix:
## MODIFY option(COLUMN) column_def
## LR(1) items:
alter_action -> MODIFY option(COLUMN) column_def . alter_pos [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On FIRST shift to state 564
-- On AFTER shift to state 565
-- On alter_pos shift to state 567
## Reductions:
-- On UPDATE reduce production alter_pos ->
-- On SET reduce production alter_pos ->
-- On SELECT reduce production alter_pos ->
-- On REPLACE reduce production alter_pos ->
-- On INSERT reduce production alter_pos ->
-- On EOF reduce production alter_pos ->
-- On END reduce production alter_pos ->
-- On DROP reduce production alter_pos ->
-- On DELETE reduce production alter_pos ->
-- On CREATE reduce production alter_pos ->
-- On COMMA reduce production alter_pos ->
-- On ALTER reduce production alter_pos ->

State 564:
## Known stack suffix:
## FIRST
## LR(1) items:
alter_pos -> FIRST . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production alter_pos -> FIRST

State 565:
## Known stack suffix:
## AFTER
## LR(1) items:
alter_pos -> AFTER . IDENT [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 566
## Reductions:

State 566:
## Known stack suffix:
## AFTER IDENT
## LR(1) items:
alter_pos -> AFTER IDENT . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production alter_pos -> AFTER IDENT

State 567:
## Known stack suffix:
## MODIFY option(COLUMN) column_def alter_pos
## LR(1) items:
alter_action -> MODIFY option(COLUMN) column_def alter_pos . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production alter_action -> MODIFY option(COLUMN) column_def alter_pos

State 568:
## Known stack suffix:
## DROP
## LR(1) items:
alter_action -> DROP . INDEX IDENT [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
alter_action -> DROP . PRIMARY KEY [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
alter_action -> DROP . option(COLUMN) IDENT option(drop_behavior) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On PRIMARY shift to state 569
-- On INDEX shift to state 571
-- On COLUMN shift to state 561
-- On option(COLUMN) shift to state 573
## Reductions:
-- On IDENT reduce production option(COLUMN) ->

State 569:
## Known stack suffix:
## DROP PRIMARY
## LR(1) items:
alter_action -> DROP PRIMARY . KEY [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On KEY shift to state 570
## Reductions:

State 570:
## Known stack suffix:
## DROP PRIMARY KEY
## LR(1) items:
alter_action -> DROP PRIMARY KEY . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production alter_action -> DROP PRIMARY KEY

State 571:
## Known stack suffix:
## DROP INDEX
## LR(1) items:
alter_action -> DROP INDEX . IDENT [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 572
## Reductions:

State 572:
## Known stack suffix:
## DROP INDEX IDENT
## LR(1) items:
alter_action -> DROP INDEX IDENT . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production alter_action -> DROP INDEX IDENT

State 573:
## Known stack suffix:
## DROP option(COLUMN)
## LR(1) items:
alter_action -> DROP option(COLUMN) . IDENT option(drop_behavior) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 574
## Reductions:

State 574:
## Known stack suffix:
## DROP option(COLUMN) IDENT
## LR(1) items:
alter_action -> DROP option(COLUMN) IDENT . option(drop_behavior) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On RESTRICT shift to state 575
-- On CASCADE shift to state 576
-- On option(drop_behavior) shift to state 577
-- On drop_behavior shift to state 578
## Reductions:
-- On UPDATE reduce production option(drop_behavior) ->
-- On SET reduce production option(drop_behavior) ->
-- On SELECT reduce production option(drop_behavior) ->
-- On REPLACE reduce production option(drop_behavior) ->
-- On INSERT reduce production option(drop_behavior) ->
-- On EOF reduce production option(drop_behavior) ->
-- On END reduce production option(drop_behavior) ->
-- On DROP reduce production option(drop_behavior) ->
-- On DELETE reduce production option(drop_behavior) ->
-- On CREATE reduce production option(drop_behavior) ->
-- On COMMA reduce production option(drop_behavior) ->
-- On ALTER reduce production option(drop_behavior) ->

State 575:
## Known stack suffix:
## RESTRICT
## LR(1) items:
drop_behavior -> RESTRICT . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production drop_behavior -> RESTRICT

State 576:
## Known stack suffix:
## CASCADE
## LR(1) items:
drop_behavior -> CASCADE . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production drop_behavior -> CASCADE

State 577:
## Known stack suffix:
## DROP option(COLUMN) IDENT option(drop_behavior)
## LR(1) items:
alter_action -> DROP option(COLUMN) IDENT option(drop_behavior) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production alter_action -> DROP option(COLUMN) IDENT option(drop_behavior)

State 578:
## Known stack suffix:
## drop_behavior
## LR(1) items:
option(drop_behavior) -> drop_behavior . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(drop_behavior) -> drop_behavior

State 579:
## Known stack suffix:
## CHANGE
## LR(1) items:
alter_action -> CHANGE . option(COLUMN) IDENT column_def alter_pos [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On COLUMN shift to state 561
-- On option(COLUMN) shift to state 580
## Reductions:
-- On IDENT reduce production option(COLUMN) ->

State 580:
## Known stack suffix:
## CHANGE option(COLUMN)
## LR(1) items:
alter_action -> CHANGE option(COLUMN) . IDENT column_def alter_pos [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 581
## Reductions:

State 581:
## Known stack suffix:
## CHANGE option(COLUMN) IDENT
## LR(1) items:
alter_action -> CHANGE option(COLUMN) IDENT . column_def alter_pos [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 357
-- On column_def shift to state 582
## Reductions:

State 582:
## Known stack suffix:
## CHANGE option(COLUMN) IDENT column_def
## LR(1) items:
alter_action -> CHANGE option(COLUMN) IDENT column_def . alter_pos [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On FIRST shift to state 564
-- On AFTER shift to state 565
-- On alter_pos shift to state 583
## Reductions:
-- On UPDATE reduce production alter_pos ->
-- On SET reduce production alter_pos ->
-- On SELECT reduce production alter_pos ->
-- On REPLACE reduce production alter_pos ->
-- On INSERT reduce production alter_pos ->
-- On EOF reduce production alter_pos ->
-- On END reduce production alter_pos ->
-- On DROP reduce production alter_pos ->
-- On DELETE reduce production alter_pos ->
-- On CREATE reduce production alter_pos ->
-- On COMMA reduce production alter_pos ->
-- On ALTER reduce production alter_pos ->

State 583:
## Known stack suffix:
## CHANGE option(COLUMN) IDENT column_def alter_pos
## LR(1) items:
alter_action -> CHANGE option(COLUMN) IDENT column_def alter_pos . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production alter_action -> CHANGE option(COLUMN) IDENT column_def alter_pos

State 584:
## Known stack suffix:
## ADD
## LR(1) items:
alter_action -> ADD . option(COLUMN) maybe_parenth(column_def) alter_pos [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
alter_action -> ADD . index_type option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On PRIMARY shift to state 585
-- On INDEX shift to state 587
-- On FULLTEXT shift to state 588
-- On COLUMN shift to state 561
-- On option(COLUMN) shift to state 589
-- On index_type shift to state 596
## Reductions:
-- On LPAREN reduce production option(COLUMN) ->
-- On IDENT reduce production option(COLUMN) ->

State 585:
## Known stack suffix:
## PRIMARY
## LR(1) items:
index_type -> PRIMARY . KEY [ LPAREN IDENT ]
## Transitions:
-- On KEY shift to state 586
## Reductions:

State 586:
## Known stack suffix:
## PRIMARY KEY
## LR(1) items:
index_type -> PRIMARY KEY . [ LPAREN IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production index_type -> PRIMARY KEY

State 587:
## Known stack suffix:
## INDEX
## LR(1) items:
index_type -> INDEX . [ LPAREN IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production index_type -> INDEX

State 588:
## Known stack suffix:
## FULLTEXT
## LR(1) items:
index_type -> FULLTEXT . [ LPAREN IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production index_type -> FULLTEXT

State 589:
## Known stack suffix:
## ADD option(COLUMN)
## LR(1) items:
alter_action -> ADD option(COLUMN) . maybe_parenth(column_def) alter_pos [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On LPAREN shift to state 590
-- On IDENT shift to state 357
-- On maybe_parenth(column_def) shift to state 593
-- On column_def shift to state 595
## Reductions:

State 590:
## Known stack suffix:
## LPAREN
## LR(1) items:
maybe_parenth(column_def) -> LPAREN . column_def RPAREN [ UPDATE SET SELECT REPLACE INSERT FIRST EOF END DROP DELETE CREATE COMMA ALTER AFTER ]
## Transitions:
-- On IDENT shift to state 357
-- On column_def shift to state 591
## Reductions:

State 591:
## Known stack suffix:
## LPAREN column_def
## LR(1) items:
maybe_parenth(column_def) -> LPAREN column_def . RPAREN [ UPDATE SET SELECT REPLACE INSERT FIRST EOF END DROP DELETE CREATE COMMA ALTER AFTER ]
## Transitions:
-- On RPAREN shift to state 592
## Reductions:

State 592:
## Known stack suffix:
## LPAREN column_def RPAREN
## LR(1) items:
maybe_parenth(column_def) -> LPAREN column_def RPAREN . [ UPDATE SET SELECT REPLACE INSERT FIRST EOF END DROP DELETE CREATE COMMA ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybe_parenth(column_def) -> LPAREN column_def RPAREN

State 593:
## Known stack suffix:
## ADD option(COLUMN) maybe_parenth(column_def)
## LR(1) items:
alter_action -> ADD option(COLUMN) maybe_parenth(column_def) . alter_pos [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On FIRST shift to state 564
-- On AFTER shift to state 565
-- On alter_pos shift to state 594
## Reductions:
-- On UPDATE reduce production alter_pos ->
-- On SET reduce production alter_pos ->
-- On SELECT reduce production alter_pos ->
-- On REPLACE reduce production alter_pos ->
-- On INSERT reduce production alter_pos ->
-- On EOF reduce production alter_pos ->
-- On END reduce production alter_pos ->
-- On DROP reduce production alter_pos ->
-- On DELETE reduce production alter_pos ->
-- On CREATE reduce production alter_pos ->
-- On COMMA reduce production alter_pos ->
-- On ALTER reduce production alter_pos ->

State 594:
## Known stack suffix:
## ADD option(COLUMN) maybe_parenth(column_def) alter_pos
## LR(1) items:
alter_action -> ADD option(COLUMN) maybe_parenth(column_def) alter_pos . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production alter_action -> ADD option(COLUMN) maybe_parenth(column_def) alter_pos

State 595:
## Known stack suffix:
## column_def
## LR(1) items:
maybe_parenth(column_def) -> column_def . [ UPDATE SET SELECT REPLACE INSERT FIRST EOF END DROP DELETE CREATE COMMA ALTER AFTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production maybe_parenth(column_def) -> column_def

State 596:
## Known stack suffix:
## ADD index_type
## LR(1) items:
alter_action -> ADD index_type . option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 464
-- On option(IDENT) shift to state 597
## Reductions:
-- On LPAREN reduce production option(IDENT) ->

State 597:
## Known stack suffix:
## ADD index_type option(IDENT)
## LR(1) items:
alter_action -> ADD index_type option(IDENT) . LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On LPAREN shift to state 598
## Reductions:

State 598:
## Known stack suffix:
## ADD index_type option(IDENT) LPAREN
## LR(1) items:
alter_action -> ADD index_type option(IDENT) LPAREN . separated_nonempty_list(COMMA,IDENT) RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On IDENT shift to state 158
-- On separated_nonempty_list(COMMA,IDENT) shift to state 599
## Reductions:

State 599:
## Known stack suffix:
## ADD index_type option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT)
## LR(1) items:
alter_action -> ADD index_type option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) . RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On RPAREN shift to state 600
## Reductions:

State 600:
## Known stack suffix:
## ADD index_type option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN
## LR(1) items:
alter_action -> ADD index_type option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production alter_action -> ADD index_type option(IDENT) LPAREN separated_nonempty_list(COMMA,IDENT) RPAREN

State 601:
## Known stack suffix:
## ALTER TABLE table_name separated_nonempty_list(COMMA,alter_action)
## LR(1) items:
statement -> ALTER TABLE table_name separated_nonempty_list(COMMA,alter_action) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> ALTER TABLE table_name separated_nonempty_list(COMMA,alter_action)

State 602:
## Known stack suffix:
## alter_action
## LR(1) items:
separated_nonempty_list(COMMA,alter_action) -> alter_action . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
separated_nonempty_list(COMMA,alter_action) -> alter_action . COMMA separated_nonempty_list(COMMA,alter_action) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On COMMA shift to state 603
## Reductions:
-- On UPDATE reduce production separated_nonempty_list(COMMA,alter_action) -> alter_action
-- On SET reduce production separated_nonempty_list(COMMA,alter_action) -> alter_action
-- On SELECT reduce production separated_nonempty_list(COMMA,alter_action) -> alter_action
-- On REPLACE reduce production separated_nonempty_list(COMMA,alter_action) -> alter_action
-- On INSERT reduce production separated_nonempty_list(COMMA,alter_action) -> alter_action
-- On EOF reduce production separated_nonempty_list(COMMA,alter_action) -> alter_action
-- On END reduce production separated_nonempty_list(COMMA,alter_action) -> alter_action
-- On DROP reduce production separated_nonempty_list(COMMA,alter_action) -> alter_action
-- On DELETE reduce production separated_nonempty_list(COMMA,alter_action) -> alter_action
-- On CREATE reduce production separated_nonempty_list(COMMA,alter_action) -> alter_action
-- On ALTER reduce production separated_nonempty_list(COMMA,alter_action) -> alter_action

State 603:
## Known stack suffix:
## alter_action COMMA
## LR(1) items:
separated_nonempty_list(COMMA,alter_action) -> alter_action COMMA . separated_nonempty_list(COMMA,alter_action) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On SET shift to state 557
-- On MODIFY shift to state 560
-- On DROP shift to state 568
-- On CHANGE shift to state 579
-- On ADD shift to state 584
-- On separated_nonempty_list(COMMA,alter_action) shift to state 604
-- On alter_action shift to state 602
## Reductions:

State 604:
## Known stack suffix:
## alter_action COMMA separated_nonempty_list(COMMA,alter_action)
## LR(1) items:
separated_nonempty_list(COMMA,alter_action) -> alter_action COMMA separated_nonempty_list(COMMA,alter_action) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,alter_action) -> alter_action COMMA separated_nonempty_list(COMMA,alter_action)

State 605:
## Known stack suffix:
## update_cmd
## LR(1) items:
statement -> update_cmd . IDENT SET separated_nonempty_list(COMMA,set_column) option(where) loption(order) loption(limit) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> update_cmd . separated_nonempty_list(COMMA,source) SET separated_nonempty_list(COMMA,set_column) option(where) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LPAREN shift to state 239
-- On IDENT shift to state 606
-- On source1 shift to state 244
-- On source shift to state 621
-- On separated_nonempty_list(COMMA,source) shift to state 624
## Reductions:

State 606:
## Known stack suffix:
## update_cmd IDENT
## LR(1) items:
source1 -> IDENT . [ SET IDENT COMMA AS ]
statement -> update_cmd IDENT . SET separated_nonempty_list(COMMA,set_column) option(where) loption(order) loption(limit) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On SET shift to state 607
## Reductions:
-- On IDENT reduce production source1 -> IDENT
-- On COMMA reduce production source1 -> IDENT
-- On AS reduce production source1 -> IDENT

State 607:
## Known stack suffix:
## update_cmd IDENT SET
## LR(1) items:
statement -> update_cmd IDENT SET . separated_nonempty_list(COMMA,set_column) option(where) loption(order) loption(limit) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 608
-- On set_column shift to state 609
-- On separated_nonempty_list(COMMA,set_column) shift to state 615
-- On attr_name shift to state 612
## Reductions:

State 608:
## Known stack suffix:
## IDENT
## LR(1) items:
attr_name -> IDENT . [ EQUAL ]
attr_name -> IDENT . DOT IDENT [ EQUAL ]
attr_name -> IDENT . DOT IDENT DOT IDENT [ EQUAL ]
## Transitions:
-- On DOT shift to state 201
## Reductions:
-- On EQUAL reduce production attr_name -> IDENT

State 609:
## Known stack suffix:
## set_column
## LR(1) items:
separated_nonempty_list(COMMA,set_column) -> set_column . [ WHERE UPDATE SET SELECT REPLACE ORDER ON LIMIT INSERT EOF END DROP DELETE CREATE ALTER ]
separated_nonempty_list(COMMA,set_column) -> set_column . COMMA separated_nonempty_list(COMMA,set_column) [ WHERE UPDATE SET SELECT REPLACE ORDER ON LIMIT INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On COMMA shift to state 610
## Reductions:
-- On WHERE reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On UPDATE reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On SET reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On SELECT reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On REPLACE reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On ORDER reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On ON reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On LIMIT reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On INSERT reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On EOF reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On END reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On DROP reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On DELETE reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On CREATE reduce production separated_nonempty_list(COMMA,set_column) -> set_column
-- On ALTER reduce production separated_nonempty_list(COMMA,set_column) -> set_column

State 610:
## Known stack suffix:
## set_column COMMA
## LR(1) items:
separated_nonempty_list(COMMA,set_column) -> set_column COMMA . separated_nonempty_list(COMMA,set_column) [ WHERE UPDATE SET SELECT REPLACE ORDER ON LIMIT INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 608
-- On set_column shift to state 609
-- On separated_nonempty_list(COMMA,set_column) shift to state 611
-- On attr_name shift to state 612
## Reductions:

State 611:
## Known stack suffix:
## set_column COMMA separated_nonempty_list(COMMA,set_column)
## LR(1) items:
separated_nonempty_list(COMMA,set_column) -> set_column COMMA separated_nonempty_list(COMMA,set_column) . [ WHERE UPDATE SET SELECT REPLACE ORDER ON LIMIT INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,set_column) -> set_column COMMA separated_nonempty_list(COMMA,set_column)

State 612:
## Known stack suffix:
## attr_name
## LR(1) items:
set_column -> attr_name . EQUAL expr [ WHERE UPDATE SET SELECT REPLACE ORDER ON LIMIT INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On EQUAL shift to state 613
## Reductions:

State 613:
## Known stack suffix:
## attr_name EQUAL
## LR(1) items:
set_column -> attr_name EQUAL . expr [ WHERE UPDATE SET SELECT REPLACE ORDER ON LIMIT INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 614
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 614:
## Known stack suffix:
## attr_name EQUAL expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ WHERE UPDATE SET SELECT REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIMIT LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . boolean_bin_op expr [ WHERE UPDATE SET SELECT REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIMIT LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . comparison_op option(anyall) expr [ WHERE UPDATE SET SELECT REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIMIT LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . CONCAT_OP expr [ WHERE UPDATE SET SELECT REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIMIT LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(like) expr option(escape) [ WHERE UPDATE SET SELECT REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIMIT LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ WHERE UPDATE SET SELECT REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIMIT LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ WHERE UPDATE SET SELECT REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIMIT LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . IN IDENT [ WHERE UPDATE SET SELECT REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIMIT LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . IS option(NOT) NULL [ WHERE UPDATE SET SELECT REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIMIT LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ WHERE UPDATE SET SELECT REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIMIT LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
expr -> expr . mnot(BETWEEN) expr AND expr [ WHERE UPDATE SET SELECT REPLACE PLUS ORDER OR ON NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIMIT LIKE_OP LIKE IS INSERT IN EQUAL EOF END DROP DELETE CREATE CONCAT_OP COMMA BETWEEN ASTERISK AND ALTER ]
set_column -> attr_name EQUAL expr . [ WHERE UPDATE SET SELECT REPLACE ORDER ON LIMIT INSERT EOF END DROP DELETE CREATE COMMA ALTER ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On WHERE reduce production set_column -> attr_name EQUAL expr
-- On UPDATE reduce production set_column -> attr_name EQUAL expr
-- On SET reduce production set_column -> attr_name EQUAL expr
-- On SELECT reduce production set_column -> attr_name EQUAL expr
-- On REPLACE reduce production set_column -> attr_name EQUAL expr
-- On ORDER reduce production set_column -> attr_name EQUAL expr
-- On ON reduce production set_column -> attr_name EQUAL expr
-- On LIMIT reduce production set_column -> attr_name EQUAL expr
-- On INSERT reduce production set_column -> attr_name EQUAL expr
-- On EOF reduce production set_column -> attr_name EQUAL expr
-- On END reduce production set_column -> attr_name EQUAL expr
-- On DROP reduce production set_column -> attr_name EQUAL expr
-- On DELETE reduce production set_column -> attr_name EQUAL expr
-- On CREATE reduce production set_column -> attr_name EQUAL expr
-- On COMMA reduce production set_column -> attr_name EQUAL expr
-- On ALTER reduce production set_column -> attr_name EQUAL expr

State 615:
## Known stack suffix:
## update_cmd IDENT SET separated_nonempty_list(COMMA,set_column)
## LR(1) items:
statement -> update_cmd IDENT SET separated_nonempty_list(COMMA,set_column) . option(where) loption(order) loption(limit) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On WHERE shift to state 277
-- On where shift to state 279
-- On option(where) shift to state 616
## Reductions:
-- On UPDATE reduce production option(where) ->
-- On SET reduce production option(where) ->
-- On SELECT reduce production option(where) ->
-- On REPLACE reduce production option(where) ->
-- On ORDER reduce production option(where) ->
-- On LIMIT reduce production option(where) ->
-- On INSERT reduce production option(where) ->
-- On EOF reduce production option(where) ->
-- On END reduce production option(where) ->
-- On DROP reduce production option(where) ->
-- On DELETE reduce production option(where) ->
-- On CREATE reduce production option(where) ->
-- On ALTER reduce production option(where) ->

State 616:
## Known stack suffix:
## update_cmd IDENT SET separated_nonempty_list(COMMA,set_column) option(where)
## LR(1) items:
statement -> update_cmd IDENT SET separated_nonempty_list(COMMA,set_column) option(where) . loption(order) loption(limit) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On ORDER shift to state 65
-- On order shift to state 140
-- On loption(order) shift to state 617
## Reductions:
-- On UPDATE reduce production loption(order) ->
-- On SET reduce production loption(order) ->
-- On SELECT reduce production loption(order) ->
-- On REPLACE reduce production loption(order) ->
-- On LIMIT reduce production loption(order) ->
-- On INSERT reduce production loption(order) ->
-- On EOF reduce production loption(order) ->
-- On END reduce production loption(order) ->
-- On DROP reduce production loption(order) ->
-- On DELETE reduce production loption(order) ->
-- On CREATE reduce production loption(order) ->
-- On ALTER reduce production loption(order) ->

State 617:
## Known stack suffix:
## update_cmd IDENT SET separated_nonempty_list(COMMA,set_column) option(where) loption(order)
## LR(1) items:
statement -> update_cmd IDENT SET separated_nonempty_list(COMMA,set_column) option(where) loption(order) . loption(limit) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LIMIT shift to state 142
-- On loption(limit) shift to state 618
-- On limit_t shift to state 619
-- On limit shift to state 620
## Reductions:
-- On UPDATE reduce production loption(limit) ->
-- On SET reduce production loption(limit) ->
-- On SELECT reduce production loption(limit) ->
-- On REPLACE reduce production loption(limit) ->
-- On INSERT reduce production loption(limit) ->
-- On EOF reduce production loption(limit) ->
-- On END reduce production loption(limit) ->
-- On DROP reduce production loption(limit) ->
-- On DELETE reduce production loption(limit) ->
-- On CREATE reduce production loption(limit) ->
-- On ALTER reduce production loption(limit) ->

State 618:
## Known stack suffix:
## update_cmd IDENT SET separated_nonempty_list(COMMA,set_column) option(where) loption(order) loption(limit)
## LR(1) items:
statement -> update_cmd IDENT SET separated_nonempty_list(COMMA,set_column) option(where) loption(order) loption(limit) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> update_cmd IDENT SET separated_nonempty_list(COMMA,set_column) option(where) loption(order) loption(limit)

State 619:
## Known stack suffix:
## limit_t
## LR(1) items:
limit -> limit_t . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production limit -> limit_t

State 620:
## Known stack suffix:
## limit
## LR(1) items:
loption(limit) -> limit . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production loption(limit) -> limit

State 621:
## Known stack suffix:
## source
## LR(1) items:
separated_nonempty_list(COMMA,source) -> source . [ SET ]
separated_nonempty_list(COMMA,source) -> source . COMMA separated_nonempty_list(COMMA,source) [ SET ]
## Transitions:
-- On COMMA shift to state 622
## Reductions:
-- On SET reduce production separated_nonempty_list(COMMA,source) -> source

State 622:
## Known stack suffix:
## source COMMA
## LR(1) items:
separated_nonempty_list(COMMA,source) -> source COMMA . separated_nonempty_list(COMMA,source) [ SET ]
## Transitions:
-- On LPAREN shift to state 239
-- On IDENT shift to state 242
-- On source1 shift to state 244
-- On source shift to state 621
-- On separated_nonempty_list(COMMA,source) shift to state 623
## Reductions:

State 623:
## Known stack suffix:
## source COMMA separated_nonempty_list(COMMA,source)
## LR(1) items:
separated_nonempty_list(COMMA,source) -> source COMMA separated_nonempty_list(COMMA,source) . [ SET ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,source) -> source COMMA separated_nonempty_list(COMMA,source)

State 624:
## Known stack suffix:
## update_cmd separated_nonempty_list(COMMA,source)
## LR(1) items:
statement -> update_cmd separated_nonempty_list(COMMA,source) . SET separated_nonempty_list(COMMA,set_column) option(where) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On SET shift to state 625
## Reductions:

State 625:
## Known stack suffix:
## update_cmd separated_nonempty_list(COMMA,source) SET
## LR(1) items:
statement -> update_cmd separated_nonempty_list(COMMA,source) SET . separated_nonempty_list(COMMA,set_column) option(where) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 608
-- On set_column shift to state 609
-- On separated_nonempty_list(COMMA,set_column) shift to state 626
-- On attr_name shift to state 612
## Reductions:

State 626:
## Known stack suffix:
## update_cmd separated_nonempty_list(COMMA,source) SET separated_nonempty_list(COMMA,set_column)
## LR(1) items:
statement -> update_cmd separated_nonempty_list(COMMA,source) SET separated_nonempty_list(COMMA,set_column) . option(where) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On WHERE shift to state 277
-- On where shift to state 279
-- On option(where) shift to state 627
## Reductions:
-- On UPDATE reduce production option(where) ->
-- On SET reduce production option(where) ->
-- On SELECT reduce production option(where) ->
-- On REPLACE reduce production option(where) ->
-- On INSERT reduce production option(where) ->
-- On EOF reduce production option(where) ->
-- On END reduce production option(where) ->
-- On DROP reduce production option(where) ->
-- On DELETE reduce production option(where) ->
-- On CREATE reduce production option(where) ->
-- On ALTER reduce production option(where) ->

State 627:
## Known stack suffix:
## update_cmd separated_nonempty_list(COMMA,source) SET separated_nonempty_list(COMMA,set_column) option(where)
## LR(1) items:
statement -> update_cmd separated_nonempty_list(COMMA,source) SET separated_nonempty_list(COMMA,set_column) option(where) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> update_cmd separated_nonempty_list(COMMA,source) SET separated_nonempty_list(COMMA,set_column) option(where)

State 628:
## Known stack suffix:
## statement
## LR(1) items:
nonempty_list(statement) -> statement . [ END ]
nonempty_list(statement) -> statement . nonempty_list(statement) [ END ]
## Transitions:
-- On UPDATE shift to state 1
-- On SET shift to state 6
-- On SELECT shift to state 26
-- On REPLACE shift to state 302
-- On INSERT shift to state 304
-- On DROP shift to state 312
-- On DELETE shift to state 319
-- On CREATE shift to state 323
-- On ALTER shift to state 551
-- On update_cmd shift to state 605
-- On statement shift to state 628
-- On select_stmt shift to state 629
-- On select_core shift to state 58
-- On nonempty_list(statement) shift to state 630
-- On insert_cmd shift to state 631
## Reductions:
-- On END reduce production nonempty_list(statement) -> statement

State 629:
## Known stack suffix:
## select_stmt
## LR(1) items:
statement -> select_stmt . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> select_stmt

State 630:
## Known stack suffix:
## statement nonempty_list(statement)
## LR(1) items:
nonempty_list(statement) -> statement nonempty_list(statement) . [ END ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(statement) -> statement nonempty_list(statement)

State 631:
## Known stack suffix:
## insert_cmd
## LR(1) items:
statement -> insert_cmd . IDENT option(sequence(IDENT)) VALUES option(commas(sequence(expr))) option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> insert_cmd . IDENT option(sequence(IDENT)) maybe_parenth(select_stmt) option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> insert_cmd . IDENT SET option(commas(set_column)) option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 632
## Reductions:

State 632:
## Known stack suffix:
## insert_cmd IDENT
## LR(1) items:
statement -> insert_cmd IDENT . option(sequence(IDENT)) VALUES option(commas(sequence(expr))) option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> insert_cmd IDENT . option(sequence(IDENT)) maybe_parenth(select_stmt) option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> insert_cmd IDENT . SET option(commas(set_column)) option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On SET shift to state 633
-- On LPAREN shift to state 471
-- On option(sequence(IDENT)) shift to state 643
## Reductions:
-- On VALUES reduce production option(sequence(IDENT)) ->
-- On SELECT reduce production option(sequence(IDENT)) ->

State 633:
## Known stack suffix:
## insert_cmd IDENT SET
## LR(1) items:
statement -> insert_cmd IDENT SET . option(commas(set_column)) option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 608
-- On set_column shift to state 609
-- On separated_nonempty_list(COMMA,set_column) shift to state 634
-- On option(commas(set_column)) shift to state 635
-- On attr_name shift to state 612
## Reductions:
-- On UPDATE reduce production option(commas(set_column)) ->
-- On SET reduce production option(commas(set_column)) ->
-- On SELECT reduce production option(commas(set_column)) ->
-- On REPLACE reduce production option(commas(set_column)) ->
-- On ON reduce production option(commas(set_column)) ->
-- On INSERT reduce production option(commas(set_column)) ->
-- On EOF reduce production option(commas(set_column)) ->
-- On END reduce production option(commas(set_column)) ->
-- On DROP reduce production option(commas(set_column)) ->
-- On DELETE reduce production option(commas(set_column)) ->
-- On CREATE reduce production option(commas(set_column)) ->
-- On ALTER reduce production option(commas(set_column)) ->

State 634:
## Known stack suffix:
## separated_nonempty_list(COMMA,set_column)
## LR(1) items:
option(commas(set_column)) -> separated_nonempty_list(COMMA,set_column) . [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(commas(set_column)) -> separated_nonempty_list(COMMA,set_column)

State 635:
## Known stack suffix:
## insert_cmd IDENT SET option(commas(set_column))
## LR(1) items:
statement -> insert_cmd IDENT SET option(commas(set_column)) . option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On ON shift to state 636
-- On option(on_duplicate) shift to state 641
-- On on_duplicate shift to state 642
## Reductions:
-- On UPDATE reduce production option(on_duplicate) ->
-- On SET reduce production option(on_duplicate) ->
-- On SELECT reduce production option(on_duplicate) ->
-- On REPLACE reduce production option(on_duplicate) ->
-- On INSERT reduce production option(on_duplicate) ->
-- On EOF reduce production option(on_duplicate) ->
-- On END reduce production option(on_duplicate) ->
-- On DROP reduce production option(on_duplicate) ->
-- On DELETE reduce production option(on_duplicate) ->
-- On CREATE reduce production option(on_duplicate) ->
-- On ALTER reduce production option(on_duplicate) ->

State 636:
## Known stack suffix:
## ON
## LR(1) items:
on_duplicate -> ON . DUPLICATE KEY UPDATE separated_nonempty_list(COMMA,set_column) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On DUPLICATE shift to state 637
## Reductions:

State 637:
## Known stack suffix:
## ON DUPLICATE
## LR(1) items:
on_duplicate -> ON DUPLICATE . KEY UPDATE separated_nonempty_list(COMMA,set_column) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On KEY shift to state 638
## Reductions:

State 638:
## Known stack suffix:
## ON DUPLICATE KEY
## LR(1) items:
on_duplicate -> ON DUPLICATE KEY . UPDATE separated_nonempty_list(COMMA,set_column) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On UPDATE shift to state 639
## Reductions:

State 639:
## Known stack suffix:
## ON DUPLICATE KEY UPDATE
## LR(1) items:
on_duplicate -> ON DUPLICATE KEY UPDATE . separated_nonempty_list(COMMA,set_column) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 608
-- On set_column shift to state 609
-- On separated_nonempty_list(COMMA,set_column) shift to state 640
-- On attr_name shift to state 612
## Reductions:

State 640:
## Known stack suffix:
## ON DUPLICATE KEY UPDATE separated_nonempty_list(COMMA,set_column)
## LR(1) items:
on_duplicate -> ON DUPLICATE KEY UPDATE separated_nonempty_list(COMMA,set_column) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production on_duplicate -> ON DUPLICATE KEY UPDATE separated_nonempty_list(COMMA,set_column)

State 641:
## Known stack suffix:
## insert_cmd IDENT SET option(commas(set_column)) option(on_duplicate)
## LR(1) items:
statement -> insert_cmd IDENT SET option(commas(set_column)) option(on_duplicate) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> insert_cmd IDENT SET option(commas(set_column)) option(on_duplicate)

State 642:
## Known stack suffix:
## on_duplicate
## LR(1) items:
option(on_duplicate) -> on_duplicate . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(on_duplicate) -> on_duplicate

State 643:
## Known stack suffix:
## insert_cmd IDENT option(sequence(IDENT))
## LR(1) items:
statement -> insert_cmd IDENT option(sequence(IDENT)) . VALUES option(commas(sequence(expr))) option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
statement -> insert_cmd IDENT option(sequence(IDENT)) . maybe_parenth(select_stmt) option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On VALUES shift to state 644
-- On SELECT shift to state 26
-- On LPAREN shift to state 327
-- On select_stmt shift to state 330
-- On select_core shift to state 58
-- On maybe_parenth(select_stmt) shift to state 653
## Reductions:

State 644:
## Known stack suffix:
## insert_cmd IDENT option(sequence(IDENT)) VALUES
## LR(1) items:
statement -> insert_cmd IDENT option(sequence(IDENT)) VALUES . option(commas(sequence(expr))) option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LPAREN shift to state 645
-- On separated_nonempty_list(COMMA,sequence(expr)) shift to state 650
-- On option(commas(sequence(expr))) shift to state 651
## Reductions:
-- On UPDATE reduce production option(commas(sequence(expr))) ->
-- On SET reduce production option(commas(sequence(expr))) ->
-- On SELECT reduce production option(commas(sequence(expr))) ->
-- On REPLACE reduce production option(commas(sequence(expr))) ->
-- On ON reduce production option(commas(sequence(expr))) ->
-- On INSERT reduce production option(commas(sequence(expr))) ->
-- On EOF reduce production option(commas(sequence(expr))) ->
-- On END reduce production option(commas(sequence(expr))) ->
-- On DROP reduce production option(commas(sequence(expr))) ->
-- On DELETE reduce production option(commas(sequence(expr))) ->
-- On CREATE reduce production option(commas(sequence(expr))) ->
-- On ALTER reduce production option(commas(sequence(expr))) ->

State 645:
## Known stack suffix:
## LPAREN
## LR(1) items:
separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN . separated_nonempty_list(COMMA,expr) RPAREN [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN . separated_nonempty_list(COMMA,expr) RPAREN COMMA separated_nonempty_list(COMMA,sequence(expr)) [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On separated_nonempty_list(COMMA,expr) shift to state 646
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 112
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 646:
## Known stack suffix:
## LPAREN separated_nonempty_list(COMMA,expr)
## LR(1) items:
separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) . RPAREN [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) . RPAREN COMMA separated_nonempty_list(COMMA,sequence(expr)) [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On RPAREN shift to state 647
## Reductions:

State 647:
## Known stack suffix:
## LPAREN separated_nonempty_list(COMMA,expr) RPAREN
## LR(1) items:
separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN . [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN . COMMA separated_nonempty_list(COMMA,sequence(expr)) [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On COMMA shift to state 648
## Reductions:
-- On UPDATE reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN
-- On SET reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN
-- On SELECT reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN
-- On REPLACE reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN
-- On ON reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN
-- On INSERT reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN
-- On EOF reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN
-- On END reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN
-- On DROP reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN
-- On DELETE reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN
-- On CREATE reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN
-- On ALTER reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN

State 648:
## Known stack suffix:
## LPAREN separated_nonempty_list(COMMA,expr) RPAREN COMMA
## LR(1) items:
separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN COMMA . separated_nonempty_list(COMMA,sequence(expr)) [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LPAREN shift to state 645
-- On separated_nonempty_list(COMMA,sequence(expr)) shift to state 649
## Reductions:

State 649:
## Known stack suffix:
## LPAREN separated_nonempty_list(COMMA,expr) RPAREN COMMA separated_nonempty_list(COMMA,sequence(expr))
## LR(1) items:
separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN COMMA separated_nonempty_list(COMMA,sequence(expr)) . [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,sequence(expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN COMMA separated_nonempty_list(COMMA,sequence(expr))

State 650:
## Known stack suffix:
## separated_nonempty_list(COMMA,sequence(expr))
## LR(1) items:
option(commas(sequence(expr))) -> separated_nonempty_list(COMMA,sequence(expr)) . [ UPDATE SET SELECT REPLACE ON INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(commas(sequence(expr))) -> separated_nonempty_list(COMMA,sequence(expr))

State 651:
## Known stack suffix:
## insert_cmd IDENT option(sequence(IDENT)) VALUES option(commas(sequence(expr)))
## LR(1) items:
statement -> insert_cmd IDENT option(sequence(IDENT)) VALUES option(commas(sequence(expr))) . option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On ON shift to state 636
-- On option(on_duplicate) shift to state 652
-- On on_duplicate shift to state 642
## Reductions:
-- On UPDATE reduce production option(on_duplicate) ->
-- On SET reduce production option(on_duplicate) ->
-- On SELECT reduce production option(on_duplicate) ->
-- On REPLACE reduce production option(on_duplicate) ->
-- On INSERT reduce production option(on_duplicate) ->
-- On EOF reduce production option(on_duplicate) ->
-- On END reduce production option(on_duplicate) ->
-- On DROP reduce production option(on_duplicate) ->
-- On DELETE reduce production option(on_duplicate) ->
-- On CREATE reduce production option(on_duplicate) ->
-- On ALTER reduce production option(on_duplicate) ->

State 652:
## Known stack suffix:
## insert_cmd IDENT option(sequence(IDENT)) VALUES option(commas(sequence(expr))) option(on_duplicate)
## LR(1) items:
statement -> insert_cmd IDENT option(sequence(IDENT)) VALUES option(commas(sequence(expr))) option(on_duplicate) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> insert_cmd IDENT option(sequence(IDENT)) VALUES option(commas(sequence(expr))) option(on_duplicate)

State 653:
## Known stack suffix:
## insert_cmd IDENT option(sequence(IDENT)) maybe_parenth(select_stmt)
## LR(1) items:
statement -> insert_cmd IDENT option(sequence(IDENT)) maybe_parenth(select_stmt) . option(on_duplicate) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On ON shift to state 636
-- On option(on_duplicate) shift to state 654
-- On on_duplicate shift to state 642
## Reductions:
-- On UPDATE reduce production option(on_duplicate) ->
-- On SET reduce production option(on_duplicate) ->
-- On SELECT reduce production option(on_duplicate) ->
-- On REPLACE reduce production option(on_duplicate) ->
-- On INSERT reduce production option(on_duplicate) ->
-- On EOF reduce production option(on_duplicate) ->
-- On END reduce production option(on_duplicate) ->
-- On DROP reduce production option(on_duplicate) ->
-- On DELETE reduce production option(on_duplicate) ->
-- On CREATE reduce production option(on_duplicate) ->
-- On ALTER reduce production option(on_duplicate) ->

State 654:
## Known stack suffix:
## insert_cmd IDENT option(sequence(IDENT)) maybe_parenth(select_stmt) option(on_duplicate)
## LR(1) items:
statement -> insert_cmd IDENT option(sequence(IDENT)) maybe_parenth(select_stmt) option(on_duplicate) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> insert_cmd IDENT option(sequence(IDENT)) maybe_parenth(select_stmt) option(on_duplicate)

State 655:
## Known stack suffix:
## BEGIN nonempty_list(statement)
## LR(1) items:
compound_stmt -> BEGIN nonempty_list(statement) . END [ UPDATE SET SELECT REPLACE LANGUAGE INSERT EOF END DROP DELETE CREATE COMMENT ALTER ]
## Transitions:
-- On END shift to state 656
## Reductions:

State 656:
## Known stack suffix:
## BEGIN nonempty_list(statement) END
## LR(1) items:
compound_stmt -> BEGIN nonempty_list(statement) END . [ UPDATE SET SELECT REPLACE LANGUAGE INSERT EOF END DROP DELETE CREATE COMMENT ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production compound_stmt -> BEGIN nonempty_list(statement) END

State 657:
## Known stack suffix:
## CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) option(AS) routine_body
## LR(1) items:
statement -> CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) option(AS) routine_body . option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LANGUAGE shift to state 542
-- On COMMENT shift to state 544
-- On routine_extra shift to state 546
-- On option(routine_extra) shift to state 658
## Reductions:
-- On UPDATE reduce production option(routine_extra) ->
-- On SET reduce production option(routine_extra) ->
-- On SELECT reduce production option(routine_extra) ->
-- On REPLACE reduce production option(routine_extra) ->
-- On INSERT reduce production option(routine_extra) ->
-- On EOF reduce production option(routine_extra) ->
-- On END reduce production option(routine_extra) ->
-- On DROP reduce production option(routine_extra) ->
-- On DELETE reduce production option(routine_extra) ->
-- On CREATE reduce production option(routine_extra) ->
-- On ALTER reduce production option(routine_extra) ->

State 658:
## Known stack suffix:
## CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) option(AS) routine_body option(routine_extra)
## LR(1) items:
statement -> CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) option(AS) routine_body option(routine_extra) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> CREATE option(or_replace) PROCEDURE IDENT LPAREN separated_nonempty_list(COMMA,proc_parameter) RPAREN option(routine_extra) option(AS) routine_body option(routine_extra)

State 659:
## Known stack suffix:
## compound_stmt
## LR(1) items:
routine_body -> compound_stmt . [ UPDATE SET SELECT REPLACE LANGUAGE INSERT EOF END DROP DELETE CREATE COMMENT ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production routine_body -> compound_stmt

State 660:
## Known stack suffix:
## proc_parameter
## LR(1) items:
separated_nonempty_list(COMMA,proc_parameter) -> proc_parameter . [ RPAREN ]
separated_nonempty_list(COMMA,proc_parameter) -> proc_parameter . COMMA separated_nonempty_list(COMMA,proc_parameter) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 661
## Reductions:
-- On RPAREN reduce production separated_nonempty_list(COMMA,proc_parameter) -> proc_parameter

State 661:
## Known stack suffix:
## proc_parameter COMMA
## LR(1) items:
separated_nonempty_list(COMMA,proc_parameter) -> proc_parameter COMMA . separated_nonempty_list(COMMA,proc_parameter) [ RPAREN ]
## Transitions:
-- On OUT shift to state 537
-- On INOUT shift to state 538
-- On IN shift to state 539
-- On separated_nonempty_list(COMMA,proc_parameter) shift to state 662
-- On proc_parameter shift to state 660
-- On parameter_mode shift to state 663
-- On option(parameter_mode) shift to state 664
## Reductions:
-- On IDENT reduce production option(parameter_mode) ->

State 662:
## Known stack suffix:
## proc_parameter COMMA separated_nonempty_list(COMMA,proc_parameter)
## LR(1) items:
separated_nonempty_list(COMMA,proc_parameter) -> proc_parameter COMMA separated_nonempty_list(COMMA,proc_parameter) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,proc_parameter) -> proc_parameter COMMA separated_nonempty_list(COMMA,proc_parameter)

State 663:
## Known stack suffix:
## parameter_mode
## LR(1) items:
option(parameter_mode) -> parameter_mode . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(parameter_mode) -> parameter_mode

State 664:
## Known stack suffix:
## option(parameter_mode)
## LR(1) items:
proc_parameter -> option(parameter_mode) . func_parameter [ RPAREN COMMA ]
## Transitions:
-- On IDENT shift to state 665
-- On func_parameter shift to state 674
## Reductions:

State 665:
## Known stack suffix:
## IDENT
## LR(1) items:
func_parameter -> IDENT . option(AS) sql_type option(parameter_default) [ RPAREN COMMA ]
## Transitions:
-- On AS shift to state 245
-- On option(AS) shift to state 666
## Reductions:
-- On YEAR reduce production option(AS) ->
-- On T_UUID reduce production option(AS) ->
-- On T_TEXT reduce production option(AS) ->
-- On T_INTEGER reduce production option(AS) ->
-- On T_FLOAT reduce production option(AS) ->
-- On T_DATETIME reduce production option(AS) ->
-- On T_BOOLEAN reduce production option(AS) ->
-- On T_BLOB reduce production option(AS) ->
-- On TIMESTAMP reduce production option(AS) ->
-- On TIME reduce production option(AS) ->
-- On NATIONAL reduce production option(AS) ->
-- On ENUM reduce production option(AS) ->
-- On DATE reduce production option(AS) ->
-- On CHARACTER reduce production option(AS) ->
-- On BINARY reduce production option(AS) ->

State 666:
## Known stack suffix:
## IDENT option(AS)
## LR(1) items:
func_parameter -> IDENT option(AS) . sql_type option(parameter_default) [ RPAREN COMMA ]
## Transitions:
-- On YEAR shift to state 358
-- On T_UUID shift to state 359
-- On T_INTEGER shift to state 360
-- On T_FLOAT shift to state 365
-- On T_DATETIME shift to state 368
-- On T_BOOLEAN shift to state 369
-- On T_BLOB shift to state 370
-- On TIMESTAMP shift to state 371
-- On TIME shift to state 372
-- On NATIONAL shift to state 373
-- On ENUM shift to state 374
-- On DATE shift to state 393
-- On BINARY shift to state 394
-- On sql_type_flavor shift to state 396
-- On sql_type shift to state 667
-- On option(NATIONAL) shift to state 434
-- On binary shift to state 445
## Reductions:
-- On T_TEXT reduce production option(NATIONAL) ->
-- On CHARACTER reduce production option(NATIONAL) ->

State 667:
## Known stack suffix:
## IDENT option(AS) sql_type
## LR(1) items:
func_parameter -> IDENT option(AS) sql_type . option(parameter_default) [ RPAREN COMMA ]
## Transitions:
-- On EQUAL shift to state 668
-- On DEFAULT shift to state 669
-- On parameter_default_ shift to state 670
-- On parameter_default shift to state 672
-- On option(parameter_default) shift to state 673
## Reductions:
-- On RPAREN reduce production option(parameter_default) ->
-- On COMMA reduce production option(parameter_default) ->

State 668:
## Known stack suffix:
## EQUAL
## LR(1) items:
parameter_default_ -> EQUAL . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parameter_default_ -> EQUAL

State 669:
## Known stack suffix:
## DEFAULT
## LR(1) items:
parameter_default_ -> DEFAULT . [ VALUES TRUE TIMESTAMP TIME TILDE TEXT PARAM NULL NOT MINUS LPAREN INTERVAL INTEGER IF IDENT FLOAT FALSE EXISTS EXCL DATETIME_FUNC DATE CASE BLOB ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production parameter_default_ -> DEFAULT

State 670:
## Known stack suffix:
## parameter_default_
## LR(1) items:
parameter_default -> parameter_default_ . expr [ RPAREN COMMA ]
## Transitions:
-- On VALUES shift to state 9
-- On TRUE shift to state 13
-- On TIMESTAMP shift to state 14
-- On TIME shift to state 16
-- On TILDE shift to state 18
-- On TEXT shift to state 19
-- On PARAM shift to state 20
-- On NULL shift to state 21
-- On NOT shift to state 22
-- On MINUS shift to state 24
-- On LPAREN shift to state 25
-- On INTERVAL shift to state 31
-- On INTEGER shift to state 32
-- On IF shift to state 33
-- On IDENT shift to state 35
-- On FLOAT shift to state 40
-- On FALSE shift to state 41
-- On EXISTS shift to state 42
-- On EXCL shift to state 43
-- On DATETIME_FUNC shift to state 44
-- On DATE shift to state 49
-- On CASE shift to state 51
-- On BLOB shift to state 52
-- On unary_op shift to state 53
-- On mnot(EXISTS) shift to state 54
-- On literal_value shift to state 68
-- On expr shift to state 671
-- On datetime_value shift to state 115
-- On attr_name shift to state 116
## Reductions:

State 671:
## Known stack suffix:
## parameter_default_ expr
## LR(1) items:
expr -> expr . numeric_bin_op expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . boolean_bin_op expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . comparison_op option(anyall) expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . CONCAT_OP expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . mnot(like) expr option(escape) [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN separated_nonempty_list(COMMA,expr) RPAREN [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . mnot(IN) LPAREN select_stmt RPAREN [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . IN IDENT [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) NULL [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . IS option(NOT) option(distinct_from) expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
expr -> expr . mnot(BETWEEN) expr AND expr [ RPAREN PLUS OR NUM_EQ_OP NUM_DIV_OP NUM_CMP_OP NUM_BIT_OP NOT_DISTINCT_OP NOT MINUS LIKE_OP LIKE IS IN EQUAL CONCAT_OP COMMA BETWEEN ASTERISK AND ]
parameter_default -> parameter_default_ expr . [ RPAREN COMMA ]
## Transitions:
-- On PLUS shift to state 70
-- On OR shift to state 71
-- On NUM_EQ_OP shift to state 72
-- On NUM_DIV_OP shift to state 73
-- On NUM_CMP_OP shift to state 74
-- On NUM_BIT_OP shift to state 75
-- On NOT_DISTINCT_OP shift to state 76
-- On NOT shift to state 77
-- On MINUS shift to state 83
-- On LIKE_OP shift to state 78
-- On LIKE shift to state 79
-- On IS shift to state 84
-- On IN shift to state 92
-- On EQUAL shift to state 94
-- On CONCAT_OP shift to state 95
-- On BETWEEN shift to state 97
-- On ASTERISK shift to state 100
-- On AND shift to state 105
-- On numeric_bin_op shift to state 98
-- On mnot(like) shift to state 101
-- On mnot(IN) shift to state 106
-- On mnot(BETWEEN) shift to state 117
-- On like shift to state 121
-- On comparison_op shift to state 122
-- On boolean_bin_op shift to state 128
## Reductions:
-- On RPAREN reduce production parameter_default -> parameter_default_ expr
-- On COMMA reduce production parameter_default -> parameter_default_ expr

State 672:
## Known stack suffix:
## parameter_default
## LR(1) items:
option(parameter_default) -> parameter_default . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(parameter_default) -> parameter_default

State 673:
## Known stack suffix:
## IDENT option(AS) sql_type option(parameter_default)
## LR(1) items:
func_parameter -> IDENT option(AS) sql_type option(parameter_default) . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production func_parameter -> IDENT option(AS) sql_type option(parameter_default)

State 674:
## Known stack suffix:
## option(parameter_mode) func_parameter
## LR(1) items:
proc_parameter -> option(parameter_mode) func_parameter . [ RPAREN COMMA ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production proc_parameter -> option(parameter_mode) func_parameter

State 675:
## Known stack suffix:
## CREATE option(or_replace) FUNCTION
## LR(1) items:
statement -> CREATE option(or_replace) FUNCTION . IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 676
## Reductions:

State 676:
## Known stack suffix:
## CREATE option(or_replace) FUNCTION IDENT
## LR(1) items:
statement -> CREATE option(or_replace) FUNCTION IDENT . LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LPAREN shift to state 677
## Reductions:

State 677:
## Known stack suffix:
## CREATE option(or_replace) FUNCTION IDENT LPAREN
## LR(1) items:
statement -> CREATE option(or_replace) FUNCTION IDENT LPAREN . separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 665
-- On separated_nonempty_list(COMMA,func_parameter) shift to state 678
-- On func_parameter shift to state 686
## Reductions:

State 678:
## Known stack suffix:
## CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter)
## LR(1) items:
statement -> CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) . RPAREN RETURNS sql_type option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On RPAREN shift to state 679
## Reductions:

State 679:
## Known stack suffix:
## CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN
## LR(1) items:
statement -> CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN . RETURNS sql_type option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On RETURNS shift to state 680
## Reductions:

State 680:
## Known stack suffix:
## CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS
## LR(1) items:
statement -> CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS . sql_type option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On YEAR shift to state 358
-- On T_UUID shift to state 359
-- On T_INTEGER shift to state 360
-- On T_FLOAT shift to state 365
-- On T_DATETIME shift to state 368
-- On T_BOOLEAN shift to state 369
-- On T_BLOB shift to state 370
-- On TIMESTAMP shift to state 371
-- On TIME shift to state 372
-- On NATIONAL shift to state 373
-- On ENUM shift to state 374
-- On DATE shift to state 393
-- On BINARY shift to state 394
-- On sql_type_flavor shift to state 396
-- On sql_type shift to state 681
-- On option(NATIONAL) shift to state 434
-- On binary shift to state 445
## Reductions:
-- On T_TEXT reduce production option(NATIONAL) ->
-- On CHARACTER reduce production option(NATIONAL) ->

State 681:
## Known stack suffix:
## CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type
## LR(1) items:
statement -> CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type . option(routine_extra) option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LANGUAGE shift to state 542
-- On COMMENT shift to state 544
-- On routine_extra shift to state 546
-- On option(routine_extra) shift to state 682
## Reductions:
-- On TEXT reduce production option(routine_extra) ->
-- On BEGIN reduce production option(routine_extra) ->
-- On AS reduce production option(routine_extra) ->

State 682:
## Known stack suffix:
## CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra)
## LR(1) items:
statement -> CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) . option(AS) routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On AS shift to state 245
-- On option(AS) shift to state 683
## Reductions:
-- On TEXT reduce production option(AS) ->
-- On BEGIN reduce production option(AS) ->

State 683:
## Known stack suffix:
## CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) option(AS)
## LR(1) items:
statement -> CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) option(AS) . routine_body option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On TEXT shift to state 549
-- On BEGIN shift to state 550
-- On routine_body shift to state 684
-- On compound_stmt shift to state 659
## Reductions:

State 684:
## Known stack suffix:
## CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) option(AS) routine_body
## LR(1) items:
statement -> CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) option(AS) routine_body . option(routine_extra) [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LANGUAGE shift to state 542
-- On COMMENT shift to state 544
-- On routine_extra shift to state 546
-- On option(routine_extra) shift to state 685
## Reductions:
-- On UPDATE reduce production option(routine_extra) ->
-- On SET reduce production option(routine_extra) ->
-- On SELECT reduce production option(routine_extra) ->
-- On REPLACE reduce production option(routine_extra) ->
-- On INSERT reduce production option(routine_extra) ->
-- On EOF reduce production option(routine_extra) ->
-- On END reduce production option(routine_extra) ->
-- On DROP reduce production option(routine_extra) ->
-- On DELETE reduce production option(routine_extra) ->
-- On CREATE reduce production option(routine_extra) ->
-- On ALTER reduce production option(routine_extra) ->

State 685:
## Known stack suffix:
## CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) option(AS) routine_body option(routine_extra)
## LR(1) items:
statement -> CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) option(AS) routine_body option(routine_extra) . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> CREATE option(or_replace) FUNCTION IDENT LPAREN separated_nonempty_list(COMMA,func_parameter) RPAREN RETURNS sql_type option(routine_extra) option(AS) routine_body option(routine_extra)

State 686:
## Known stack suffix:
## func_parameter
## LR(1) items:
separated_nonempty_list(COMMA,func_parameter) -> func_parameter . [ RPAREN ]
separated_nonempty_list(COMMA,func_parameter) -> func_parameter . COMMA separated_nonempty_list(COMMA,func_parameter) [ RPAREN ]
## Transitions:
-- On COMMA shift to state 687
## Reductions:
-- On RPAREN reduce production separated_nonempty_list(COMMA,func_parameter) -> func_parameter

State 687:
## Known stack suffix:
## func_parameter COMMA
## LR(1) items:
separated_nonempty_list(COMMA,func_parameter) -> func_parameter COMMA . separated_nonempty_list(COMMA,func_parameter) [ RPAREN ]
## Transitions:
-- On IDENT shift to state 665
-- On separated_nonempty_list(COMMA,func_parameter) shift to state 688
-- On func_parameter shift to state 686
## Reductions:

State 688:
## Known stack suffix:
## func_parameter COMMA separated_nonempty_list(COMMA,func_parameter)
## LR(1) items:
separated_nonempty_list(COMMA,func_parameter) -> func_parameter COMMA separated_nonempty_list(COMMA,func_parameter) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production separated_nonempty_list(COMMA,func_parameter) -> func_parameter COMMA separated_nonempty_list(COMMA,func_parameter)

State 689:
## Known stack suffix:
## option(either(GLOBAL,LOCAL))
## LR(1) items:
temporary -> option(either(GLOBAL,LOCAL)) . TEMPORARY [ TABLE ]
## Transitions:
-- On TEMPORARY shift to state 690
## Reductions:

State 690:
## Known stack suffix:
## option(either(GLOBAL,LOCAL)) TEMPORARY
## LR(1) items:
temporary -> option(either(GLOBAL,LOCAL)) TEMPORARY . [ TABLE ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production temporary -> option(either(GLOBAL,LOCAL)) TEMPORARY

State 691:
## Known stack suffix:
## CREATE option(UNIQUE)
## LR(1) items:
statement -> CREATE option(UNIQUE) . INDEX option(if_not_exists) table_name ON table_name LPAREN separated_nonempty_list(COMMA,index_column) RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On INDEX shift to state 692
## Reductions:

State 692:
## Known stack suffix:
## CREATE option(UNIQUE) INDEX
## LR(1) items:
statement -> CREATE option(UNIQUE) INDEX . option(if_not_exists) table_name ON table_name LPAREN separated_nonempty_list(COMMA,index_column) RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IF shift to state 334
-- On option(if_not_exists) shift to state 693
-- On if_not_exists shift to state 700
## Reductions:
-- On IDENT reduce production option(if_not_exists) ->

State 693:
## Known stack suffix:
## CREATE option(UNIQUE) INDEX option(if_not_exists)
## LR(1) items:
statement -> CREATE option(UNIQUE) INDEX option(if_not_exists) . table_name ON table_name LPAREN separated_nonempty_list(COMMA,index_column) RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 553
-- On table_name shift to state 694
## Reductions:

State 694:
## Known stack suffix:
## CREATE option(UNIQUE) INDEX option(if_not_exists) table_name
## LR(1) items:
statement -> CREATE option(UNIQUE) INDEX option(if_not_exists) table_name . ON table_name LPAREN separated_nonempty_list(COMMA,index_column) RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On ON shift to state 695
## Reductions:

State 695:
## Known stack suffix:
## CREATE option(UNIQUE) INDEX option(if_not_exists) table_name ON
## LR(1) items:
statement -> CREATE option(UNIQUE) INDEX option(if_not_exists) table_name ON . table_name LPAREN separated_nonempty_list(COMMA,index_column) RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 553
-- On table_name shift to state 696
## Reductions:

State 696:
## Known stack suffix:
## CREATE option(UNIQUE) INDEX option(if_not_exists) table_name ON table_name
## LR(1) items:
statement -> CREATE option(UNIQUE) INDEX option(if_not_exists) table_name ON table_name . LPAREN separated_nonempty_list(COMMA,index_column) RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On LPAREN shift to state 697
## Reductions:

State 697:
## Known stack suffix:
## CREATE option(UNIQUE) INDEX option(if_not_exists) table_name ON table_name LPAREN
## LR(1) items:
statement -> CREATE option(UNIQUE) INDEX option(if_not_exists) table_name ON table_name LPAREN . separated_nonempty_list(COMMA,index_column) RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On IDENT shift to state 341
-- On separated_nonempty_list(COMMA,index_column) shift to state 698
-- On index_column shift to state 354
## Reductions:

State 698:
## Known stack suffix:
## CREATE option(UNIQUE) INDEX option(if_not_exists) table_name ON table_name LPAREN separated_nonempty_list(COMMA,index_column)
## LR(1) items:
statement -> CREATE option(UNIQUE) INDEX option(if_not_exists) table_name ON table_name LPAREN separated_nonempty_list(COMMA,index_column) . RPAREN [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
-- On RPAREN shift to state 699
## Reductions:

State 699:
## Known stack suffix:
## CREATE option(UNIQUE) INDEX option(if_not_exists) table_name ON table_name LPAREN separated_nonempty_list(COMMA,index_column) RPAREN
## LR(1) items:
statement -> CREATE option(UNIQUE) INDEX option(if_not_exists) table_name ON table_name LPAREN separated_nonempty_list(COMMA,index_column) RPAREN . [ UPDATE SET SELECT REPLACE INSERT EOF END DROP DELETE CREATE ALTER ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production statement -> CREATE option(UNIQUE) INDEX option(if_not_exists) table_name ON table_name LPAREN separated_nonempty_list(COMMA,index_column) RPAREN

State 700:
## Known stack suffix:
## if_not_exists
## LR(1) items:
option(if_not_exists) -> if_not_exists . [ IDENT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(if_not_exists) -> if_not_exists

State 701:
## Known stack suffix:
## statement
## LR(1) items:
input -> statement . EOF [ # ]
## Transitions:
-- On EOF shift to state 702
## Reductions:

State 702:
## Known stack suffix:
## statement EOF
## LR(1) items:
input -> statement EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production input -> statement EOF

State 703:
## Known stack suffix:
## input
## LR(1) items:
input' -> input . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept input

