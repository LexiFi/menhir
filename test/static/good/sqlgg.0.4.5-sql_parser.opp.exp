%{
  open Sql
  open Sql.Type
  open Sql.Constraint
  open ExtLib

  (* preserve order *)
  let make_limit l =
    let param = function
      | _, `Const _ -> None
      | x, `Param (None,pos) -> Some ((Some (match x with `Limit -> "limit" | `Offset -> "offset"),pos),Int)
      | _, `Param p -> Some (p,Int)
    in
    List.filter_map param l, List.mem (`Limit,`Const 1) l

  let poly ret args = Fun (F (Typ ret, List.map (fun _ -> Var 0) args), args)
%}
%start input
%token ACTION
%token ADD
%token AFTER
%token ALL
%token ALTER
%token AND
%token ANY
%token AS
%token ASC
%token ASCII
%token ASTERISK
%token AUTOINCREMENT
%token BEGIN
%token BETWEEN
%token BINARY
%token <string> BLOB
%token BY
%token CASCADE
%token CASE
%token CHANGE
%token CHARACTER
%token CHARSET
%token CHECK
%token COLLATE
%token COLUMN
%token COMMA
%token COMMENT
%token CONCAT_OP
%token CONFLICT
%token CONFLICT_ALGO
%token CONSTRAINT
%token CREATE
%token CROSS
%token DATE
%token DATETIME_FUNC
%token DAY
%token DAY_HOUR
%token DAY_MICROSECOND
%token DAY_MINUTE
%token DAY_SECOND
%token DEFAULT
%token DELAYED
%token DELETE
%token DESC
%token DISTINCT
%token DOT
%token DROP
%token DUPLICATE
%token ELSE
%token END
%token ENUM
%token EOF
%token EQUAL
%token ESCAPE
%token EXCEPT
%token EXCL
%token EXISTS
%token FALSE
%token FIRST
%token <float> FLOAT
%token FOR
%token FOREIGN
%token FROM
%token FULLTEXT
%token FUNCTION
%token GLOBAL
%token GROUP
%token HAVING
%token HOUR
%token HOUR_MICROSECOND
%token HOUR_MINUTE
%token HOUR_SECOND
%token <string> IDENT
%token IF
%token IGNORED
%token IN
%token INDEX
%token INOUT
%token INSERT
%token <int> INTEGER
%token INTERSECT
%token INTERVAL
%token INTO
%token IS
%token JOIN
%token JOIN_TYPE1
%token JOIN_TYPE2
%token KEY
%token LANGUAGE
%token LIKE
%token LIKE_OP
%token LIMIT
%token LOCAL
%token LOCK
%token LPAREN
%token MICROSECOND
%token MINUS
%token MINUTE
%token MINUTE_MICROSECOND
%token MINUTE_SECOND
%token MODE
%token MODIFY
%token MONTH
%token NATIONAL
%token NATURAL
%token NO
%token NOT
%token NOT_DISTINCT_OP
%token NOWAIT
%token NULL
%token NUM_BIT_OP
%token NUM_CMP_OP
%token NUM_DIV_OP
%token NUM_EQ_OP
%token OF
%token OFFSET
%token ON
%token OR
%token ORDER
%token OUT
%token <Sql.param_id> PARAM
%token PLUS
%token PRECISION
%token PRIMARY
%token PROCEDURE
%token QUARTER
%token REFERENCES
%token REPLACE
%token RESTRICT
%token RETURNS
%token RPAREN
%token SECOND
%token SECOND_MICROSECOND
%token SELECT
%token SET
%token SHARE
%token SOME
%token TABLE
%token TEMPORARY
%token <string> TEXT
%token THEN
%token TILDE
%token TIME
%token TIMESTAMP
%token TRUE
%token T_BLOB
%token T_BOOLEAN
%token T_DATETIME
%token T_FLOAT
%token T_INTEGER
%token T_TEXT
%token T_UUID
%token UNICODE
%token UNION
%token UNIQUE
%token UNSIGNED
%token UPDATE
%token USING
%token VALUE
%token VALUES
%token VARYING
%token VIEW
%token WEEK
%token WHEN
%token WHERE
%token WITH
%token YEAR
%token YEAR_MONTH
%token ZEROFILL
%left OR
%left AND
%nonassoc EQUAL NOT_DISTINCT_OP NUM_EQ_OP
%nonassoc NUM_CMP_OP
%nonassoc NUM_BIT_OP
%left MINUS PLUS
%left ASTERISK NUM_DIV_OP
%left CONCAT_OP
%nonassoc UNARY_MINUS
%type <Sql.expr> expr
%type <Sql.stmt> input
%%

option_ALL_:
  
    {    ( None )}
| x = ALL
    {    ( Some x )}

option_AS_:
  
    {    ( None )}
| x = AS
    {    ( Some x )}

option_COLUMN_:
  
    {    ( None )}
| x = COLUMN
    {    ( Some x )}

option_DELAYED_:
  
    {    ( None )}
| x = DELAYED
    {    ( Some x )}

option_DISTINCT_:
  
    {    ( None )}
| x = DISTINCT
    {    ( Some x )}

option_IDENT_:
  
    {    ( None )}
| x = IDENT
    {    ( Some x )}

option_INTEGER_:
  
    {    ( None )}
| x = INTEGER
    {    ( Some x )}

option_JOIN_TYPE1_:
  
    {    ( None )}
| x = JOIN_TYPE1
    {    ( Some x )}

option_JOIN_TYPE2_:
  
    {    ( None )}
| x = JOIN_TYPE2
    {    ( Some x )}

option_KEY_:
  
    {    ( None )}
| x = KEY
    {    ( Some x )}

option_NATIONAL_:
  
    {    ( None )}
| x = NATIONAL
    {    ( Some x )}

option_NOT_:
  
    {    ( None )}
| x = NOT
    {    ( Some x )}

option_NOWAIT_:
  
    {    ( None )}
| x = NOWAIT
    {    ( Some x )}

option_OR_:
  
    {    ( None )}
| x = OR
    {    ( Some x )}

option_PRECISION_:
  
    {    ( None )}
| x = PRECISION
    {    ( Some x )}

option_PRIMARY_:
  
    {    ( None )}
| x = PRIMARY
    {    ( Some x )}

option_UNIQUE_:
  
    {    ( None )}
| x = UNIQUE
    {    ( Some x )}

option_UNSIGNED_:
  
    {    ( None )}
| x = UNSIGNED
    {    ( Some x )}

option_VARYING_:
  
    {    ( None )}
| x = VARYING
    {    ( Some x )}

option_ZEROFILL_:
  
    {    ( None )}
| x = ZEROFILL
    {    ( Some x )}

option_anyall_:
  
    {    ( None )}
| x = anyall
    {    ( Some x )}

option_charset_:
  
    {    ( None )}
| x = charset
    {    ( Some x )}

option_collate_:
  
    {    ( None )}
| x = collate
    {    ( Some x )}

option_commas_sequence_expr___:
  
    {    ( None )}
| l = separated_nonempty_list_COMMA_sequence_expr__
    {let x =                                                       ( l ) in
    ( Some x )}

option_commas_set_column__:
  
    {    ( None )}
| l = separated_nonempty_list_COMMA_set_column_
    {let x =                                                       ( l ) in
    ( Some x )}

option_distinct_from_:
  
    {    ( None )}
| x = distinct_from
    {    ( Some x )}

option_drop_behavior_:
  
    {    ( None )}
| x = drop_behavior
    {    ( Some x )}

option_either_GLOBAL_LOCAL__:
  
    {    ( None )}
| _1 = GLOBAL
    {let x =                            ( ) in
    ( Some x )}
| _1 = LOCAL
    {let x =                            ( ) in
    ( Some x )}

option_escape_:
  
    {    ( None )}
| x = escape
    {    ( Some x )}

option_expr_:
  
    {    ( None )}
| x = expr
    {    ( Some x )}

option_from_:
  
    {    ( None )}
| x = from
    {    ( Some x )}

option_having_:
  
    {    ( None )}
| x = having
    {    ( Some x )}

option_if_exists_:
  
    {    ( None )}
| x = if_exists
    {    ( Some x )}

option_if_not_exists_:
  
    {    ( None )}
| x = if_not_exists
    {    ( Some x )}

option_index_prefix_:
  
    {    ( None )}
| x = index_prefix
    {    ( Some x )}

option_limit_t_:
  
    {    ( None )}
| x = limit_t
    {    ( Some x )}

option_on_duplicate_:
  
    {    ( None )}
| x = on_duplicate
    {    ( Some x )}

option_or_replace_:
  
    {    ( None )}
| x = or_replace
    {    ( Some x )}

option_order_type_:
  
    {    ( None )}
| x = order_type
    {    ( Some x )}

option_pair_CONSTRAINT_IDENT__:
  
    {    ( None )}
| x = CONSTRAINT y = IDENT
    {let x =     ( (x, y) ) in
    ( Some x )}

option_parameter_default_:
  
    {    ( None )}
| x = parameter_default
    {    ( Some x )}

option_parameter_mode_:
  
    {    ( None )}
| x = parameter_mode
    {    ( Some x )}

option_preceded_ELSE_expr__:
  
    {    ( None )}
| _1 = ELSE x = expr
    {let x =     ( x ) in
    ( Some x )}

option_routine_extra_:
  
    {    ( None )}
| x = routine_extra
    {    ( Some x )}

option_select_row_locking_:
  
    {    ( None )}
| x = select_row_locking
    {    ( Some x )}

option_select_type_:
  
    {    ( None )}
| x = select_type
    {    ( Some x )}

option_sequence_IDENT__:
  
    {    ( None )}
| _1 = LPAREN l = separated_nonempty_list_COMMA_IDENT_ _2 = RPAREN
    {let x =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
    ( Some x )}

option_sql_type_:
  
    {    ( None )}
| x = sql_type
    {    ( Some x )}

option_update_or_share_of_:
  
    {    ( None )}
| x = update_or_share_of
    {    ( Some x )}

option_where_:
  
    {    ( None )}
| x = where
    {    ( Some x )}

option_with_lock_:
  
    {    ( None )}
| x = with_lock
    {    ( Some x )}

loption_group_:
  
    {    ( [] )}
| x = group
    {    ( x )}

loption_limit_:
  
    {    ( [] )}
| x = limit
    {    ( x )}

loption_order_:
  
    {    ( [] )}
| x = order
    {    ( x )}

list_IGNORED_:
  
    {    ( [] )}
| x = IGNORED xs = list_IGNORED_
    {    ( x :: xs )}

list_column_def_extra_:
  
    {    ( [] )}
| x = column_def_extra xs = list_column_def_extra_
    {    ( x :: xs )}

list_join_source_:
  
    {    ( [] )}
| x = join_source xs = list_join_source_
    {    ( x :: xs )}

list_preceded_compound_op_select_core__:
  
    {    ( [] )}
| _1 = compound_op x = select_core xs = list_preceded_compound_op_select_core__
    {let x =     ( x ) in
    ( x :: xs )}

list_reference_action_clause_:
  
    {    ( [] )}
| x = reference_action_clause xs = list_reference_action_clause_
    {    ( x :: xs )}

nonempty_list_case_branch_:
  x = case_branch
    {    ( [ x ] )}
| x = case_branch xs = nonempty_list_case_branch_
    {    ( x :: xs )}

nonempty_list_for_update_or_share_:
  x = for_update_or_share
    {    ( [ x ] )}
| x = for_update_or_share xs = nonempty_list_for_update_or_share_
    {    ( x :: xs )}

nonempty_list_statement_:
  x = statement
    {    ( [ x ] )}
| x = statement xs = nonempty_list_statement_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_IDENT_:
  x = IDENT
    {    ( [ x ] )}
| x = IDENT _2 = COMMA xs = separated_nonempty_list_COMMA_IDENT_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_TEXT_:
  x = TEXT
    {    ( [ x ] )}
| x = TEXT _2 = COMMA xs = separated_nonempty_list_COMMA_TEXT_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_alter_action_:
  x = alter_action
    {    ( [ x ] )}
| x = alter_action _2 = COMMA xs = separated_nonempty_list_COMMA_alter_action_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_column1_:
  x = column1
    {    ( [ x ] )}
| x = column1 _2 = COMMA xs = separated_nonempty_list_COMMA_column1_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_column_def1_:
  x = column_def1
    {    ( [ x ] )}
| x = column_def1 _2 = COMMA xs = separated_nonempty_list_COMMA_column_def1_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_expr_:
  x = expr
    {    ( [ x ] )}
| x = expr _2 = COMMA xs = separated_nonempty_list_COMMA_expr_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_func_parameter_:
  x = func_parameter
    {    ( [ x ] )}
| x = func_parameter _2 = COMMA xs = separated_nonempty_list_COMMA_func_parameter_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_index_column_:
  x = index_column
    {    ( [ x ] )}
| x = index_column _2 = COMMA xs = separated_nonempty_list_COMMA_index_column_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_proc_parameter_:
  x = proc_parameter
    {    ( [ x ] )}
| x = proc_parameter _2 = COMMA xs = separated_nonempty_list_COMMA_proc_parameter_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_sequence_expr__:
  _1 = LPAREN l = separated_nonempty_list_COMMA_expr_ _2 = RPAREN
    {let x =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
    ( [ x ] )}
| _1 = LPAREN l = separated_nonempty_list_COMMA_expr_ _2_inlined1 = RPAREN _2 = COMMA xs = separated_nonempty_list_COMMA_sequence_expr__
    {let x =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
    ( x :: xs )}

separated_nonempty_list_COMMA_set_column_:
  x = set_column
    {    ( [ x ] )}
| x = set_column _2 = COMMA xs = separated_nonempty_list_COMMA_set_column_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_source_:
  x = source
    {    ( [ x ] )}
| x = source _2 = COMMA xs = separated_nonempty_list_COMMA_source_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_terminated_expr_option_order_type___:
  x = expr _2 = option_order_type_
    {let x =     ( x ) in
    ( [ x ] )}
| x = expr _2_inlined1 = option_order_type_ _2 = COMMA xs = separated_nonempty_list_COMMA_terminated_expr_option_order_type___
    {let x =     ( x ) in
    ( x :: xs )}

input:
  _1 = statement _2 = EOF
    {                     ( _1 )}

if_not_exists:
  _1 = IF _2 = NOT _3 = EXISTS
    {                             ( )}

if_exists:
  _1 = IF _2 = EXISTS
    {                     ()}

temporary:
  _1 = option_either_GLOBAL_LOCAL__ _2 = TEMPORARY
    {                                           ( )}

statement:
  _1 = CREATE _3 = TABLE name = IDENT schema = table_definition
    {let _4 =     ( None ) in
let _2 =     ( None ) in
              (
                Create (name,`Schema schema)
              )}
| _1 = CREATE _3 = TABLE x = if_not_exists name = IDENT schema = table_definition
    {let _4 =     ( Some x ) in
let _2 =     ( None ) in
              (
                Create (name,`Schema schema)
              )}
| _1 = CREATE x = temporary _3 = TABLE name = IDENT schema = table_definition
    {let _4 =     ( None ) in
let _2 =     ( Some x ) in
              (
                Create (name,`Schema schema)
              )}
| _1 = CREATE x = temporary _3 = TABLE x_inlined1 = if_not_exists name = IDENT schema = table_definition
    {let _4 =
  let x = x_inlined1 in
      ( Some x )
in
let _2 =     ( Some x ) in
              (
                Create (name,`Schema schema)
              )}
| _1 = CREATE _1_inlined1 = TABLE name = IDENT _4 = AS select = maybe_parenth_select_stmt_
    {let _2 =                            ( ) in
              (
                Create (name,`Select select)
              )}
| _1 = CREATE _1_inlined1 = VIEW name = IDENT _4 = AS select = maybe_parenth_select_stmt_
    {let _2 =                            ( ) in
              (
                Create (name,`Select select)
              )}
| _1 = ALTER _2 = TABLE name = table_name l = separated_nonempty_list_COMMA_alter_action_
    {let actions =                                                       ( l ) in
              (
                Alter (name,actions)
              )}
| _1 = DROP _2 = TABLE _3 = option_if_exists_ name = IDENT
    {              (
                Drop name
              )}
| _1 = CREATE _2 = option_UNIQUE_ _3 = INDEX _4 = option_if_not_exists_ name = table_name _6 = ON table = table_name _1_inlined1 = LPAREN l = separated_nonempty_list_COMMA_index_column_ _2_inlined1 = RPAREN
    {let cols =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
              (
                CreateIndex (name, table, cols)
              )}
| _1 = select_stmt
    {                       ( Select _1 )}
| _1 = insert_cmd target = IDENT names = option_sequence_IDENT__ _4 = VALUES values = option_commas_sequence_expr___ ss = option_on_duplicate_
    {              (
                Insert { target; action=`Values (names, values); on_duplicate=ss; }
              )}
| _1 = insert_cmd target = IDENT names = option_sequence_IDENT__ select = maybe_parenth_select_stmt_ ss = option_on_duplicate_
    {              (
                Insert { target; action=`Select (names, select); on_duplicate=ss; }
              )}
| _1 = insert_cmd target = IDENT _3 = SET set = option_commas_set_column__ ss = option_on_duplicate_
    {              (
                Insert { target; action=`Set set; on_duplicate=ss; }
              )}
| _1 = update_cmd table = IDENT _3 = SET l = separated_nonempty_list_COMMA_set_column_ w = option_where_ o = loption_order_ lim = loption_limit_
    {let ss =                                                       ( l ) in
              (
                Update (table,ss,w,o,lim)
              )}
| _1 = update_cmd l = separated_nonempty_list_COMMA_source_ _3 = SET l_inlined1 = separated_nonempty_list_COMMA_set_column_ w = option_where_
    {let ss =
  let l = l_inlined1 in
                                                        ( l )
in
let tables =                                                       ( l ) in
              (
                UpdateMulti (tables,ss,w)
              )}
| _1 = DELETE _2 = FROM table = IDENT w = option_where_
    {              (
                Delete (table,w)
              )}
| _1 = SET name = IDENT _3 = EQUAL e = expr
    {              (
                Set (name, e)
              )}
| _1 = CREATE _2 = option_or_replace_ _3 = FUNCTION name = IDENT _1_inlined1 = LPAREN l = separated_nonempty_list_COMMA_func_parameter_ _2_inlined1 = RPAREN _6 = RETURNS ret = sql_type _8 = option_routine_extra_ _9 = option_AS_ _10 = routine_body _11 = option_routine_extra_
    {let params =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
              (
                Function.add (List.length params) (Ret ret) name;
                CreateRoutine (name, Some ret, params)
              )}
| _1 = CREATE _2 = option_or_replace_ _3 = PROCEDURE name = IDENT _1_inlined1 = LPAREN l = separated_nonempty_list_COMMA_proc_parameter_ _2_inlined1 = RPAREN _6 = option_routine_extra_ _7 = option_AS_ _8 = routine_body _9 = option_routine_extra_
    {let params =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
              (
                Function.add (List.length params) (Ret Any) name; (* FIXME void *)
                CreateRoutine (name, None, params)
              )}

parameter_default_:
  _1 = DEFAULT
    {                                    ( )}
| _1 = EQUAL
    {                                    ( )}

parameter_default:
  _1 = parameter_default_ e = expr
    {                                             ( e )}

func_parameter:
  n = IDENT _2 = option_AS_ t = sql_type e = option_parameter_default_
    {                                                            ( (n,t,e) )}

parameter_mode:
  _1 = IN
    {                                 ( )}
| _1 = OUT
    {                                 ( )}
| _1 = INOUT
    {                                 ( )}

proc_parameter:
  _1 = option_parameter_mode_ p = func_parameter
    {                                                 ( p )}

or_replace:
  _1 = OR _2 = REPLACE
    {                       ( )}

routine_body:
  _1 = TEXT
    {                                   ( )}
| _1 = compound_stmt
    {                                   ( )}

compound_stmt:
  _1 = BEGIN _2 = nonempty_list_statement_ _3 = END
    {                                    ( )}

routine_extra:
  _1 = LANGUAGE _2 = IDENT
    {                              ( )}
| _1 = COMMENT _2 = TEXT
    {                            ( )}

table_name:
  name = IDENT
    {                                              ( name )}
| _1 = IDENT _2 = DOT name = IDENT
    {                                              ( name )}

index_prefix:
  _1 = LPAREN n = INTEGER _3 = RPAREN
    {                                      ( n )}

index_column:
  name = IDENT _2 = option_index_prefix_ _3 = option_collate_ _4 = option_order_type_
    {                                                            ( name )}

table_definition:
  _1 = LPAREN l = separated_nonempty_list_COMMA_column_def1_ _2 = table_def_done
    {let t =
  let l =                                                       ( l ) in
                                           ( l )
in
                                                          ( List.filter_map (function `Attr a -> Some a | `Constraint _ | `Index _ -> None) t )}
| _1 = LIKE name = maybe_parenth_IDENT_
    {                                                 ( Tables.get name |> snd )}

table_def_done:
  _1 = table_def_done1 _2 = RPAREN _3 = list_IGNORED_
    {                                                ( Parser_state.mode_normal () )}

table_def_done1:
  
    {                 ( Parser_state.mode_ignore () )}

select_stmt:
  _1 = select_core other = list_preceded_compound_op_select_core__ o = loption_order_ lim = option_limit_t_ _5 = option_select_row_locking_
    {              (
                { select = (_1, other); order=o; limit=lim; }
              )}

select_core:
  _1 = SELECT _2 = option_select_type_ l = separated_nonempty_list_COMMA_column1_ f = option_from_ w = option_where_ g = loption_group_ h = option_having_
    {let r =                                                       ( l ) in
              (
                { columns=r; from=f; where=w; group=g; having=h; }
              )}

table_list:
  src = source joins = list_join_source_
    {                                          ( (src,joins) )}

join_source:
  _1 = NATURAL _2 = maybe_join_type _3 = JOIN src = source
    {                                                     ( src,`Natural )}
| _1 = CROSS _2 = JOIN src = source
    {                                   ( src,`Cross )}
| _1 = qualified_join src = source cond = join_cond
    {                                                      ( src,cond )}

qualified_join:
  _1 = COMMA
    {                                             ( )}
| _1 = maybe_join_type _2 = JOIN
    {                                             ( )}

join_cond:
  _1 = ON e = expr
    {                     ( `Search e )}
| _1 = USING _1_inlined1 = LPAREN l = separated_nonempty_list_COMMA_IDENT_ _2 = RPAREN
    {let l =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
                                   ( `Using l )}
| 
    {                 ( `Default )}

source1:
  _1 = IDENT
    {               ( `Table _1 )}
| _1 = LPAREN s = select_core _3 = RPAREN
    {                                     ( `Select s )}

source:
  src = source1 alias = maybe_as
    {                                   ( src, alias )}

insert_cmd:
  _1 = INSERT _2 = option_DELAYED_ _3 = option_OR_ _4 = conflict_algo _5 = INTO
    {                                                                                ( )}
| _1 = INSERT _2 = INTO
    {                                                                                ( )}
| _1 = REPLACE _2 = INTO
    {                                                                                ( )}

update_cmd:
  _1 = UPDATE
    {                                             ( )}
| _1 = UPDATE _2 = OR _3 = conflict_algo
    {                                             ( )}

conflict_algo:
  _1 = CONFLICT_ALGO
    {                                       ( )}
| _1 = REPLACE
    {                                       ( )}

on_duplicate:
  _1 = ON _2 = DUPLICATE _3 = KEY _4 = UPDATE l = separated_nonempty_list_COMMA_set_column_
    {let ss =                                                       ( l ) in
                                                            ( ss )}

select_type:
  _1 = DISTINCT
    {                            ( )}
| _1 = ALL
    {                            ( )}

select_row_locking:
  _1 = nonempty_list_for_update_or_share_
    {      ( )}
| _1 = LOCK _2 = IN _3 = SHARE _4 = MODE
    {      ( )}

for_update_or_share:
  _1 = FOR _1_inlined1 = UPDATE _3 = option_update_or_share_of_ _4 = option_NOWAIT_ _5 = option_with_lock_
    {let _2 =                            ( ) in
                                                                   ( )}
| _1 = FOR _1_inlined1 = SHARE _3 = option_update_or_share_of_ _4 = option_NOWAIT_ _5 = option_with_lock_
    {let _2 =                            ( ) in
                                                                   ( )}

update_or_share_of:
  _1 = OF l = separated_nonempty_list_COMMA_IDENT_
    {let _2 =                                                       ( l ) in
                                     ( )}

with_lock:
  _1 = WITH _2 = LOCK
    {                     ( )}

int_or_param:
  i = INTEGER
    {                        ( `Const i )}
| p = PARAM
    {                      ( `Param p )}

limit_t:
  _1 = LIMIT lim = int_or_param
    {                                ( make_limit [`Limit,lim] )}
| _1 = LIMIT ofs = int_or_param _3 = COMMA lim = int_or_param
    {                                                       ( make_limit [`Offset,ofs; `Limit,lim] )}
| _1 = LIMIT lim = int_or_param _3 = OFFSET ofs = int_or_param
    {                                                        ( make_limit [`Limit,lim; `Offset,ofs] )}

limit:
  _1 = limit_t
    {               ( fst _1 )}

order:
  _1 = ORDER _2 = BY l = separated_nonempty_list_COMMA_terminated_expr_option_order_type___
    {let l =                                                       ( l ) in
                                                       ( l )}

order_type:
  _1 = DESC
    {                       ( )}
| _1 = ASC
    {                       ( )}

from:
  _1 = FROM t = table_list
    {                        ( t )}

where:
  _1 = WHERE e = expr
    {                    ( e )}

group:
  _1 = GROUP _2 = BY l = expr_list
    {                            ( l )}

having:
  _1 = HAVING e = expr
    {                      ( e )}

column1:
  _1 = IDENT _2 = DOT _3 = ASTERISK
    {                            ( Sql.AllOf _1 )}
| _1 = ASTERISK
    {                  ( Sql.All )}
| e = expr m = maybe_as
    {                           ( Sql.Expr (e,m) )}

maybe_as:
  _1 = option_AS_ name = IDENT
    {                         ( Some name )}
| 
    {          ( None )}

maybe_parenth_IDENT_:
  x = IDENT
    {                                          ( x )}
| _1 = LPAREN x = IDENT _3 = RPAREN
    {                                          ( x )}

maybe_parenth_column_def_:
  x = column_def
    {                                          ( x )}
| _1 = LPAREN x = column_def _3 = RPAREN
    {                                          ( x )}

maybe_parenth_select_stmt_:
  x = select_stmt
    {                                          ( x )}
| _1 = LPAREN x = select_stmt _3 = RPAREN
    {                                          ( x )}

alter_action:
  _1 = ADD _2 = option_COLUMN_ col = maybe_parenth_column_def_ pos = alter_pos
    {                                                                      ( `Add (col,pos) )}
| _1 = ADD _2 = index_type _3 = option_IDENT_ _1_inlined1 = LPAREN l = separated_nonempty_list_COMMA_IDENT_ _2_inlined1 = RPAREN
    {let _4 =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
                                                    ( `None )}
| _1 = DROP _2 = INDEX _3 = IDENT
    {                               ( `None )}
| _1 = DROP _2 = PRIMARY _3 = KEY
    {                               ( `None )}
| _1 = DROP _2 = option_COLUMN_ col = IDENT _4 = option_drop_behavior_
    {                                                    ( `Drop col )}
| _1 = CHANGE _2 = option_COLUMN_ old_name = IDENT column = column_def pos = alter_pos
    {                                                                            ( `Change (old_name,column,pos) )}
| _1 = MODIFY _2 = option_COLUMN_ column = column_def pos = alter_pos
    {                                                             ( `Change (column.name,column,pos) )}
| _1 = SET _2 = IDENT _3 = IDENT
    {                              ( `None )}

index_type:
  _1 = INDEX
    {                                           ( )}
| _1 = FULLTEXT
    {                                           ( )}
| _1 = PRIMARY _2 = KEY
    {                                           ( )}

alter_pos:
  _1 = AFTER col = IDENT
    {                           ( `After col )}
| _1 = FIRST
    {                 ( `First )}
| 
    {           ( `Default )}

drop_behavior:
  _1 = CASCADE
    {                                  ( )}
| _1 = RESTRICT
    {                                  ( )}

column_def:
  name = IDENT t = option_sql_type_ _3 = list_column_def_extra_
    {    ( attr name (match t with Some x -> x | None -> Int) )}

column_def1:
  c = column_def
    {                          ( `Attr c )}
| _1 = option_pair_CONSTRAINT_IDENT__ c = table_constraint_1
    {                                                          ( `Constraint c )}
| _1 = INDEX _1_inlined1 = LPAREN l = separated_nonempty_list_COMMA_index_column_ _2 = RPAREN
    {let cols =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
                                               ( `Index cols )}

on_conflict:
  _1 = ON _2 = CONFLICT algo = conflict_algo
    {                                            ( algo )}

column_def_extra:
  _1 = PRIMARY _2 = KEY
    {                              ( Some PrimaryKey )}
| _1 = NOT _2 = NULL
    {                           ( Some NotNull )}
| _1 = NULL
    {                       ( None )}
| _1 = UNIQUE
    {                         ( Some Unique )}
| _1 = AUTOINCREMENT
    {                                ( Some Autoincrement )}
| _1 = on_conflict
    {                              ( None )}
| _1 = CHECK _2 = LPAREN _3 = expr _4 = RPAREN
    {                                           ( None )}
| _1 = DEFAULT _2 = default_value
    {                                        ( None )}
| _1 = COLLATE _2 = IDENT
    {                                ( None )}

default_value:
  _1 = single_literal_value
    {                                                     ( )}
| _1 = datetime_value
    {                                                     ( )}

table_constraint_1:
  _1 = some_key _2 = option_IDENT_ _3 = key_arg
    {                                ( [] )}
| _1 = FOREIGN _2 = KEY _3 = option_IDENT_ _1_inlined1 = LPAREN l = separated_nonempty_list_COMMA_IDENT_ _2_inlined1 = RPAREN _5 = REFERENCES _6 = IDENT _7 = option_sequence_IDENT__ _8 = list_reference_action_clause_
    {let _4 =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
          ( [] )}
| _1 = CHECK _2 = LPAREN _3 = expr _4 = RPAREN
    {                                 ( [] )}

reference_action_clause:
  _1 = ON _1_inlined1 = DELETE _3 = reference_action
    {let _2 =                            ( ) in
                                             ( )}
| _1 = ON _1_inlined1 = UPDATE _3 = reference_action
    {let _2 =                            ( ) in
                                             ( )}

reference_action:
  _1 = RESTRICT
    {                                                          ( )}
| _1 = CASCADE
    {                                                          ( )}
| _1 = SET _2 = NULL
    {                                                          ( )}
| _1 = NO _2 = ACTION
    {                                                          ( )}
| _1 = SET _2 = DEFAULT
    {                                                          ( )}

some_key:
  _1 = UNIQUE _2 = option_KEY_
    {                                                    ( )}
| _1 = option_PRIMARY_ _2 = KEY
    {                                                    ( )}
| _1 = FULLTEXT _2 = KEY
    {                                                    ( )}

key_arg:
  _1 = LPAREN _2 = VALUE _3 = RPAREN
    {                                               ( )}
| _1 = LPAREN l = separated_nonempty_list_COMMA_IDENT_ _2 = RPAREN
    {let _1 =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
                                               ( )}

set_column:
  name = attr_name _2 = EQUAL e = expr
    {                                        ( name,e )}

anyall:
  _1 = ANY
    {                         ( )}
| _1 = ALL
    {                         ( )}
| _1 = SOME
    {                         ( )}

mnot_BETWEEN_:
  _1 = NOT x = BETWEEN
    {                           ( x )}
| x = BETWEEN
    {                           ( x )}

mnot_EXISTS_:
  _1 = NOT x = EXISTS
    {                           ( x )}
| x = EXISTS
    {                           ( x )}

mnot_IN_:
  _1 = NOT x = IN
    {                           ( x )}
| x = IN
    {                           ( x )}

mnot_like_:
  _1 = NOT x = like
    {                           ( x )}
| x = like
    {                           ( x )}

attr_name:
  cname = IDENT
    {                       ( { cname; tname=None} )}
| table = IDENT _2 = DOT cname = IDENT
    {                                                 ( {cname; tname=Some table} )}
| _1 = IDENT _2 = DOT table = IDENT _4 = DOT cname = IDENT
    {                                                 ( {cname; tname=Some table} )}

distinct_from:
  _1 = DISTINCT _2 = FROM
    {                             ( )}

expr:
  _1 = expr _2 = numeric_bin_op _3 = expr %prec PLUS
    {                                          ( Fun ((Ret Any),[_1;_3]) )}
| _1 = expr _2 = boolean_bin_op _3 = expr %prec AND
    {                                         ( Fun ((fixed Bool [Bool;Bool]),[_1;_3]) )}
| e1 = expr _2 = comparison_op _3 = option_anyall_ e2 = expr %prec EQUAL
    {                                                        ( poly Bool [e1;e2] )}
| _1 = expr _2 = CONCAT_OP _3 = expr
    {                          ( Fun ((fixed Text [Text;Text]),[_1;_3]) )}
| e1 = expr _2 = mnot_like_ e2 = expr e3 = option_escape_
    {      (
        match e3 with
        | None -> Fun ((fixed Bool [Text; Text]), [e1;e2])
        | Some e3 -> Fun ((fixed Bool [Text; Text; Text]), [e1;e2;e3])
      )}
| _1 = unary_op _2 = expr
    {                    ( _2 )}
| _1 = MINUS _2 = expr %prec UNARY_MINUS
    {                                   ( _2 )}
| _1 = INTERVAL _2 = expr _3 = interval_unit
    {                                  ( Fun (fixed Datetime [Int], [_2]) )}
| _1 = LPAREN _2 = expr _3 = RPAREN
    {                         ( _2 )}
| _1 = attr_name
    {                ( Column _1 )}
| _1 = VALUES _2 = LPAREN n = IDENT _4 = RPAREN
    {                                   ( Inserted n )}
| v = literal_value
    {                                         ( v )}
| v = datetime_value
    {                                         ( v )}
| e1 = expr _2 = mnot_IN_ _1 = LPAREN l = separated_nonempty_list_COMMA_expr_ _2_inlined1 = RPAREN
    {let l =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
                                        ( poly Bool (e1::l) )}
| e1 = expr _2 = mnot_IN_ _3 = LPAREN select = select_stmt _5 = RPAREN
    {      (
        Fun ((Poly Bool),[e1; Select (select, true)])
      )}
| e1 = expr _2 = IN table = IDENT
    {                             ( Tables.check table; e1 )}
| _1 = LPAREN select = select_stmt _3 = RPAREN
    {                                       ( Select (select, true) )}
| _1 = PARAM
    {            ( Param (_1,Any) )}
| f = IDENT _2 = LPAREN p = func_params _4 = RPAREN
    {                                          ( Fun (Function.lookup f (List.length p), p) )}
| _1 = expr _2 = IS _3 = option_NOT_ _4 = NULL
    {                        ( Fun (Ret Bool, [_1]) )}
| e1 = expr _2 = IS _3 = option_NOT_ _4 = option_distinct_from_ e2 = expr
    {                                             ( poly Bool [e1;e2] )}
| _1 = expr _2 = mnot_BETWEEN_ _3 = expr _4 = AND _5 = expr
    {                                       ( poly Bool [_1;_3;_5] )}
| _1 = mnot_EXISTS_ _2 = LPAREN select = select_stmt _4 = RPAREN
    {                                                    ( Fun ((Ret Bool),[Select (select,false)]) )}
| _1 = CASE e1 = option_expr_ branches = nonempty_list_case_branch_ e2 = option_preceded_ELSE_expr__ _5 = END
    {      (
        let maybe f = function None -> [] | Some x -> [f x] in
        let t_args =
          match e1 with
          | None -> (List.flatten @@ List.map (fun _ -> [Typ Bool; Var 1]) branches)
          | Some _ -> [Var 0] @ (List.flatten @@ List.map (fun _ -> [Var 0; Var 1]) branches)
        in
        let t_args = t_args @ maybe (fun _ -> Var 1) e2 in
        let v_args = maybe Prelude.identity e1 @ List.flatten branches @ maybe Prelude.identity e2 in
        Fun (F (Var 1, t_args), v_args)
      )}
| _1 = IF _2 = LPAREN e1 = expr _4 = COMMA e2 = expr _6 = COMMA e3 = expr _8 = RPAREN
    {                                                           ( Fun (F (Var 0, [Typ Bool;Var 0;Var 0]), [e1;e2;e3]) )}

case_branch:
  _1 = WHEN e1 = expr _3 = THEN e2 = expr
    {                                       ( [e1;e2] )}

like:
  _1 = LIKE
    {                     ( )}
| _1 = LIKE_OP
    {                     ( )}

datetime_value:
  _1 = DATETIME_FUNC
    {                                                                       ( Value Datetime )}
| _1 = DATETIME_FUNC _2 = LPAREN _3 = option_INTEGER_ _4 = RPAREN
    {                                                                       ( Value Datetime )}

literal_value:
  _1 = TEXT
    {           ( Value Text )}
| _1 = BLOB
    {           ( Value Blob )}
| _1 = INTEGER
    {              ( Value Int )}
| _1 = FLOAT
    {            ( Value Float )}
| _1 = TRUE
    {            ( Value Bool )}
| _1 = FALSE
    {            ( Value Bool )}
| _1 = DATE _2 = TEXT
    {                     ( Value Datetime )}
| _1 = TIME _2 = TEXT
    {                     ( Value Datetime )}
| _1 = TIMESTAMP _2 = TEXT
    {                     ( Value Datetime )}
| _1 = NULL
    {           ( Value Any )}

single_literal_value:
  _1 = literal_value
    {                    ( _1 )}
| _1 = MINUS _2 = INTEGER
    {                    ( Value Int )}
| _1 = MINUS _2 = FLOAT
    {                  ( Value Float )}

expr_list:
  l = separated_nonempty_list_COMMA_expr_
    {let l =                                                       ( l ) in
                          ( l )}

func_params:
  _1 = option_DISTINCT_ l = expr_list
    {                                   ( l )}
| _1 = ASTERISK
    {                      ( [] )}
| 
    {                   ( [] )}

escape:
  _1 = ESCAPE _2 = expr
    {                    ( _2 )}

numeric_bin_op:
  _1 = PLUS
    {                                                                  ( )}
| _1 = MINUS
    {                                                                  ( )}
| _1 = ASTERISK
    {                                                                  ( )}
| _1 = NUM_DIV_OP
    {                                                                  ( )}
| _1 = NUM_BIT_OP
    {                                                                  ( )}

comparison_op:
  _1 = EQUAL
    {                                                                ( )}
| _1 = NUM_CMP_OP
    {                                                                ( )}
| _1 = NUM_EQ_OP
    {                                                                ( )}
| _1 = NOT_DISTINCT_OP
    {                                                                ( )}

boolean_bin_op:
  _1 = AND
    {                         ( )}
| _1 = OR
    {                         ( )}

unary_op:
  _1 = EXCL
    {               ( )}
| _1 = TILDE
    {                ( )}
| _1 = NOT
    {              ( )}

interval_unit:
  _1 = MICROSECOND
    {                          ( )}
| _1 = SECOND
    {                          ( )}
| _1 = MINUTE
    {                          ( )}
| _1 = HOUR
    {                          ( )}
| _1 = DAY
    {                          ( )}
| _1 = WEEK
    {                          ( )}
| _1 = MONTH
    {                          ( )}
| _1 = QUARTER
    {                          ( )}
| _1 = YEAR
    {                          ( )}
| _1 = SECOND_MICROSECOND
    {                          ( )}
| _1 = MINUTE_MICROSECOND
    {                          ( )}
| _1 = MINUTE_SECOND
    {                          ( )}
| _1 = HOUR_MICROSECOND
    {                          ( )}
| _1 = HOUR_SECOND
    {                          ( )}
| _1 = HOUR_MINUTE
    {                          ( )}
| _1 = DAY_MICROSECOND
    {                          ( )}
| _1 = DAY_SECOND
    {                          ( )}
| _1 = DAY_MINUTE
    {                          ( )}
| _1 = DAY_HOUR
    {                          ( )}
| _1 = YEAR_MONTH
    {                          ( )}

sql_type_flavor:
  _1 = T_INTEGER _2 = option_UNSIGNED_ _3 = option_ZEROFILL_
    {                                               ( Int )}
| _1 = binary
    {                        ( Blob )}
| _1 = option_NATIONAL_ _2 = text _3 = option_VARYING_ _4 = option_charset_ _5 = option_collate_
    {                                                           ( Text )}
| _1 = ENUM _1_inlined1 = LPAREN l = separated_nonempty_list_COMMA_TEXT_ _2 = RPAREN _3 = option_charset_ _4 = option_collate_
    {let _2 =
  let l =
    let l =                                                       ( l ) in
                                             ( l )
  in
                                             ( l )
in
                                                       ( Text )}
| _1 = T_FLOAT _2 = option_PRECISION_
    {                                    ( Float )}
| _1 = T_BOOLEAN
    {                           ( Bool )}
| _1 = T_DATETIME
    {                                                             ( Datetime )}
| _1 = YEAR
    {                                                             ( Datetime )}
| _1 = DATE
    {                                                             ( Datetime )}
| _1 = TIME
    {                                                             ( Datetime )}
| _1 = TIMESTAMP
    {                                                             ( Datetime )}
| _1 = T_UUID
    {                        ( Blob )}

binary:
  _1 = T_BLOB
    {                                         ( )}
| _1 = BINARY
    {                                         ( )}
| _1 = BINARY _2 = VARYING
    {                                         ( )}

text:
  _1 = T_TEXT
    {                                                        ( )}
| _1 = T_TEXT _2 = LPAREN _3 = INTEGER _4 = RPAREN
    {                                                        ( )}
| _1 = CHARACTER
    {                                                        ( )}

charset:
  _1 = CHARSET _1_inlined1 = IDENT
    {let _2 =                            ( ) in
                                                                                             ( )}
| _1 = CHARSET _1_inlined1 = BINARY
    {let _2 =                            ( ) in
                                                                                             ( )}
| _1 = CHARACTER _2 = SET _1_inlined1 = IDENT
    {let _3 =                            ( ) in
                                                                                             ( )}
| _1 = CHARACTER _2 = SET _1_inlined1 = BINARY
    {let _3 =                            ( ) in
                                                                                             ( )}
| _1 = ASCII
    {                                                                                             ( )}
| _1 = UNICODE
    {                                                                                             ( )}

collate:
  _1 = COLLATE _2 = IDENT
    {                       ( )}

sql_type:
  t = sql_type_flavor
    {        ( t )}
| t = sql_type_flavor _2 = LPAREN _3 = INTEGER _4 = RPAREN _5 = option_UNSIGNED_
    {        ( t )}
| t = sql_type_flavor _2 = LPAREN _3 = INTEGER _4 = COMMA _5 = INTEGER _6 = RPAREN
    {        ( t )}

compound_op:
  _1 = UNION _2 = option_ALL_
    {                                             ( )}
| _1 = EXCEPT
    {                                             ( )}
| _1 = INTERSECT
    {                                             ( )}

maybe_join_type:
  _1 = option_JOIN_TYPE1_ _2 = option_JOIN_TYPE2_
    {                                         ( )}

%%


