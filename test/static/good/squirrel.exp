Grammar has 83 nonterminal symbols, among which 4 start symbols.
Grammar has 105 terminal symbols.
Grammar has 268 productions.
nullable(undo) = false
nullable(top_process) = false
nullable(top_formula) = false
nullable(tm_list) = true
nullable(term_list1) = false
nullable(term_list) = true
nullable(term_i) = false
nullable(term) = false
nullable(tactic_params) = true
nullable(tactic_param) = false
nullable(tactic) = false
nullable(tac_formula) = false
nullable(tac_errors) = true
nullable(tac) = false
nullable(system) = true
nullable(sterm_i) = false
nullable(sterm) = false
nullable(single_system) = false
nullable(simpl_pat) = false
nullable(set_option) = false
nullable(separated_nonempty_list(empty,sterm)) = false
nullable(separated_nonempty_list(empty,simpl_pat)) = false
nullable(separated_nonempty_list(empty,rw_arg)) = false
nullable(separated_nonempty_list(empty,lsymb)) = false
nullable(separated_nonempty_list(empty,intro_pat)) = false
nullable(separated_nonempty_list(PARALLEL,simpl_pat)) = false
nullable(separated_nonempty_list(PARALLEL,sel_tac)) = false
nullable(separated_nonempty_list(COMMA,term)) = false
nullable(separated_nonempty_list(COMMA,lsymb)) = false
nullable(separated_nonempty_list(COMMA,int)) = false
nullable(sep) = true
nullable(selector) = false
nullable(sel_tacs) = false
nullable(s_item) = false
nullable(rw_type) = false
nullable(rw_mult) = true
nullable(rw_item) = false
nullable(rw_in) = true
nullable(rw_dir) = true
nullable(rw_args) = false
nullable(rw_arg) = false
nullable(qed) = false
nullable(processes_i) = false
nullable(process_i) = false
nullable(process_cont) = true
nullable(process) = false
nullable(option_param) = false
nullable(option(as_ip)) = true
nullable(opt_arg_list) = true
nullable(naming_pat) = false
nullable(name_type) = false
nullable(msg_type) = false
nullable(msg_or_bool) = false
nullable(lsymb) = false
nullable(loption(separated_nonempty_list(empty,simpl_pat))) = true
nullable(loption(separated_nonempty_list(PARALLEL,simpl_pat))) = true
nullable(kind) = false
nullable(intro_pat_list) = false
nullable(intro_pat) = false
nullable(interactive) = false
nullable(int) = false
nullable(indices) = false
nullable(index_arity) = true
nullable(ids) = false
nullable(help_tac_i) = false
nullable(help_tac) = false
nullable(goal_i) = false
nullable(goal) = false
nullable(gname) = false
nullable(equiv_form) = false
nullable(equiv) = false
nullable(else_process) = true
nullable(declarations) = false
nullable(declaration_list) = false
nullable(declaration_i) = false
nullable(declaration) = false
nullable(bsystem) = true
nullable(as_ip) = false
nullable(args) = true
nullable(arg_list) = true
nullable(and_or_pat) = false
nullable(abs_type) = false
nullable(abort) = false
first(undo) = UNDO
first(top_process) = OUT NULL NEW LPAREN LET IN IF ID FIND BANG
first(top_formula) = TRUE SEQ PRED NOT LPAREN LANGLE INIT IF ID HAPPENS FORALL FIND FALSE EXISTS DIFF
first(tm_list) = COMMA
first(term_list1) = LPAREN
first(term_list) = LPAREN
first(term_i) = TRUE SEQ PRED NOT LPAREN LANGLE INIT IF ID HAPPENS FORALL FIND FALSE EXISTS DIFF
first(term) = TRUE SEQ PRED NOT LPAREN LANGLE INIT IF ID HAPPENS FORALL FIND FALSE EXISTS DIFF
first(tactic_params) = TRUE SEQ PRED NOT LPAREN LANGLE INT INIT IF ID HAPPENS FORALL FIND FALSE EXISTS DIFF
first(tactic_param) = TRUE SEQ PRED NOT LPAREN LANGLE INT INIT IF ID HAPPENS FORALL FIND FALSE EXISTS DIFF
first(tactic) = USE TRY RIGHT REWRITE REVERT REPEAT NOSIMPL LPAREN LEFT INTRO ID HELP GENERALIZE EXISTS DESTRUCT DEPENDS DDH CYCLE CLEAR CHECKFAIL BY ASSERT
first(tac_formula) = TRUE SEQ PRED NOT LPAREN LANGLE INIT IF ID HAPPENS FORALL FIND FALSE EXISTS DIFF
first(tac_errors) = ID
first(tac) = USE TRY RIGHT REWRITE REVERT REPEAT NOSIMPL LPAREN LEFT INTRO ID HELP GENERALIZE EXISTS DESTRUCT DEPENDS DDH CYCLE CLEAR CHECKFAIL BY ASSERT
first(system) = LBRACKET
first(sterm_i) = TRUE SEQ PRED NOT LPAREN LANGLE INIT ID HAPPENS FALSE DIFF
first(sterm) = TRUE SEQ PRED NOT LPAREN LANGLE INIT ID HAPPENS FALSE DIFF
first(single_system) = LBRACKET
first(simpl_pat) = UNDERSCORE QMARK LBRACKET ID
first(set_option) = SET
first(separated_nonempty_list(empty,sterm)) = TRUE SEQ PRED NOT LPAREN LANGLE INIT ID HAPPENS FALSE DIFF
first(separated_nonempty_list(empty,simpl_pat)) = UNDERSCORE QMARK LBRACKET ID
first(separated_nonempty_list(empty,rw_arg)) = TRUE SLASHSLASH SLASHEQUAL SLASH SEQ QMARK PRED NOT MINUS LPAREN LANGLE INIT ID HAPPENS FALSE DIFF BANGU
first(separated_nonempty_list(empty,lsymb)) = ID
first(separated_nonempty_list(empty,intro_pat)) = UNDERSCORE STAR SLASHSLASH SLASHEQUAL QMARK LBRACKET ID
first(separated_nonempty_list(PARALLEL,simpl_pat)) = UNDERSCORE QMARK LBRACKET ID
first(separated_nonempty_list(PARALLEL,sel_tac)) = INT
first(separated_nonempty_list(COMMA,term)) = TRUE SEQ PRED NOT LPAREN LANGLE INIT IF ID HAPPENS FORALL FIND FALSE EXISTS DIFF
first(separated_nonempty_list(COMMA,lsymb)) = ID
first(separated_nonempty_list(COMMA,int)) = INT
first(sep) = COMMA
first(selector) = INT
first(sel_tacs) = INT
first(s_item) = SLASHSLASH SLASHEQUAL
first(rw_type) = TRUE SLASH SEQ PRED NOT LPAREN LANGLE INIT ID HAPPENS FALSE DIFF
first(rw_mult) = QMARK BANGU
first(rw_item) = TRUE SLASH SEQ QMARK PRED NOT MINUS LPAREN LANGLE INIT ID HAPPENS FALSE DIFF BANGU
first(rw_in) = IN
first(rw_dir) = MINUS
first(rw_args) = TRUE SLASHSLASH SLASHEQUAL SLASH SEQ QMARK PRED NOT MINUS LPAREN LANGLE INIT ID HAPPENS FALSE DIFF BANGU
first(rw_arg) = TRUE SLASHSLASH SLASHEQUAL SLASH SEQ QMARK PRED NOT MINUS LPAREN LANGLE INIT ID HAPPENS FALSE DIFF BANGU
first(qed) = QED
first(processes_i) = OUT NULL NEW LPAREN LET IN IF ID FIND BANG
first(process_i) = OUT NULL NEW LPAREN LET IN IF ID FIND BANG
first(process_cont) = SEMICOLON
first(process) = OUT NULL NEW LPAREN LET IN IF ID FIND BANG
first(option_param) = TRUE INT ID FALSE
first(option(as_ip)) = AS
first(opt_arg_list) = LPAREN
first(naming_pat) = UNDERSCORE QMARK ID
first(name_type) = MESSAGE INDEX
first(msg_type) = MESSAGE
first(msg_or_bool) = MESSAGE BOOLEAN
first(lsymb) = ID
first(loption(separated_nonempty_list(empty,simpl_pat))) = UNDERSCORE QMARK LBRACKET ID
first(loption(separated_nonempty_list(PARALLEL,simpl_pat))) = UNDERSCORE QMARK LBRACKET ID
first(kind) = TIMESTAMP MESSAGE INDEX BOOLEAN
first(intro_pat_list) = UNDERSCORE STAR SLASHSLASH SLASHEQUAL QMARK LBRACKET ID
first(intro_pat) = UNDERSCORE STAR SLASHSLASH SLASHEQUAL QMARK LBRACKET ID
first(interactive) = USE UNDO TRY TERM SYSTEM SIGNATURE SET SENC RIGHT REWRITE REVERT REPEAT QED PROOF PROCESS NOSIMPL NAME MUTABLE LPAREN LEFT INTRO ID HELP HASH GOAL GENERALIZE EXISTS EQUIV EOF DESTRUCT DEPENDS DDH CYCLE CLEAR CHECKFAIL CHANNEL BY AXIOM ASSERT AENC ABSTRACT ABORT
first(int) = INT
first(indices) = ID
first(index_arity) = LPAREN
first(ids) = ID
first(help_tac_i) = USE RIGHT REWRITE REVERT LEFT INTRO GENERALIZE EXISTS DESTRUCT DEPENDS DDH ASSERT
first(help_tac) = USE RIGHT REWRITE REVERT LEFT INTRO GENERALIZE EXISTS DESTRUCT DEPENDS DDH ASSERT
first(goal_i) = PROOF GOAL EQUIV
first(goal) = PROOF GOAL EQUIV
first(gname) = UNDERSCORE ID
first(equiv_form) = TRUE SEQ PRED NOT LPAREN LBRACKET LANGLE INIT IF ID HAPPENS FORALL FIND FALSE EXISTS DIFF
first(equiv) = TRUE SEQ PRED NOT LPAREN LANGLE INIT IF ID HAPPENS FORALL FIND FALSE EXISTS DIFF
first(else_process) = ELSE
first(declarations) = TERM SYSTEM SIGNATURE SENC PROCESS NAME MUTABLE HASH CHANNEL AXIOM AENC ABSTRACT
first(declaration_list) = TERM SYSTEM SIGNATURE SENC PROCESS NAME MUTABLE HASH CHANNEL AXIOM AENC ABSTRACT
first(declaration_i) = TERM SYSTEM SIGNATURE SENC PROCESS NAME MUTABLE HASH CHANNEL AXIOM AENC ABSTRACT
first(declaration) = TERM SYSTEM SIGNATURE SENC PROCESS NAME MUTABLE HASH CHANNEL AXIOM AENC ABSTRACT
first(bsystem) = LBRACKET
first(as_ip) = AS
first(args) = LPAREN
first(arg_list) = ID
first(and_or_pat) = LBRACKET
first(abs_type) = MESSAGE INDEX
first(abort) = ABORT
minimal(undo) = (* 3 *) UNDO INT DOT
minimal(top_process) = (* 2 *) NULL EOF
minimal(top_formula) = (* 2 *) ID EOF
minimal(tm_list) = (* 0 *)
minimal(term_list1) = (* 3 *) LPAREN ID RPAREN
minimal(term_list) = (* 0 *)
minimal(term_i) = (* 1 *) ID
minimal(term) = (* 1 *) ID
minimal(tactic_params) = (* 0 *)
minimal(tactic_param) = (* 1 *) ID
minimal(tactic) = (* 2 *) ID DOT
minimal(tac_formula) = (* 1 *) ID
minimal(tac_errors) = (* 0 *)
minimal(tac) = (* 1 *) ID
minimal(system) = (* 0 *)
minimal(sterm_i) = (* 1 *) ID
minimal(sterm) = (* 1 *) ID
minimal(single_system) = (* 3 *) LBRACKET LEFT RBRACKET
minimal(simpl_pat) = (* 1 *) UNDERSCORE
minimal(set_option) = (* 5 *) SET ID EQ TRUE DOT
minimal(separated_nonempty_list(empty,sterm)) = (* 1 *) ID
minimal(separated_nonempty_list(empty,simpl_pat)) = (* 1 *) UNDERSCORE
minimal(separated_nonempty_list(empty,rw_arg)) = (* 1 *) ID
minimal(separated_nonempty_list(empty,lsymb)) = (* 1 *) ID
minimal(separated_nonempty_list(empty,intro_pat)) = (* 1 *) SLASHSLASH
minimal(separated_nonempty_list(PARALLEL,simpl_pat)) = (* 1 *) UNDERSCORE
minimal(separated_nonempty_list(PARALLEL,sel_tac)) = (* 3 *) INT COLON ID
minimal(separated_nonempty_list(COMMA,term)) = (* 1 *) ID
minimal(separated_nonempty_list(COMMA,lsymb)) = (* 1 *) ID
minimal(separated_nonempty_list(COMMA,int)) = (* 1 *) INT
minimal(sep) = (* 0 *)
minimal(selector) = (* 1 *) INT
minimal(sel_tacs) = (* 3 *) INT COLON ID
minimal(s_item) = (* 1 *) SLASHSLASH
minimal(rw_type) = (* 1 *) ID
minimal(rw_mult) = (* 0 *)
minimal(rw_item) = (* 1 *) ID
minimal(rw_in) = (* 0 *)
minimal(rw_dir) = (* 0 *)
minimal(rw_args) = (* 1 *) ID
minimal(rw_arg) = (* 1 *) ID
minimal(qed) = (* 1 *) QED
minimal(processes_i) = (* 1 *) NULL
minimal(process_i) = (* 1 *) NULL
minimal(process_cont) = (* 0 *)
minimal(process) = (* 1 *) NULL
minimal(option_param) = (* 1 *) TRUE
minimal(option(as_ip)) = (* 0 *)
minimal(opt_arg_list) = (* 0 *)
minimal(naming_pat) = (* 1 *) UNDERSCORE
minimal(name_type) = (* 1 *) MESSAGE
minimal(msg_type) = (* 1 *) MESSAGE
minimal(msg_or_bool) = (* 1 *) MESSAGE
minimal(lsymb) = (* 1 *) ID
minimal(loption(separated_nonempty_list(empty,simpl_pat))) = (* 0 *)
minimal(loption(separated_nonempty_list(PARALLEL,simpl_pat))) = (* 0 *)
minimal(kind) = (* 1 *) INDEX
minimal(intro_pat_list) = (* 1 *) SLASHSLASH
minimal(intro_pat) = (* 1 *) SLASHSLASH
minimal(interactive) = (* 1 *) QED
minimal(int) = (* 1 *) INT
minimal(indices) = (* 1 *) ID
minimal(index_arity) = (* 0 *)
minimal(ids) = (* 1 *) ID
minimal(help_tac_i) = (* 1 *) LEFT
minimal(help_tac) = (* 1 *) LEFT
minimal(goal_i) = (* 1 *) PROOF
minimal(goal) = (* 1 *) PROOF
minimal(gname) = (* 1 *) ID
minimal(equiv_form) = (* 1 *) ID
minimal(equiv) = (* 1 *) ID
minimal(else_process) = (* 0 *)
minimal(declarations) = (* 3 *) HASH ID DOT
minimal(declaration_list) = (* 2 *) HASH ID
minimal(declaration_i) = (* 2 *) HASH ID
minimal(declaration) = (* 2 *) HASH ID
minimal(bsystem) = (* 0 *)
minimal(as_ip) = (* 2 *) AS UNDERSCORE
minimal(args) = (* 0 *)
minimal(arg_list) = (* 0 *)
minimal(and_or_pat) = (* 2 *) LBRACKET RBRACKET
minimal(abs_type) = (* 1 *) MESSAGE
minimal(abort) = (* 1 *) ABORT
maximal(undo) = 3
maximal(top_process) = infinity
maximal(top_formula) = infinity
maximal(tm_list) = infinity
maximal(term_list1) = infinity
maximal(term_list) = infinity
maximal(term_i) = infinity
maximal(term) = infinity
maximal(tactic_params) = infinity
maximal(tactic_param) = infinity
maximal(tactic) = infinity
maximal(tac_formula) = infinity
maximal(tac_errors) = infinity
maximal(tac) = infinity
maximal(system) = 5
maximal(sterm_i) = infinity
maximal(sterm) = infinity
maximal(single_system) = 5
maximal(simpl_pat) = infinity
maximal(set_option) = 5
maximal(separated_nonempty_list(empty,sterm)) = infinity
maximal(separated_nonempty_list(empty,simpl_pat)) = infinity
maximal(separated_nonempty_list(empty,rw_arg)) = infinity
maximal(separated_nonempty_list(empty,lsymb)) = infinity
maximal(separated_nonempty_list(empty,intro_pat)) = infinity
maximal(separated_nonempty_list(PARALLEL,simpl_pat)) = infinity
maximal(separated_nonempty_list(PARALLEL,sel_tac)) = infinity
maximal(separated_nonempty_list(COMMA,term)) = infinity
maximal(separated_nonempty_list(COMMA,lsymb)) = infinity
maximal(separated_nonempty_list(COMMA,int)) = infinity
maximal(sep) = 1
maximal(selector) = infinity
maximal(sel_tacs) = infinity
maximal(s_item) = 1
maximal(rw_type) = infinity
maximal(rw_mult) = 1
maximal(rw_item) = infinity
maximal(rw_in) = infinity
maximal(rw_dir) = 1
maximal(rw_args) = infinity
maximal(rw_arg) = infinity
maximal(qed) = 1
maximal(processes_i) = infinity
maximal(process_i) = infinity
maximal(process_cont) = infinity
maximal(process) = infinity
maximal(option_param) = 1
maximal(option(as_ip)) = infinity
maximal(opt_arg_list) = infinity
maximal(naming_pat) = 1
maximal(name_type) = infinity
maximal(msg_type) = infinity
maximal(msg_or_bool) = 1
maximal(lsymb) = 1
maximal(loption(separated_nonempty_list(empty,simpl_pat))) = infinity
maximal(loption(separated_nonempty_list(PARALLEL,simpl_pat))) = infinity
maximal(kind) = 1
maximal(intro_pat_list) = infinity
maximal(intro_pat) = infinity
maximal(interactive) = infinity
maximal(int) = 1
maximal(indices) = infinity
maximal(index_arity) = 3
maximal(ids) = infinity
maximal(help_tac_i) = 1
maximal(help_tac) = 1
maximal(goal_i) = infinity
maximal(goal) = infinity
maximal(gname) = 1
maximal(equiv_form) = infinity
maximal(equiv) = infinity
maximal(else_process) = infinity
maximal(declarations) = infinity
maximal(declaration_list) = infinity
maximal(declaration_i) = infinity
maximal(declaration) = infinity
maximal(bsystem) = 3
maximal(as_ip) = infinity
maximal(args) = infinity
maximal(arg_list) = infinity
maximal(and_or_pat) = infinity
maximal(abs_type) = infinity
maximal(abort) = 1
follow(undo) = #
follow(top_process) = #
follow(top_formula) = #
follow(tm_list) = RPAREN
follow(term_list1) = XOR THEN TERM SYSTEM SIGNATURE SENC SEMICOLON RPAREN RBRACKET RANGLE PROCESS PLUS PARALLEL OR NEQ NAME MUTABLE LEQ LANGLE IN HASH GEQ EXP EXN EQ EOF ELSE DOT DEQUIVARROW DARROW COMMA CHANNEL BY AXIOM AT AS ARROW AND AENC ABSTRACT
follow(term_list) = TERM SYSTEM SIGNATURE SENC RPAREN PROCESS PARALLEL NAME MUTABLE HASH EOF ELSE DOT CHANNEL AXIOM ASSIGN AENC ABSTRACT
follow(term_i) = XOR THEN TERM SYSTEM SIGNATURE SENC SEMICOLON RPAREN RBRACKET RANGLE PROCESS PLUS PARALLEL OR NEQ NAME MUTABLE LEQ LANGLE IN HASH GEQ EXP EXN EQ EOF ELSE DOT DEQUIVARROW DARROW COMMA CHANNEL BY AXIOM AS ARROW AND AENC ABSTRACT
follow(term) = XOR THEN TERM SYSTEM SIGNATURE SENC SEMICOLON RPAREN RBRACKET RANGLE PROCESS PLUS PARALLEL OR NEQ NAME MUTABLE LEQ LANGLE IN HASH GEQ EXP EXN EQ EOF ELSE DOT DEQUIVARROW DARROW COMMA CHANNEL BY AXIOM AS ARROW AND AENC ABSTRACT
follow(tactic_params) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW BY AS
follow(tactic_param) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW COMMA BY AS
follow(tactic) = #
follow(tac_formula) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW AS
follow(tac_errors) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW
follow(tac) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW
follow(system) = UNDERSCORE ID
follow(sterm_i) = XOR TRUE THEN TERM SYSTEM SLASHSLASH SLASHEQUAL SLASH SIGNATURE SEQ SENC SEMICOLON RPAREN RBRACKET RANGLE QMARK PROCESS PRED PLUS PARALLEL OR NOT NEQ NAME MUTABLE MINUS LPAREN LEQ LANGLE INIT IN ID HASH HAPPENS GEQ FALSE EXP EXN EQ EOF ELSE DOT DIFF DEQUIVARROW DARROW COMMA CHANNEL BY BANGU AXIOM AS ARROW AND AENC ABSTRACT
follow(sterm) = XOR TRUE THEN TERM SYSTEM SLASHSLASH SLASHEQUAL SLASH SIGNATURE SEQ SENC SEMICOLON RPAREN RBRACKET RANGLE QMARK PROCESS PRED PLUS PARALLEL OR NOT NEQ NAME MUTABLE MINUS LPAREN LEQ LANGLE INIT IN ID HASH HAPPENS GEQ FALSE EXP EXN EQ EOF ELSE DOT DIFF DEQUIVARROW DARROW COMMA CHANNEL BY BANGU AXIOM AS ARROW AND AENC ABSTRACT
follow(single_system) = UNDERSCORE LBRACKET ID
follow(simpl_pat) = UNDERSCORE STAR SLASHSLASH SLASHEQUAL SEMICOLON RPAREN RBRACKET QMARK PLUS PARALLEL LBRACKET ID EXN DOT DARROW
follow(set_option) = #
follow(separated_nonempty_list(empty,sterm)) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW
follow(separated_nonempty_list(empty,simpl_pat)) = RBRACKET
follow(separated_nonempty_list(empty,rw_arg)) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL IN EXN DOT DARROW
follow(separated_nonempty_list(empty,lsymb)) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW
follow(separated_nonempty_list(empty,intro_pat)) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW
follow(separated_nonempty_list(PARALLEL,simpl_pat)) = RBRACKET
follow(separated_nonempty_list(PARALLEL,sel_tac)) = RBRACKET
follow(separated_nonempty_list(COMMA,term)) = RPAREN
follow(separated_nonempty_list(COMMA,lsymb)) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW
follow(separated_nonempty_list(COMMA,int)) = COLON
follow(sep) = TRUE SEQ PRED NOT LPAREN LANGLE INIT IF ID HAPPENS FORALL FIND FALSE EXISTS DIFF
follow(selector) = COLON
follow(sel_tacs) = RBRACKET
follow(s_item) = UNDERSCORE TRUE STAR SLASHSLASH SLASHEQUAL SLASH SEQ SEMICOLON RPAREN RBRACKET QMARK PRED PLUS PARALLEL NOT MINUS LPAREN LBRACKET LANGLE INIT IN ID HAPPENS FALSE EXN DOT DIFF DARROW BANGU
follow(rw_type) = TRUE SLASHSLASH SLASHEQUAL SLASH SEQ SEMICOLON RPAREN RBRACKET QMARK PRED PLUS PARALLEL NOT MINUS LPAREN LANGLE INIT IN ID HAPPENS FALSE EXN DOT DIFF DARROW BANGU
follow(rw_mult) = TRUE SLASH SEQ PRED NOT MINUS LPAREN LANGLE INIT ID HAPPENS FALSE DIFF
follow(rw_item) = TRUE SLASHSLASH SLASHEQUAL SLASH SEQ SEMICOLON RPAREN RBRACKET QMARK PRED PLUS PARALLEL NOT MINUS LPAREN LANGLE INIT IN ID HAPPENS FALSE EXN DOT DIFF DARROW BANGU
follow(rw_in) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW
follow(rw_dir) = TRUE SLASH SEQ PRED NOT LPAREN LANGLE INIT ID HAPPENS FALSE DIFF
follow(rw_args) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL IN EXN DOT DARROW
follow(rw_arg) = TRUE SLASHSLASH SLASHEQUAL SLASH SEQ SEMICOLON RPAREN RBRACKET QMARK PRED PLUS PARALLEL NOT MINUS LPAREN LANGLE INIT IN ID HAPPENS FALSE EXN DOT DIFF DARROW BANGU
follow(qed) = #
follow(processes_i) = RPAREN
follow(process_i) = TERM SYSTEM SIGNATURE SENC RPAREN PROCESS PARALLEL NAME MUTABLE HASH EOF ELSE DOT CHANNEL AXIOM AENC ABSTRACT
follow(process_cont) = TERM SYSTEM SIGNATURE SENC RPAREN PROCESS PARALLEL NAME MUTABLE HASH EOF ELSE DOT CHANNEL AXIOM AENC ABSTRACT
follow(process) = TERM SYSTEM SIGNATURE SENC RPAREN PROCESS PARALLEL NAME MUTABLE HASH EOF ELSE DOT CHANNEL AXIOM AENC ABSTRACT
follow(option_param) = DOT
follow(option(as_ip)) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW
follow(opt_arg_list) = EQ COLON
follow(naming_pat) = UNDERSCORE STAR SLASHSLASH SLASHEQUAL SEMICOLON RPAREN RBRACKET QMARK PLUS PARALLEL LBRACKET ID EXN DOT DARROW
follow(name_type) = TERM SYSTEM SIGNATURE SENC PROCESS NAME MUTABLE HASH DOT CHANNEL AXIOM AENC ABSTRACT
follow(msg_type) = TERM SYSTEM SIGNATURE SENC PROCESS NAME MUTABLE HASH DOT CHANNEL AXIOM AENC ABSTRACT
follow(msg_or_bool) = EQ
follow(lsymb) = XOR WITH TRUE THEN TERM SYSTEM SUCHTHAT SLASHSLASH SLASHEQUAL SLASH SIGNATURE SEQ SENC SEMICOLON RPAREN RBRACKET RANGLE QMARK PROCESS PRED PLUS PARALLEL OR NOT NEQ NAME MUTABLE MINUS LPAREN LEQ LANGLE INIT IN ID HASH HAPPENS GEQ FALSE EXP EXN EQ EOF ELSE DOT DIFF DEQUIVARROW DARROW COMMA COLON CHANNEL BY BANGU AXIOM AT ASSIGN AS ARROW AND AENC ABSTRACT
follow(loption(separated_nonempty_list(empty,simpl_pat))) = RBRACKET
follow(loption(separated_nonempty_list(PARALLEL,simpl_pat))) = RBRACKET
follow(kind) = TRUE SEQ RPAREN PRED NOT LPAREN LANGLE INIT IF ID HAPPENS FORALL FIND FALSE EXISTS DIFF COMMA
follow(intro_pat_list) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW
follow(intro_pat) = UNDERSCORE STAR SLASHSLASH SLASHEQUAL SEMICOLON RPAREN RBRACKET QMARK PLUS PARALLEL LBRACKET ID EXN DOT DARROW
follow(interactive) = #
follow(int) = COMMA COLON
follow(indices) = SUCHTHAT
follow(index_arity) = TERM SYSTEM SIGNATURE SENC PROCESS NAME MUTABLE HASH DOT CHANNEL AXIOM AENC ABSTRACT
follow(ids) = COLON ARROW
follow(help_tac_i) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW
follow(help_tac) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW
follow(goal_i) = #
follow(goal) = #
follow(gname) = LPAREN DOT COLON
follow(equiv_form) = DOT ARROW
follow(equiv) = DOT ARROW
follow(else_process) = TERM SYSTEM SIGNATURE SENC RPAREN PROCESS PARALLEL NAME MUTABLE HASH EOF ELSE DOT CHANNEL AXIOM AENC ABSTRACT
follow(declarations) = #
follow(declaration_list) = DOT
follow(declaration_i) = TERM SYSTEM SIGNATURE SENC PROCESS NAME MUTABLE HASH DOT CHANNEL AXIOM AENC ABSTRACT
follow(declaration) = TERM SYSTEM SIGNATURE SENC PROCESS NAME MUTABLE HASH DOT CHANNEL AXIOM AENC ABSTRACT
follow(bsystem) = TRUE SEQ PRED NOT LPAREN LANGLE INIT IF ID HAPPENS FORALL FIND FALSE EXISTS DIFF
follow(as_ip) = SEMICOLON RPAREN RBRACKET PLUS PARALLEL EXN DOT DARROW
follow(args) = COLON
follow(arg_list) = RPAREN
follow(and_or_pat) = UNDERSCORE STAR SLASHSLASH SLASHEQUAL SEMICOLON RPAREN RBRACKET QMARK PLUS PARALLEL LBRACKET ID EXN DOT DARROW
follow(abs_type) = TERM SYSTEM SIGNATURE SENC PROCESS NAME MUTABLE HASH DOT CHANNEL AXIOM AENC ABSTRACT
follow(abort) = #
Built an LR(0) automaton with 548 states.
The grammar is not SLR(1) -- 40 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 548 states.
306 shift/reduce conflicts were silently solved.
194 out of 548 states have a default reduction.
The action table is 58088 entries; 3593 non-zero; 3959 compressed.
The action table occupies roughly 8008 bytes.
The goto table is 47676 entries; 551 non-zero; 1094 compressed.
The goto table occupies roughly 2280 bytes.
The error table occupies roughly 7296 bytes.
The default_reduction table occupies roughly 1128 bytes.
The lhs table occupies roughly 304 bytes.
The trace table occupies roughly 8 bytes.
