State 0:
## Known stack suffix:
##
## LR(1) items:
touist_qbf' -> . touist_qbf [ # ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 217
-- On touist_qbf shift to state 220
-- On prop shift to state 189
-- On nonempty_list(affect_or(formula_qbf)) shift to state 221
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 223
-- On affect_or(formula_qbf) shift to state 226
## Reductions:

State 1:
## Known stack suffix:
## VARTUPLE
## LR(1) items:
var -> VARTUPLE . comma_list(indices) RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND AFFECT ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 114
-- On comma_list(indices) shift to state 123
## Reductions:

State 2:
## Known stack suffix:
## VAR
## LR(1) items:
var -> VAR . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND AFFECT ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND AFFECT ADD
--   reduce production var -> VAR

State 3:
## Known stack suffix:
## UNION_PR
## LR(1) items:
expr -> UNION_PR . expr COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 119
## Reductions:

State 4:
## Known stack suffix:
## TUPLE
## LR(1) items:
prop -> TUPLE . comma_list(indices) RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 114
-- On comma_list(indices) shift to state 117
## Reductions:

State 5:
## Known stack suffix:
## TOINT
## LR(1) items:
expr -> TOINT . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 112
## Reductions:

State 6:
## Known stack suffix:
## TOFLOAT
## LR(1) items:
expr -> TOFLOAT . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 110
## Reductions:

State 7:
## Known stack suffix:
## TERM
## LR(1) items:
prop -> TERM . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production prop -> TERM

State 8:
## Known stack suffix:
## SUBSET_PR
## LR(1) items:
expr -> SUBSET_PR . expr COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 106
## Reductions:

State 9:
## Known stack suffix:
## SUB
## LR(1) items:
expr -> SUB . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 105
## Reductions:

State 10:
## Known stack suffix:
## SQRT
## LR(1) items:
expr -> SQRT . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 103
## Reductions:

State 11:
## Known stack suffix:
## POWERSET
## LR(1) items:
expr -> POWERSET . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 101
## Reductions:

State 12:
## Known stack suffix:
## NOT
## LR(1) items:
expr -> NOT . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 100
## Reductions:

State 13:
## Known stack suffix:
## LPAREN
## LR(1) items:
expr -> LPAREN . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 98
## Reductions:

State 14:
## Known stack suffix:
## LBRACK
## LR(1) items:
expr -> LBRACK . expr RANGE expr RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> LBRACK . RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> LBRACK . comma_list(expr) RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On RBRACK shift to state 15
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 89
-- On comma_list(expr) shift to state 96
## Reductions:

State 15:
## Known stack suffix:
## LBRACK RBRACK
## LR(1) items:
expr -> LBRACK RBRACK . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> LBRACK RBRACK

State 16:
## Known stack suffix:
## INTER_PR
## LR(1) items:
expr -> INTER_PR . expr COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 85
## Reductions:

State 17:
## Known stack suffix:
## INT
## LR(1) items:
expr -> INT . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> INT

State 18:
## Known stack suffix:
## IF
## LR(1) items:
expr -> IF . expr THEN expr ELSE expr END [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 79
## Reductions:

State 19:
## Known stack suffix:
## FLOAT
## LR(1) items:
expr -> FLOAT . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> FLOAT

State 20:
## Known stack suffix:
## EMPTY
## LR(1) items:
expr -> EMPTY . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 77
## Reductions:

State 21:
## Known stack suffix:
## DIFF_PR
## LR(1) items:
expr -> DIFF_PR . expr COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 73
## Reductions:

State 22:
## Known stack suffix:
## CARD
## LR(1) items:
expr -> CARD . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 71
## Reductions:

State 23:
## Known stack suffix:
## BOOL
## LR(1) items:
expr -> BOOL . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> BOOL

State 24:
## Known stack suffix:
## ABS
## LR(1) items:
expr -> ABS . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 27
## Reductions:

State 25:
## Known stack suffix:
## var
## LR(1) items:
expr -> var . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> var

State 26:
## Known stack suffix:
## prop
## LR(1) items:
expr -> prop . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> prop

State 27:
## Known stack suffix:
## ABS expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> ABS expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 66
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 28:
## Known stack suffix:
## expr XOR
## LR(1) items:
expr -> expr XOR . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 29
## Reductions:

State 29:
## Known stack suffix:
## expr XOR expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr XOR expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE OR NOT NEWLINE LPAREN LET INTER INT IMPLIES IF FORALL FLOAT EXISTS EXACT EQUIV EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr -> expr XOR expr

State 30:
## Known stack suffix:
## expr SUB
## LR(1) items:
expr -> expr SUB . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 31
## Reductions:

State 31:
## Known stack suffix:
## expr SUB expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr SUB expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> expr SUB expr

State 32:
## Known stack suffix:
## expr MUL
## LR(1) items:
expr -> expr MUL . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 33
## Reductions:

State 33:
## Known stack suffix:
## expr MUL expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr MUL expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MOD shift to state 34
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> expr MUL expr

State 34:
## Known stack suffix:
## expr MOD
## LR(1) items:
expr -> expr MOD . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 35
## Reductions:

State 35:
## Known stack suffix:
## expr MOD expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr MOD expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> expr MOD expr

State 36:
## Known stack suffix:
## expr DIV
## LR(1) items:
expr -> expr DIV . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 37
## Reductions:

State 37:
## Known stack suffix:
## expr DIV expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr DIV expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MOD shift to state 34
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> expr DIV expr

State 38:
## Known stack suffix:
## expr NOTEQUAL
## LR(1) items:
expr -> expr NOTEQUAL . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 39
## Reductions:

State 39:
## Known stack suffix:
## expr NOTEQUAL expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr NOTEQUAL expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE OR NOT NEWLINE LPAREN LET INTER INT IMPLIES IF FORALL FLOAT EXISTS EXACT EQUIV EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr -> expr NOTEQUAL expr

State 40:
## Known stack suffix:
## expr ADD
## LR(1) items:
expr -> expr ADD . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 41
## Reductions:

State 41:
## Known stack suffix:
## expr ADD expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr ADD expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> expr ADD expr

State 42:
## Known stack suffix:
## expr LT
## LR(1) items:
expr -> expr LT . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 43
## Reductions:

State 43:
## Known stack suffix:
## expr LT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr LT expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE OR NOT NEWLINE LPAREN LET INTER INT IMPLIES IF FORALL FLOAT EXISTS EXACT EQUIV EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr -> expr LT expr

State 44:
## Known stack suffix:
## expr LE
## LR(1) items:
expr -> expr LE . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 45
## Reductions:

State 45:
## Known stack suffix:
## expr LE expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr LE expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE OR NOT NEWLINE LPAREN LET INTER INT IMPLIES IF FORALL FLOAT EXISTS EXACT EQUIV EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr -> expr LE expr

State 46:
## Known stack suffix:
## expr IN
## LR(1) items:
expr -> expr IN . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 47
## Reductions:

State 47:
## Known stack suffix:
## expr IN expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr IN expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE OR NOT NEWLINE LPAREN LET INTER INT IMPLIES IF FORALL FLOAT EXISTS EXACT EQUIV EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr -> expr IN expr

State 48:
## Known stack suffix:
## expr GT
## LR(1) items:
expr -> expr GT . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 49
## Reductions:

State 49:
## Known stack suffix:
## expr GT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr GT expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE OR NOT NEWLINE LPAREN LET INTER INT IMPLIES IF FORALL FLOAT EXISTS EXACT EQUIV EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr -> expr GT expr

State 50:
## Known stack suffix:
## expr GE
## LR(1) items:
expr -> expr GE . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 51
## Reductions:

State 51:
## Known stack suffix:
## expr GE expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr GE expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE OR NOT NEWLINE LPAREN LET INTER INT IMPLIES IF FORALL FLOAT EXISTS EXACT EQUIV EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr -> expr GE expr

State 52:
## Known stack suffix:
## expr EQUAL
## LR(1) items:
expr -> expr EQUAL . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 53
## Reductions:

State 53:
## Known stack suffix:
## expr EQUAL expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr EQUAL expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE OR NOT NEWLINE LPAREN LET INTER INT IMPLIES IF FORALL FLOAT EXISTS EXACT EQUIV EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr -> expr EQUAL expr

State 54:
## Known stack suffix:
## expr UNION
## LR(1) items:
expr -> expr UNION . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 55
## Reductions:

State 55:
## Known stack suffix:
## expr UNION expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr UNION expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM RPAREN RBRACK RANGE NOT NEWLINE LPAREN LET INTER INT IF FORALL FLOAT EXISTS EXACT EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production expr -> expr UNION expr

State 56:
## Known stack suffix:
## expr SUBSET
## LR(1) items:
expr -> expr SUBSET . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 57
## Reductions:

State 57:
## Known stack suffix:
## expr SUBSET expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr SUBSET expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE NOT NEWLINE LPAREN LET INTER INT IF FORALL FLOAT EXISTS EXACT EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production expr -> expr SUBSET expr

State 58:
## Known stack suffix:
## expr OR
## LR(1) items:
expr -> expr OR . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 59
## Reductions:

State 59:
## Known stack suffix:
## expr OR expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr OR expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUB shift to state 30
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE OR NOT NEWLINE LPAREN LET INTER INT IMPLIES IF FORALL FLOAT EXISTS EXACT EQUIV EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production expr -> expr OR expr

State 60:
## Known stack suffix:
## expr AND
## LR(1) items:
expr -> expr AND . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 61
## Reductions:

State 61:
## Known stack suffix:
## expr AND expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr AND expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUB shift to state 30
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE OR NOT NEWLINE LPAREN LET INTER INT IMPLIES IF FORALL FLOAT EXISTS EXACT EQUIV EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr -> expr AND expr

State 62:
## Known stack suffix:
## expr IMPLIES
## LR(1) items:
expr -> expr IMPLIES . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 63
## Reductions:

State 63:
## Known stack suffix:
## expr IMPLIES expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr IMPLIES expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE NOT NEWLINE LPAREN LET INTER INT IF FORALL FLOAT EXISTS EXACT EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production expr -> expr IMPLIES expr

State 64:
## Known stack suffix:
## expr EQUIV
## LR(1) items:
expr -> expr EQUIV . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 65
## Reductions:

State 65:
## Known stack suffix:
## expr EQUIV expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr EQUIV expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE NOT NEWLINE LPAREN LET INTER INT IF FORALL FLOAT EXISTS EXACT EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production expr -> expr EQUIV expr

State 66:
## Known stack suffix:
## ABS expr RPAREN
## LR(1) items:
expr -> ABS expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> ABS expr RPAREN

State 67:
## Known stack suffix:
## expr INTER
## LR(1) items:
expr -> expr INTER . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 68
## Reductions:

State 68:
## Known stack suffix:
## expr INTER expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr INTER expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN VARTUPLE VAR TUPLE TOP THEN TERM RPAREN RBRACK RANGE NOT NEWLINE LPAREN LET INTER INT IF FORALL FLOAT EXISTS EXACT EOF END ELSE COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production expr -> expr INTER expr

State 69:
## Known stack suffix:
## expr DIFF
## LR(1) items:
expr -> expr DIFF . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 70
## Reductions:

State 70:
## Known stack suffix:
## expr DIFF expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr DIFF expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM RPAREN RBRACK RANGE NOT NEWLINE LPAREN LET INTER INT IF FORALL FLOAT EXISTS EXACT EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production expr -> expr DIFF expr

State 71:
## Known stack suffix:
## CARD expr
## LR(1) items:
expr -> CARD expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 72
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 72:
## Known stack suffix:
## CARD expr RPAREN
## LR(1) items:
expr -> CARD expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> CARD expr RPAREN

State 73:
## Known stack suffix:
## DIFF_PR expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> DIFF_PR expr . COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 74
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 74:
## Known stack suffix:
## DIFF_PR expr COMMA
## LR(1) items:
expr -> DIFF_PR expr COMMA . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 75
## Reductions:

State 75:
## Known stack suffix:
## DIFF_PR expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> DIFF_PR expr COMMA expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 76
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 76:
## Known stack suffix:
## DIFF_PR expr COMMA expr RPAREN
## LR(1) items:
expr -> DIFF_PR expr COMMA expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> DIFF_PR expr COMMA expr RPAREN

State 77:
## Known stack suffix:
## EMPTY expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> EMPTY expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 78
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 78:
## Known stack suffix:
## EMPTY expr RPAREN
## LR(1) items:
expr -> EMPTY expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> EMPTY expr RPAREN

State 79:
## Known stack suffix:
## IF expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> IF expr . THEN expr ELSE expr END [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On THEN shift to state 80
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 80:
## Known stack suffix:
## IF expr THEN
## LR(1) items:
expr -> IF expr THEN . expr ELSE expr END [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 81
## Reductions:

State 81:
## Known stack suffix:
## IF expr THEN expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> IF expr THEN expr . ELSE expr END [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On ELSE shift to state 82
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 82:
## Known stack suffix:
## IF expr THEN expr ELSE
## LR(1) items:
expr -> IF expr THEN expr ELSE . expr END [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 83
## Reductions:

State 83:
## Known stack suffix:
## IF expr THEN expr ELSE expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> IF expr THEN expr ELSE expr . END [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On END shift to state 84
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 84:
## Known stack suffix:
## IF expr THEN expr ELSE expr END
## LR(1) items:
expr -> IF expr THEN expr ELSE expr END . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> IF expr THEN expr ELSE expr END

State 85:
## Known stack suffix:
## INTER_PR expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> INTER_PR expr . COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 86
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 86:
## Known stack suffix:
## INTER_PR expr COMMA
## LR(1) items:
expr -> INTER_PR expr COMMA . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 87
## Reductions:

State 87:
## Known stack suffix:
## INTER_PR expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> INTER_PR expr COMMA expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 88
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 88:
## Known stack suffix:
## INTER_PR expr COMMA expr RPAREN
## LR(1) items:
expr -> INTER_PR expr COMMA expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> INTER_PR expr COMMA expr RPAREN

State 89:
## Known stack suffix:
## LBRACK expr
## LR(1) items:
comma_list(expr) -> expr . [ RBRACK ]
comma_list(expr) -> expr . COMMA comma_list(expr) [ RBRACK ]
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> LBRACK expr . RANGE expr RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RANGE shift to state 90
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 93
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On RBRACK
--   reduce production comma_list(expr) -> expr

State 90:
## Known stack suffix:
## LBRACK expr RANGE
## LR(1) items:
expr -> LBRACK expr RANGE . expr RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 91
## Reductions:

State 91:
## Known stack suffix:
## LBRACK expr RANGE expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> LBRACK expr RANGE expr . RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RBRACK shift to state 92
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 92:
## Known stack suffix:
## LBRACK expr RANGE expr RBRACK
## LR(1) items:
expr -> LBRACK expr RANGE expr RBRACK . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> LBRACK expr RANGE expr RBRACK

State 93:
## Known stack suffix:
## expr COMMA
## LR(1) items:
comma_list(expr) -> expr COMMA . comma_list(expr) [ WHEN RBRACK COLON ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 95
## Reductions:

State 94:
## Known stack suffix:
## expr
## LR(1) items:
comma_list(expr) -> expr . [ WHEN RBRACK COLON ]
comma_list(expr) -> expr . COMMA comma_list(expr) [ WHEN RBRACK COLON ]
expr -> expr . ADD expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . SUB expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . MUL expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . DIV expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . MOD expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . AND expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . OR expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . XOR expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . LT expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . LE expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . GT expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . GE expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . IN expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . UNION expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . INTER expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 93
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN RBRACK COLON
--   reduce production comma_list(expr) -> expr

State 95:
## Known stack suffix:
## expr COMMA comma_list(expr)
## LR(1) items:
comma_list(expr) -> expr COMMA comma_list(expr) . [ WHEN RBRACK COLON ]
## Transitions:
## Reductions:
-- On WHEN RBRACK COLON
--   reduce production comma_list(expr) -> expr COMMA comma_list(expr)

State 96:
## Known stack suffix:
## LBRACK comma_list(expr)
## LR(1) items:
expr -> LBRACK comma_list(expr) . RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On RBRACK shift to state 97
## Reductions:

State 97:
## Known stack suffix:
## LBRACK comma_list(expr) RBRACK
## LR(1) items:
expr -> LBRACK comma_list(expr) RBRACK . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> LBRACK comma_list(expr) RBRACK

State 98:
## Known stack suffix:
## LPAREN expr
## LR(1) items:
expr -> LPAREN expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 99
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 99:
## Known stack suffix:
## LPAREN expr RPAREN
## LR(1) items:
expr -> LPAREN expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> LPAREN expr RPAREN

State 100:
## Known stack suffix:
## NOT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> NOT expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET RPAREN RBRACK RANGE OR NOT NEWLINE LPAREN LET INTER INT IMPLIES IF FORALL FLOAT EXISTS EXACT EQUIV EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr -> NOT expr

State 101:
## Known stack suffix:
## POWERSET expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> POWERSET expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 102
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 102:
## Known stack suffix:
## POWERSET expr RPAREN
## LR(1) items:
expr -> POWERSET expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> POWERSET expr RPAREN

State 103:
## Known stack suffix:
## SQRT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> SQRT expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 104
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 104:
## Known stack suffix:
## SQRT expr RPAREN
## LR(1) items:
expr -> SQRT expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> SQRT expr RPAREN

State 105:
## Known stack suffix:
## SUB expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> SUB expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> SUB expr

State 106:
## Known stack suffix:
## SUBSET_PR expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> SUBSET_PR expr . COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 107
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 107:
## Known stack suffix:
## SUBSET_PR expr COMMA
## LR(1) items:
expr -> SUBSET_PR expr COMMA . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 108
## Reductions:

State 108:
## Known stack suffix:
## SUBSET_PR expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> SUBSET_PR expr COMMA expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 109
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 109:
## Known stack suffix:
## SUBSET_PR expr COMMA expr RPAREN
## LR(1) items:
expr -> SUBSET_PR expr COMMA expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> SUBSET_PR expr COMMA expr RPAREN

State 110:
## Known stack suffix:
## TOFLOAT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> TOFLOAT expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 111
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 111:
## Known stack suffix:
## TOFLOAT expr RPAREN
## LR(1) items:
expr -> TOFLOAT expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> TOFLOAT expr RPAREN

State 112:
## Known stack suffix:
## TOINT expr
## LR(1) items:
expr -> TOINT expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 113
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 113:
## Known stack suffix:
## TOINT expr RPAREN
## LR(1) items:
expr -> TOINT expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> TOINT expr RPAREN

State 114:
## Known stack suffix:
## expr
## LR(1) items:
comma_list(indices) -> expr . [ RPAREN ]
comma_list(indices) -> expr . COMMA comma_list(indices) [ RPAREN ]
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 115
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On RPAREN
--   reduce production comma_list(indices) -> expr

State 115:
## Known stack suffix:
## expr COMMA
## LR(1) items:
comma_list(indices) -> expr COMMA . comma_list(indices) [ RPAREN ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 114
-- On comma_list(indices) shift to state 116
## Reductions:

State 116:
## Known stack suffix:
## expr COMMA comma_list(indices)
## LR(1) items:
comma_list(indices) -> expr COMMA comma_list(indices) . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN
--   reduce production comma_list(indices) -> expr COMMA comma_list(indices)

State 117:
## Known stack suffix:
## TUPLE comma_list(indices)
## LR(1) items:
prop -> TUPLE comma_list(indices) . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On RPAREN shift to state 118
## Reductions:

State 118:
## Known stack suffix:
## TUPLE comma_list(indices) RPAREN
## LR(1) items:
prop -> TUPLE comma_list(indices) RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production prop -> TUPLE comma_list(indices) RPAREN

State 119:
## Known stack suffix:
## UNION_PR expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> UNION_PR expr . COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 120
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 120:
## Known stack suffix:
## UNION_PR expr COMMA
## LR(1) items:
expr -> UNION_PR expr COMMA . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 121
## Reductions:

State 121:
## Known stack suffix:
## UNION_PR expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> UNION_PR expr COMMA expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 122
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 122:
## Known stack suffix:
## UNION_PR expr COMMA expr RPAREN
## LR(1) items:
expr -> UNION_PR expr COMMA expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr -> UNION_PR expr COMMA expr RPAREN

State 123:
## Known stack suffix:
## VARTUPLE comma_list(indices)
## LR(1) items:
var -> VARTUPLE comma_list(indices) . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND AFFECT ADD ]
## Transitions:
-- On RPAREN shift to state 124
## Reductions:

State 124:
## Known stack suffix:
## VARTUPLE comma_list(indices) RPAREN
## LR(1) items:
var -> VARTUPLE comma_list(indices) RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND AFFECT ADD ]
## Transitions:
## Reductions:
-- On XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND AFFECT ADD
--   reduce production var -> VARTUPLE comma_list(indices) RPAREN

State 125:
## Known stack suffix:
## TOP
## LR(1) items:
formula_qbf -> TOP . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> TOP

State 126:
## Known stack suffix:
## NOT
## LR(1) items:
formula_qbf -> NOT . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 216
## Reductions:

State 127:
## Known stack suffix:
## NEWLINE
## LR(1) items:
formula_qbf -> NEWLINE . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 215
## Reductions:

State 128:
## Known stack suffix:
## LPAREN
## LR(1) items:
formula_qbf -> LPAREN . formula_qbf RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 213
## Reductions:

State 129:
## Known stack suffix:
## LET
## LR(1) items:
let_affect(expr,formula_qbf) -> LET . comma_list(var) AFFECT comma_list(expr) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 133
## Reductions:

State 130:
## Known stack suffix:
## var
## LR(1) items:
comma_list(var) -> var . [ IN AFFECT ]
comma_list(var) -> var . COMMA comma_list(var) [ IN AFFECT ]
## Transitions:
-- On COMMA shift to state 131
## Reductions:
-- On IN AFFECT
--   reduce production comma_list(var) -> var

State 131:
## Known stack suffix:
## var COMMA
## LR(1) items:
comma_list(var) -> var COMMA . comma_list(var) [ IN AFFECT ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 132
## Reductions:

State 132:
## Known stack suffix:
## var COMMA comma_list(var)
## LR(1) items:
comma_list(var) -> var COMMA comma_list(var) . [ IN AFFECT ]
## Transitions:
## Reductions:
-- On IN AFFECT
--   reduce production comma_list(var) -> var COMMA comma_list(var)

State 133:
## Known stack suffix:
## LET comma_list(var)
## LR(1) items:
let_affect(expr,formula_qbf) -> LET comma_list(var) . AFFECT comma_list(expr) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On AFFECT shift to state 134
## Reductions:

State 134:
## Known stack suffix:
## LET comma_list(var) AFFECT
## LR(1) items:
let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT . comma_list(expr) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 135
## Reductions:

State 135:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr)
## LR(1) items:
let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) . COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 136
## Reductions:

State 136:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr) COLON
## LR(1) items:
let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 212
## Reductions:

State 137:
## Known stack suffix:
## IF
## LR(1) items:
formula_qbf -> IF . expr THEN formula_qbf ELSE formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 138
## Reductions:

State 138:
## Known stack suffix:
## IF expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_qbf -> IF expr . THEN formula_qbf ELSE formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On THEN shift to state 139
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 139:
## Known stack suffix:
## IF expr THEN
## LR(1) items:
formula_qbf -> IF expr THEN . formula_qbf ELSE formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 208
## Reductions:

State 140:
## Known stack suffix:
## FORALL
## LR(1) items:
formula_qbf -> FORALL . comma_list(prop_or_var) option(for_statement) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TERM shift to state 7
-- On var shift to state 141
-- On prop shift to state 143
-- On comma_list(prop_or_var) shift to state 147
## Reductions:

State 141:
## Known stack suffix:
## var
## LR(1) items:
comma_list(prop_or_var) -> var . [ FOR COLON ]
comma_list(prop_or_var) -> var . COMMA comma_list(prop_or_var) [ FOR COLON ]
## Transitions:
-- On COMMA shift to state 142
## Reductions:
-- On FOR COLON
--   reduce production comma_list(prop_or_var) -> var

State 142:
## Known stack suffix:
## var COMMA
## LR(1) items:
comma_list(prop_or_var) -> var COMMA . comma_list(prop_or_var) [ FOR COLON ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TERM shift to state 7
-- On var shift to state 141
-- On prop shift to state 143
-- On comma_list(prop_or_var) shift to state 146
## Reductions:

State 143:
## Known stack suffix:
## prop
## LR(1) items:
comma_list(prop_or_var) -> prop . [ FOR COLON ]
comma_list(prop_or_var) -> prop . COMMA comma_list(prop_or_var) [ FOR COLON ]
## Transitions:
-- On COMMA shift to state 144
## Reductions:
-- On FOR COLON
--   reduce production comma_list(prop_or_var) -> prop

State 144:
## Known stack suffix:
## prop COMMA
## LR(1) items:
comma_list(prop_or_var) -> prop COMMA . comma_list(prop_or_var) [ FOR COLON ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TERM shift to state 7
-- On var shift to state 141
-- On prop shift to state 143
-- On comma_list(prop_or_var) shift to state 145
## Reductions:

State 145:
## Known stack suffix:
## prop COMMA comma_list(prop_or_var)
## LR(1) items:
comma_list(prop_or_var) -> prop COMMA comma_list(prop_or_var) . [ FOR COLON ]
## Transitions:
## Reductions:
-- On FOR COLON
--   reduce production comma_list(prop_or_var) -> prop COMMA comma_list(prop_or_var)

State 146:
## Known stack suffix:
## var COMMA comma_list(prop_or_var)
## LR(1) items:
comma_list(prop_or_var) -> var COMMA comma_list(prop_or_var) . [ FOR COLON ]
## Transitions:
## Reductions:
-- On FOR COLON
--   reduce production comma_list(prop_or_var) -> var COMMA comma_list(prop_or_var)

State 147:
## Known stack suffix:
## FORALL comma_list(prop_or_var)
## LR(1) items:
formula_qbf -> FORALL comma_list(prop_or_var) . option(for_statement) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On FOR shift to state 148
-- On option(for_statement) shift to state 152
## Reductions:
-- On COLON
--   reduce production option(for_statement) ->

State 148:
## Known stack suffix:
## FOR
## LR(1) items:
option(for_statement) -> FOR . var IN expr [ COLON ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 149
## Reductions:

State 149:
## Known stack suffix:
## FOR var
## LR(1) items:
option(for_statement) -> FOR var . IN expr [ COLON ]
## Transitions:
-- On IN shift to state 150
## Reductions:

State 150:
## Known stack suffix:
## FOR var IN
## LR(1) items:
option(for_statement) -> FOR var IN . expr [ COLON ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 151
## Reductions:

State 151:
## Known stack suffix:
## FOR var IN expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
option(for_statement) -> FOR var IN expr . [ COLON ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On COLON
--   reduce production option(for_statement) -> FOR var IN expr

State 152:
## Known stack suffix:
## FORALL comma_list(prop_or_var) option(for_statement)
## LR(1) items:
formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) . COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 153
## Reductions:

State 153:
## Known stack suffix:
## FORALL comma_list(prop_or_var) option(for_statement) COLON
## LR(1) items:
formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 207
## Reductions:

State 154:
## Known stack suffix:
## EXISTS
## LR(1) items:
formula_qbf -> EXISTS . comma_list(prop_or_var) option(for_statement) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TERM shift to state 7
-- On var shift to state 141
-- On prop shift to state 143
-- On comma_list(prop_or_var) shift to state 155
## Reductions:

State 155:
## Known stack suffix:
## EXISTS comma_list(prop_or_var)
## LR(1) items:
formula_qbf -> EXISTS comma_list(prop_or_var) . option(for_statement) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On FOR shift to state 148
-- On option(for_statement) shift to state 156
## Reductions:
-- On COLON
--   reduce production option(for_statement) ->

State 156:
## Known stack suffix:
## EXISTS comma_list(prop_or_var) option(for_statement)
## LR(1) items:
formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) . COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 157
## Reductions:

State 157:
## Known stack suffix:
## EXISTS comma_list(prop_or_var) option(for_statement) COLON
## LR(1) items:
formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 206
## Reductions:

State 158:
## Known stack suffix:
## EXACT
## LR(1) items:
formula_qbf -> EXACT . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 159
## Reductions:

State 159:
## Known stack suffix:
## EXACT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_qbf -> EXACT expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 160
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 160:
## Known stack suffix:
## EXACT expr COMMA
## LR(1) items:
formula_qbf -> EXACT expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 161
## Reductions:

State 161:
## Known stack suffix:
## EXACT expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_qbf -> EXACT expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 162
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 162:
## Known stack suffix:
## EXACT expr COMMA expr RPAREN
## LR(1) items:
formula_qbf -> EXACT expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> EXACT expr COMMA expr RPAREN

State 163:
## Known stack suffix:
## BOTTOM
## LR(1) items:
formula_qbf -> BOTTOM . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> BOTTOM

State 164:
## Known stack suffix:
## BIGOR
## LR(1) items:
formula_qbf -> BIGOR . comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 165
## Reductions:

State 165:
## Known stack suffix:
## BIGOR comma_list(var)
## LR(1) items:
formula_qbf -> BIGOR comma_list(var) . IN comma_list(expr) option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On IN shift to state 166
## Reductions:

State 166:
## Known stack suffix:
## BIGOR comma_list(var) IN
## LR(1) items:
formula_qbf -> BIGOR comma_list(var) IN . comma_list(expr) option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 167
## Reductions:

State 167:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr)
## LR(1) items:
formula_qbf -> BIGOR comma_list(var) IN comma_list(expr) . option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On WHEN shift to state 168
-- On option(when_cond) shift to state 170
## Reductions:
-- On COLON
--   reduce production option(when_cond) ->

State 168:
## Known stack suffix:
## WHEN
## LR(1) items:
option(when_cond) -> WHEN . expr [ COLON ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 169
## Reductions:

State 169:
## Known stack suffix:
## WHEN expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
option(when_cond) -> WHEN expr . [ COLON ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On COLON
--   reduce production option(when_cond) -> WHEN expr

State 170:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond)
## LR(1) items:
formula_qbf -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) . COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 171
## Reductions:

State 171:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON
## LR(1) items:
formula_qbf -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON . formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 204
## Reductions:

State 172:
## Known stack suffix:
## BIGAND
## LR(1) items:
formula_qbf -> BIGAND . comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 173
## Reductions:

State 173:
## Known stack suffix:
## BIGAND comma_list(var)
## LR(1) items:
formula_qbf -> BIGAND comma_list(var) . IN comma_list(expr) option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On IN shift to state 174
## Reductions:

State 174:
## Known stack suffix:
## BIGAND comma_list(var) IN
## LR(1) items:
formula_qbf -> BIGAND comma_list(var) IN . comma_list(expr) option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 175
## Reductions:

State 175:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr)
## LR(1) items:
formula_qbf -> BIGAND comma_list(var) IN comma_list(expr) . option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On WHEN shift to state 168
-- On option(when_cond) shift to state 176
## Reductions:
-- On COLON
--   reduce production option(when_cond) ->

State 176:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond)
## LR(1) items:
formula_qbf -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) . COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 177
## Reductions:

State 177:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON
## LR(1) items:
formula_qbf -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON . formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 191
## Reductions:

State 178:
## Known stack suffix:
## ATMOST
## LR(1) items:
formula_qbf -> ATMOST . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 179
## Reductions:

State 179:
## Known stack suffix:
## ATMOST expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_qbf -> ATMOST expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 180
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 180:
## Known stack suffix:
## ATMOST expr COMMA
## LR(1) items:
formula_qbf -> ATMOST expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 181
## Reductions:

State 181:
## Known stack suffix:
## ATMOST expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_qbf -> ATMOST expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 182
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 182:
## Known stack suffix:
## ATMOST expr COMMA expr RPAREN
## LR(1) items:
formula_qbf -> ATMOST expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> ATMOST expr COMMA expr RPAREN

State 183:
## Known stack suffix:
## ATLEAST
## LR(1) items:
formula_qbf -> ATLEAST . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 184
## Reductions:

State 184:
## Known stack suffix:
## ATLEAST expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_qbf -> ATLEAST expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 185
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 185:
## Known stack suffix:
## ATLEAST expr COMMA
## LR(1) items:
formula_qbf -> ATLEAST expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 186
## Reductions:

State 186:
## Known stack suffix:
## ATLEAST expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_qbf -> ATLEAST expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 187
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 187:
## Known stack suffix:
## ATLEAST expr COMMA expr RPAREN
## LR(1) items:
formula_qbf -> ATLEAST expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> ATLEAST expr COMMA expr RPAREN

State 188:
## Known stack suffix:
## var
## LR(1) items:
formula_qbf -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> var

State 189:
## Known stack suffix:
## prop
## LR(1) items:
formula_qbf -> prop . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> prop

State 190:
## Known stack suffix:
## let_affect(expr,formula_qbf)
## LR(1) items:
formula_qbf -> let_affect(expr,formula_qbf) . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> let_affect(expr,formula_qbf)

State 191:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On END shift to state 203
-- On AND shift to state 196
## Reductions:

State 192:
## Known stack suffix:
## formula_qbf XOR
## LR(1) items:
formula_qbf -> formula_qbf XOR . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 193
## Reductions:

State 193:
## Known stack suffix:
## formula_qbf XOR formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf XOR formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> formula_qbf XOR formula_qbf

State 194:
## Known stack suffix:
## formula_qbf OR
## LR(1) items:
formula_qbf -> formula_qbf OR . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 195
## Reductions:

State 195:
## Known stack suffix:
## formula_qbf OR formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf OR formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On AND shift to state 196
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production formula_qbf -> formula_qbf OR formula_qbf

State 196:
## Known stack suffix:
## formula_qbf AND
## LR(1) items:
formula_qbf -> formula_qbf AND . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 197
## Reductions:

State 197:
## Known stack suffix:
## formula_qbf AND formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf AND formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> formula_qbf AND formula_qbf

State 198:
## Known stack suffix:
## formula_qbf NEWLINE
## LR(1) items:
formula_qbf -> formula_qbf NEWLINE . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> formula_qbf NEWLINE

State 199:
## Known stack suffix:
## formula_qbf IMPLIES
## LR(1) items:
formula_qbf -> formula_qbf IMPLIES . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 200
## Reductions:

State 200:
## Known stack suffix:
## formula_qbf IMPLIES formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf IMPLIES formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM RPAREN NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf

State 201:
## Known stack suffix:
## formula_qbf EQUIV
## LR(1) items:
formula_qbf -> formula_qbf EQUIV . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 202
## Reductions:

State 202:
## Known stack suffix:
## formula_qbf EQUIV formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf EQUIV formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM RPAREN NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production formula_qbf -> formula_qbf EQUIV formula_qbf

State 203:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END
## LR(1) items:
formula_qbf -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END

State 204:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On END shift to state 205
-- On AND shift to state 196
## Reductions:

State 205:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END
## LR(1) items:
formula_qbf -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END

State 206:
## Known stack suffix:
## EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
** Conflict on XOR OR NEWLINE IMPLIES EQUIV AND

State 207:
## Known stack suffix:
## FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
** Conflict on XOR OR NEWLINE IMPLIES EQUIV AND

State 208:
## Known stack suffix:
## IF expr THEN formula_qbf
## LR(1) items:
formula_qbf -> IF expr THEN formula_qbf . ELSE formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . AND formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On ELSE shift to state 209
-- On AND shift to state 196
## Reductions:

State 209:
## Known stack suffix:
## IF expr THEN formula_qbf ELSE
## LR(1) items:
formula_qbf -> IF expr THEN formula_qbf ELSE . formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 210
## Reductions:

State 210:
## Known stack suffix:
## IF expr THEN formula_qbf ELSE formula_qbf
## LR(1) items:
formula_qbf -> IF expr THEN formula_qbf ELSE formula_qbf . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . AND formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On END shift to state 211
-- On AND shift to state 196
## Reductions:

State 211:
## Known stack suffix:
## IF expr THEN formula_qbf ELSE formula_qbf END
## LR(1) items:
formula_qbf -> IF expr THEN formula_qbf ELSE formula_qbf END . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> IF expr THEN formula_qbf ELSE formula_qbf END

State 212:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM RPAREN NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf

State 213:
## Known stack suffix:
## LPAREN formula_qbf
## LR(1) items:
formula_qbf -> LPAREN formula_qbf . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . AND formula_qbf [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
## Transitions:
-- On XOR shift to state 192
-- On RPAREN shift to state 214
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:

State 214:
## Known stack suffix:
## LPAREN formula_qbf RPAREN
## LR(1) items:
formula_qbf -> LPAREN formula_qbf RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> LPAREN formula_qbf RPAREN

State 215:
## Known stack suffix:
## NEWLINE formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> NEWLINE formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM RPAREN NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production formula_qbf -> NEWLINE formula_qbf

State 216:
## Known stack suffix:
## NOT formula_qbf
## LR(1) items:
formula_qbf -> NOT formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> NOT formula_qbf

State 217:
## Known stack suffix:
## var
## LR(1) items:
affect_or(formula_qbf) -> var . AFFECT expr [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
formula_qbf -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On AFFECT shift to state 218
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_qbf -> var

State 218:
## Known stack suffix:
## var AFFECT
## LR(1) items:
affect_or(formula_qbf) -> var AFFECT . expr [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 219
## Reductions:

State 219:
## Known stack suffix:
## var AFFECT expr
## LR(1) items:
affect_or(formula_qbf) -> var AFFECT expr . [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
expr -> expr . ADD expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production affect_or(formula_qbf) -> var AFFECT expr

State 220:
## Known stack suffix:
## touist_qbf
## LR(1) items:
touist_qbf' -> touist_qbf . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept touist_qbf

State 221:
## Known stack suffix:
## nonempty_list(affect_or(formula_qbf))
## LR(1) items:
touist_qbf -> nonempty_list(affect_or(formula_qbf)) . EOF [ # ]
## Transitions:
-- On EOF shift to state 222
## Reductions:

State 222:
## Known stack suffix:
## nonempty_list(affect_or(formula_qbf)) EOF
## LR(1) items:
touist_qbf -> nonempty_list(affect_or(formula_qbf)) EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production touist_qbf -> nonempty_list(affect_or(formula_qbf)) EOF

State 223:
## Known stack suffix:
## formula_qbf
## LR(1) items:
affect_or(formula_qbf) -> formula_qbf . option(DATA) [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On DATA shift to state 224
-- On AND shift to state 196
-- On option(DATA) shift to state 225
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production option(DATA) ->
** Conflict on NEWLINE

State 224:
## Known stack suffix:
## DATA
## LR(1) items:
option(DATA) -> DATA . [ VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FORALL FLOAT EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FORALL FLOAT EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production option(DATA) -> DATA

State 225:
## Known stack suffix:
## formula_qbf option(DATA)
## LR(1) items:
affect_or(formula_qbf) -> formula_qbf option(DATA) . [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production affect_or(formula_qbf) -> formula_qbf option(DATA)

State 226:
## Known stack suffix:
## affect_or(formula_qbf)
## LR(1) items:
nonempty_list(affect_or(formula_qbf)) -> affect_or(formula_qbf) . [ EOF ]
nonempty_list(affect_or(formula_qbf)) -> affect_or(formula_qbf) . nonempty_list(affect_or(formula_qbf)) [ EOF ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 217
-- On prop shift to state 189
-- On nonempty_list(affect_or(formula_qbf)) shift to state 227
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 223
-- On affect_or(formula_qbf) shift to state 226
## Reductions:
-- On EOF
--   reduce production nonempty_list(affect_or(formula_qbf)) -> affect_or(formula_qbf)

State 227:
## Known stack suffix:
## affect_or(formula_qbf) nonempty_list(affect_or(formula_qbf))
## LR(1) items:
nonempty_list(affect_or(formula_qbf)) -> affect_or(formula_qbf) nonempty_list(affect_or(formula_qbf)) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production nonempty_list(affect_or(formula_qbf)) -> affect_or(formula_qbf) nonempty_list(affect_or(formula_qbf))

State 228:
## Known stack suffix:
##
## LR(1) items:
touist_simple' -> . touist_simple [ # ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 296
-- On touist_simple shift to state 299
-- On prop shift to state 270
-- On nonempty_list(affect_or(formula_simple)) shift to state 300
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 302
-- On affect_or(formula_simple) shift to state 304
## Reductions:

State 229:
## Known stack suffix:
## TOP
## LR(1) items:
formula_simple -> TOP . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> TOP

State 230:
## Known stack suffix:
## NOT
## LR(1) items:
formula_simple -> NOT . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 295
## Reductions:

State 231:
## Known stack suffix:
## NEWLINE
## LR(1) items:
formula_simple -> NEWLINE . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 294
## Reductions:

State 232:
## Known stack suffix:
## LPAREN
## LR(1) items:
formula_simple -> LPAREN . formula_simple RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 292
## Reductions:

State 233:
## Known stack suffix:
## LET
## LR(1) items:
let_affect(expr,formula_simple) -> LET . comma_list(var) AFFECT comma_list(expr) COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 234
## Reductions:

State 234:
## Known stack suffix:
## LET comma_list(var)
## LR(1) items:
let_affect(expr,formula_simple) -> LET comma_list(var) . AFFECT comma_list(expr) COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On AFFECT shift to state 235
## Reductions:

State 235:
## Known stack suffix:
## LET comma_list(var) AFFECT
## LR(1) items:
let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT . comma_list(expr) COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 236
## Reductions:

State 236:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr)
## LR(1) items:
let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) . COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 237
## Reductions:

State 237:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr) COLON
## LR(1) items:
let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 291
## Reductions:

State 238:
## Known stack suffix:
## IF
## LR(1) items:
formula_simple -> IF . expr THEN formula_simple ELSE formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 239
## Reductions:

State 239:
## Known stack suffix:
## IF expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_simple -> IF expr . THEN formula_simple ELSE formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On THEN shift to state 240
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 240:
## Known stack suffix:
## IF expr THEN
## LR(1) items:
formula_simple -> IF expr THEN . formula_simple ELSE formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 287
## Reductions:

State 241:
## Known stack suffix:
## EXACT
## LR(1) items:
formula_simple -> EXACT . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 242
## Reductions:

State 242:
## Known stack suffix:
## EXACT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_simple -> EXACT expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 243
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 243:
## Known stack suffix:
## EXACT expr COMMA
## LR(1) items:
formula_simple -> EXACT expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 244
## Reductions:

State 244:
## Known stack suffix:
## EXACT expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_simple -> EXACT expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 245
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 245:
## Known stack suffix:
## EXACT expr COMMA expr RPAREN
## LR(1) items:
formula_simple -> EXACT expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> EXACT expr COMMA expr RPAREN

State 246:
## Known stack suffix:
## BOTTOM
## LR(1) items:
formula_simple -> BOTTOM . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> BOTTOM

State 247:
## Known stack suffix:
## BIGOR
## LR(1) items:
formula_simple -> BIGOR . comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 248
## Reductions:

State 248:
## Known stack suffix:
## BIGOR comma_list(var)
## LR(1) items:
formula_simple -> BIGOR comma_list(var) . IN comma_list(expr) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On IN shift to state 249
## Reductions:

State 249:
## Known stack suffix:
## BIGOR comma_list(var) IN
## LR(1) items:
formula_simple -> BIGOR comma_list(var) IN . comma_list(expr) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 250
## Reductions:

State 250:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr)
## LR(1) items:
formula_simple -> BIGOR comma_list(var) IN comma_list(expr) . option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On WHEN shift to state 168
-- On option(when_cond) shift to state 251
## Reductions:
-- On COLON
--   reduce production option(when_cond) ->

State 251:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond)
## LR(1) items:
formula_simple -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) . COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 252
## Reductions:

State 252:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON
## LR(1) items:
formula_simple -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON . formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 285
## Reductions:

State 253:
## Known stack suffix:
## BIGAND
## LR(1) items:
formula_simple -> BIGAND . comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 254
## Reductions:

State 254:
## Known stack suffix:
## BIGAND comma_list(var)
## LR(1) items:
formula_simple -> BIGAND comma_list(var) . IN comma_list(expr) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On IN shift to state 255
## Reductions:

State 255:
## Known stack suffix:
## BIGAND comma_list(var) IN
## LR(1) items:
formula_simple -> BIGAND comma_list(var) IN . comma_list(expr) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 256
## Reductions:

State 256:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr)
## LR(1) items:
formula_simple -> BIGAND comma_list(var) IN comma_list(expr) . option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On WHEN shift to state 168
-- On option(when_cond) shift to state 257
## Reductions:
-- On COLON
--   reduce production option(when_cond) ->

State 257:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond)
## LR(1) items:
formula_simple -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) . COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 258
## Reductions:

State 258:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON
## LR(1) items:
formula_simple -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON . formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 272
## Reductions:

State 259:
## Known stack suffix:
## ATMOST
## LR(1) items:
formula_simple -> ATMOST . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 260
## Reductions:

State 260:
## Known stack suffix:
## ATMOST expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_simple -> ATMOST expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 261
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 261:
## Known stack suffix:
## ATMOST expr COMMA
## LR(1) items:
formula_simple -> ATMOST expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 262
## Reductions:

State 262:
## Known stack suffix:
## ATMOST expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_simple -> ATMOST expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 263
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 263:
## Known stack suffix:
## ATMOST expr COMMA expr RPAREN
## LR(1) items:
formula_simple -> ATMOST expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> ATMOST expr COMMA expr RPAREN

State 264:
## Known stack suffix:
## ATLEAST
## LR(1) items:
formula_simple -> ATLEAST . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 265
## Reductions:

State 265:
## Known stack suffix:
## ATLEAST expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_simple -> ATLEAST expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 266
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 266:
## Known stack suffix:
## ATLEAST expr COMMA
## LR(1) items:
formula_simple -> ATLEAST expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## ATLEAST expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_simple -> ATLEAST expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 268
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 268:
## Known stack suffix:
## ATLEAST expr COMMA expr RPAREN
## LR(1) items:
formula_simple -> ATLEAST expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> ATLEAST expr COMMA expr RPAREN

State 269:
## Known stack suffix:
## var
## LR(1) items:
formula_simple -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> var

State 270:
## Known stack suffix:
## prop
## LR(1) items:
formula_simple -> prop . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> prop

State 271:
## Known stack suffix:
## let_affect(expr,formula_simple)
## LR(1) items:
formula_simple -> let_affect(expr,formula_simple) . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> let_affect(expr,formula_simple)

State 272:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On NEWLINE shift to state 279
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On END shift to state 284
-- On AND shift to state 277
## Reductions:

State 273:
## Known stack suffix:
## formula_simple XOR
## LR(1) items:
formula_simple -> formula_simple XOR . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 274
## Reductions:

State 274:
## Known stack suffix:
## formula_simple XOR formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple XOR formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> formula_simple XOR formula_simple

State 275:
## Known stack suffix:
## formula_simple OR
## LR(1) items:
formula_simple -> formula_simple OR . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 276
## Reductions:

State 276:
## Known stack suffix:
## formula_simple OR formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple OR formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
-- On AND shift to state 277
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production formula_simple -> formula_simple OR formula_simple

State 277:
## Known stack suffix:
## formula_simple AND
## LR(1) items:
formula_simple -> formula_simple AND . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 278
## Reductions:

State 278:
## Known stack suffix:
## formula_simple AND formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple AND formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> formula_simple AND formula_simple

State 279:
## Known stack suffix:
## formula_simple NEWLINE
## LR(1) items:
formula_simple -> formula_simple NEWLINE . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> formula_simple NEWLINE

State 280:
## Known stack suffix:
## formula_simple IMPLIES
## LR(1) items:
formula_simple -> formula_simple IMPLIES . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 281
## Reductions:

State 281:
## Known stack suffix:
## formula_simple IMPLIES formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple IMPLIES formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On AND shift to state 277
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM RPAREN NOT NEWLINE LPAREN LET IF EXACT EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production formula_simple -> formula_simple IMPLIES formula_simple

State 282:
## Known stack suffix:
## formula_simple EQUIV
## LR(1) items:
formula_simple -> formula_simple EQUIV . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 283
## Reductions:

State 283:
## Known stack suffix:
## formula_simple EQUIV formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple EQUIV formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On AND shift to state 277
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM RPAREN NOT NEWLINE LPAREN LET IF EXACT EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production formula_simple -> formula_simple EQUIV formula_simple

State 284:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END
## LR(1) items:
formula_simple -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END

State 285:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On NEWLINE shift to state 279
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On END shift to state 286
-- On AND shift to state 277
## Reductions:

State 286:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END
## LR(1) items:
formula_simple -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END

State 287:
## Known stack suffix:
## IF expr THEN formula_simple
## LR(1) items:
formula_simple -> IF expr THEN formula_simple . ELSE formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . AND formula_simple [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_simple -> formula_simple . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On NEWLINE shift to state 279
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On ELSE shift to state 288
-- On AND shift to state 277
## Reductions:

State 288:
## Known stack suffix:
## IF expr THEN formula_simple ELSE
## LR(1) items:
formula_simple -> IF expr THEN formula_simple ELSE . formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 289
## Reductions:

State 289:
## Known stack suffix:
## IF expr THEN formula_simple ELSE formula_simple
## LR(1) items:
formula_simple -> IF expr THEN formula_simple ELSE formula_simple . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . AND formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On NEWLINE shift to state 279
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On END shift to state 290
-- On AND shift to state 277
## Reductions:

State 290:
## Known stack suffix:
## IF expr THEN formula_simple ELSE formula_simple END
## LR(1) items:
formula_simple -> IF expr THEN formula_simple ELSE formula_simple END . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> IF expr THEN formula_simple ELSE formula_simple END

State 291:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On AND shift to state 277
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM RPAREN NOT NEWLINE LPAREN LET IF EXACT EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple

State 292:
## Known stack suffix:
## LPAREN formula_simple
## LR(1) items:
formula_simple -> LPAREN formula_simple . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . AND formula_simple [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_simple -> formula_simple . NEWLINE [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
## Transitions:
-- On XOR shift to state 273
-- On RPAREN shift to state 293
-- On OR shift to state 275
-- On NEWLINE shift to state 279
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On AND shift to state 277
## Reductions:

State 293:
## Known stack suffix:
## LPAREN formula_simple RPAREN
## LR(1) items:
formula_simple -> LPAREN formula_simple RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> LPAREN formula_simple RPAREN

State 294:
## Known stack suffix:
## NEWLINE formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> NEWLINE formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On AND shift to state 277
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM RPAREN NOT NEWLINE LPAREN LET IF EXACT EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production formula_simple -> NEWLINE formula_simple

State 295:
## Known stack suffix:
## NOT formula_simple
## LR(1) items:
formula_simple -> NOT formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> NOT formula_simple

State 296:
## Known stack suffix:
## var
## LR(1) items:
affect_or(formula_simple) -> var . AFFECT expr [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
formula_simple -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On AFFECT shift to state 297
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_simple -> var

State 297:
## Known stack suffix:
## var AFFECT
## LR(1) items:
affect_or(formula_simple) -> var AFFECT . expr [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 298
## Reductions:

State 298:
## Known stack suffix:
## var AFFECT expr
## LR(1) items:
affect_or(formula_simple) -> var AFFECT expr . [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
expr -> expr . ADD expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production affect_or(formula_simple) -> var AFFECT expr

State 299:
## Known stack suffix:
## touist_simple
## LR(1) items:
touist_simple' -> touist_simple . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept touist_simple

State 300:
## Known stack suffix:
## nonempty_list(affect_or(formula_simple))
## LR(1) items:
touist_simple -> nonempty_list(affect_or(formula_simple)) . EOF [ # ]
## Transitions:
-- On EOF shift to state 301
## Reductions:

State 301:
## Known stack suffix:
## nonempty_list(affect_or(formula_simple)) EOF
## LR(1) items:
touist_simple -> nonempty_list(affect_or(formula_simple)) EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production touist_simple -> nonempty_list(affect_or(formula_simple)) EOF

State 302:
## Known stack suffix:
## formula_simple
## LR(1) items:
affect_or(formula_simple) -> formula_simple . option(DATA) [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On NEWLINE shift to state 279
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On DATA shift to state 224
-- On AND shift to state 277
-- On option(DATA) shift to state 303
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production option(DATA) ->
** Conflict on NEWLINE

State 303:
## Known stack suffix:
## formula_simple option(DATA)
## LR(1) items:
affect_or(formula_simple) -> formula_simple option(DATA) . [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production affect_or(formula_simple) -> formula_simple option(DATA)

State 304:
## Known stack suffix:
## affect_or(formula_simple)
## LR(1) items:
nonempty_list(affect_or(formula_simple)) -> affect_or(formula_simple) . [ EOF ]
nonempty_list(affect_or(formula_simple)) -> affect_or(formula_simple) . nonempty_list(affect_or(formula_simple)) [ EOF ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 296
-- On prop shift to state 270
-- On nonempty_list(affect_or(formula_simple)) shift to state 305
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 302
-- On affect_or(formula_simple) shift to state 304
## Reductions:
-- On EOF
--   reduce production nonempty_list(affect_or(formula_simple)) -> affect_or(formula_simple)

State 305:
## Known stack suffix:
## affect_or(formula_simple) nonempty_list(affect_or(formula_simple))
## LR(1) items:
nonempty_list(affect_or(formula_simple)) -> affect_or(formula_simple) nonempty_list(affect_or(formula_simple)) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production nonempty_list(affect_or(formula_simple)) -> affect_or(formula_simple) nonempty_list(affect_or(formula_simple))

State 306:
## Known stack suffix:
##
## LR(1) items:
touist_smt' -> . touist_smt [ # ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 403
-- On touist_smt shift to state 406
-- On prop shift to state 314
-- On nonempty_list(affect_or(formula_smt)) shift to state 407
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 409
-- On expr_smt shift to state 380
-- On affect_or(formula_smt) shift to state 411
## Reductions:

State 307:
## Known stack suffix:
## TOP
## LR(1) items:
expr_smt -> TOP . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> TOP

State 308:
## Known stack suffix:
## SUB
## LR(1) items:
expr_smt -> SUB . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 337
## Reductions:

State 309:
## Known stack suffix:
## LPAREN
## LR(1) items:
expr_smt -> LPAREN . expr_smt RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 315
## Reductions:

State 310:
## Known stack suffix:
## INT
## LR(1) items:
expr_smt -> INT . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> INT

State 311:
## Known stack suffix:
## FLOAT
## LR(1) items:
expr_smt -> FLOAT . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> FLOAT

State 312:
## Known stack suffix:
## BOTTOM
## LR(1) items:
expr_smt -> BOTTOM . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> BOTTOM

State 313:
## Known stack suffix:
## var
## LR(1) items:
expr_smt -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> var

State 314:
## Known stack suffix:
## prop
## LR(1) items:
expr_smt -> prop . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> prop

State 315:
## Known stack suffix:
## LPAREN expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . LE expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . GT expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . GE expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . ADD expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . SUB expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . MUL expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . DIV expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> LPAREN expr_smt . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On RPAREN shift to state 322
-- On NOTEQUAL shift to state 323
-- On MUL shift to state 318
-- On LT shift to state 327
-- On LE shift to state 329
-- On GT shift to state 331
-- On GE shift to state 333
-- On EQUAL shift to state 335
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:

State 316:
## Known stack suffix:
## expr_smt SUB
## LR(1) items:
expr_smt -> expr_smt SUB . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 317
## Reductions:

State 317:
## Known stack suffix:
## expr_smt SUB expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt SUB expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MUL shift to state 318
-- On DIV shift to state 320
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> expr_smt SUB expr_smt

State 318:
## Known stack suffix:
## expr_smt MUL
## LR(1) items:
expr_smt -> expr_smt MUL . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 319
## Reductions:

State 319:
## Known stack suffix:
## expr_smt MUL expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt MUL expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> expr_smt MUL expr_smt

State 320:
## Known stack suffix:
## expr_smt DIV
## LR(1) items:
expr_smt -> expr_smt DIV . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 321
## Reductions:

State 321:
## Known stack suffix:
## expr_smt DIV expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt DIV expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> expr_smt DIV expr_smt

State 322:
## Known stack suffix:
## LPAREN expr_smt RPAREN
## LR(1) items:
expr_smt -> LPAREN expr_smt RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> LPAREN expr_smt RPAREN

State 323:
## Known stack suffix:
## expr_smt NOTEQUAL
## LR(1) items:
expr_smt -> expr_smt NOTEQUAL . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 324
## Reductions:

State 324:
## Known stack suffix:
## expr_smt NOTEQUAL expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt NOTEQUAL expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On MUL shift to state 318
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr_smt -> expr_smt NOTEQUAL expr_smt

State 325:
## Known stack suffix:
## expr_smt ADD
## LR(1) items:
expr_smt -> expr_smt ADD . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 326
## Reductions:

State 326:
## Known stack suffix:
## expr_smt ADD expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt ADD expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MUL shift to state 318
-- On DIV shift to state 320
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> expr_smt ADD expr_smt

State 327:
## Known stack suffix:
## expr_smt LT
## LR(1) items:
expr_smt -> expr_smt LT . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 328
## Reductions:

State 328:
## Known stack suffix:
## expr_smt LT expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt LT expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On MUL shift to state 318
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr_smt -> expr_smt LT expr_smt

State 329:
## Known stack suffix:
## expr_smt LE
## LR(1) items:
expr_smt -> expr_smt LE . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 330
## Reductions:

State 330:
## Known stack suffix:
## expr_smt LE expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt LE expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On MUL shift to state 318
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr_smt -> expr_smt LE expr_smt

State 331:
## Known stack suffix:
## expr_smt GT
## LR(1) items:
expr_smt -> expr_smt GT . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 332
## Reductions:

State 332:
## Known stack suffix:
## expr_smt GT expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt GT expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On MUL shift to state 318
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr_smt -> expr_smt GT expr_smt

State 333:
## Known stack suffix:
## expr_smt GE
## LR(1) items:
expr_smt -> expr_smt GE . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 334
## Reductions:

State 334:
## Known stack suffix:
## expr_smt GE expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt GE expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On MUL shift to state 318
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr_smt -> expr_smt GE expr_smt

State 335:
## Known stack suffix:
## expr_smt EQUAL
## LR(1) items:
expr_smt -> expr_smt EQUAL . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 336
## Reductions:

State 336:
## Known stack suffix:
## expr_smt EQUAL expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt EQUAL expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On MUL shift to state 318
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production expr_smt -> expr_smt EQUAL expr_smt

State 337:
## Known stack suffix:
## SUB expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> SUB expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MUL shift to state 318
-- On DIV shift to state 320
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> SUB expr_smt

State 338:
## Known stack suffix:
## NOT
## LR(1) items:
formula_smt -> NOT . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 402
-- On expr_smt shift to state 380
## Reductions:

State 339:
## Known stack suffix:
## NEWLINE
## LR(1) items:
formula_smt -> NEWLINE . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 401
-- On expr_smt shift to state 380
## Reductions:

State 340:
## Known stack suffix:
## LPAREN
## LR(1) items:
expr_smt -> LPAREN . expr_smt RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
formula_smt -> LPAREN . formula_smt RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 398
-- On expr_smt shift to state 400
## Reductions:

State 341:
## Known stack suffix:
## LET
## LR(1) items:
let_affect(expr,formula_smt) -> LET . comma_list(var) AFFECT comma_list(expr) COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 342
## Reductions:

State 342:
## Known stack suffix:
## LET comma_list(var)
## LR(1) items:
let_affect(expr,formula_smt) -> LET comma_list(var) . AFFECT comma_list(expr) COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On AFFECT shift to state 343
## Reductions:

State 343:
## Known stack suffix:
## LET comma_list(var) AFFECT
## LR(1) items:
let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT . comma_list(expr) COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 344
## Reductions:

State 344:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr)
## LR(1) items:
let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) . COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 345
## Reductions:

State 345:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr) COLON
## LR(1) items:
let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 397
-- On expr_smt shift to state 380
## Reductions:

State 346:
## Known stack suffix:
## IF
## LR(1) items:
formula_smt -> IF . expr THEN formula_smt ELSE formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 347
## Reductions:

State 347:
## Known stack suffix:
## IF expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_smt -> IF expr . THEN formula_smt ELSE formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On THEN shift to state 348
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 348:
## Known stack suffix:
## IF expr THEN
## LR(1) items:
formula_smt -> IF expr THEN . formula_smt ELSE formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 393
-- On expr_smt shift to state 380
## Reductions:

State 349:
## Known stack suffix:
## EXACT
## LR(1) items:
formula_smt -> EXACT . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 350
## Reductions:

State 350:
## Known stack suffix:
## EXACT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_smt -> EXACT expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 351
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 351:
## Known stack suffix:
## EXACT expr COMMA
## LR(1) items:
formula_smt -> EXACT expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 352
## Reductions:

State 352:
## Known stack suffix:
## EXACT expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_smt -> EXACT expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 353
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 353:
## Known stack suffix:
## EXACT expr COMMA expr RPAREN
## LR(1) items:
formula_smt -> EXACT expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> EXACT expr COMMA expr RPAREN

State 354:
## Known stack suffix:
## BIGOR
## LR(1) items:
formula_smt -> BIGOR . comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 355
## Reductions:

State 355:
## Known stack suffix:
## BIGOR comma_list(var)
## LR(1) items:
formula_smt -> BIGOR comma_list(var) . IN comma_list(expr) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On IN shift to state 356
## Reductions:

State 356:
## Known stack suffix:
## BIGOR comma_list(var) IN
## LR(1) items:
formula_smt -> BIGOR comma_list(var) IN . comma_list(expr) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 357
## Reductions:

State 357:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr)
## LR(1) items:
formula_smt -> BIGOR comma_list(var) IN comma_list(expr) . option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On WHEN shift to state 168
-- On option(when_cond) shift to state 358
## Reductions:
-- On COLON
--   reduce production option(when_cond) ->

State 358:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond)
## LR(1) items:
formula_smt -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) . COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 359
## Reductions:

State 359:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON
## LR(1) items:
formula_smt -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON . formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 391
-- On expr_smt shift to state 380
## Reductions:

State 360:
## Known stack suffix:
## BIGAND
## LR(1) items:
formula_smt -> BIGAND . comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 361
## Reductions:

State 361:
## Known stack suffix:
## BIGAND comma_list(var)
## LR(1) items:
formula_smt -> BIGAND comma_list(var) . IN comma_list(expr) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On IN shift to state 362
## Reductions:

State 362:
## Known stack suffix:
## BIGAND comma_list(var) IN
## LR(1) items:
formula_smt -> BIGAND comma_list(var) IN . comma_list(expr) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 363
## Reductions:

State 363:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr)
## LR(1) items:
formula_smt -> BIGAND comma_list(var) IN comma_list(expr) . option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On WHEN shift to state 168
-- On option(when_cond) shift to state 364
## Reductions:
-- On COLON
--   reduce production option(when_cond) ->

State 364:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond)
## LR(1) items:
formula_smt -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) . COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 365
## Reductions:

State 365:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON
## LR(1) items:
formula_smt -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON . formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 377
-- On expr_smt shift to state 380
## Reductions:

State 366:
## Known stack suffix:
## ATMOST
## LR(1) items:
formula_smt -> ATMOST . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 367
## Reductions:

State 367:
## Known stack suffix:
## ATMOST expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_smt -> ATMOST expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 368
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 368:
## Known stack suffix:
## ATMOST expr COMMA
## LR(1) items:
formula_smt -> ATMOST expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 369
## Reductions:

State 369:
## Known stack suffix:
## ATMOST expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_smt -> ATMOST expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 370
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 370:
## Known stack suffix:
## ATMOST expr COMMA expr RPAREN
## LR(1) items:
formula_smt -> ATMOST expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> ATMOST expr COMMA expr RPAREN

State 371:
## Known stack suffix:
## ATLEAST
## LR(1) items:
formula_smt -> ATLEAST . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 372
## Reductions:

State 372:
## Known stack suffix:
## ATLEAST expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_smt -> ATLEAST expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 373
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 373:
## Known stack suffix:
## ATLEAST expr COMMA
## LR(1) items:
formula_smt -> ATLEAST expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 374
## Reductions:

State 374:
## Known stack suffix:
## ATLEAST expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_smt -> ATLEAST expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 375
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 375:
## Known stack suffix:
## ATLEAST expr COMMA expr RPAREN
## LR(1) items:
formula_smt -> ATLEAST expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> ATLEAST expr COMMA expr RPAREN

State 376:
## Known stack suffix:
## let_affect(expr,formula_smt)
## LR(1) items:
formula_smt -> let_affect(expr,formula_smt) . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> let_affect(expr,formula_smt)

State 377:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt . END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On NEWLINE shift to state 385
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On END shift to state 390
-- On AND shift to state 383
## Reductions:

State 378:
## Known stack suffix:
## formula_smt XOR
## LR(1) items:
formula_smt -> formula_smt XOR . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 379
-- On expr_smt shift to state 380
## Reductions:

State 379:
## Known stack suffix:
## formula_smt XOR formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt XOR formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> formula_smt XOR formula_smt

State 380:
## Known stack suffix:
## expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
formula_smt -> expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On SUB shift to state 316
-- On NOTEQUAL shift to state 323
-- On MUL shift to state 318
-- On LT shift to state 327
-- On LE shift to state 329
-- On GT shift to state 331
-- On GE shift to state 333
-- On EQUAL shift to state 335
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> expr_smt
** Conflict on SUB

State 381:
## Known stack suffix:
## formula_smt OR
## LR(1) items:
formula_smt -> formula_smt OR . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 382
-- On expr_smt shift to state 380
## Reductions:

State 382:
## Known stack suffix:
## formula_smt OR formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt OR formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
-- On AND shift to state 383
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production formula_smt -> formula_smt OR formula_smt

State 383:
## Known stack suffix:
## formula_smt AND
## LR(1) items:
formula_smt -> formula_smt AND . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 384
-- On expr_smt shift to state 380
## Reductions:

State 384:
## Known stack suffix:
## formula_smt AND formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt AND formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> formula_smt AND formula_smt

State 385:
## Known stack suffix:
## formula_smt NEWLINE
## LR(1) items:
formula_smt -> formula_smt NEWLINE . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> formula_smt NEWLINE

State 386:
## Known stack suffix:
## formula_smt IMPLIES
## LR(1) items:
formula_smt -> formula_smt IMPLIES . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 387
-- On expr_smt shift to state 380
## Reductions:

State 387:
## Known stack suffix:
## formula_smt IMPLIES formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt IMPLIES formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On AND shift to state 383
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM SUB RPAREN NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production formula_smt -> formula_smt IMPLIES formula_smt

State 388:
## Known stack suffix:
## formula_smt EQUIV
## LR(1) items:
formula_smt -> formula_smt EQUIV . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 389
-- On expr_smt shift to state 380
## Reductions:

State 389:
## Known stack suffix:
## formula_smt EQUIV formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt EQUIV formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On AND shift to state 383
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM SUB RPAREN NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production formula_smt -> formula_smt EQUIV formula_smt

State 390:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END
## LR(1) items:
formula_smt -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END

State 391:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt . END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On NEWLINE shift to state 385
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On END shift to state 392
-- On AND shift to state 383
## Reductions:

State 392:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END
## LR(1) items:
formula_smt -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END

State 393:
## Known stack suffix:
## IF expr THEN formula_smt
## LR(1) items:
formula_smt -> IF expr THEN formula_smt . ELSE formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . AND formula_smt [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_smt -> formula_smt . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On NEWLINE shift to state 385
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On ELSE shift to state 394
-- On AND shift to state 383
## Reductions:

State 394:
## Known stack suffix:
## IF expr THEN formula_smt ELSE
## LR(1) items:
formula_smt -> IF expr THEN formula_smt ELSE . formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 395
-- On expr_smt shift to state 380
## Reductions:

State 395:
## Known stack suffix:
## IF expr THEN formula_smt ELSE formula_smt
## LR(1) items:
formula_smt -> IF expr THEN formula_smt ELSE formula_smt . END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . AND formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On NEWLINE shift to state 385
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On END shift to state 396
-- On AND shift to state 383
## Reductions:

State 396:
## Known stack suffix:
## IF expr THEN formula_smt ELSE formula_smt END
## LR(1) items:
formula_smt -> IF expr THEN formula_smt ELSE formula_smt END . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> IF expr THEN formula_smt ELSE formula_smt END

State 397:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On AND shift to state 383
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM SUB RPAREN NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt

State 398:
## Known stack suffix:
## LPAREN formula_smt
## LR(1) items:
formula_smt -> LPAREN formula_smt . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . AND formula_smt [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_smt -> formula_smt . NEWLINE [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
## Transitions:
-- On XOR shift to state 378
-- On RPAREN shift to state 399
-- On OR shift to state 381
-- On NEWLINE shift to state 385
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On AND shift to state 383
## Reductions:

State 399:
## Known stack suffix:
## LPAREN formula_smt RPAREN
## LR(1) items:
formula_smt -> LPAREN formula_smt RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> LPAREN formula_smt RPAREN

State 400:
## Known stack suffix:
## LPAREN expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> LPAREN expr_smt . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
formula_smt -> expr_smt . [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
## Transitions:
-- On SUB shift to state 316
-- On RPAREN shift to state 322
-- On NOTEQUAL shift to state 323
-- On MUL shift to state 318
-- On LT shift to state 327
-- On LE shift to state 329
-- On GT shift to state 331
-- On GE shift to state 333
-- On EQUAL shift to state 335
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR RPAREN OR NEWLINE IMPLIES EQUIV AND
--   reduce production formula_smt -> expr_smt
** Conflict on RPAREN

State 401:
## Known stack suffix:
## NEWLINE formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> NEWLINE formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On AND shift to state 383
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM SUB RPAREN NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production formula_smt -> NEWLINE formula_smt

State 402:
## Known stack suffix:
## NOT formula_smt
## LR(1) items:
formula_smt -> NOT formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND
--   reduce production formula_smt -> NOT formula_smt

State 403:
## Known stack suffix:
## var
## LR(1) items:
affect_or(formula_smt) -> var . AFFECT expr [ VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
expr_smt -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On AFFECT shift to state 404
## Reductions:
-- On XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD
--   reduce production expr_smt -> var

State 404:
## Known stack suffix:
## var AFFECT
## LR(1) items:
affect_or(formula_smt) -> var AFFECT . expr [ VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 405
## Reductions:

State 405:
## Known stack suffix:
## var AFFECT expr
## LR(1) items:
affect_or(formula_smt) -> var AFFECT expr . [ VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
expr -> expr . ADD expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production affect_or(formula_smt) -> var AFFECT expr

State 406:
## Known stack suffix:
## touist_smt
## LR(1) items:
touist_smt' -> touist_smt . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept touist_smt

State 407:
## Known stack suffix:
## nonempty_list(affect_or(formula_smt))
## LR(1) items:
touist_smt -> nonempty_list(affect_or(formula_smt)) . EOF [ # ]
## Transitions:
-- On EOF shift to state 408
## Reductions:

State 408:
## Known stack suffix:
## nonempty_list(affect_or(formula_smt)) EOF
## LR(1) items:
touist_smt -> nonempty_list(affect_or(formula_smt)) EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production touist_smt -> nonempty_list(affect_or(formula_smt)) EOF

State 409:
## Known stack suffix:
## formula_smt
## LR(1) items:
affect_or(formula_smt) -> formula_smt . option(DATA) [ VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On NEWLINE shift to state 385
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On DATA shift to state 224
-- On AND shift to state 383
-- On option(DATA) shift to state 410
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production option(DATA) ->
** Conflict on NEWLINE

State 410:
## Known stack suffix:
## formula_smt option(DATA)
## LR(1) items:
affect_or(formula_smt) -> formula_smt option(DATA) . [ VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
## Reductions:
-- On VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST
--   reduce production affect_or(formula_smt) -> formula_smt option(DATA)

State 411:
## Known stack suffix:
## affect_or(formula_smt)
## LR(1) items:
nonempty_list(affect_or(formula_smt)) -> affect_or(formula_smt) . [ EOF ]
nonempty_list(affect_or(formula_smt)) -> affect_or(formula_smt) . nonempty_list(affect_or(formula_smt)) [ EOF ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 403
-- On prop shift to state 314
-- On nonempty_list(affect_or(formula_smt)) shift to state 412
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 409
-- On expr_smt shift to state 380
-- On affect_or(formula_smt) shift to state 411
## Reductions:
-- On EOF
--   reduce production nonempty_list(affect_or(formula_smt)) -> affect_or(formula_smt)

State 412:
## Known stack suffix:
## affect_or(formula_smt) nonempty_list(affect_or(formula_smt))
## LR(1) items:
nonempty_list(affect_or(formula_smt)) -> affect_or(formula_smt) nonempty_list(affect_or(formula_smt)) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production nonempty_list(affect_or(formula_smt)) -> affect_or(formula_smt) nonempty_list(affect_or(formula_smt))

