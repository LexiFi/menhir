State 0:
## Known stack suffix:
##
## LR(1) items:
touist_qbf' -> . touist_qbf [ # ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 217
-- On touist_qbf shift to state 220
-- On prop shift to state 189
-- On nonempty_list(affect_or(formula_qbf)) shift to state 221
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 223
-- On affect_or(formula_qbf) shift to state 226
## Reductions:

State 1:
## Known stack suffix:
## VARTUPLE
## LR(1) items:
var -> VARTUPLE . comma_list(indices) RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND AFFECT ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 114
-- On comma_list(indices) shift to state 123
## Reductions:

State 2:
## Known stack suffix:
## VAR
## LR(1) items:
var -> VAR . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND AFFECT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production var -> VAR

State 3:
## Known stack suffix:
## UNION_PR
## LR(1) items:
expr -> UNION_PR . expr COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 119
## Reductions:

State 4:
## Known stack suffix:
## TUPLE
## LR(1) items:
prop -> TUPLE . comma_list(indices) RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 114
-- On comma_list(indices) shift to state 117
## Reductions:

State 5:
## Known stack suffix:
## TOINT
## LR(1) items:
expr -> TOINT . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 112
## Reductions:

State 6:
## Known stack suffix:
## TOFLOAT
## LR(1) items:
expr -> TOFLOAT . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 110
## Reductions:

State 7:
## Known stack suffix:
## TERM
## LR(1) items:
prop -> TERM . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production prop -> TERM

State 8:
## Known stack suffix:
## SUBSET_PR
## LR(1) items:
expr -> SUBSET_PR . expr COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 106
## Reductions:

State 9:
## Known stack suffix:
## SUB
## LR(1) items:
expr -> SUB . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 105
## Reductions:

State 10:
## Known stack suffix:
## SQRT
## LR(1) items:
expr -> SQRT . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 103
## Reductions:

State 11:
## Known stack suffix:
## POWERSET
## LR(1) items:
expr -> POWERSET . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 101
## Reductions:

State 12:
## Known stack suffix:
## NOT
## LR(1) items:
expr -> NOT . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 100
## Reductions:

State 13:
## Known stack suffix:
## LPAREN
## LR(1) items:
expr -> LPAREN . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 98
## Reductions:

State 14:
## Known stack suffix:
## LBRACK
## LR(1) items:
expr -> LBRACK . expr RANGE expr RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> LBRACK . RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> LBRACK . comma_list(expr) RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On RBRACK shift to state 15
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 89
-- On comma_list(expr) shift to state 96
## Reductions:

State 15:
## Known stack suffix:
## LBRACK RBRACK
## LR(1) items:
expr -> LBRACK RBRACK . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> LBRACK RBRACK

State 16:
## Known stack suffix:
## INTER_PR
## LR(1) items:
expr -> INTER_PR . expr COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 85
## Reductions:

State 17:
## Known stack suffix:
## INT
## LR(1) items:
expr -> INT . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> INT

State 18:
## Known stack suffix:
## IF
## LR(1) items:
expr -> IF . expr THEN expr ELSE expr END [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 79
## Reductions:

State 19:
## Known stack suffix:
## FLOAT
## LR(1) items:
expr -> FLOAT . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> FLOAT

State 20:
## Known stack suffix:
## EMPTY
## LR(1) items:
expr -> EMPTY . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 77
## Reductions:

State 21:
## Known stack suffix:
## DIFF_PR
## LR(1) items:
expr -> DIFF_PR . expr COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 73
## Reductions:

State 22:
## Known stack suffix:
## CARD
## LR(1) items:
expr -> CARD . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 71
## Reductions:

State 23:
## Known stack suffix:
## BOOL
## LR(1) items:
expr -> BOOL . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> BOOL

State 24:
## Known stack suffix:
## ABS
## LR(1) items:
expr -> ABS . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 27
## Reductions:

State 25:
## Known stack suffix:
## var
## LR(1) items:
expr -> var . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> var

State 26:
## Known stack suffix:
## prop
## LR(1) items:
expr -> prop . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> prop

State 27:
## Known stack suffix:
## ABS expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> ABS expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 66
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 28:
## Known stack suffix:
## expr XOR
## LR(1) items:
expr -> expr XOR . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 29
## Reductions:

State 29:
## Known stack suffix:
## expr XOR expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr XOR expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR reduce production expr -> expr XOR expr
-- On WHEN reduce production expr -> expr XOR expr
-- On VARTUPLE reduce production expr -> expr XOR expr
-- On VAR reduce production expr -> expr XOR expr
-- On UNION reduce production expr -> expr XOR expr
-- On TUPLE reduce production expr -> expr XOR expr
-- On TOP reduce production expr -> expr XOR expr
-- On THEN reduce production expr -> expr XOR expr
-- On TERM reduce production expr -> expr XOR expr
-- On SUBSET reduce production expr -> expr XOR expr
-- On RPAREN reduce production expr -> expr XOR expr
-- On RBRACK reduce production expr -> expr XOR expr
-- On RANGE reduce production expr -> expr XOR expr
-- On OR reduce production expr -> expr XOR expr
-- On NOT reduce production expr -> expr XOR expr
-- On NEWLINE reduce production expr -> expr XOR expr
-- On LPAREN reduce production expr -> expr XOR expr
-- On LET reduce production expr -> expr XOR expr
-- On INTER reduce production expr -> expr XOR expr
-- On INT reduce production expr -> expr XOR expr
-- On IMPLIES reduce production expr -> expr XOR expr
-- On IF reduce production expr -> expr XOR expr
-- On FORALL reduce production expr -> expr XOR expr
-- On FLOAT reduce production expr -> expr XOR expr
-- On EXISTS reduce production expr -> expr XOR expr
-- On EXACT reduce production expr -> expr XOR expr
-- On EQUIV reduce production expr -> expr XOR expr
-- On EOF reduce production expr -> expr XOR expr
-- On END reduce production expr -> expr XOR expr
-- On ELSE reduce production expr -> expr XOR expr
-- On DIFF reduce production expr -> expr XOR expr
-- On COMMA reduce production expr -> expr XOR expr
-- On COLON reduce production expr -> expr XOR expr
-- On BOTTOM reduce production expr -> expr XOR expr
-- On BIGOR reduce production expr -> expr XOR expr
-- On BIGAND reduce production expr -> expr XOR expr
-- On ATMOST reduce production expr -> expr XOR expr
-- On ATLEAST reduce production expr -> expr XOR expr
-- On AND reduce production expr -> expr XOR expr

State 30:
## Known stack suffix:
## expr SUB
## LR(1) items:
expr -> expr SUB . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 31
## Reductions:

State 31:
## Known stack suffix:
## expr SUB expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr SUB expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
## Reductions:
-- On XOR reduce production expr -> expr SUB expr
-- On WHEN reduce production expr -> expr SUB expr
-- On VARTUPLE reduce production expr -> expr SUB expr
-- On VAR reduce production expr -> expr SUB expr
-- On UNION reduce production expr -> expr SUB expr
-- On TUPLE reduce production expr -> expr SUB expr
-- On TOP reduce production expr -> expr SUB expr
-- On THEN reduce production expr -> expr SUB expr
-- On TERM reduce production expr -> expr SUB expr
-- On SUBSET reduce production expr -> expr SUB expr
-- On SUB reduce production expr -> expr SUB expr
-- On RPAREN reduce production expr -> expr SUB expr
-- On RBRACK reduce production expr -> expr SUB expr
-- On RANGE reduce production expr -> expr SUB expr
-- On OR reduce production expr -> expr SUB expr
-- On NOTEQUAL reduce production expr -> expr SUB expr
-- On NOT reduce production expr -> expr SUB expr
-- On NEWLINE reduce production expr -> expr SUB expr
-- On LT reduce production expr -> expr SUB expr
-- On LPAREN reduce production expr -> expr SUB expr
-- On LET reduce production expr -> expr SUB expr
-- On LE reduce production expr -> expr SUB expr
-- On INTER reduce production expr -> expr SUB expr
-- On INT reduce production expr -> expr SUB expr
-- On IN reduce production expr -> expr SUB expr
-- On IMPLIES reduce production expr -> expr SUB expr
-- On IF reduce production expr -> expr SUB expr
-- On GT reduce production expr -> expr SUB expr
-- On GE reduce production expr -> expr SUB expr
-- On FORALL reduce production expr -> expr SUB expr
-- On FLOAT reduce production expr -> expr SUB expr
-- On EXISTS reduce production expr -> expr SUB expr
-- On EXACT reduce production expr -> expr SUB expr
-- On EQUIV reduce production expr -> expr SUB expr
-- On EQUAL reduce production expr -> expr SUB expr
-- On EOF reduce production expr -> expr SUB expr
-- On END reduce production expr -> expr SUB expr
-- On ELSE reduce production expr -> expr SUB expr
-- On DIFF reduce production expr -> expr SUB expr
-- On COMMA reduce production expr -> expr SUB expr
-- On COLON reduce production expr -> expr SUB expr
-- On BOTTOM reduce production expr -> expr SUB expr
-- On BIGOR reduce production expr -> expr SUB expr
-- On BIGAND reduce production expr -> expr SUB expr
-- On ATMOST reduce production expr -> expr SUB expr
-- On ATLEAST reduce production expr -> expr SUB expr
-- On AND reduce production expr -> expr SUB expr
-- On ADD reduce production expr -> expr SUB expr

State 32:
## Known stack suffix:
## expr MUL
## LR(1) items:
expr -> expr MUL . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 33
## Reductions:

State 33:
## Known stack suffix:
## expr MUL expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr MUL expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MOD shift to state 34
## Reductions:
-- On XOR reduce production expr -> expr MUL expr
-- On WHEN reduce production expr -> expr MUL expr
-- On VARTUPLE reduce production expr -> expr MUL expr
-- On VAR reduce production expr -> expr MUL expr
-- On UNION reduce production expr -> expr MUL expr
-- On TUPLE reduce production expr -> expr MUL expr
-- On TOP reduce production expr -> expr MUL expr
-- On THEN reduce production expr -> expr MUL expr
-- On TERM reduce production expr -> expr MUL expr
-- On SUBSET reduce production expr -> expr MUL expr
-- On SUB reduce production expr -> expr MUL expr
-- On RPAREN reduce production expr -> expr MUL expr
-- On RBRACK reduce production expr -> expr MUL expr
-- On RANGE reduce production expr -> expr MUL expr
-- On OR reduce production expr -> expr MUL expr
-- On NOTEQUAL reduce production expr -> expr MUL expr
-- On NOT reduce production expr -> expr MUL expr
-- On NEWLINE reduce production expr -> expr MUL expr
-- On MUL reduce production expr -> expr MUL expr
-- On LT reduce production expr -> expr MUL expr
-- On LPAREN reduce production expr -> expr MUL expr
-- On LET reduce production expr -> expr MUL expr
-- On LE reduce production expr -> expr MUL expr
-- On INTER reduce production expr -> expr MUL expr
-- On INT reduce production expr -> expr MUL expr
-- On IN reduce production expr -> expr MUL expr
-- On IMPLIES reduce production expr -> expr MUL expr
-- On IF reduce production expr -> expr MUL expr
-- On GT reduce production expr -> expr MUL expr
-- On GE reduce production expr -> expr MUL expr
-- On FORALL reduce production expr -> expr MUL expr
-- On FLOAT reduce production expr -> expr MUL expr
-- On EXISTS reduce production expr -> expr MUL expr
-- On EXACT reduce production expr -> expr MUL expr
-- On EQUIV reduce production expr -> expr MUL expr
-- On EQUAL reduce production expr -> expr MUL expr
-- On EOF reduce production expr -> expr MUL expr
-- On END reduce production expr -> expr MUL expr
-- On ELSE reduce production expr -> expr MUL expr
-- On DIV reduce production expr -> expr MUL expr
-- On DIFF reduce production expr -> expr MUL expr
-- On COMMA reduce production expr -> expr MUL expr
-- On COLON reduce production expr -> expr MUL expr
-- On BOTTOM reduce production expr -> expr MUL expr
-- On BIGOR reduce production expr -> expr MUL expr
-- On BIGAND reduce production expr -> expr MUL expr
-- On ATMOST reduce production expr -> expr MUL expr
-- On ATLEAST reduce production expr -> expr MUL expr
-- On AND reduce production expr -> expr MUL expr
-- On ADD reduce production expr -> expr MUL expr

State 34:
## Known stack suffix:
## expr MOD
## LR(1) items:
expr -> expr MOD . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 35
## Reductions:

State 35:
## Known stack suffix:
## expr MOD expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr MOD expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> expr MOD expr

State 36:
## Known stack suffix:
## expr DIV
## LR(1) items:
expr -> expr DIV . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 37
## Reductions:

State 37:
## Known stack suffix:
## expr DIV expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr DIV expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MOD shift to state 34
## Reductions:
-- On XOR reduce production expr -> expr DIV expr
-- On WHEN reduce production expr -> expr DIV expr
-- On VARTUPLE reduce production expr -> expr DIV expr
-- On VAR reduce production expr -> expr DIV expr
-- On UNION reduce production expr -> expr DIV expr
-- On TUPLE reduce production expr -> expr DIV expr
-- On TOP reduce production expr -> expr DIV expr
-- On THEN reduce production expr -> expr DIV expr
-- On TERM reduce production expr -> expr DIV expr
-- On SUBSET reduce production expr -> expr DIV expr
-- On SUB reduce production expr -> expr DIV expr
-- On RPAREN reduce production expr -> expr DIV expr
-- On RBRACK reduce production expr -> expr DIV expr
-- On RANGE reduce production expr -> expr DIV expr
-- On OR reduce production expr -> expr DIV expr
-- On NOTEQUAL reduce production expr -> expr DIV expr
-- On NOT reduce production expr -> expr DIV expr
-- On NEWLINE reduce production expr -> expr DIV expr
-- On MUL reduce production expr -> expr DIV expr
-- On LT reduce production expr -> expr DIV expr
-- On LPAREN reduce production expr -> expr DIV expr
-- On LET reduce production expr -> expr DIV expr
-- On LE reduce production expr -> expr DIV expr
-- On INTER reduce production expr -> expr DIV expr
-- On INT reduce production expr -> expr DIV expr
-- On IN reduce production expr -> expr DIV expr
-- On IMPLIES reduce production expr -> expr DIV expr
-- On IF reduce production expr -> expr DIV expr
-- On GT reduce production expr -> expr DIV expr
-- On GE reduce production expr -> expr DIV expr
-- On FORALL reduce production expr -> expr DIV expr
-- On FLOAT reduce production expr -> expr DIV expr
-- On EXISTS reduce production expr -> expr DIV expr
-- On EXACT reduce production expr -> expr DIV expr
-- On EQUIV reduce production expr -> expr DIV expr
-- On EQUAL reduce production expr -> expr DIV expr
-- On EOF reduce production expr -> expr DIV expr
-- On END reduce production expr -> expr DIV expr
-- On ELSE reduce production expr -> expr DIV expr
-- On DIV reduce production expr -> expr DIV expr
-- On DIFF reduce production expr -> expr DIV expr
-- On COMMA reduce production expr -> expr DIV expr
-- On COLON reduce production expr -> expr DIV expr
-- On BOTTOM reduce production expr -> expr DIV expr
-- On BIGOR reduce production expr -> expr DIV expr
-- On BIGAND reduce production expr -> expr DIV expr
-- On ATMOST reduce production expr -> expr DIV expr
-- On ATLEAST reduce production expr -> expr DIV expr
-- On AND reduce production expr -> expr DIV expr
-- On ADD reduce production expr -> expr DIV expr

State 38:
## Known stack suffix:
## expr NOTEQUAL
## LR(1) items:
expr -> expr NOTEQUAL . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 39
## Reductions:

State 39:
## Known stack suffix:
## expr NOTEQUAL expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr NOTEQUAL expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR reduce production expr -> expr NOTEQUAL expr
-- On WHEN reduce production expr -> expr NOTEQUAL expr
-- On VARTUPLE reduce production expr -> expr NOTEQUAL expr
-- On VAR reduce production expr -> expr NOTEQUAL expr
-- On UNION reduce production expr -> expr NOTEQUAL expr
-- On TUPLE reduce production expr -> expr NOTEQUAL expr
-- On TOP reduce production expr -> expr NOTEQUAL expr
-- On THEN reduce production expr -> expr NOTEQUAL expr
-- On TERM reduce production expr -> expr NOTEQUAL expr
-- On SUBSET reduce production expr -> expr NOTEQUAL expr
-- On RPAREN reduce production expr -> expr NOTEQUAL expr
-- On RBRACK reduce production expr -> expr NOTEQUAL expr
-- On RANGE reduce production expr -> expr NOTEQUAL expr
-- On OR reduce production expr -> expr NOTEQUAL expr
-- On NOT reduce production expr -> expr NOTEQUAL expr
-- On NEWLINE reduce production expr -> expr NOTEQUAL expr
-- On LPAREN reduce production expr -> expr NOTEQUAL expr
-- On LET reduce production expr -> expr NOTEQUAL expr
-- On INTER reduce production expr -> expr NOTEQUAL expr
-- On INT reduce production expr -> expr NOTEQUAL expr
-- On IMPLIES reduce production expr -> expr NOTEQUAL expr
-- On IF reduce production expr -> expr NOTEQUAL expr
-- On FORALL reduce production expr -> expr NOTEQUAL expr
-- On FLOAT reduce production expr -> expr NOTEQUAL expr
-- On EXISTS reduce production expr -> expr NOTEQUAL expr
-- On EXACT reduce production expr -> expr NOTEQUAL expr
-- On EQUIV reduce production expr -> expr NOTEQUAL expr
-- On EOF reduce production expr -> expr NOTEQUAL expr
-- On END reduce production expr -> expr NOTEQUAL expr
-- On ELSE reduce production expr -> expr NOTEQUAL expr
-- On DIFF reduce production expr -> expr NOTEQUAL expr
-- On COMMA reduce production expr -> expr NOTEQUAL expr
-- On COLON reduce production expr -> expr NOTEQUAL expr
-- On BOTTOM reduce production expr -> expr NOTEQUAL expr
-- On BIGOR reduce production expr -> expr NOTEQUAL expr
-- On BIGAND reduce production expr -> expr NOTEQUAL expr
-- On ATMOST reduce production expr -> expr NOTEQUAL expr
-- On ATLEAST reduce production expr -> expr NOTEQUAL expr
-- On AND reduce production expr -> expr NOTEQUAL expr

State 40:
## Known stack suffix:
## expr ADD
## LR(1) items:
expr -> expr ADD . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 41
## Reductions:

State 41:
## Known stack suffix:
## expr ADD expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr ADD expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
## Reductions:
-- On XOR reduce production expr -> expr ADD expr
-- On WHEN reduce production expr -> expr ADD expr
-- On VARTUPLE reduce production expr -> expr ADD expr
-- On VAR reduce production expr -> expr ADD expr
-- On UNION reduce production expr -> expr ADD expr
-- On TUPLE reduce production expr -> expr ADD expr
-- On TOP reduce production expr -> expr ADD expr
-- On THEN reduce production expr -> expr ADD expr
-- On TERM reduce production expr -> expr ADD expr
-- On SUBSET reduce production expr -> expr ADD expr
-- On SUB reduce production expr -> expr ADD expr
-- On RPAREN reduce production expr -> expr ADD expr
-- On RBRACK reduce production expr -> expr ADD expr
-- On RANGE reduce production expr -> expr ADD expr
-- On OR reduce production expr -> expr ADD expr
-- On NOTEQUAL reduce production expr -> expr ADD expr
-- On NOT reduce production expr -> expr ADD expr
-- On NEWLINE reduce production expr -> expr ADD expr
-- On LT reduce production expr -> expr ADD expr
-- On LPAREN reduce production expr -> expr ADD expr
-- On LET reduce production expr -> expr ADD expr
-- On LE reduce production expr -> expr ADD expr
-- On INTER reduce production expr -> expr ADD expr
-- On INT reduce production expr -> expr ADD expr
-- On IN reduce production expr -> expr ADD expr
-- On IMPLIES reduce production expr -> expr ADD expr
-- On IF reduce production expr -> expr ADD expr
-- On GT reduce production expr -> expr ADD expr
-- On GE reduce production expr -> expr ADD expr
-- On FORALL reduce production expr -> expr ADD expr
-- On FLOAT reduce production expr -> expr ADD expr
-- On EXISTS reduce production expr -> expr ADD expr
-- On EXACT reduce production expr -> expr ADD expr
-- On EQUIV reduce production expr -> expr ADD expr
-- On EQUAL reduce production expr -> expr ADD expr
-- On EOF reduce production expr -> expr ADD expr
-- On END reduce production expr -> expr ADD expr
-- On ELSE reduce production expr -> expr ADD expr
-- On DIFF reduce production expr -> expr ADD expr
-- On COMMA reduce production expr -> expr ADD expr
-- On COLON reduce production expr -> expr ADD expr
-- On BOTTOM reduce production expr -> expr ADD expr
-- On BIGOR reduce production expr -> expr ADD expr
-- On BIGAND reduce production expr -> expr ADD expr
-- On ATMOST reduce production expr -> expr ADD expr
-- On ATLEAST reduce production expr -> expr ADD expr
-- On AND reduce production expr -> expr ADD expr
-- On ADD reduce production expr -> expr ADD expr

State 42:
## Known stack suffix:
## expr LT
## LR(1) items:
expr -> expr LT . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 43
## Reductions:

State 43:
## Known stack suffix:
## expr LT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr LT expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR reduce production expr -> expr LT expr
-- On WHEN reduce production expr -> expr LT expr
-- On VARTUPLE reduce production expr -> expr LT expr
-- On VAR reduce production expr -> expr LT expr
-- On UNION reduce production expr -> expr LT expr
-- On TUPLE reduce production expr -> expr LT expr
-- On TOP reduce production expr -> expr LT expr
-- On THEN reduce production expr -> expr LT expr
-- On TERM reduce production expr -> expr LT expr
-- On SUBSET reduce production expr -> expr LT expr
-- On RPAREN reduce production expr -> expr LT expr
-- On RBRACK reduce production expr -> expr LT expr
-- On RANGE reduce production expr -> expr LT expr
-- On OR reduce production expr -> expr LT expr
-- On NOT reduce production expr -> expr LT expr
-- On NEWLINE reduce production expr -> expr LT expr
-- On LPAREN reduce production expr -> expr LT expr
-- On LET reduce production expr -> expr LT expr
-- On INTER reduce production expr -> expr LT expr
-- On INT reduce production expr -> expr LT expr
-- On IMPLIES reduce production expr -> expr LT expr
-- On IF reduce production expr -> expr LT expr
-- On FORALL reduce production expr -> expr LT expr
-- On FLOAT reduce production expr -> expr LT expr
-- On EXISTS reduce production expr -> expr LT expr
-- On EXACT reduce production expr -> expr LT expr
-- On EQUIV reduce production expr -> expr LT expr
-- On EOF reduce production expr -> expr LT expr
-- On END reduce production expr -> expr LT expr
-- On ELSE reduce production expr -> expr LT expr
-- On DIFF reduce production expr -> expr LT expr
-- On COMMA reduce production expr -> expr LT expr
-- On COLON reduce production expr -> expr LT expr
-- On BOTTOM reduce production expr -> expr LT expr
-- On BIGOR reduce production expr -> expr LT expr
-- On BIGAND reduce production expr -> expr LT expr
-- On ATMOST reduce production expr -> expr LT expr
-- On ATLEAST reduce production expr -> expr LT expr
-- On AND reduce production expr -> expr LT expr

State 44:
## Known stack suffix:
## expr LE
## LR(1) items:
expr -> expr LE . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 45
## Reductions:

State 45:
## Known stack suffix:
## expr LE expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr LE expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR reduce production expr -> expr LE expr
-- On WHEN reduce production expr -> expr LE expr
-- On VARTUPLE reduce production expr -> expr LE expr
-- On VAR reduce production expr -> expr LE expr
-- On UNION reduce production expr -> expr LE expr
-- On TUPLE reduce production expr -> expr LE expr
-- On TOP reduce production expr -> expr LE expr
-- On THEN reduce production expr -> expr LE expr
-- On TERM reduce production expr -> expr LE expr
-- On SUBSET reduce production expr -> expr LE expr
-- On RPAREN reduce production expr -> expr LE expr
-- On RBRACK reduce production expr -> expr LE expr
-- On RANGE reduce production expr -> expr LE expr
-- On OR reduce production expr -> expr LE expr
-- On NOT reduce production expr -> expr LE expr
-- On NEWLINE reduce production expr -> expr LE expr
-- On LPAREN reduce production expr -> expr LE expr
-- On LET reduce production expr -> expr LE expr
-- On INTER reduce production expr -> expr LE expr
-- On INT reduce production expr -> expr LE expr
-- On IMPLIES reduce production expr -> expr LE expr
-- On IF reduce production expr -> expr LE expr
-- On FORALL reduce production expr -> expr LE expr
-- On FLOAT reduce production expr -> expr LE expr
-- On EXISTS reduce production expr -> expr LE expr
-- On EXACT reduce production expr -> expr LE expr
-- On EQUIV reduce production expr -> expr LE expr
-- On EOF reduce production expr -> expr LE expr
-- On END reduce production expr -> expr LE expr
-- On ELSE reduce production expr -> expr LE expr
-- On DIFF reduce production expr -> expr LE expr
-- On COMMA reduce production expr -> expr LE expr
-- On COLON reduce production expr -> expr LE expr
-- On BOTTOM reduce production expr -> expr LE expr
-- On BIGOR reduce production expr -> expr LE expr
-- On BIGAND reduce production expr -> expr LE expr
-- On ATMOST reduce production expr -> expr LE expr
-- On ATLEAST reduce production expr -> expr LE expr
-- On AND reduce production expr -> expr LE expr

State 46:
## Known stack suffix:
## expr IN
## LR(1) items:
expr -> expr IN . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 47
## Reductions:

State 47:
## Known stack suffix:
## expr IN expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr IN expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR reduce production expr -> expr IN expr
-- On WHEN reduce production expr -> expr IN expr
-- On VARTUPLE reduce production expr -> expr IN expr
-- On VAR reduce production expr -> expr IN expr
-- On UNION reduce production expr -> expr IN expr
-- On TUPLE reduce production expr -> expr IN expr
-- On TOP reduce production expr -> expr IN expr
-- On THEN reduce production expr -> expr IN expr
-- On TERM reduce production expr -> expr IN expr
-- On SUBSET reduce production expr -> expr IN expr
-- On RPAREN reduce production expr -> expr IN expr
-- On RBRACK reduce production expr -> expr IN expr
-- On RANGE reduce production expr -> expr IN expr
-- On OR reduce production expr -> expr IN expr
-- On NOT reduce production expr -> expr IN expr
-- On NEWLINE reduce production expr -> expr IN expr
-- On LPAREN reduce production expr -> expr IN expr
-- On LET reduce production expr -> expr IN expr
-- On INTER reduce production expr -> expr IN expr
-- On INT reduce production expr -> expr IN expr
-- On IMPLIES reduce production expr -> expr IN expr
-- On IF reduce production expr -> expr IN expr
-- On FORALL reduce production expr -> expr IN expr
-- On FLOAT reduce production expr -> expr IN expr
-- On EXISTS reduce production expr -> expr IN expr
-- On EXACT reduce production expr -> expr IN expr
-- On EQUIV reduce production expr -> expr IN expr
-- On EOF reduce production expr -> expr IN expr
-- On END reduce production expr -> expr IN expr
-- On ELSE reduce production expr -> expr IN expr
-- On DIFF reduce production expr -> expr IN expr
-- On COMMA reduce production expr -> expr IN expr
-- On COLON reduce production expr -> expr IN expr
-- On BOTTOM reduce production expr -> expr IN expr
-- On BIGOR reduce production expr -> expr IN expr
-- On BIGAND reduce production expr -> expr IN expr
-- On ATMOST reduce production expr -> expr IN expr
-- On ATLEAST reduce production expr -> expr IN expr
-- On AND reduce production expr -> expr IN expr

State 48:
## Known stack suffix:
## expr GT
## LR(1) items:
expr -> expr GT . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 49
## Reductions:

State 49:
## Known stack suffix:
## expr GT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr GT expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR reduce production expr -> expr GT expr
-- On WHEN reduce production expr -> expr GT expr
-- On VARTUPLE reduce production expr -> expr GT expr
-- On VAR reduce production expr -> expr GT expr
-- On UNION reduce production expr -> expr GT expr
-- On TUPLE reduce production expr -> expr GT expr
-- On TOP reduce production expr -> expr GT expr
-- On THEN reduce production expr -> expr GT expr
-- On TERM reduce production expr -> expr GT expr
-- On SUBSET reduce production expr -> expr GT expr
-- On RPAREN reduce production expr -> expr GT expr
-- On RBRACK reduce production expr -> expr GT expr
-- On RANGE reduce production expr -> expr GT expr
-- On OR reduce production expr -> expr GT expr
-- On NOT reduce production expr -> expr GT expr
-- On NEWLINE reduce production expr -> expr GT expr
-- On LPAREN reduce production expr -> expr GT expr
-- On LET reduce production expr -> expr GT expr
-- On INTER reduce production expr -> expr GT expr
-- On INT reduce production expr -> expr GT expr
-- On IMPLIES reduce production expr -> expr GT expr
-- On IF reduce production expr -> expr GT expr
-- On FORALL reduce production expr -> expr GT expr
-- On FLOAT reduce production expr -> expr GT expr
-- On EXISTS reduce production expr -> expr GT expr
-- On EXACT reduce production expr -> expr GT expr
-- On EQUIV reduce production expr -> expr GT expr
-- On EOF reduce production expr -> expr GT expr
-- On END reduce production expr -> expr GT expr
-- On ELSE reduce production expr -> expr GT expr
-- On DIFF reduce production expr -> expr GT expr
-- On COMMA reduce production expr -> expr GT expr
-- On COLON reduce production expr -> expr GT expr
-- On BOTTOM reduce production expr -> expr GT expr
-- On BIGOR reduce production expr -> expr GT expr
-- On BIGAND reduce production expr -> expr GT expr
-- On ATMOST reduce production expr -> expr GT expr
-- On ATLEAST reduce production expr -> expr GT expr
-- On AND reduce production expr -> expr GT expr

State 50:
## Known stack suffix:
## expr GE
## LR(1) items:
expr -> expr GE . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 51
## Reductions:

State 51:
## Known stack suffix:
## expr GE expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr GE expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR reduce production expr -> expr GE expr
-- On WHEN reduce production expr -> expr GE expr
-- On VARTUPLE reduce production expr -> expr GE expr
-- On VAR reduce production expr -> expr GE expr
-- On UNION reduce production expr -> expr GE expr
-- On TUPLE reduce production expr -> expr GE expr
-- On TOP reduce production expr -> expr GE expr
-- On THEN reduce production expr -> expr GE expr
-- On TERM reduce production expr -> expr GE expr
-- On SUBSET reduce production expr -> expr GE expr
-- On RPAREN reduce production expr -> expr GE expr
-- On RBRACK reduce production expr -> expr GE expr
-- On RANGE reduce production expr -> expr GE expr
-- On OR reduce production expr -> expr GE expr
-- On NOT reduce production expr -> expr GE expr
-- On NEWLINE reduce production expr -> expr GE expr
-- On LPAREN reduce production expr -> expr GE expr
-- On LET reduce production expr -> expr GE expr
-- On INTER reduce production expr -> expr GE expr
-- On INT reduce production expr -> expr GE expr
-- On IMPLIES reduce production expr -> expr GE expr
-- On IF reduce production expr -> expr GE expr
-- On FORALL reduce production expr -> expr GE expr
-- On FLOAT reduce production expr -> expr GE expr
-- On EXISTS reduce production expr -> expr GE expr
-- On EXACT reduce production expr -> expr GE expr
-- On EQUIV reduce production expr -> expr GE expr
-- On EOF reduce production expr -> expr GE expr
-- On END reduce production expr -> expr GE expr
-- On ELSE reduce production expr -> expr GE expr
-- On DIFF reduce production expr -> expr GE expr
-- On COMMA reduce production expr -> expr GE expr
-- On COLON reduce production expr -> expr GE expr
-- On BOTTOM reduce production expr -> expr GE expr
-- On BIGOR reduce production expr -> expr GE expr
-- On BIGAND reduce production expr -> expr GE expr
-- On ATMOST reduce production expr -> expr GE expr
-- On ATLEAST reduce production expr -> expr GE expr
-- On AND reduce production expr -> expr GE expr

State 52:
## Known stack suffix:
## expr EQUAL
## LR(1) items:
expr -> expr EQUAL . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 53
## Reductions:

State 53:
## Known stack suffix:
## expr EQUAL expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr EQUAL expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR reduce production expr -> expr EQUAL expr
-- On WHEN reduce production expr -> expr EQUAL expr
-- On VARTUPLE reduce production expr -> expr EQUAL expr
-- On VAR reduce production expr -> expr EQUAL expr
-- On UNION reduce production expr -> expr EQUAL expr
-- On TUPLE reduce production expr -> expr EQUAL expr
-- On TOP reduce production expr -> expr EQUAL expr
-- On THEN reduce production expr -> expr EQUAL expr
-- On TERM reduce production expr -> expr EQUAL expr
-- On SUBSET reduce production expr -> expr EQUAL expr
-- On RPAREN reduce production expr -> expr EQUAL expr
-- On RBRACK reduce production expr -> expr EQUAL expr
-- On RANGE reduce production expr -> expr EQUAL expr
-- On OR reduce production expr -> expr EQUAL expr
-- On NOT reduce production expr -> expr EQUAL expr
-- On NEWLINE reduce production expr -> expr EQUAL expr
-- On LPAREN reduce production expr -> expr EQUAL expr
-- On LET reduce production expr -> expr EQUAL expr
-- On INTER reduce production expr -> expr EQUAL expr
-- On INT reduce production expr -> expr EQUAL expr
-- On IMPLIES reduce production expr -> expr EQUAL expr
-- On IF reduce production expr -> expr EQUAL expr
-- On FORALL reduce production expr -> expr EQUAL expr
-- On FLOAT reduce production expr -> expr EQUAL expr
-- On EXISTS reduce production expr -> expr EQUAL expr
-- On EXACT reduce production expr -> expr EQUAL expr
-- On EQUIV reduce production expr -> expr EQUAL expr
-- On EOF reduce production expr -> expr EQUAL expr
-- On END reduce production expr -> expr EQUAL expr
-- On ELSE reduce production expr -> expr EQUAL expr
-- On DIFF reduce production expr -> expr EQUAL expr
-- On COMMA reduce production expr -> expr EQUAL expr
-- On COLON reduce production expr -> expr EQUAL expr
-- On BOTTOM reduce production expr -> expr EQUAL expr
-- On BIGOR reduce production expr -> expr EQUAL expr
-- On BIGAND reduce production expr -> expr EQUAL expr
-- On ATMOST reduce production expr -> expr EQUAL expr
-- On ATLEAST reduce production expr -> expr EQUAL expr
-- On AND reduce production expr -> expr EQUAL expr

State 54:
## Known stack suffix:
## expr UNION
## LR(1) items:
expr -> expr UNION . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 55
## Reductions:

State 55:
## Known stack suffix:
## expr UNION expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr UNION expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN reduce production expr -> expr UNION expr
-- On VARTUPLE reduce production expr -> expr UNION expr
-- On VAR reduce production expr -> expr UNION expr
-- On UNION reduce production expr -> expr UNION expr
-- On TUPLE reduce production expr -> expr UNION expr
-- On TOP reduce production expr -> expr UNION expr
-- On THEN reduce production expr -> expr UNION expr
-- On TERM reduce production expr -> expr UNION expr
-- On RPAREN reduce production expr -> expr UNION expr
-- On RBRACK reduce production expr -> expr UNION expr
-- On RANGE reduce production expr -> expr UNION expr
-- On NOT reduce production expr -> expr UNION expr
-- On NEWLINE reduce production expr -> expr UNION expr
-- On LPAREN reduce production expr -> expr UNION expr
-- On LET reduce production expr -> expr UNION expr
-- On INTER reduce production expr -> expr UNION expr
-- On INT reduce production expr -> expr UNION expr
-- On IF reduce production expr -> expr UNION expr
-- On FORALL reduce production expr -> expr UNION expr
-- On FLOAT reduce production expr -> expr UNION expr
-- On EXISTS reduce production expr -> expr UNION expr
-- On EXACT reduce production expr -> expr UNION expr
-- On EOF reduce production expr -> expr UNION expr
-- On END reduce production expr -> expr UNION expr
-- On ELSE reduce production expr -> expr UNION expr
-- On DIFF reduce production expr -> expr UNION expr
-- On COMMA reduce production expr -> expr UNION expr
-- On COLON reduce production expr -> expr UNION expr
-- On BOTTOM reduce production expr -> expr UNION expr
-- On BIGOR reduce production expr -> expr UNION expr
-- On BIGAND reduce production expr -> expr UNION expr
-- On ATMOST reduce production expr -> expr UNION expr
-- On ATLEAST reduce production expr -> expr UNION expr

State 56:
## Known stack suffix:
## expr SUBSET
## LR(1) items:
expr -> expr SUBSET . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 57
## Reductions:

State 57:
## Known stack suffix:
## expr SUBSET expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr SUBSET expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN reduce production expr -> expr SUBSET expr
-- On VARTUPLE reduce production expr -> expr SUBSET expr
-- On VAR reduce production expr -> expr SUBSET expr
-- On UNION reduce production expr -> expr SUBSET expr
-- On TUPLE reduce production expr -> expr SUBSET expr
-- On TOP reduce production expr -> expr SUBSET expr
-- On THEN reduce production expr -> expr SUBSET expr
-- On TERM reduce production expr -> expr SUBSET expr
-- On SUBSET reduce production expr -> expr SUBSET expr
-- On RPAREN reduce production expr -> expr SUBSET expr
-- On RBRACK reduce production expr -> expr SUBSET expr
-- On RANGE reduce production expr -> expr SUBSET expr
-- On NOT reduce production expr -> expr SUBSET expr
-- On NEWLINE reduce production expr -> expr SUBSET expr
-- On LPAREN reduce production expr -> expr SUBSET expr
-- On LET reduce production expr -> expr SUBSET expr
-- On INTER reduce production expr -> expr SUBSET expr
-- On INT reduce production expr -> expr SUBSET expr
-- On IF reduce production expr -> expr SUBSET expr
-- On FORALL reduce production expr -> expr SUBSET expr
-- On FLOAT reduce production expr -> expr SUBSET expr
-- On EXISTS reduce production expr -> expr SUBSET expr
-- On EXACT reduce production expr -> expr SUBSET expr
-- On EOF reduce production expr -> expr SUBSET expr
-- On END reduce production expr -> expr SUBSET expr
-- On ELSE reduce production expr -> expr SUBSET expr
-- On DIFF reduce production expr -> expr SUBSET expr
-- On COMMA reduce production expr -> expr SUBSET expr
-- On COLON reduce production expr -> expr SUBSET expr
-- On BOTTOM reduce production expr -> expr SUBSET expr
-- On BIGOR reduce production expr -> expr SUBSET expr
-- On BIGAND reduce production expr -> expr SUBSET expr
-- On ATMOST reduce production expr -> expr SUBSET expr
-- On ATLEAST reduce production expr -> expr SUBSET expr

State 58:
## Known stack suffix:
## expr OR
## LR(1) items:
expr -> expr OR . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 59
## Reductions:

State 59:
## Known stack suffix:
## expr OR expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr OR expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUB shift to state 30
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN reduce production expr -> expr OR expr
-- On VARTUPLE reduce production expr -> expr OR expr
-- On VAR reduce production expr -> expr OR expr
-- On UNION reduce production expr -> expr OR expr
-- On TUPLE reduce production expr -> expr OR expr
-- On TOP reduce production expr -> expr OR expr
-- On THEN reduce production expr -> expr OR expr
-- On TERM reduce production expr -> expr OR expr
-- On SUBSET reduce production expr -> expr OR expr
-- On RPAREN reduce production expr -> expr OR expr
-- On RBRACK reduce production expr -> expr OR expr
-- On RANGE reduce production expr -> expr OR expr
-- On OR reduce production expr -> expr OR expr
-- On NOT reduce production expr -> expr OR expr
-- On NEWLINE reduce production expr -> expr OR expr
-- On LPAREN reduce production expr -> expr OR expr
-- On LET reduce production expr -> expr OR expr
-- On INTER reduce production expr -> expr OR expr
-- On INT reduce production expr -> expr OR expr
-- On IMPLIES reduce production expr -> expr OR expr
-- On IF reduce production expr -> expr OR expr
-- On FORALL reduce production expr -> expr OR expr
-- On FLOAT reduce production expr -> expr OR expr
-- On EXISTS reduce production expr -> expr OR expr
-- On EXACT reduce production expr -> expr OR expr
-- On EQUIV reduce production expr -> expr OR expr
-- On EOF reduce production expr -> expr OR expr
-- On END reduce production expr -> expr OR expr
-- On ELSE reduce production expr -> expr OR expr
-- On DIFF reduce production expr -> expr OR expr
-- On COMMA reduce production expr -> expr OR expr
-- On COLON reduce production expr -> expr OR expr
-- On BOTTOM reduce production expr -> expr OR expr
-- On BIGOR reduce production expr -> expr OR expr
-- On BIGAND reduce production expr -> expr OR expr
-- On ATMOST reduce production expr -> expr OR expr
-- On ATLEAST reduce production expr -> expr OR expr

State 60:
## Known stack suffix:
## expr AND
## LR(1) items:
expr -> expr AND . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 61
## Reductions:

State 61:
## Known stack suffix:
## expr AND expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr AND expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUB shift to state 30
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On WHEN reduce production expr -> expr AND expr
-- On VARTUPLE reduce production expr -> expr AND expr
-- On VAR reduce production expr -> expr AND expr
-- On UNION reduce production expr -> expr AND expr
-- On TUPLE reduce production expr -> expr AND expr
-- On TOP reduce production expr -> expr AND expr
-- On THEN reduce production expr -> expr AND expr
-- On TERM reduce production expr -> expr AND expr
-- On SUBSET reduce production expr -> expr AND expr
-- On RPAREN reduce production expr -> expr AND expr
-- On RBRACK reduce production expr -> expr AND expr
-- On RANGE reduce production expr -> expr AND expr
-- On OR reduce production expr -> expr AND expr
-- On NOT reduce production expr -> expr AND expr
-- On NEWLINE reduce production expr -> expr AND expr
-- On LPAREN reduce production expr -> expr AND expr
-- On LET reduce production expr -> expr AND expr
-- On INTER reduce production expr -> expr AND expr
-- On INT reduce production expr -> expr AND expr
-- On IMPLIES reduce production expr -> expr AND expr
-- On IF reduce production expr -> expr AND expr
-- On FORALL reduce production expr -> expr AND expr
-- On FLOAT reduce production expr -> expr AND expr
-- On EXISTS reduce production expr -> expr AND expr
-- On EXACT reduce production expr -> expr AND expr
-- On EQUIV reduce production expr -> expr AND expr
-- On EOF reduce production expr -> expr AND expr
-- On END reduce production expr -> expr AND expr
-- On ELSE reduce production expr -> expr AND expr
-- On DIFF reduce production expr -> expr AND expr
-- On COMMA reduce production expr -> expr AND expr
-- On COLON reduce production expr -> expr AND expr
-- On BOTTOM reduce production expr -> expr AND expr
-- On BIGOR reduce production expr -> expr AND expr
-- On BIGAND reduce production expr -> expr AND expr
-- On ATMOST reduce production expr -> expr AND expr
-- On ATLEAST reduce production expr -> expr AND expr
-- On AND reduce production expr -> expr AND expr

State 62:
## Known stack suffix:
## expr IMPLIES
## LR(1) items:
expr -> expr IMPLIES . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 63
## Reductions:

State 63:
## Known stack suffix:
## expr IMPLIES expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr IMPLIES expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN reduce production expr -> expr IMPLIES expr
-- On VARTUPLE reduce production expr -> expr IMPLIES expr
-- On VAR reduce production expr -> expr IMPLIES expr
-- On UNION reduce production expr -> expr IMPLIES expr
-- On TUPLE reduce production expr -> expr IMPLIES expr
-- On TOP reduce production expr -> expr IMPLIES expr
-- On THEN reduce production expr -> expr IMPLIES expr
-- On TERM reduce production expr -> expr IMPLIES expr
-- On SUBSET reduce production expr -> expr IMPLIES expr
-- On RPAREN reduce production expr -> expr IMPLIES expr
-- On RBRACK reduce production expr -> expr IMPLIES expr
-- On RANGE reduce production expr -> expr IMPLIES expr
-- On NOT reduce production expr -> expr IMPLIES expr
-- On NEWLINE reduce production expr -> expr IMPLIES expr
-- On LPAREN reduce production expr -> expr IMPLIES expr
-- On LET reduce production expr -> expr IMPLIES expr
-- On INTER reduce production expr -> expr IMPLIES expr
-- On INT reduce production expr -> expr IMPLIES expr
-- On IF reduce production expr -> expr IMPLIES expr
-- On FORALL reduce production expr -> expr IMPLIES expr
-- On FLOAT reduce production expr -> expr IMPLIES expr
-- On EXISTS reduce production expr -> expr IMPLIES expr
-- On EXACT reduce production expr -> expr IMPLIES expr
-- On EOF reduce production expr -> expr IMPLIES expr
-- On END reduce production expr -> expr IMPLIES expr
-- On ELSE reduce production expr -> expr IMPLIES expr
-- On DIFF reduce production expr -> expr IMPLIES expr
-- On COMMA reduce production expr -> expr IMPLIES expr
-- On COLON reduce production expr -> expr IMPLIES expr
-- On BOTTOM reduce production expr -> expr IMPLIES expr
-- On BIGOR reduce production expr -> expr IMPLIES expr
-- On BIGAND reduce production expr -> expr IMPLIES expr
-- On ATMOST reduce production expr -> expr IMPLIES expr
-- On ATLEAST reduce production expr -> expr IMPLIES expr

State 64:
## Known stack suffix:
## expr EQUIV
## LR(1) items:
expr -> expr EQUIV . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 65
## Reductions:

State 65:
## Known stack suffix:
## expr EQUIV expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr EQUIV expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN reduce production expr -> expr EQUIV expr
-- On VARTUPLE reduce production expr -> expr EQUIV expr
-- On VAR reduce production expr -> expr EQUIV expr
-- On UNION reduce production expr -> expr EQUIV expr
-- On TUPLE reduce production expr -> expr EQUIV expr
-- On TOP reduce production expr -> expr EQUIV expr
-- On THEN reduce production expr -> expr EQUIV expr
-- On TERM reduce production expr -> expr EQUIV expr
-- On SUBSET reduce production expr -> expr EQUIV expr
-- On RPAREN reduce production expr -> expr EQUIV expr
-- On RBRACK reduce production expr -> expr EQUIV expr
-- On RANGE reduce production expr -> expr EQUIV expr
-- On NOT reduce production expr -> expr EQUIV expr
-- On NEWLINE reduce production expr -> expr EQUIV expr
-- On LPAREN reduce production expr -> expr EQUIV expr
-- On LET reduce production expr -> expr EQUIV expr
-- On INTER reduce production expr -> expr EQUIV expr
-- On INT reduce production expr -> expr EQUIV expr
-- On IF reduce production expr -> expr EQUIV expr
-- On FORALL reduce production expr -> expr EQUIV expr
-- On FLOAT reduce production expr -> expr EQUIV expr
-- On EXISTS reduce production expr -> expr EQUIV expr
-- On EXACT reduce production expr -> expr EQUIV expr
-- On EOF reduce production expr -> expr EQUIV expr
-- On END reduce production expr -> expr EQUIV expr
-- On ELSE reduce production expr -> expr EQUIV expr
-- On DIFF reduce production expr -> expr EQUIV expr
-- On COMMA reduce production expr -> expr EQUIV expr
-- On COLON reduce production expr -> expr EQUIV expr
-- On BOTTOM reduce production expr -> expr EQUIV expr
-- On BIGOR reduce production expr -> expr EQUIV expr
-- On BIGAND reduce production expr -> expr EQUIV expr
-- On ATMOST reduce production expr -> expr EQUIV expr
-- On ATLEAST reduce production expr -> expr EQUIV expr

State 66:
## Known stack suffix:
## ABS expr RPAREN
## LR(1) items:
expr -> ABS expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> ABS expr RPAREN

State 67:
## Known stack suffix:
## expr INTER
## LR(1) items:
expr -> expr INTER . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 68
## Reductions:

State 68:
## Known stack suffix:
## expr INTER expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr INTER expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN reduce production expr -> expr INTER expr
-- On VARTUPLE reduce production expr -> expr INTER expr
-- On VAR reduce production expr -> expr INTER expr
-- On TUPLE reduce production expr -> expr INTER expr
-- On TOP reduce production expr -> expr INTER expr
-- On THEN reduce production expr -> expr INTER expr
-- On TERM reduce production expr -> expr INTER expr
-- On RPAREN reduce production expr -> expr INTER expr
-- On RBRACK reduce production expr -> expr INTER expr
-- On RANGE reduce production expr -> expr INTER expr
-- On NOT reduce production expr -> expr INTER expr
-- On NEWLINE reduce production expr -> expr INTER expr
-- On LPAREN reduce production expr -> expr INTER expr
-- On LET reduce production expr -> expr INTER expr
-- On INTER reduce production expr -> expr INTER expr
-- On INT reduce production expr -> expr INTER expr
-- On IF reduce production expr -> expr INTER expr
-- On FORALL reduce production expr -> expr INTER expr
-- On FLOAT reduce production expr -> expr INTER expr
-- On EXISTS reduce production expr -> expr INTER expr
-- On EXACT reduce production expr -> expr INTER expr
-- On EOF reduce production expr -> expr INTER expr
-- On END reduce production expr -> expr INTER expr
-- On ELSE reduce production expr -> expr INTER expr
-- On COMMA reduce production expr -> expr INTER expr
-- On COLON reduce production expr -> expr INTER expr
-- On BOTTOM reduce production expr -> expr INTER expr
-- On BIGOR reduce production expr -> expr INTER expr
-- On BIGAND reduce production expr -> expr INTER expr
-- On ATMOST reduce production expr -> expr INTER expr
-- On ATLEAST reduce production expr -> expr INTER expr

State 69:
## Known stack suffix:
## expr DIFF
## LR(1) items:
expr -> expr DIFF . expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 70
## Reductions:

State 70:
## Known stack suffix:
## expr DIFF expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr DIFF expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN reduce production expr -> expr DIFF expr
-- On VARTUPLE reduce production expr -> expr DIFF expr
-- On VAR reduce production expr -> expr DIFF expr
-- On UNION reduce production expr -> expr DIFF expr
-- On TUPLE reduce production expr -> expr DIFF expr
-- On TOP reduce production expr -> expr DIFF expr
-- On THEN reduce production expr -> expr DIFF expr
-- On TERM reduce production expr -> expr DIFF expr
-- On RPAREN reduce production expr -> expr DIFF expr
-- On RBRACK reduce production expr -> expr DIFF expr
-- On RANGE reduce production expr -> expr DIFF expr
-- On NOT reduce production expr -> expr DIFF expr
-- On NEWLINE reduce production expr -> expr DIFF expr
-- On LPAREN reduce production expr -> expr DIFF expr
-- On LET reduce production expr -> expr DIFF expr
-- On INTER reduce production expr -> expr DIFF expr
-- On INT reduce production expr -> expr DIFF expr
-- On IF reduce production expr -> expr DIFF expr
-- On FORALL reduce production expr -> expr DIFF expr
-- On FLOAT reduce production expr -> expr DIFF expr
-- On EXISTS reduce production expr -> expr DIFF expr
-- On EXACT reduce production expr -> expr DIFF expr
-- On EOF reduce production expr -> expr DIFF expr
-- On END reduce production expr -> expr DIFF expr
-- On ELSE reduce production expr -> expr DIFF expr
-- On DIFF reduce production expr -> expr DIFF expr
-- On COMMA reduce production expr -> expr DIFF expr
-- On COLON reduce production expr -> expr DIFF expr
-- On BOTTOM reduce production expr -> expr DIFF expr
-- On BIGOR reduce production expr -> expr DIFF expr
-- On BIGAND reduce production expr -> expr DIFF expr
-- On ATMOST reduce production expr -> expr DIFF expr
-- On ATLEAST reduce production expr -> expr DIFF expr

State 71:
## Known stack suffix:
## CARD expr
## LR(1) items:
expr -> CARD expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 72
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 72:
## Known stack suffix:
## CARD expr RPAREN
## LR(1) items:
expr -> CARD expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> CARD expr RPAREN

State 73:
## Known stack suffix:
## DIFF_PR expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> DIFF_PR expr . COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 74
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 74:
## Known stack suffix:
## DIFF_PR expr COMMA
## LR(1) items:
expr -> DIFF_PR expr COMMA . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 75
## Reductions:

State 75:
## Known stack suffix:
## DIFF_PR expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> DIFF_PR expr COMMA expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 76
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 76:
## Known stack suffix:
## DIFF_PR expr COMMA expr RPAREN
## LR(1) items:
expr -> DIFF_PR expr COMMA expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> DIFF_PR expr COMMA expr RPAREN

State 77:
## Known stack suffix:
## EMPTY expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> EMPTY expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 78
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 78:
## Known stack suffix:
## EMPTY expr RPAREN
## LR(1) items:
expr -> EMPTY expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> EMPTY expr RPAREN

State 79:
## Known stack suffix:
## IF expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> IF expr . THEN expr ELSE expr END [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On THEN shift to state 80
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 80:
## Known stack suffix:
## IF expr THEN
## LR(1) items:
expr -> IF expr THEN . expr ELSE expr END [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 81
## Reductions:

State 81:
## Known stack suffix:
## IF expr THEN expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> IF expr THEN expr . ELSE expr END [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL ELSE DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On ELSE shift to state 82
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 82:
## Known stack suffix:
## IF expr THEN expr ELSE
## LR(1) items:
expr -> IF expr THEN expr ELSE . expr END [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 83
## Reductions:

State 83:
## Known stack suffix:
## IF expr THEN expr ELSE expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> IF expr THEN expr ELSE expr . END [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL END DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On END shift to state 84
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 84:
## Known stack suffix:
## IF expr THEN expr ELSE expr END
## LR(1) items:
expr -> IF expr THEN expr ELSE expr END . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> IF expr THEN expr ELSE expr END

State 85:
## Known stack suffix:
## INTER_PR expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> INTER_PR expr . COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 86
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 86:
## Known stack suffix:
## INTER_PR expr COMMA
## LR(1) items:
expr -> INTER_PR expr COMMA . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 87
## Reductions:

State 87:
## Known stack suffix:
## INTER_PR expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> INTER_PR expr COMMA expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 88
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 88:
## Known stack suffix:
## INTER_PR expr COMMA expr RPAREN
## LR(1) items:
expr -> INTER_PR expr COMMA expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> INTER_PR expr COMMA expr RPAREN

State 89:
## Known stack suffix:
## LBRACK expr
## LR(1) items:
comma_list(expr) -> expr . [ RBRACK ]
comma_list(expr) -> expr . COMMA comma_list(expr) [ RBRACK ]
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> LBRACK expr . RANGE expr RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RBRACK RANGE OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RANGE shift to state 90
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 93
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN reduce production comma_list(expr) -> expr
-- On VARTUPLE reduce production comma_list(expr) -> expr
-- On VAR reduce production comma_list(expr) -> expr
-- On UNION_PR reduce production comma_list(expr) -> expr
-- On TUPLE reduce production comma_list(expr) -> expr
-- On TOP reduce production comma_list(expr) -> expr
-- On TOINT reduce production comma_list(expr) -> expr
-- On TOFLOAT reduce production comma_list(expr) -> expr
-- On THEN reduce production comma_list(expr) -> expr
-- On TERM reduce production comma_list(expr) -> expr
-- On SUBSET_PR reduce production comma_list(expr) -> expr
-- On SQRT reduce production comma_list(expr) -> expr
-- On RPAREN reduce production comma_list(expr) -> expr
-- On RBRACK reduce production comma_list(expr) -> expr
-- On POWERSET reduce production comma_list(expr) -> expr
-- On NOT reduce production comma_list(expr) -> expr
-- On NEWLINE reduce production comma_list(expr) -> expr
-- On LPAREN reduce production comma_list(expr) -> expr
-- On LET reduce production comma_list(expr) -> expr
-- On LBRACK reduce production comma_list(expr) -> expr
-- On INTER_PR reduce production comma_list(expr) -> expr
-- On INT reduce production comma_list(expr) -> expr
-- On IF reduce production comma_list(expr) -> expr
-- On FORALL reduce production comma_list(expr) -> expr
-- On FOR reduce production comma_list(expr) -> expr
-- On FLOAT reduce production comma_list(expr) -> expr
-- On EXISTS reduce production comma_list(expr) -> expr
-- On EXACT reduce production comma_list(expr) -> expr
-- On EOF reduce production comma_list(expr) -> expr
-- On END reduce production comma_list(expr) -> expr
-- On EMPTY reduce production comma_list(expr) -> expr
-- On ELSE reduce production comma_list(expr) -> expr
-- On DIFF_PR reduce production comma_list(expr) -> expr
-- On DATA reduce production comma_list(expr) -> expr
-- On COLON reduce production comma_list(expr) -> expr
-- On CARD reduce production comma_list(expr) -> expr
-- On BOTTOM reduce production comma_list(expr) -> expr
-- On BOOL reduce production comma_list(expr) -> expr
-- On BIGOR reduce production comma_list(expr) -> expr
-- On BIGAND reduce production comma_list(expr) -> expr
-- On ATMOST reduce production comma_list(expr) -> expr
-- On ATLEAST reduce production comma_list(expr) -> expr
-- On AFFECT reduce production comma_list(expr) -> expr
-- On ABS reduce production comma_list(expr) -> expr

State 90:
## Known stack suffix:
## LBRACK expr RANGE
## LR(1) items:
expr -> LBRACK expr RANGE . expr RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 91
## Reductions:

State 91:
## Known stack suffix:
## LBRACK expr RANGE expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> LBRACK expr RANGE expr . RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RBRACK shift to state 92
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 92:
## Known stack suffix:
## LBRACK expr RANGE expr RBRACK
## LR(1) items:
expr -> LBRACK expr RANGE expr RBRACK . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> LBRACK expr RANGE expr RBRACK

State 93:
## Known stack suffix:
## expr COMMA
## LR(1) items:
comma_list(expr) -> expr COMMA . comma_list(expr) [ WHEN RBRACK COLON ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 95
## Reductions:

State 94:
## Known stack suffix:
## expr
## LR(1) items:
comma_list(expr) -> expr . [ WHEN RBRACK COLON ]
comma_list(expr) -> expr . COMMA comma_list(expr) [ WHEN RBRACK COLON ]
expr -> expr . ADD expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . SUB expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . MUL expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . DIV expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . MOD expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . AND expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . OR expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . XOR expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . LT expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . LE expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . GT expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . GE expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . IN expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . UNION expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . INTER expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN UNION SUBSET SUB RBRACK OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA COLON AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 93
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN reduce production comma_list(expr) -> expr
-- On VARTUPLE reduce production comma_list(expr) -> expr
-- On VAR reduce production comma_list(expr) -> expr
-- On UNION_PR reduce production comma_list(expr) -> expr
-- On TUPLE reduce production comma_list(expr) -> expr
-- On TOP reduce production comma_list(expr) -> expr
-- On TOINT reduce production comma_list(expr) -> expr
-- On TOFLOAT reduce production comma_list(expr) -> expr
-- On THEN reduce production comma_list(expr) -> expr
-- On TERM reduce production comma_list(expr) -> expr
-- On SUBSET_PR reduce production comma_list(expr) -> expr
-- On SQRT reduce production comma_list(expr) -> expr
-- On RPAREN reduce production comma_list(expr) -> expr
-- On RBRACK reduce production comma_list(expr) -> expr
-- On RANGE reduce production comma_list(expr) -> expr
-- On POWERSET reduce production comma_list(expr) -> expr
-- On NOT reduce production comma_list(expr) -> expr
-- On NEWLINE reduce production comma_list(expr) -> expr
-- On LPAREN reduce production comma_list(expr) -> expr
-- On LET reduce production comma_list(expr) -> expr
-- On LBRACK reduce production comma_list(expr) -> expr
-- On INTER_PR reduce production comma_list(expr) -> expr
-- On INT reduce production comma_list(expr) -> expr
-- On IF reduce production comma_list(expr) -> expr
-- On FORALL reduce production comma_list(expr) -> expr
-- On FOR reduce production comma_list(expr) -> expr
-- On FLOAT reduce production comma_list(expr) -> expr
-- On EXISTS reduce production comma_list(expr) -> expr
-- On EXACT reduce production comma_list(expr) -> expr
-- On EOF reduce production comma_list(expr) -> expr
-- On END reduce production comma_list(expr) -> expr
-- On EMPTY reduce production comma_list(expr) -> expr
-- On ELSE reduce production comma_list(expr) -> expr
-- On DIFF_PR reduce production comma_list(expr) -> expr
-- On DATA reduce production comma_list(expr) -> expr
-- On COLON reduce production comma_list(expr) -> expr
-- On CARD reduce production comma_list(expr) -> expr
-- On BOTTOM reduce production comma_list(expr) -> expr
-- On BOOL reduce production comma_list(expr) -> expr
-- On BIGOR reduce production comma_list(expr) -> expr
-- On BIGAND reduce production comma_list(expr) -> expr
-- On ATMOST reduce production comma_list(expr) -> expr
-- On ATLEAST reduce production comma_list(expr) -> expr
-- On AFFECT reduce production comma_list(expr) -> expr
-- On ABS reduce production comma_list(expr) -> expr

State 95:
## Known stack suffix:
## expr COMMA comma_list(expr)
## LR(1) items:
comma_list(expr) -> expr COMMA comma_list(expr) . [ WHEN RBRACK COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_list(expr) -> expr COMMA comma_list(expr)

State 96:
## Known stack suffix:
## LBRACK comma_list(expr)
## LR(1) items:
expr -> LBRACK comma_list(expr) . RBRACK [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On RBRACK shift to state 97
## Reductions:

State 97:
## Known stack suffix:
## LBRACK comma_list(expr) RBRACK
## LR(1) items:
expr -> LBRACK comma_list(expr) RBRACK . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> LBRACK comma_list(expr) RBRACK

State 98:
## Known stack suffix:
## LPAREN expr
## LR(1) items:
expr -> LPAREN expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 99
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 99:
## Known stack suffix:
## LPAREN expr RPAREN
## LR(1) items:
expr -> LPAREN expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> LPAREN expr RPAREN

State 100:
## Known stack suffix:
## NOT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> NOT expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 30
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On IN shift to state 46
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On ADD shift to state 40
## Reductions:
-- On XOR reduce production expr -> NOT expr
-- On WHEN reduce production expr -> NOT expr
-- On VARTUPLE reduce production expr -> NOT expr
-- On VAR reduce production expr -> NOT expr
-- On UNION reduce production expr -> NOT expr
-- On TUPLE reduce production expr -> NOT expr
-- On TOP reduce production expr -> NOT expr
-- On THEN reduce production expr -> NOT expr
-- On TERM reduce production expr -> NOT expr
-- On SUBSET reduce production expr -> NOT expr
-- On RPAREN reduce production expr -> NOT expr
-- On RBRACK reduce production expr -> NOT expr
-- On RANGE reduce production expr -> NOT expr
-- On OR reduce production expr -> NOT expr
-- On NOT reduce production expr -> NOT expr
-- On NEWLINE reduce production expr -> NOT expr
-- On LPAREN reduce production expr -> NOT expr
-- On LET reduce production expr -> NOT expr
-- On INTER reduce production expr -> NOT expr
-- On INT reduce production expr -> NOT expr
-- On IMPLIES reduce production expr -> NOT expr
-- On IF reduce production expr -> NOT expr
-- On FORALL reduce production expr -> NOT expr
-- On FLOAT reduce production expr -> NOT expr
-- On EXISTS reduce production expr -> NOT expr
-- On EXACT reduce production expr -> NOT expr
-- On EQUIV reduce production expr -> NOT expr
-- On EOF reduce production expr -> NOT expr
-- On END reduce production expr -> NOT expr
-- On ELSE reduce production expr -> NOT expr
-- On DIFF reduce production expr -> NOT expr
-- On COMMA reduce production expr -> NOT expr
-- On COLON reduce production expr -> NOT expr
-- On BOTTOM reduce production expr -> NOT expr
-- On BIGOR reduce production expr -> NOT expr
-- On BIGAND reduce production expr -> NOT expr
-- On ATMOST reduce production expr -> NOT expr
-- On ATLEAST reduce production expr -> NOT expr
-- On AND reduce production expr -> NOT expr

State 101:
## Known stack suffix:
## POWERSET expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> POWERSET expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 102
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 102:
## Known stack suffix:
## POWERSET expr RPAREN
## LR(1) items:
expr -> POWERSET expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> POWERSET expr RPAREN

State 103:
## Known stack suffix:
## SQRT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> SQRT expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 104
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 104:
## Known stack suffix:
## SQRT expr RPAREN
## LR(1) items:
expr -> SQRT expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> SQRT expr RPAREN

State 105:
## Known stack suffix:
## SUB expr
## LR(1) items:
expr -> expr . ADD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> SUB expr . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On DIV shift to state 36
## Reductions:
-- On XOR reduce production expr -> SUB expr
-- On WHEN reduce production expr -> SUB expr
-- On VARTUPLE reduce production expr -> SUB expr
-- On VAR reduce production expr -> SUB expr
-- On UNION reduce production expr -> SUB expr
-- On TUPLE reduce production expr -> SUB expr
-- On TOP reduce production expr -> SUB expr
-- On THEN reduce production expr -> SUB expr
-- On TERM reduce production expr -> SUB expr
-- On SUBSET reduce production expr -> SUB expr
-- On SUB reduce production expr -> SUB expr
-- On RPAREN reduce production expr -> SUB expr
-- On RBRACK reduce production expr -> SUB expr
-- On RANGE reduce production expr -> SUB expr
-- On OR reduce production expr -> SUB expr
-- On NOTEQUAL reduce production expr -> SUB expr
-- On NOT reduce production expr -> SUB expr
-- On NEWLINE reduce production expr -> SUB expr
-- On LT reduce production expr -> SUB expr
-- On LPAREN reduce production expr -> SUB expr
-- On LET reduce production expr -> SUB expr
-- On LE reduce production expr -> SUB expr
-- On INTER reduce production expr -> SUB expr
-- On INT reduce production expr -> SUB expr
-- On IN reduce production expr -> SUB expr
-- On IMPLIES reduce production expr -> SUB expr
-- On IF reduce production expr -> SUB expr
-- On GT reduce production expr -> SUB expr
-- On GE reduce production expr -> SUB expr
-- On FORALL reduce production expr -> SUB expr
-- On FLOAT reduce production expr -> SUB expr
-- On EXISTS reduce production expr -> SUB expr
-- On EXACT reduce production expr -> SUB expr
-- On EQUIV reduce production expr -> SUB expr
-- On EQUAL reduce production expr -> SUB expr
-- On EOF reduce production expr -> SUB expr
-- On END reduce production expr -> SUB expr
-- On ELSE reduce production expr -> SUB expr
-- On DIFF reduce production expr -> SUB expr
-- On COMMA reduce production expr -> SUB expr
-- On COLON reduce production expr -> SUB expr
-- On BOTTOM reduce production expr -> SUB expr
-- On BIGOR reduce production expr -> SUB expr
-- On BIGAND reduce production expr -> SUB expr
-- On ATMOST reduce production expr -> SUB expr
-- On ATLEAST reduce production expr -> SUB expr
-- On AND reduce production expr -> SUB expr
-- On ADD reduce production expr -> SUB expr

State 106:
## Known stack suffix:
## SUBSET_PR expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> SUBSET_PR expr . COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 107
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 107:
## Known stack suffix:
## SUBSET_PR expr COMMA
## LR(1) items:
expr -> SUBSET_PR expr COMMA . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 108
## Reductions:

State 108:
## Known stack suffix:
## SUBSET_PR expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> SUBSET_PR expr COMMA expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 109
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 109:
## Known stack suffix:
## SUBSET_PR expr COMMA expr RPAREN
## LR(1) items:
expr -> SUBSET_PR expr COMMA expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> SUBSET_PR expr COMMA expr RPAREN

State 110:
## Known stack suffix:
## TOFLOAT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> TOFLOAT expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 111
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 111:
## Known stack suffix:
## TOFLOAT expr RPAREN
## LR(1) items:
expr -> TOFLOAT expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> TOFLOAT expr RPAREN

State 112:
## Known stack suffix:
## TOINT expr
## LR(1) items:
expr -> TOINT expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 113
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 113:
## Known stack suffix:
## TOINT expr RPAREN
## LR(1) items:
expr -> TOINT expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> TOINT expr RPAREN

State 114:
## Known stack suffix:
## expr
## LR(1) items:
comma_list(indices) -> expr . [ RPAREN ]
comma_list(indices) -> expr . COMMA comma_list(indices) [ RPAREN ]
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 115
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On WHEN reduce production comma_list(indices) -> expr
-- On VARTUPLE reduce production comma_list(indices) -> expr
-- On VAR reduce production comma_list(indices) -> expr
-- On UNION_PR reduce production comma_list(indices) -> expr
-- On TUPLE reduce production comma_list(indices) -> expr
-- On TOP reduce production comma_list(indices) -> expr
-- On TOINT reduce production comma_list(indices) -> expr
-- On TOFLOAT reduce production comma_list(indices) -> expr
-- On THEN reduce production comma_list(indices) -> expr
-- On TERM reduce production comma_list(indices) -> expr
-- On SUBSET_PR reduce production comma_list(indices) -> expr
-- On SQRT reduce production comma_list(indices) -> expr
-- On RPAREN reduce production comma_list(indices) -> expr
-- On RBRACK reduce production comma_list(indices) -> expr
-- On RANGE reduce production comma_list(indices) -> expr
-- On POWERSET reduce production comma_list(indices) -> expr
-- On NOT reduce production comma_list(indices) -> expr
-- On NEWLINE reduce production comma_list(indices) -> expr
-- On LPAREN reduce production comma_list(indices) -> expr
-- On LET reduce production comma_list(indices) -> expr
-- On LBRACK reduce production comma_list(indices) -> expr
-- On INTER_PR reduce production comma_list(indices) -> expr
-- On INT reduce production comma_list(indices) -> expr
-- On IF reduce production comma_list(indices) -> expr
-- On FORALL reduce production comma_list(indices) -> expr
-- On FOR reduce production comma_list(indices) -> expr
-- On FLOAT reduce production comma_list(indices) -> expr
-- On EXISTS reduce production comma_list(indices) -> expr
-- On EXACT reduce production comma_list(indices) -> expr
-- On EOF reduce production comma_list(indices) -> expr
-- On END reduce production comma_list(indices) -> expr
-- On EMPTY reduce production comma_list(indices) -> expr
-- On ELSE reduce production comma_list(indices) -> expr
-- On DIFF_PR reduce production comma_list(indices) -> expr
-- On DATA reduce production comma_list(indices) -> expr
-- On COLON reduce production comma_list(indices) -> expr
-- On CARD reduce production comma_list(indices) -> expr
-- On BOTTOM reduce production comma_list(indices) -> expr
-- On BOOL reduce production comma_list(indices) -> expr
-- On BIGOR reduce production comma_list(indices) -> expr
-- On BIGAND reduce production comma_list(indices) -> expr
-- On ATMOST reduce production comma_list(indices) -> expr
-- On ATLEAST reduce production comma_list(indices) -> expr
-- On AFFECT reduce production comma_list(indices) -> expr
-- On ABS reduce production comma_list(indices) -> expr

State 115:
## Known stack suffix:
## expr COMMA
## LR(1) items:
comma_list(indices) -> expr COMMA . comma_list(indices) [ RPAREN ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 114
-- On comma_list(indices) shift to state 116
## Reductions:

State 116:
## Known stack suffix:
## expr COMMA comma_list(indices)
## LR(1) items:
comma_list(indices) -> expr COMMA comma_list(indices) . [ RPAREN ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_list(indices) -> expr COMMA comma_list(indices)

State 117:
## Known stack suffix:
## TUPLE comma_list(indices)
## LR(1) items:
prop -> TUPLE comma_list(indices) . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On RPAREN shift to state 118
## Reductions:

State 118:
## Known stack suffix:
## TUPLE comma_list(indices) RPAREN
## LR(1) items:
prop -> TUPLE comma_list(indices) RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production prop -> TUPLE comma_list(indices) RPAREN

State 119:
## Known stack suffix:
## UNION_PR expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> UNION_PR expr . COMMA expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 120
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 120:
## Known stack suffix:
## UNION_PR expr COMMA
## LR(1) items:
expr -> UNION_PR expr COMMA . expr RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 121
## Reductions:

State 121:
## Known stack suffix:
## UNION_PR expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> UNION_PR expr COMMA expr . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 122
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 122:
## Known stack suffix:
## UNION_PR expr COMMA expr RPAREN
## LR(1) items:
expr -> UNION_PR expr COMMA expr RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr -> UNION_PR expr COMMA expr RPAREN

State 123:
## Known stack suffix:
## VARTUPLE comma_list(indices)
## LR(1) items:
var -> VARTUPLE comma_list(indices) . RPAREN [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND AFFECT ADD ]
## Transitions:
-- On RPAREN shift to state 124
## Reductions:

State 124:
## Known stack suffix:
## VARTUPLE comma_list(indices) RPAREN
## LR(1) items:
var -> VARTUPLE comma_list(indices) RPAREN . [ XOR WHEN VARTUPLE VAR UNION TUPLE TOP THEN TERM SUBSET SUB RPAREN RBRACK RANGE OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FORALL FOR FLOAT EXISTS EXACT EQUIV EQUAL EOF END ELSE DIV DIFF DATA COMMA COLON BOTTOM BIGOR BIGAND ATMOST ATLEAST AND AFFECT ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production var -> VARTUPLE comma_list(indices) RPAREN

State 125:
## Known stack suffix:
## TOP
## LR(1) items:
formula_qbf -> TOP . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> TOP

State 126:
## Known stack suffix:
## NOT
## LR(1) items:
formula_qbf -> NOT . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 216
## Reductions:

State 127:
## Known stack suffix:
## NEWLINE
## LR(1) items:
formula_qbf -> NEWLINE . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 215
## Reductions:

State 128:
## Known stack suffix:
## LPAREN
## LR(1) items:
formula_qbf -> LPAREN . formula_qbf RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 213
## Reductions:

State 129:
## Known stack suffix:
## LET
## LR(1) items:
let_affect(expr,formula_qbf) -> LET . comma_list(var) AFFECT comma_list(expr) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 133
## Reductions:

State 130:
## Known stack suffix:
## var
## LR(1) items:
comma_list(var) -> var . [ IN AFFECT ]
comma_list(var) -> var . COMMA comma_list(var) [ IN AFFECT ]
## Transitions:
-- On COMMA shift to state 131
## Reductions:
-- On XOR reduce production comma_list(var) -> var
-- On WHEN reduce production comma_list(var) -> var
-- On VARTUPLE reduce production comma_list(var) -> var
-- On VAR reduce production comma_list(var) -> var
-- On UNION_PR reduce production comma_list(var) -> var
-- On UNION reduce production comma_list(var) -> var
-- On TUPLE reduce production comma_list(var) -> var
-- On TOP reduce production comma_list(var) -> var
-- On TOINT reduce production comma_list(var) -> var
-- On TOFLOAT reduce production comma_list(var) -> var
-- On THEN reduce production comma_list(var) -> var
-- On TERM reduce production comma_list(var) -> var
-- On SUBSET_PR reduce production comma_list(var) -> var
-- On SUBSET reduce production comma_list(var) -> var
-- On SUB reduce production comma_list(var) -> var
-- On SQRT reduce production comma_list(var) -> var
-- On RPAREN reduce production comma_list(var) -> var
-- On RBRACK reduce production comma_list(var) -> var
-- On RANGE reduce production comma_list(var) -> var
-- On POWERSET reduce production comma_list(var) -> var
-- On OR reduce production comma_list(var) -> var
-- On NOTEQUAL reduce production comma_list(var) -> var
-- On NOT reduce production comma_list(var) -> var
-- On NEWLINE reduce production comma_list(var) -> var
-- On MUL reduce production comma_list(var) -> var
-- On MOD reduce production comma_list(var) -> var
-- On LT reduce production comma_list(var) -> var
-- On LPAREN reduce production comma_list(var) -> var
-- On LET reduce production comma_list(var) -> var
-- On LE reduce production comma_list(var) -> var
-- On LBRACK reduce production comma_list(var) -> var
-- On INTER_PR reduce production comma_list(var) -> var
-- On INTER reduce production comma_list(var) -> var
-- On INT reduce production comma_list(var) -> var
-- On IN reduce production comma_list(var) -> var
-- On IMPLIES reduce production comma_list(var) -> var
-- On IF reduce production comma_list(var) -> var
-- On GT reduce production comma_list(var) -> var
-- On GE reduce production comma_list(var) -> var
-- On FORALL reduce production comma_list(var) -> var
-- On FOR reduce production comma_list(var) -> var
-- On FLOAT reduce production comma_list(var) -> var
-- On EXISTS reduce production comma_list(var) -> var
-- On EXACT reduce production comma_list(var) -> var
-- On EQUIV reduce production comma_list(var) -> var
-- On EQUAL reduce production comma_list(var) -> var
-- On EOF reduce production comma_list(var) -> var
-- On END reduce production comma_list(var) -> var
-- On EMPTY reduce production comma_list(var) -> var
-- On ELSE reduce production comma_list(var) -> var
-- On DIV reduce production comma_list(var) -> var
-- On DIFF_PR reduce production comma_list(var) -> var
-- On DIFF reduce production comma_list(var) -> var
-- On DATA reduce production comma_list(var) -> var
-- On COLON reduce production comma_list(var) -> var
-- On CARD reduce production comma_list(var) -> var
-- On BOTTOM reduce production comma_list(var) -> var
-- On BOOL reduce production comma_list(var) -> var
-- On BIGOR reduce production comma_list(var) -> var
-- On BIGAND reduce production comma_list(var) -> var
-- On ATMOST reduce production comma_list(var) -> var
-- On ATLEAST reduce production comma_list(var) -> var
-- On AND reduce production comma_list(var) -> var
-- On AFFECT reduce production comma_list(var) -> var
-- On ADD reduce production comma_list(var) -> var
-- On ABS reduce production comma_list(var) -> var

State 131:
## Known stack suffix:
## var COMMA
## LR(1) items:
comma_list(var) -> var COMMA . comma_list(var) [ IN AFFECT ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 132
## Reductions:

State 132:
## Known stack suffix:
## var COMMA comma_list(var)
## LR(1) items:
comma_list(var) -> var COMMA comma_list(var) . [ IN AFFECT ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_list(var) -> var COMMA comma_list(var)

State 133:
## Known stack suffix:
## LET comma_list(var)
## LR(1) items:
let_affect(expr,formula_qbf) -> LET comma_list(var) . AFFECT comma_list(expr) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On AFFECT shift to state 134
## Reductions:

State 134:
## Known stack suffix:
## LET comma_list(var) AFFECT
## LR(1) items:
let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT . comma_list(expr) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 135
## Reductions:

State 135:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr)
## LR(1) items:
let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) . COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 136
## Reductions:

State 136:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr) COLON
## LR(1) items:
let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 212
## Reductions:

State 137:
## Known stack suffix:
## IF
## LR(1) items:
formula_qbf -> IF . expr THEN formula_qbf ELSE formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 138
## Reductions:

State 138:
## Known stack suffix:
## IF expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_qbf -> IF expr . THEN formula_qbf ELSE formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On THEN shift to state 139
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 139:
## Known stack suffix:
## IF expr THEN
## LR(1) items:
formula_qbf -> IF expr THEN . formula_qbf ELSE formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 208
## Reductions:

State 140:
## Known stack suffix:
## FORALL
## LR(1) items:
formula_qbf -> FORALL . comma_list(prop_or_var) option(for_statement) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TERM shift to state 7
-- On var shift to state 141
-- On prop shift to state 143
-- On comma_list(prop_or_var) shift to state 147
## Reductions:

State 141:
## Known stack suffix:
## var
## LR(1) items:
comma_list(prop_or_var) -> var . [ FOR COLON ]
comma_list(prop_or_var) -> var . COMMA comma_list(prop_or_var) [ FOR COLON ]
## Transitions:
-- On COMMA shift to state 142
## Reductions:
-- On FOR reduce production comma_list(prop_or_var) -> var
-- On COLON reduce production comma_list(prop_or_var) -> var

State 142:
## Known stack suffix:
## var COMMA
## LR(1) items:
comma_list(prop_or_var) -> var COMMA . comma_list(prop_or_var) [ FOR COLON ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TERM shift to state 7
-- On var shift to state 141
-- On prop shift to state 143
-- On comma_list(prop_or_var) shift to state 146
## Reductions:

State 143:
## Known stack suffix:
## prop
## LR(1) items:
comma_list(prop_or_var) -> prop . [ FOR COLON ]
comma_list(prop_or_var) -> prop . COMMA comma_list(prop_or_var) [ FOR COLON ]
## Transitions:
-- On COMMA shift to state 144
## Reductions:
-- On FOR reduce production comma_list(prop_or_var) -> prop
-- On COLON reduce production comma_list(prop_or_var) -> prop

State 144:
## Known stack suffix:
## prop COMMA
## LR(1) items:
comma_list(prop_or_var) -> prop COMMA . comma_list(prop_or_var) [ FOR COLON ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TERM shift to state 7
-- On var shift to state 141
-- On prop shift to state 143
-- On comma_list(prop_or_var) shift to state 145
## Reductions:

State 145:
## Known stack suffix:
## prop COMMA comma_list(prop_or_var)
## LR(1) items:
comma_list(prop_or_var) -> prop COMMA comma_list(prop_or_var) . [ FOR COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_list(prop_or_var) -> prop COMMA comma_list(prop_or_var)

State 146:
## Known stack suffix:
## var COMMA comma_list(prop_or_var)
## LR(1) items:
comma_list(prop_or_var) -> var COMMA comma_list(prop_or_var) . [ FOR COLON ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production comma_list(prop_or_var) -> var COMMA comma_list(prop_or_var)

State 147:
## Known stack suffix:
## FORALL comma_list(prop_or_var)
## LR(1) items:
formula_qbf -> FORALL comma_list(prop_or_var) . option(for_statement) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On FOR shift to state 148
-- On option(for_statement) shift to state 152
## Reductions:
-- On COLON reduce production option(for_statement) ->

State 148:
## Known stack suffix:
## FOR
## LR(1) items:
option(for_statement) -> FOR . var IN expr [ COLON ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 149
## Reductions:

State 149:
## Known stack suffix:
## FOR var
## LR(1) items:
option(for_statement) -> FOR var . IN expr [ COLON ]
## Transitions:
-- On IN shift to state 150
## Reductions:

State 150:
## Known stack suffix:
## FOR var IN
## LR(1) items:
option(for_statement) -> FOR var IN . expr [ COLON ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 151
## Reductions:

State 151:
## Known stack suffix:
## FOR var IN expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
option(for_statement) -> FOR var IN expr . [ COLON ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On COLON reduce production option(for_statement) -> FOR var IN expr

State 152:
## Known stack suffix:
## FORALL comma_list(prop_or_var) option(for_statement)
## LR(1) items:
formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) . COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 153
## Reductions:

State 153:
## Known stack suffix:
## FORALL comma_list(prop_or_var) option(for_statement) COLON
## LR(1) items:
formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 207
## Reductions:

State 154:
## Known stack suffix:
## EXISTS
## LR(1) items:
formula_qbf -> EXISTS . comma_list(prop_or_var) option(for_statement) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TERM shift to state 7
-- On var shift to state 141
-- On prop shift to state 143
-- On comma_list(prop_or_var) shift to state 155
## Reductions:

State 155:
## Known stack suffix:
## EXISTS comma_list(prop_or_var)
## LR(1) items:
formula_qbf -> EXISTS comma_list(prop_or_var) . option(for_statement) COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On FOR shift to state 148
-- On option(for_statement) shift to state 156
## Reductions:
-- On COLON reduce production option(for_statement) ->

State 156:
## Known stack suffix:
## EXISTS comma_list(prop_or_var) option(for_statement)
## LR(1) items:
formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) . COLON formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 157
## Reductions:

State 157:
## Known stack suffix:
## EXISTS comma_list(prop_or_var) option(for_statement) COLON
## LR(1) items:
formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 206
## Reductions:

State 158:
## Known stack suffix:
## EXACT
## LR(1) items:
formula_qbf -> EXACT . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 159
## Reductions:

State 159:
## Known stack suffix:
## EXACT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_qbf -> EXACT expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 160
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 160:
## Known stack suffix:
## EXACT expr COMMA
## LR(1) items:
formula_qbf -> EXACT expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 161
## Reductions:

State 161:
## Known stack suffix:
## EXACT expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_qbf -> EXACT expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 162
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 162:
## Known stack suffix:
## EXACT expr COMMA expr RPAREN
## LR(1) items:
formula_qbf -> EXACT expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> EXACT expr COMMA expr RPAREN

State 163:
## Known stack suffix:
## BOTTOM
## LR(1) items:
formula_qbf -> BOTTOM . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> BOTTOM

State 164:
## Known stack suffix:
## BIGOR
## LR(1) items:
formula_qbf -> BIGOR . comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 165
## Reductions:

State 165:
## Known stack suffix:
## BIGOR comma_list(var)
## LR(1) items:
formula_qbf -> BIGOR comma_list(var) . IN comma_list(expr) option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On IN shift to state 166
## Reductions:

State 166:
## Known stack suffix:
## BIGOR comma_list(var) IN
## LR(1) items:
formula_qbf -> BIGOR comma_list(var) IN . comma_list(expr) option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 167
## Reductions:

State 167:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr)
## LR(1) items:
formula_qbf -> BIGOR comma_list(var) IN comma_list(expr) . option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On WHEN shift to state 168
-- On option(when_cond) shift to state 170
## Reductions:
-- On COLON reduce production option(when_cond) ->

State 168:
## Known stack suffix:
## WHEN
## LR(1) items:
option(when_cond) -> WHEN . expr [ COLON ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 169
## Reductions:

State 169:
## Known stack suffix:
## WHEN expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COLON AND ADD ]
option(when_cond) -> WHEN expr . [ COLON ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On COLON reduce production option(when_cond) -> WHEN expr

State 170:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond)
## LR(1) items:
formula_qbf -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) . COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 171
## Reductions:

State 171:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON
## LR(1) items:
formula_qbf -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON . formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 204
## Reductions:

State 172:
## Known stack suffix:
## BIGAND
## LR(1) items:
formula_qbf -> BIGAND . comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 173
## Reductions:

State 173:
## Known stack suffix:
## BIGAND comma_list(var)
## LR(1) items:
formula_qbf -> BIGAND comma_list(var) . IN comma_list(expr) option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On IN shift to state 174
## Reductions:

State 174:
## Known stack suffix:
## BIGAND comma_list(var) IN
## LR(1) items:
formula_qbf -> BIGAND comma_list(var) IN . comma_list(expr) option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 175
## Reductions:

State 175:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr)
## LR(1) items:
formula_qbf -> BIGAND comma_list(var) IN comma_list(expr) . option(when_cond) COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On WHEN shift to state 168
-- On option(when_cond) shift to state 176
## Reductions:
-- On COLON reduce production option(when_cond) ->

State 176:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond)
## LR(1) items:
formula_qbf -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) . COLON formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 177
## Reductions:

State 177:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON
## LR(1) items:
formula_qbf -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON . formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 191
## Reductions:

State 178:
## Known stack suffix:
## ATMOST
## LR(1) items:
formula_qbf -> ATMOST . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 179
## Reductions:

State 179:
## Known stack suffix:
## ATMOST expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_qbf -> ATMOST expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 180
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 180:
## Known stack suffix:
## ATMOST expr COMMA
## LR(1) items:
formula_qbf -> ATMOST expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 181
## Reductions:

State 181:
## Known stack suffix:
## ATMOST expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_qbf -> ATMOST expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 182
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 182:
## Known stack suffix:
## ATMOST expr COMMA expr RPAREN
## LR(1) items:
formula_qbf -> ATMOST expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> ATMOST expr COMMA expr RPAREN

State 183:
## Known stack suffix:
## ATLEAST
## LR(1) items:
formula_qbf -> ATLEAST . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 184
## Reductions:

State 184:
## Known stack suffix:
## ATLEAST expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_qbf -> ATLEAST expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 185
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 185:
## Known stack suffix:
## ATLEAST expr COMMA
## LR(1) items:
formula_qbf -> ATLEAST expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 186
## Reductions:

State 186:
## Known stack suffix:
## ATLEAST expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_qbf -> ATLEAST expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 187
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 187:
## Known stack suffix:
## ATLEAST expr COMMA expr RPAREN
## LR(1) items:
formula_qbf -> ATLEAST expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> ATLEAST expr COMMA expr RPAREN

State 188:
## Known stack suffix:
## var
## LR(1) items:
formula_qbf -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> var

State 189:
## Known stack suffix:
## prop
## LR(1) items:
formula_qbf -> prop . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> prop

State 190:
## Known stack suffix:
## let_affect(expr,formula_qbf)
## LR(1) items:
formula_qbf -> let_affect(expr,formula_qbf) . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> let_affect(expr,formula_qbf)

State 191:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On END shift to state 203
-- On AND shift to state 196
## Reductions:

State 192:
## Known stack suffix:
## formula_qbf XOR
## LR(1) items:
formula_qbf -> formula_qbf XOR . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 193
## Reductions:

State 193:
## Known stack suffix:
## formula_qbf XOR formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf XOR formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> formula_qbf XOR formula_qbf

State 194:
## Known stack suffix:
## formula_qbf OR
## LR(1) items:
formula_qbf -> formula_qbf OR . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 195
## Reductions:

State 195:
## Known stack suffix:
## formula_qbf OR formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf OR formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On AND shift to state 196
## Reductions:
-- On VARTUPLE reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On VAR reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On TUPLE reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On TOP reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On TERM reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On RPAREN reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On OR reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On NOT reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On NEWLINE reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On LPAREN reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On LET reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On IMPLIES reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On IF reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On FORALL reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On EXISTS reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On EXACT reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On EQUIV reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On EOF reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On END reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On ELSE reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On DATA reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On BOTTOM reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On BIGOR reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On BIGAND reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On ATMOST reduce production formula_qbf -> formula_qbf OR formula_qbf
-- On ATLEAST reduce production formula_qbf -> formula_qbf OR formula_qbf

State 196:
## Known stack suffix:
## formula_qbf AND
## LR(1) items:
formula_qbf -> formula_qbf AND . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 197
## Reductions:

State 197:
## Known stack suffix:
## formula_qbf AND formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf AND formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
## Reductions:
-- On VARTUPLE reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On VAR reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On TUPLE reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On TOP reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On TERM reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On RPAREN reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On OR reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On NOT reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On NEWLINE reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On LPAREN reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On LET reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On IMPLIES reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On IF reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On FORALL reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On EXISTS reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On EXACT reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On EQUIV reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On EOF reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On END reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On ELSE reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On DATA reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On BOTTOM reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On BIGOR reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On BIGAND reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On ATMOST reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On ATLEAST reduce production formula_qbf -> formula_qbf AND formula_qbf
-- On AND reduce production formula_qbf -> formula_qbf AND formula_qbf

State 198:
## Known stack suffix:
## formula_qbf NEWLINE
## LR(1) items:
formula_qbf -> formula_qbf NEWLINE . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> formula_qbf NEWLINE

State 199:
## Known stack suffix:
## formula_qbf IMPLIES
## LR(1) items:
formula_qbf -> formula_qbf IMPLIES . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 200
## Reductions:

State 200:
## Known stack suffix:
## formula_qbf IMPLIES formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf IMPLIES formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:
-- On VARTUPLE reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On VAR reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On TUPLE reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On TOP reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On TERM reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On RPAREN reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On NOT reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On NEWLINE reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On LPAREN reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On LET reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On IF reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On FORALL reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On EXISTS reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On EXACT reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On EOF reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On END reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On ELSE reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On DATA reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On BOTTOM reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On BIGOR reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On BIGAND reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On ATMOST reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf
-- On ATLEAST reduce production formula_qbf -> formula_qbf IMPLIES formula_qbf

State 201:
## Known stack suffix:
## formula_qbf EQUIV
## LR(1) items:
formula_qbf -> formula_qbf EQUIV . formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 202
## Reductions:

State 202:
## Known stack suffix:
## formula_qbf EQUIV formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf EQUIV formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:
-- On VARTUPLE reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On VAR reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On TUPLE reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On TOP reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On TERM reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On RPAREN reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On NOT reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On NEWLINE reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On LPAREN reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On LET reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On IF reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On FORALL reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On EXISTS reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On EXACT reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On EOF reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On END reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On ELSE reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On DATA reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On BOTTOM reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On BIGOR reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On BIGAND reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On ATMOST reduce production formula_qbf -> formula_qbf EQUIV formula_qbf
-- On ATLEAST reduce production formula_qbf -> formula_qbf EQUIV formula_qbf

State 203:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END
## LR(1) items:
formula_qbf -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END

State 204:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On END shift to state 205
-- On AND shift to state 196
## Reductions:

State 205:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END
## LR(1) items:
formula_qbf -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_qbf END

State 206:
## Known stack suffix:
## EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:
-- On VARTUPLE reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On VAR reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On TUPLE reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On TOP reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On TERM reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On RPAREN reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On NOT reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On LPAREN reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On LET reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On IF reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On FORALL reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On EXISTS reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On EXACT reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On EOF reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On END reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On ELSE reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On DATA reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On BOTTOM reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On BIGOR reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On BIGAND reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On ATMOST reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On ATLEAST reduce production formula_qbf -> EXISTS comma_list(prop_or_var) option(for_statement) COLON formula_qbf

State 207:
## Known stack suffix:
## FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:
-- On VARTUPLE reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On VAR reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On TUPLE reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On TOP reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On TERM reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On RPAREN reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On NOT reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On LPAREN reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On LET reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On IF reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On FORALL reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On EXISTS reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On EXACT reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On EOF reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On END reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On ELSE reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On DATA reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On BOTTOM reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On BIGOR reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On BIGAND reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On ATMOST reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf
-- On ATLEAST reduce production formula_qbf -> FORALL comma_list(prop_or_var) option(for_statement) COLON formula_qbf

State 208:
## Known stack suffix:
## IF expr THEN formula_qbf
## LR(1) items:
formula_qbf -> IF expr THEN formula_qbf . ELSE formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . AND formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On ELSE shift to state 209
-- On AND shift to state 196
## Reductions:

State 209:
## Known stack suffix:
## IF expr THEN formula_qbf ELSE
## LR(1) items:
formula_qbf -> IF expr THEN formula_qbf ELSE . formula_qbf END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 188
-- On prop shift to state 189
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 210
## Reductions:

State 210:
## Known stack suffix:
## IF expr THEN formula_qbf ELSE formula_qbf
## LR(1) items:
formula_qbf -> IF expr THEN formula_qbf ELSE formula_qbf . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . AND formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On END shift to state 211
-- On AND shift to state 196
## Reductions:

State 211:
## Known stack suffix:
## IF expr THEN formula_qbf ELSE formula_qbf END
## LR(1) items:
formula_qbf -> IF expr THEN formula_qbf ELSE formula_qbf END . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> IF expr THEN formula_qbf ELSE formula_qbf END

State 212:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:
-- On VARTUPLE reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On VAR reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On TUPLE reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On TOP reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On TERM reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On RPAREN reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On NOT reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On NEWLINE reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On LPAREN reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On LET reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On IF reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On FORALL reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On EXISTS reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On EXACT reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On EOF reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On END reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On ELSE reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On DATA reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On BOTTOM reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On BIGOR reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On BIGAND reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On ATMOST reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf
-- On ATLEAST reduce production let_affect(expr,formula_qbf) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_qbf

State 213:
## Known stack suffix:
## LPAREN formula_qbf
## LR(1) items:
formula_qbf -> LPAREN formula_qbf . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . AND formula_qbf [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
## Transitions:
-- On XOR shift to state 192
-- On RPAREN shift to state 214
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:

State 214:
## Known stack suffix:
## LPAREN formula_qbf RPAREN
## LR(1) items:
formula_qbf -> LPAREN formula_qbf RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> LPAREN formula_qbf RPAREN

State 215:
## Known stack suffix:
## NEWLINE formula_qbf
## LR(1) items:
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> NEWLINE formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On AND shift to state 196
## Reductions:
-- On VARTUPLE reduce production formula_qbf -> NEWLINE formula_qbf
-- On VAR reduce production formula_qbf -> NEWLINE formula_qbf
-- On TUPLE reduce production formula_qbf -> NEWLINE formula_qbf
-- On TOP reduce production formula_qbf -> NEWLINE formula_qbf
-- On TERM reduce production formula_qbf -> NEWLINE formula_qbf
-- On RPAREN reduce production formula_qbf -> NEWLINE formula_qbf
-- On NOT reduce production formula_qbf -> NEWLINE formula_qbf
-- On NEWLINE reduce production formula_qbf -> NEWLINE formula_qbf
-- On LPAREN reduce production formula_qbf -> NEWLINE formula_qbf
-- On LET reduce production formula_qbf -> NEWLINE formula_qbf
-- On IF reduce production formula_qbf -> NEWLINE formula_qbf
-- On FORALL reduce production formula_qbf -> NEWLINE formula_qbf
-- On EXISTS reduce production formula_qbf -> NEWLINE formula_qbf
-- On EXACT reduce production formula_qbf -> NEWLINE formula_qbf
-- On EOF reduce production formula_qbf -> NEWLINE formula_qbf
-- On END reduce production formula_qbf -> NEWLINE formula_qbf
-- On ELSE reduce production formula_qbf -> NEWLINE formula_qbf
-- On DATA reduce production formula_qbf -> NEWLINE formula_qbf
-- On BOTTOM reduce production formula_qbf -> NEWLINE formula_qbf
-- On BIGOR reduce production formula_qbf -> NEWLINE formula_qbf
-- On BIGAND reduce production formula_qbf -> NEWLINE formula_qbf
-- On ATMOST reduce production formula_qbf -> NEWLINE formula_qbf
-- On ATLEAST reduce production formula_qbf -> NEWLINE formula_qbf

State 216:
## Known stack suffix:
## NOT formula_qbf
## LR(1) items:
formula_qbf -> NOT formula_qbf . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_qbf -> NOT formula_qbf

State 217:
## Known stack suffix:
## var
## LR(1) items:
affect_or(formula_qbf) -> var . AFFECT expr [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
formula_qbf -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On AFFECT shift to state 218
## Reductions:
-- On XOR reduce production formula_qbf -> var
-- On VARTUPLE reduce production formula_qbf -> var
-- On VAR reduce production formula_qbf -> var
-- On TUPLE reduce production formula_qbf -> var
-- On TOP reduce production formula_qbf -> var
-- On TERM reduce production formula_qbf -> var
-- On OR reduce production formula_qbf -> var
-- On NOT reduce production formula_qbf -> var
-- On NEWLINE reduce production formula_qbf -> var
-- On LPAREN reduce production formula_qbf -> var
-- On LET reduce production formula_qbf -> var
-- On IMPLIES reduce production formula_qbf -> var
-- On IF reduce production formula_qbf -> var
-- On FORALL reduce production formula_qbf -> var
-- On EXISTS reduce production formula_qbf -> var
-- On EXACT reduce production formula_qbf -> var
-- On EQUIV reduce production formula_qbf -> var
-- On EOF reduce production formula_qbf -> var
-- On DATA reduce production formula_qbf -> var
-- On BOTTOM reduce production formula_qbf -> var
-- On BIGOR reduce production formula_qbf -> var
-- On BIGAND reduce production formula_qbf -> var
-- On ATMOST reduce production formula_qbf -> var
-- On ATLEAST reduce production formula_qbf -> var
-- On AND reduce production formula_qbf -> var

State 218:
## Known stack suffix:
## var AFFECT
## LR(1) items:
affect_or(formula_qbf) -> var AFFECT . expr [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 219
## Reductions:

State 219:
## Known stack suffix:
## var AFFECT expr
## LR(1) items:
affect_or(formula_qbf) -> var AFFECT expr . [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
expr -> expr . ADD expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE FORALL EXISTS EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On VARTUPLE reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On VAR reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On TUPLE reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On TOP reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On TERM reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On NOT reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On NEWLINE reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On LPAREN reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On LET reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On IF reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On FORALL reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On EXISTS reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On EXACT reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On EOF reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On BOTTOM reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On BIGOR reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On BIGAND reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On ATMOST reduce production affect_or(formula_qbf) -> var AFFECT expr
-- On ATLEAST reduce production affect_or(formula_qbf) -> var AFFECT expr

State 220:
## Known stack suffix:
## touist_qbf
## LR(1) items:
touist_qbf' -> touist_qbf . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept touist_qbf

State 221:
## Known stack suffix:
## nonempty_list(affect_or(formula_qbf))
## LR(1) items:
touist_qbf -> nonempty_list(affect_or(formula_qbf)) . EOF [ # ]
## Transitions:
-- On EOF shift to state 222
## Reductions:

State 222:
## Known stack suffix:
## nonempty_list(affect_or(formula_qbf)) EOF
## LR(1) items:
touist_qbf -> nonempty_list(affect_or(formula_qbf)) EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production touist_qbf -> nonempty_list(affect_or(formula_qbf)) EOF

State 223:
## Known stack suffix:
## formula_qbf
## LR(1) items:
affect_or(formula_qbf) -> formula_qbf . option(DATA) [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
formula_qbf -> formula_qbf . AND formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . OR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . XOR formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . IMPLIES formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . EQUIV formula_qbf [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_qbf -> formula_qbf . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF FORALL EXISTS EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 192
-- On OR shift to state 194
-- On NEWLINE shift to state 198
-- On IMPLIES shift to state 199
-- On EQUIV shift to state 201
-- On DATA shift to state 224
-- On AND shift to state 196
-- On option(DATA) shift to state 225
## Reductions:
-- On VARTUPLE reduce production option(DATA) ->
-- On VAR reduce production option(DATA) ->
-- On TUPLE reduce production option(DATA) ->
-- On TOP reduce production option(DATA) ->
-- On TERM reduce production option(DATA) ->
-- On NOT reduce production option(DATA) ->
-- On LPAREN reduce production option(DATA) ->
-- On LET reduce production option(DATA) ->
-- On IF reduce production option(DATA) ->
-- On FORALL reduce production option(DATA) ->
-- On EXISTS reduce production option(DATA) ->
-- On EXACT reduce production option(DATA) ->
-- On EOF reduce production option(DATA) ->
-- On BOTTOM reduce production option(DATA) ->
-- On BIGOR reduce production option(DATA) ->
-- On BIGAND reduce production option(DATA) ->
-- On ATMOST reduce production option(DATA) ->
-- On ATLEAST reduce production option(DATA) ->

State 224:
## Known stack suffix:
## DATA
## LR(1) items:
option(DATA) -> DATA . [ VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FORALL FLOAT EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production option(DATA) -> DATA

State 225:
## Known stack suffix:
## formula_qbf option(DATA)
## LR(1) items:
affect_or(formula_qbf) -> formula_qbf option(DATA) . [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF FORALL EXISTS EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production affect_or(formula_qbf) -> formula_qbf option(DATA)

State 226:
## Known stack suffix:
## affect_or(formula_qbf)
## LR(1) items:
nonempty_list(affect_or(formula_qbf)) -> affect_or(formula_qbf) . [ EOF ]
nonempty_list(affect_or(formula_qbf)) -> affect_or(formula_qbf) . nonempty_list(affect_or(formula_qbf)) [ EOF ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 125
-- On TERM shift to state 7
-- On NOT shift to state 126
-- On NEWLINE shift to state 127
-- On LPAREN shift to state 128
-- On LET shift to state 129
-- On IF shift to state 137
-- On FORALL shift to state 140
-- On EXISTS shift to state 154
-- On EXACT shift to state 158
-- On BOTTOM shift to state 163
-- On BIGOR shift to state 164
-- On BIGAND shift to state 172
-- On ATMOST shift to state 178
-- On ATLEAST shift to state 183
-- On var shift to state 217
-- On prop shift to state 189
-- On nonempty_list(affect_or(formula_qbf)) shift to state 227
-- On let_affect(expr,formula_qbf) shift to state 190
-- On formula_qbf shift to state 223
-- On affect_or(formula_qbf) shift to state 226
## Reductions:
-- On EOF reduce production nonempty_list(affect_or(formula_qbf)) -> affect_or(formula_qbf)

State 227:
## Known stack suffix:
## affect_or(formula_qbf) nonempty_list(affect_or(formula_qbf))
## LR(1) items:
nonempty_list(affect_or(formula_qbf)) -> affect_or(formula_qbf) nonempty_list(affect_or(formula_qbf)) . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(affect_or(formula_qbf)) -> affect_or(formula_qbf) nonempty_list(affect_or(formula_qbf))

State 228:
## Known stack suffix:
##
## LR(1) items:
touist_simple' -> . touist_simple [ # ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 296
-- On touist_simple shift to state 299
-- On prop shift to state 270
-- On nonempty_list(affect_or(formula_simple)) shift to state 300
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 302
-- On affect_or(formula_simple) shift to state 304
## Reductions:

State 229:
## Known stack suffix:
## TOP
## LR(1) items:
formula_simple -> TOP . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> TOP

State 230:
## Known stack suffix:
## NOT
## LR(1) items:
formula_simple -> NOT . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 295
## Reductions:

State 231:
## Known stack suffix:
## NEWLINE
## LR(1) items:
formula_simple -> NEWLINE . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 294
## Reductions:

State 232:
## Known stack suffix:
## LPAREN
## LR(1) items:
formula_simple -> LPAREN . formula_simple RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 292
## Reductions:

State 233:
## Known stack suffix:
## LET
## LR(1) items:
let_affect(expr,formula_simple) -> LET . comma_list(var) AFFECT comma_list(expr) COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 234
## Reductions:

State 234:
## Known stack suffix:
## LET comma_list(var)
## LR(1) items:
let_affect(expr,formula_simple) -> LET comma_list(var) . AFFECT comma_list(expr) COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On AFFECT shift to state 235
## Reductions:

State 235:
## Known stack suffix:
## LET comma_list(var) AFFECT
## LR(1) items:
let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT . comma_list(expr) COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 236
## Reductions:

State 236:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr)
## LR(1) items:
let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) . COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 237
## Reductions:

State 237:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr) COLON
## LR(1) items:
let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 291
## Reductions:

State 238:
## Known stack suffix:
## IF
## LR(1) items:
formula_simple -> IF . expr THEN formula_simple ELSE formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 239
## Reductions:

State 239:
## Known stack suffix:
## IF expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_simple -> IF expr . THEN formula_simple ELSE formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On THEN shift to state 240
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 240:
## Known stack suffix:
## IF expr THEN
## LR(1) items:
formula_simple -> IF expr THEN . formula_simple ELSE formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 287
## Reductions:

State 241:
## Known stack suffix:
## EXACT
## LR(1) items:
formula_simple -> EXACT . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 242
## Reductions:

State 242:
## Known stack suffix:
## EXACT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_simple -> EXACT expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 243
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 243:
## Known stack suffix:
## EXACT expr COMMA
## LR(1) items:
formula_simple -> EXACT expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 244
## Reductions:

State 244:
## Known stack suffix:
## EXACT expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_simple -> EXACT expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 245
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 245:
## Known stack suffix:
## EXACT expr COMMA expr RPAREN
## LR(1) items:
formula_simple -> EXACT expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> EXACT expr COMMA expr RPAREN

State 246:
## Known stack suffix:
## BOTTOM
## LR(1) items:
formula_simple -> BOTTOM . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> BOTTOM

State 247:
## Known stack suffix:
## BIGOR
## LR(1) items:
formula_simple -> BIGOR . comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 248
## Reductions:

State 248:
## Known stack suffix:
## BIGOR comma_list(var)
## LR(1) items:
formula_simple -> BIGOR comma_list(var) . IN comma_list(expr) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On IN shift to state 249
## Reductions:

State 249:
## Known stack suffix:
## BIGOR comma_list(var) IN
## LR(1) items:
formula_simple -> BIGOR comma_list(var) IN . comma_list(expr) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 250
## Reductions:

State 250:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr)
## LR(1) items:
formula_simple -> BIGOR comma_list(var) IN comma_list(expr) . option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On WHEN shift to state 168
-- On option(when_cond) shift to state 251
## Reductions:
-- On COLON reduce production option(when_cond) ->

State 251:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond)
## LR(1) items:
formula_simple -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) . COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 252
## Reductions:

State 252:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON
## LR(1) items:
formula_simple -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON . formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 285
## Reductions:

State 253:
## Known stack suffix:
## BIGAND
## LR(1) items:
formula_simple -> BIGAND . comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 254
## Reductions:

State 254:
## Known stack suffix:
## BIGAND comma_list(var)
## LR(1) items:
formula_simple -> BIGAND comma_list(var) . IN comma_list(expr) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On IN shift to state 255
## Reductions:

State 255:
## Known stack suffix:
## BIGAND comma_list(var) IN
## LR(1) items:
formula_simple -> BIGAND comma_list(var) IN . comma_list(expr) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 256
## Reductions:

State 256:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr)
## LR(1) items:
formula_simple -> BIGAND comma_list(var) IN comma_list(expr) . option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On WHEN shift to state 168
-- On option(when_cond) shift to state 257
## Reductions:
-- On COLON reduce production option(when_cond) ->

State 257:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond)
## LR(1) items:
formula_simple -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) . COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 258
## Reductions:

State 258:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON
## LR(1) items:
formula_simple -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON . formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 272
## Reductions:

State 259:
## Known stack suffix:
## ATMOST
## LR(1) items:
formula_simple -> ATMOST . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 260
## Reductions:

State 260:
## Known stack suffix:
## ATMOST expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_simple -> ATMOST expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 261
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 261:
## Known stack suffix:
## ATMOST expr COMMA
## LR(1) items:
formula_simple -> ATMOST expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 262
## Reductions:

State 262:
## Known stack suffix:
## ATMOST expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_simple -> ATMOST expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 263
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 263:
## Known stack suffix:
## ATMOST expr COMMA expr RPAREN
## LR(1) items:
formula_simple -> ATMOST expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> ATMOST expr COMMA expr RPAREN

State 264:
## Known stack suffix:
## ATLEAST
## LR(1) items:
formula_simple -> ATLEAST . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 265
## Reductions:

State 265:
## Known stack suffix:
## ATLEAST expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_simple -> ATLEAST expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 266
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 266:
## Known stack suffix:
## ATLEAST expr COMMA
## LR(1) items:
formula_simple -> ATLEAST expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## ATLEAST expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_simple -> ATLEAST expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 268
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 268:
## Known stack suffix:
## ATLEAST expr COMMA expr RPAREN
## LR(1) items:
formula_simple -> ATLEAST expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> ATLEAST expr COMMA expr RPAREN

State 269:
## Known stack suffix:
## var
## LR(1) items:
formula_simple -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> var

State 270:
## Known stack suffix:
## prop
## LR(1) items:
formula_simple -> prop . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> prop

State 271:
## Known stack suffix:
## let_affect(expr,formula_simple)
## LR(1) items:
formula_simple -> let_affect(expr,formula_simple) . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> let_affect(expr,formula_simple)

State 272:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On NEWLINE shift to state 279
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On END shift to state 284
-- On AND shift to state 277
## Reductions:

State 273:
## Known stack suffix:
## formula_simple XOR
## LR(1) items:
formula_simple -> formula_simple XOR . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 274
## Reductions:

State 274:
## Known stack suffix:
## formula_simple XOR formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple XOR formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> formula_simple XOR formula_simple

State 275:
## Known stack suffix:
## formula_simple OR
## LR(1) items:
formula_simple -> formula_simple OR . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 276
## Reductions:

State 276:
## Known stack suffix:
## formula_simple OR formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple OR formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
-- On AND shift to state 277
## Reductions:
-- On VARTUPLE reduce production formula_simple -> formula_simple OR formula_simple
-- On VAR reduce production formula_simple -> formula_simple OR formula_simple
-- On TUPLE reduce production formula_simple -> formula_simple OR formula_simple
-- On TOP reduce production formula_simple -> formula_simple OR formula_simple
-- On TERM reduce production formula_simple -> formula_simple OR formula_simple
-- On RPAREN reduce production formula_simple -> formula_simple OR formula_simple
-- On OR reduce production formula_simple -> formula_simple OR formula_simple
-- On NOT reduce production formula_simple -> formula_simple OR formula_simple
-- On NEWLINE reduce production formula_simple -> formula_simple OR formula_simple
-- On LPAREN reduce production formula_simple -> formula_simple OR formula_simple
-- On LET reduce production formula_simple -> formula_simple OR formula_simple
-- On IMPLIES reduce production formula_simple -> formula_simple OR formula_simple
-- On IF reduce production formula_simple -> formula_simple OR formula_simple
-- On EXACT reduce production formula_simple -> formula_simple OR formula_simple
-- On EQUIV reduce production formula_simple -> formula_simple OR formula_simple
-- On EOF reduce production formula_simple -> formula_simple OR formula_simple
-- On END reduce production formula_simple -> formula_simple OR formula_simple
-- On ELSE reduce production formula_simple -> formula_simple OR formula_simple
-- On DATA reduce production formula_simple -> formula_simple OR formula_simple
-- On BOTTOM reduce production formula_simple -> formula_simple OR formula_simple
-- On BIGOR reduce production formula_simple -> formula_simple OR formula_simple
-- On BIGAND reduce production formula_simple -> formula_simple OR formula_simple
-- On ATMOST reduce production formula_simple -> formula_simple OR formula_simple
-- On ATLEAST reduce production formula_simple -> formula_simple OR formula_simple

State 277:
## Known stack suffix:
## formula_simple AND
## LR(1) items:
formula_simple -> formula_simple AND . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 278
## Reductions:

State 278:
## Known stack suffix:
## formula_simple AND formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple AND formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
## Reductions:
-- On VARTUPLE reduce production formula_simple -> formula_simple AND formula_simple
-- On VAR reduce production formula_simple -> formula_simple AND formula_simple
-- On TUPLE reduce production formula_simple -> formula_simple AND formula_simple
-- On TOP reduce production formula_simple -> formula_simple AND formula_simple
-- On TERM reduce production formula_simple -> formula_simple AND formula_simple
-- On RPAREN reduce production formula_simple -> formula_simple AND formula_simple
-- On OR reduce production formula_simple -> formula_simple AND formula_simple
-- On NOT reduce production formula_simple -> formula_simple AND formula_simple
-- On NEWLINE reduce production formula_simple -> formula_simple AND formula_simple
-- On LPAREN reduce production formula_simple -> formula_simple AND formula_simple
-- On LET reduce production formula_simple -> formula_simple AND formula_simple
-- On IMPLIES reduce production formula_simple -> formula_simple AND formula_simple
-- On IF reduce production formula_simple -> formula_simple AND formula_simple
-- On EXACT reduce production formula_simple -> formula_simple AND formula_simple
-- On EQUIV reduce production formula_simple -> formula_simple AND formula_simple
-- On EOF reduce production formula_simple -> formula_simple AND formula_simple
-- On END reduce production formula_simple -> formula_simple AND formula_simple
-- On ELSE reduce production formula_simple -> formula_simple AND formula_simple
-- On DATA reduce production formula_simple -> formula_simple AND formula_simple
-- On BOTTOM reduce production formula_simple -> formula_simple AND formula_simple
-- On BIGOR reduce production formula_simple -> formula_simple AND formula_simple
-- On BIGAND reduce production formula_simple -> formula_simple AND formula_simple
-- On ATMOST reduce production formula_simple -> formula_simple AND formula_simple
-- On ATLEAST reduce production formula_simple -> formula_simple AND formula_simple
-- On AND reduce production formula_simple -> formula_simple AND formula_simple

State 279:
## Known stack suffix:
## formula_simple NEWLINE
## LR(1) items:
formula_simple -> formula_simple NEWLINE . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> formula_simple NEWLINE

State 280:
## Known stack suffix:
## formula_simple IMPLIES
## LR(1) items:
formula_simple -> formula_simple IMPLIES . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 281
## Reductions:

State 281:
## Known stack suffix:
## formula_simple IMPLIES formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple IMPLIES formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On AND shift to state 277
## Reductions:
-- On VARTUPLE reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On VAR reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On TUPLE reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On TOP reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On TERM reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On RPAREN reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On NOT reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On NEWLINE reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On LPAREN reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On LET reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On IF reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On EXACT reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On EOF reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On END reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On ELSE reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On DATA reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On BOTTOM reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On BIGOR reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On BIGAND reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On ATMOST reduce production formula_simple -> formula_simple IMPLIES formula_simple
-- On ATLEAST reduce production formula_simple -> formula_simple IMPLIES formula_simple

State 282:
## Known stack suffix:
## formula_simple EQUIV
## LR(1) items:
formula_simple -> formula_simple EQUIV . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 283
## Reductions:

State 283:
## Known stack suffix:
## formula_simple EQUIV formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple EQUIV formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On AND shift to state 277
## Reductions:
-- On VARTUPLE reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On VAR reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On TUPLE reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On TOP reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On TERM reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On RPAREN reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On NOT reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On NEWLINE reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On LPAREN reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On LET reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On IF reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On EXACT reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On EOF reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On END reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On ELSE reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On DATA reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On BOTTOM reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On BIGOR reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On BIGAND reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On ATMOST reduce production formula_simple -> formula_simple EQUIV formula_simple
-- On ATLEAST reduce production formula_simple -> formula_simple EQUIV formula_simple

State 284:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END
## LR(1) items:
formula_simple -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END

State 285:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On NEWLINE shift to state 279
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On END shift to state 286
-- On AND shift to state 277
## Reductions:

State 286:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END
## LR(1) items:
formula_simple -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_simple END

State 287:
## Known stack suffix:
## IF expr THEN formula_simple
## LR(1) items:
formula_simple -> IF expr THEN formula_simple . ELSE formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . AND formula_simple [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_simple -> formula_simple . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On NEWLINE shift to state 279
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On ELSE shift to state 288
-- On AND shift to state 277
## Reductions:

State 288:
## Known stack suffix:
## IF expr THEN formula_simple ELSE
## LR(1) items:
formula_simple -> IF expr THEN formula_simple ELSE . formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 269
-- On prop shift to state 270
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 289
## Reductions:

State 289:
## Known stack suffix:
## IF expr THEN formula_simple ELSE formula_simple
## LR(1) items:
formula_simple -> IF expr THEN formula_simple ELSE formula_simple . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . AND formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_simple -> formula_simple . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On NEWLINE shift to state 279
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On END shift to state 290
-- On AND shift to state 277
## Reductions:

State 290:
## Known stack suffix:
## IF expr THEN formula_simple ELSE formula_simple END
## LR(1) items:
formula_simple -> IF expr THEN formula_simple ELSE formula_simple END . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> IF expr THEN formula_simple ELSE formula_simple END

State 291:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On AND shift to state 277
## Reductions:
-- On VARTUPLE reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On VAR reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On TUPLE reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On TOP reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On TERM reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On RPAREN reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On NOT reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On NEWLINE reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On LPAREN reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On LET reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On IF reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On EXACT reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On EOF reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On END reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On ELSE reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On DATA reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On BOTTOM reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On BIGOR reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On BIGAND reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On ATMOST reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple
-- On ATLEAST reduce production let_affect(expr,formula_simple) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_simple

State 292:
## Known stack suffix:
## LPAREN formula_simple
## LR(1) items:
formula_simple -> LPAREN formula_simple . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . AND formula_simple [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_simple -> formula_simple . NEWLINE [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
## Transitions:
-- On XOR shift to state 273
-- On RPAREN shift to state 293
-- On OR shift to state 275
-- On NEWLINE shift to state 279
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On AND shift to state 277
## Reductions:

State 293:
## Known stack suffix:
## LPAREN formula_simple RPAREN
## LR(1) items:
formula_simple -> LPAREN formula_simple RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> LPAREN formula_simple RPAREN

State 294:
## Known stack suffix:
## NEWLINE formula_simple
## LR(1) items:
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> NEWLINE formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On AND shift to state 277
## Reductions:
-- On VARTUPLE reduce production formula_simple -> NEWLINE formula_simple
-- On VAR reduce production formula_simple -> NEWLINE formula_simple
-- On TUPLE reduce production formula_simple -> NEWLINE formula_simple
-- On TOP reduce production formula_simple -> NEWLINE formula_simple
-- On TERM reduce production formula_simple -> NEWLINE formula_simple
-- On RPAREN reduce production formula_simple -> NEWLINE formula_simple
-- On NOT reduce production formula_simple -> NEWLINE formula_simple
-- On NEWLINE reduce production formula_simple -> NEWLINE formula_simple
-- On LPAREN reduce production formula_simple -> NEWLINE formula_simple
-- On LET reduce production formula_simple -> NEWLINE formula_simple
-- On IF reduce production formula_simple -> NEWLINE formula_simple
-- On EXACT reduce production formula_simple -> NEWLINE formula_simple
-- On EOF reduce production formula_simple -> NEWLINE formula_simple
-- On END reduce production formula_simple -> NEWLINE formula_simple
-- On ELSE reduce production formula_simple -> NEWLINE formula_simple
-- On DATA reduce production formula_simple -> NEWLINE formula_simple
-- On BOTTOM reduce production formula_simple -> NEWLINE formula_simple
-- On BIGOR reduce production formula_simple -> NEWLINE formula_simple
-- On BIGAND reduce production formula_simple -> NEWLINE formula_simple
-- On ATMOST reduce production formula_simple -> NEWLINE formula_simple
-- On ATLEAST reduce production formula_simple -> NEWLINE formula_simple

State 295:
## Known stack suffix:
## NOT formula_simple
## LR(1) items:
formula_simple -> NOT formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_simple -> NOT formula_simple

State 296:
## Known stack suffix:
## var
## LR(1) items:
affect_or(formula_simple) -> var . AFFECT expr [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
formula_simple -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On AFFECT shift to state 297
## Reductions:
-- On XOR reduce production formula_simple -> var
-- On VARTUPLE reduce production formula_simple -> var
-- On VAR reduce production formula_simple -> var
-- On TUPLE reduce production formula_simple -> var
-- On TOP reduce production formula_simple -> var
-- On TERM reduce production formula_simple -> var
-- On OR reduce production formula_simple -> var
-- On NOT reduce production formula_simple -> var
-- On NEWLINE reduce production formula_simple -> var
-- On LPAREN reduce production formula_simple -> var
-- On LET reduce production formula_simple -> var
-- On IMPLIES reduce production formula_simple -> var
-- On IF reduce production formula_simple -> var
-- On EXACT reduce production formula_simple -> var
-- On EQUIV reduce production formula_simple -> var
-- On EOF reduce production formula_simple -> var
-- On DATA reduce production formula_simple -> var
-- On BOTTOM reduce production formula_simple -> var
-- On BIGOR reduce production formula_simple -> var
-- On BIGAND reduce production formula_simple -> var
-- On ATMOST reduce production formula_simple -> var
-- On ATLEAST reduce production formula_simple -> var
-- On AND reduce production formula_simple -> var

State 297:
## Known stack suffix:
## var AFFECT
## LR(1) items:
affect_or(formula_simple) -> var AFFECT . expr [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 298
## Reductions:

State 298:
## Known stack suffix:
## var AFFECT expr
## LR(1) items:
affect_or(formula_simple) -> var AFFECT expr . [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
expr -> expr . ADD expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER IN IMPLIES IF GT GE EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On VARTUPLE reduce production affect_or(formula_simple) -> var AFFECT expr
-- On VAR reduce production affect_or(formula_simple) -> var AFFECT expr
-- On TUPLE reduce production affect_or(formula_simple) -> var AFFECT expr
-- On TOP reduce production affect_or(formula_simple) -> var AFFECT expr
-- On TERM reduce production affect_or(formula_simple) -> var AFFECT expr
-- On NOT reduce production affect_or(formula_simple) -> var AFFECT expr
-- On NEWLINE reduce production affect_or(formula_simple) -> var AFFECT expr
-- On LPAREN reduce production affect_or(formula_simple) -> var AFFECT expr
-- On LET reduce production affect_or(formula_simple) -> var AFFECT expr
-- On IF reduce production affect_or(formula_simple) -> var AFFECT expr
-- On EXACT reduce production affect_or(formula_simple) -> var AFFECT expr
-- On EOF reduce production affect_or(formula_simple) -> var AFFECT expr
-- On BOTTOM reduce production affect_or(formula_simple) -> var AFFECT expr
-- On BIGOR reduce production affect_or(formula_simple) -> var AFFECT expr
-- On BIGAND reduce production affect_or(formula_simple) -> var AFFECT expr
-- On ATMOST reduce production affect_or(formula_simple) -> var AFFECT expr
-- On ATLEAST reduce production affect_or(formula_simple) -> var AFFECT expr

State 299:
## Known stack suffix:
## touist_simple
## LR(1) items:
touist_simple' -> touist_simple . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept touist_simple

State 300:
## Known stack suffix:
## nonempty_list(affect_or(formula_simple))
## LR(1) items:
touist_simple -> nonempty_list(affect_or(formula_simple)) . EOF [ # ]
## Transitions:
-- On EOF shift to state 301
## Reductions:

State 301:
## Known stack suffix:
## nonempty_list(affect_or(formula_simple)) EOF
## LR(1) items:
touist_simple -> nonempty_list(affect_or(formula_simple)) EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production touist_simple -> nonempty_list(affect_or(formula_simple)) EOF

State 302:
## Known stack suffix:
## formula_simple
## LR(1) items:
affect_or(formula_simple) -> formula_simple . option(DATA) [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
formula_simple -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_simple -> formula_simple . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT NEWLINE LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 273
-- On OR shift to state 275
-- On NEWLINE shift to state 279
-- On IMPLIES shift to state 280
-- On EQUIV shift to state 282
-- On DATA shift to state 224
-- On AND shift to state 277
-- On option(DATA) shift to state 303
## Reductions:
-- On VARTUPLE reduce production option(DATA) ->
-- On VAR reduce production option(DATA) ->
-- On TUPLE reduce production option(DATA) ->
-- On TOP reduce production option(DATA) ->
-- On TERM reduce production option(DATA) ->
-- On NOT reduce production option(DATA) ->
-- On LPAREN reduce production option(DATA) ->
-- On LET reduce production option(DATA) ->
-- On IF reduce production option(DATA) ->
-- On EXACT reduce production option(DATA) ->
-- On EOF reduce production option(DATA) ->
-- On BOTTOM reduce production option(DATA) ->
-- On BIGOR reduce production option(DATA) ->
-- On BIGAND reduce production option(DATA) ->
-- On ATMOST reduce production option(DATA) ->
-- On ATLEAST reduce production option(DATA) ->

State 303:
## Known stack suffix:
## formula_simple option(DATA)
## LR(1) items:
affect_or(formula_simple) -> formula_simple option(DATA) . [ VARTUPLE VAR TUPLE TOP TERM NOT NEWLINE LPAREN LET IF EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production affect_or(formula_simple) -> formula_simple option(DATA)

State 304:
## Known stack suffix:
## affect_or(formula_simple)
## LR(1) items:
nonempty_list(affect_or(formula_simple)) -> affect_or(formula_simple) . [ EOF ]
nonempty_list(affect_or(formula_simple)) -> affect_or(formula_simple) . nonempty_list(affect_or(formula_simple)) [ EOF ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 229
-- On TERM shift to state 7
-- On NOT shift to state 230
-- On NEWLINE shift to state 231
-- On LPAREN shift to state 232
-- On LET shift to state 233
-- On IF shift to state 238
-- On EXACT shift to state 241
-- On BOTTOM shift to state 246
-- On BIGOR shift to state 247
-- On BIGAND shift to state 253
-- On ATMOST shift to state 259
-- On ATLEAST shift to state 264
-- On var shift to state 296
-- On prop shift to state 270
-- On nonempty_list(affect_or(formula_simple)) shift to state 305
-- On let_affect(expr,formula_simple) shift to state 271
-- On formula_simple shift to state 302
-- On affect_or(formula_simple) shift to state 304
## Reductions:
-- On EOF reduce production nonempty_list(affect_or(formula_simple)) -> affect_or(formula_simple)

State 305:
## Known stack suffix:
## affect_or(formula_simple) nonempty_list(affect_or(formula_simple))
## LR(1) items:
nonempty_list(affect_or(formula_simple)) -> affect_or(formula_simple) nonempty_list(affect_or(formula_simple)) . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(affect_or(formula_simple)) -> affect_or(formula_simple) nonempty_list(affect_or(formula_simple))

State 306:
## Known stack suffix:
##
## LR(1) items:
touist_smt' -> . touist_smt [ # ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 403
-- On touist_smt shift to state 406
-- On prop shift to state 314
-- On nonempty_list(affect_or(formula_smt)) shift to state 407
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 409
-- On expr_smt shift to state 380
-- On affect_or(formula_smt) shift to state 411
## Reductions:

State 307:
## Known stack suffix:
## TOP
## LR(1) items:
expr_smt -> TOP . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr_smt -> TOP

State 308:
## Known stack suffix:
## SUB
## LR(1) items:
expr_smt -> SUB . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 337
## Reductions:

State 309:
## Known stack suffix:
## LPAREN
## LR(1) items:
expr_smt -> LPAREN . expr_smt RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 315
## Reductions:

State 310:
## Known stack suffix:
## INT
## LR(1) items:
expr_smt -> INT . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr_smt -> INT

State 311:
## Known stack suffix:
## FLOAT
## LR(1) items:
expr_smt -> FLOAT . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr_smt -> FLOAT

State 312:
## Known stack suffix:
## BOTTOM
## LR(1) items:
expr_smt -> BOTTOM . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr_smt -> BOTTOM

State 313:
## Known stack suffix:
## var
## LR(1) items:
expr_smt -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr_smt -> var

State 314:
## Known stack suffix:
## prop
## LR(1) items:
expr_smt -> prop . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr_smt -> prop

State 315:
## Known stack suffix:
## LPAREN expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . LE expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . GT expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . GE expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . ADD expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . SUB expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . MUL expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . DIV expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ SUB RPAREN NOTEQUAL MUL LT LE GT GE EQUAL DIV ADD ]
expr_smt -> LPAREN expr_smt . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On RPAREN shift to state 322
-- On NOTEQUAL shift to state 323
-- On MUL shift to state 318
-- On LT shift to state 327
-- On LE shift to state 329
-- On GT shift to state 331
-- On GE shift to state 333
-- On EQUAL shift to state 335
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:

State 316:
## Known stack suffix:
## expr_smt SUB
## LR(1) items:
expr_smt -> expr_smt SUB . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 317
## Reductions:

State 317:
## Known stack suffix:
## expr_smt SUB expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt SUB expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MUL shift to state 318
-- On DIV shift to state 320
## Reductions:
-- On XOR reduce production expr_smt -> expr_smt SUB expr_smt
-- On VARTUPLE reduce production expr_smt -> expr_smt SUB expr_smt
-- On VAR reduce production expr_smt -> expr_smt SUB expr_smt
-- On TUPLE reduce production expr_smt -> expr_smt SUB expr_smt
-- On TOP reduce production expr_smt -> expr_smt SUB expr_smt
-- On TERM reduce production expr_smt -> expr_smt SUB expr_smt
-- On SUB reduce production expr_smt -> expr_smt SUB expr_smt
-- On RPAREN reduce production expr_smt -> expr_smt SUB expr_smt
-- On OR reduce production expr_smt -> expr_smt SUB expr_smt
-- On NOTEQUAL reduce production expr_smt -> expr_smt SUB expr_smt
-- On NOT reduce production expr_smt -> expr_smt SUB expr_smt
-- On NEWLINE reduce production expr_smt -> expr_smt SUB expr_smt
-- On LT reduce production expr_smt -> expr_smt SUB expr_smt
-- On LPAREN reduce production expr_smt -> expr_smt SUB expr_smt
-- On LET reduce production expr_smt -> expr_smt SUB expr_smt
-- On LE reduce production expr_smt -> expr_smt SUB expr_smt
-- On INT reduce production expr_smt -> expr_smt SUB expr_smt
-- On IMPLIES reduce production expr_smt -> expr_smt SUB expr_smt
-- On IF reduce production expr_smt -> expr_smt SUB expr_smt
-- On GT reduce production expr_smt -> expr_smt SUB expr_smt
-- On GE reduce production expr_smt -> expr_smt SUB expr_smt
-- On FLOAT reduce production expr_smt -> expr_smt SUB expr_smt
-- On EXACT reduce production expr_smt -> expr_smt SUB expr_smt
-- On EQUIV reduce production expr_smt -> expr_smt SUB expr_smt
-- On EQUAL reduce production expr_smt -> expr_smt SUB expr_smt
-- On EOF reduce production expr_smt -> expr_smt SUB expr_smt
-- On END reduce production expr_smt -> expr_smt SUB expr_smt
-- On ELSE reduce production expr_smt -> expr_smt SUB expr_smt
-- On DATA reduce production expr_smt -> expr_smt SUB expr_smt
-- On BOTTOM reduce production expr_smt -> expr_smt SUB expr_smt
-- On BIGOR reduce production expr_smt -> expr_smt SUB expr_smt
-- On BIGAND reduce production expr_smt -> expr_smt SUB expr_smt
-- On ATMOST reduce production expr_smt -> expr_smt SUB expr_smt
-- On ATLEAST reduce production expr_smt -> expr_smt SUB expr_smt
-- On AND reduce production expr_smt -> expr_smt SUB expr_smt
-- On ADD reduce production expr_smt -> expr_smt SUB expr_smt

State 318:
## Known stack suffix:
## expr_smt MUL
## LR(1) items:
expr_smt -> expr_smt MUL . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 319
## Reductions:

State 319:
## Known stack suffix:
## expr_smt MUL expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt MUL expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr_smt -> expr_smt MUL expr_smt

State 320:
## Known stack suffix:
## expr_smt DIV
## LR(1) items:
expr_smt -> expr_smt DIV . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 321
## Reductions:

State 321:
## Known stack suffix:
## expr_smt DIV expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt DIV expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr_smt -> expr_smt DIV expr_smt

State 322:
## Known stack suffix:
## LPAREN expr_smt RPAREN
## LR(1) items:
expr_smt -> LPAREN expr_smt RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production expr_smt -> LPAREN expr_smt RPAREN

State 323:
## Known stack suffix:
## expr_smt NOTEQUAL
## LR(1) items:
expr_smt -> expr_smt NOTEQUAL . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 324
## Reductions:

State 324:
## Known stack suffix:
## expr_smt NOTEQUAL expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt NOTEQUAL expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On MUL shift to state 318
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On VARTUPLE reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On VAR reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On TUPLE reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On TOP reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On TERM reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On RPAREN reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On OR reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On NOT reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On NEWLINE reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On LPAREN reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On LET reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On INT reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On IMPLIES reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On IF reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On FLOAT reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On EXACT reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On EQUIV reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On EOF reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On END reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On ELSE reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On DATA reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On BOTTOM reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On BIGOR reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On BIGAND reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On ATMOST reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On ATLEAST reduce production expr_smt -> expr_smt NOTEQUAL expr_smt
-- On AND reduce production expr_smt -> expr_smt NOTEQUAL expr_smt

State 325:
## Known stack suffix:
## expr_smt ADD
## LR(1) items:
expr_smt -> expr_smt ADD . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 326
## Reductions:

State 326:
## Known stack suffix:
## expr_smt ADD expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt ADD expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MUL shift to state 318
-- On DIV shift to state 320
## Reductions:
-- On XOR reduce production expr_smt -> expr_smt ADD expr_smt
-- On VARTUPLE reduce production expr_smt -> expr_smt ADD expr_smt
-- On VAR reduce production expr_smt -> expr_smt ADD expr_smt
-- On TUPLE reduce production expr_smt -> expr_smt ADD expr_smt
-- On TOP reduce production expr_smt -> expr_smt ADD expr_smt
-- On TERM reduce production expr_smt -> expr_smt ADD expr_smt
-- On SUB reduce production expr_smt -> expr_smt ADD expr_smt
-- On RPAREN reduce production expr_smt -> expr_smt ADD expr_smt
-- On OR reduce production expr_smt -> expr_smt ADD expr_smt
-- On NOTEQUAL reduce production expr_smt -> expr_smt ADD expr_smt
-- On NOT reduce production expr_smt -> expr_smt ADD expr_smt
-- On NEWLINE reduce production expr_smt -> expr_smt ADD expr_smt
-- On LT reduce production expr_smt -> expr_smt ADD expr_smt
-- On LPAREN reduce production expr_smt -> expr_smt ADD expr_smt
-- On LET reduce production expr_smt -> expr_smt ADD expr_smt
-- On LE reduce production expr_smt -> expr_smt ADD expr_smt
-- On INT reduce production expr_smt -> expr_smt ADD expr_smt
-- On IMPLIES reduce production expr_smt -> expr_smt ADD expr_smt
-- On IF reduce production expr_smt -> expr_smt ADD expr_smt
-- On GT reduce production expr_smt -> expr_smt ADD expr_smt
-- On GE reduce production expr_smt -> expr_smt ADD expr_smt
-- On FLOAT reduce production expr_smt -> expr_smt ADD expr_smt
-- On EXACT reduce production expr_smt -> expr_smt ADD expr_smt
-- On EQUIV reduce production expr_smt -> expr_smt ADD expr_smt
-- On EQUAL reduce production expr_smt -> expr_smt ADD expr_smt
-- On EOF reduce production expr_smt -> expr_smt ADD expr_smt
-- On END reduce production expr_smt -> expr_smt ADD expr_smt
-- On ELSE reduce production expr_smt -> expr_smt ADD expr_smt
-- On DATA reduce production expr_smt -> expr_smt ADD expr_smt
-- On BOTTOM reduce production expr_smt -> expr_smt ADD expr_smt
-- On BIGOR reduce production expr_smt -> expr_smt ADD expr_smt
-- On BIGAND reduce production expr_smt -> expr_smt ADD expr_smt
-- On ATMOST reduce production expr_smt -> expr_smt ADD expr_smt
-- On ATLEAST reduce production expr_smt -> expr_smt ADD expr_smt
-- On AND reduce production expr_smt -> expr_smt ADD expr_smt
-- On ADD reduce production expr_smt -> expr_smt ADD expr_smt

State 327:
## Known stack suffix:
## expr_smt LT
## LR(1) items:
expr_smt -> expr_smt LT . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 328
## Reductions:

State 328:
## Known stack suffix:
## expr_smt LT expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt LT expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On MUL shift to state 318
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR reduce production expr_smt -> expr_smt LT expr_smt
-- On VARTUPLE reduce production expr_smt -> expr_smt LT expr_smt
-- On VAR reduce production expr_smt -> expr_smt LT expr_smt
-- On TUPLE reduce production expr_smt -> expr_smt LT expr_smt
-- On TOP reduce production expr_smt -> expr_smt LT expr_smt
-- On TERM reduce production expr_smt -> expr_smt LT expr_smt
-- On RPAREN reduce production expr_smt -> expr_smt LT expr_smt
-- On OR reduce production expr_smt -> expr_smt LT expr_smt
-- On NOT reduce production expr_smt -> expr_smt LT expr_smt
-- On NEWLINE reduce production expr_smt -> expr_smt LT expr_smt
-- On LPAREN reduce production expr_smt -> expr_smt LT expr_smt
-- On LET reduce production expr_smt -> expr_smt LT expr_smt
-- On INT reduce production expr_smt -> expr_smt LT expr_smt
-- On IMPLIES reduce production expr_smt -> expr_smt LT expr_smt
-- On IF reduce production expr_smt -> expr_smt LT expr_smt
-- On FLOAT reduce production expr_smt -> expr_smt LT expr_smt
-- On EXACT reduce production expr_smt -> expr_smt LT expr_smt
-- On EQUIV reduce production expr_smt -> expr_smt LT expr_smt
-- On EOF reduce production expr_smt -> expr_smt LT expr_smt
-- On END reduce production expr_smt -> expr_smt LT expr_smt
-- On ELSE reduce production expr_smt -> expr_smt LT expr_smt
-- On DATA reduce production expr_smt -> expr_smt LT expr_smt
-- On BOTTOM reduce production expr_smt -> expr_smt LT expr_smt
-- On BIGOR reduce production expr_smt -> expr_smt LT expr_smt
-- On BIGAND reduce production expr_smt -> expr_smt LT expr_smt
-- On ATMOST reduce production expr_smt -> expr_smt LT expr_smt
-- On ATLEAST reduce production expr_smt -> expr_smt LT expr_smt
-- On AND reduce production expr_smt -> expr_smt LT expr_smt

State 329:
## Known stack suffix:
## expr_smt LE
## LR(1) items:
expr_smt -> expr_smt LE . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 330
## Reductions:

State 330:
## Known stack suffix:
## expr_smt LE expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt LE expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On MUL shift to state 318
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR reduce production expr_smt -> expr_smt LE expr_smt
-- On VARTUPLE reduce production expr_smt -> expr_smt LE expr_smt
-- On VAR reduce production expr_smt -> expr_smt LE expr_smt
-- On TUPLE reduce production expr_smt -> expr_smt LE expr_smt
-- On TOP reduce production expr_smt -> expr_smt LE expr_smt
-- On TERM reduce production expr_smt -> expr_smt LE expr_smt
-- On RPAREN reduce production expr_smt -> expr_smt LE expr_smt
-- On OR reduce production expr_smt -> expr_smt LE expr_smt
-- On NOT reduce production expr_smt -> expr_smt LE expr_smt
-- On NEWLINE reduce production expr_smt -> expr_smt LE expr_smt
-- On LPAREN reduce production expr_smt -> expr_smt LE expr_smt
-- On LET reduce production expr_smt -> expr_smt LE expr_smt
-- On INT reduce production expr_smt -> expr_smt LE expr_smt
-- On IMPLIES reduce production expr_smt -> expr_smt LE expr_smt
-- On IF reduce production expr_smt -> expr_smt LE expr_smt
-- On FLOAT reduce production expr_smt -> expr_smt LE expr_smt
-- On EXACT reduce production expr_smt -> expr_smt LE expr_smt
-- On EQUIV reduce production expr_smt -> expr_smt LE expr_smt
-- On EOF reduce production expr_smt -> expr_smt LE expr_smt
-- On END reduce production expr_smt -> expr_smt LE expr_smt
-- On ELSE reduce production expr_smt -> expr_smt LE expr_smt
-- On DATA reduce production expr_smt -> expr_smt LE expr_smt
-- On BOTTOM reduce production expr_smt -> expr_smt LE expr_smt
-- On BIGOR reduce production expr_smt -> expr_smt LE expr_smt
-- On BIGAND reduce production expr_smt -> expr_smt LE expr_smt
-- On ATMOST reduce production expr_smt -> expr_smt LE expr_smt
-- On ATLEAST reduce production expr_smt -> expr_smt LE expr_smt
-- On AND reduce production expr_smt -> expr_smt LE expr_smt

State 331:
## Known stack suffix:
## expr_smt GT
## LR(1) items:
expr_smt -> expr_smt GT . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 332
## Reductions:

State 332:
## Known stack suffix:
## expr_smt GT expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt GT expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On MUL shift to state 318
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR reduce production expr_smt -> expr_smt GT expr_smt
-- On VARTUPLE reduce production expr_smt -> expr_smt GT expr_smt
-- On VAR reduce production expr_smt -> expr_smt GT expr_smt
-- On TUPLE reduce production expr_smt -> expr_smt GT expr_smt
-- On TOP reduce production expr_smt -> expr_smt GT expr_smt
-- On TERM reduce production expr_smt -> expr_smt GT expr_smt
-- On RPAREN reduce production expr_smt -> expr_smt GT expr_smt
-- On OR reduce production expr_smt -> expr_smt GT expr_smt
-- On NOT reduce production expr_smt -> expr_smt GT expr_smt
-- On NEWLINE reduce production expr_smt -> expr_smt GT expr_smt
-- On LPAREN reduce production expr_smt -> expr_smt GT expr_smt
-- On LET reduce production expr_smt -> expr_smt GT expr_smt
-- On INT reduce production expr_smt -> expr_smt GT expr_smt
-- On IMPLIES reduce production expr_smt -> expr_smt GT expr_smt
-- On IF reduce production expr_smt -> expr_smt GT expr_smt
-- On FLOAT reduce production expr_smt -> expr_smt GT expr_smt
-- On EXACT reduce production expr_smt -> expr_smt GT expr_smt
-- On EQUIV reduce production expr_smt -> expr_smt GT expr_smt
-- On EOF reduce production expr_smt -> expr_smt GT expr_smt
-- On END reduce production expr_smt -> expr_smt GT expr_smt
-- On ELSE reduce production expr_smt -> expr_smt GT expr_smt
-- On DATA reduce production expr_smt -> expr_smt GT expr_smt
-- On BOTTOM reduce production expr_smt -> expr_smt GT expr_smt
-- On BIGOR reduce production expr_smt -> expr_smt GT expr_smt
-- On BIGAND reduce production expr_smt -> expr_smt GT expr_smt
-- On ATMOST reduce production expr_smt -> expr_smt GT expr_smt
-- On ATLEAST reduce production expr_smt -> expr_smt GT expr_smt
-- On AND reduce production expr_smt -> expr_smt GT expr_smt

State 333:
## Known stack suffix:
## expr_smt GE
## LR(1) items:
expr_smt -> expr_smt GE . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 334
## Reductions:

State 334:
## Known stack suffix:
## expr_smt GE expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt GE expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On MUL shift to state 318
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR reduce production expr_smt -> expr_smt GE expr_smt
-- On VARTUPLE reduce production expr_smt -> expr_smt GE expr_smt
-- On VAR reduce production expr_smt -> expr_smt GE expr_smt
-- On TUPLE reduce production expr_smt -> expr_smt GE expr_smt
-- On TOP reduce production expr_smt -> expr_smt GE expr_smt
-- On TERM reduce production expr_smt -> expr_smt GE expr_smt
-- On RPAREN reduce production expr_smt -> expr_smt GE expr_smt
-- On OR reduce production expr_smt -> expr_smt GE expr_smt
-- On NOT reduce production expr_smt -> expr_smt GE expr_smt
-- On NEWLINE reduce production expr_smt -> expr_smt GE expr_smt
-- On LPAREN reduce production expr_smt -> expr_smt GE expr_smt
-- On LET reduce production expr_smt -> expr_smt GE expr_smt
-- On INT reduce production expr_smt -> expr_smt GE expr_smt
-- On IMPLIES reduce production expr_smt -> expr_smt GE expr_smt
-- On IF reduce production expr_smt -> expr_smt GE expr_smt
-- On FLOAT reduce production expr_smt -> expr_smt GE expr_smt
-- On EXACT reduce production expr_smt -> expr_smt GE expr_smt
-- On EQUIV reduce production expr_smt -> expr_smt GE expr_smt
-- On EOF reduce production expr_smt -> expr_smt GE expr_smt
-- On END reduce production expr_smt -> expr_smt GE expr_smt
-- On ELSE reduce production expr_smt -> expr_smt GE expr_smt
-- On DATA reduce production expr_smt -> expr_smt GE expr_smt
-- On BOTTOM reduce production expr_smt -> expr_smt GE expr_smt
-- On BIGOR reduce production expr_smt -> expr_smt GE expr_smt
-- On BIGAND reduce production expr_smt -> expr_smt GE expr_smt
-- On ATMOST reduce production expr_smt -> expr_smt GE expr_smt
-- On ATLEAST reduce production expr_smt -> expr_smt GE expr_smt
-- On AND reduce production expr_smt -> expr_smt GE expr_smt

State 335:
## Known stack suffix:
## expr_smt EQUAL
## LR(1) items:
expr_smt -> expr_smt EQUAL . expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On LPAREN shift to state 309
-- On INT shift to state 310
-- On FLOAT shift to state 311
-- On BOTTOM shift to state 312
-- On var shift to state 313
-- On prop shift to state 314
-- On expr_smt shift to state 336
## Reductions:

State 336:
## Known stack suffix:
## expr_smt EQUAL expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt EQUAL expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On SUB shift to state 316
-- On MUL shift to state 318
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On VARTUPLE reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On VAR reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On TUPLE reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On TOP reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On TERM reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On RPAREN reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On OR reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On NOT reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On NEWLINE reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On LPAREN reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On LET reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On INT reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On IMPLIES reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On IF reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On FLOAT reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On EXACT reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On EQUIV reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On EOF reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On END reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On ELSE reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On DATA reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On BOTTOM reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On BIGOR reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On BIGAND reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On ATMOST reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On ATLEAST reduce production expr_smt -> expr_smt EQUAL expr_smt
-- On AND reduce production expr_smt -> expr_smt EQUAL expr_smt

State 337:
## Known stack suffix:
## SUB expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> SUB expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On MUL shift to state 318
-- On DIV shift to state 320
## Reductions:
-- On XOR reduce production expr_smt -> SUB expr_smt
-- On VARTUPLE reduce production expr_smt -> SUB expr_smt
-- On VAR reduce production expr_smt -> SUB expr_smt
-- On TUPLE reduce production expr_smt -> SUB expr_smt
-- On TOP reduce production expr_smt -> SUB expr_smt
-- On TERM reduce production expr_smt -> SUB expr_smt
-- On SUB reduce production expr_smt -> SUB expr_smt
-- On RPAREN reduce production expr_smt -> SUB expr_smt
-- On OR reduce production expr_smt -> SUB expr_smt
-- On NOTEQUAL reduce production expr_smt -> SUB expr_smt
-- On NOT reduce production expr_smt -> SUB expr_smt
-- On NEWLINE reduce production expr_smt -> SUB expr_smt
-- On LT reduce production expr_smt -> SUB expr_smt
-- On LPAREN reduce production expr_smt -> SUB expr_smt
-- On LET reduce production expr_smt -> SUB expr_smt
-- On LE reduce production expr_smt -> SUB expr_smt
-- On INT reduce production expr_smt -> SUB expr_smt
-- On IMPLIES reduce production expr_smt -> SUB expr_smt
-- On IF reduce production expr_smt -> SUB expr_smt
-- On GT reduce production expr_smt -> SUB expr_smt
-- On GE reduce production expr_smt -> SUB expr_smt
-- On FLOAT reduce production expr_smt -> SUB expr_smt
-- On EXACT reduce production expr_smt -> SUB expr_smt
-- On EQUIV reduce production expr_smt -> SUB expr_smt
-- On EQUAL reduce production expr_smt -> SUB expr_smt
-- On EOF reduce production expr_smt -> SUB expr_smt
-- On END reduce production expr_smt -> SUB expr_smt
-- On ELSE reduce production expr_smt -> SUB expr_smt
-- On DATA reduce production expr_smt -> SUB expr_smt
-- On BOTTOM reduce production expr_smt -> SUB expr_smt
-- On BIGOR reduce production expr_smt -> SUB expr_smt
-- On BIGAND reduce production expr_smt -> SUB expr_smt
-- On ATMOST reduce production expr_smt -> SUB expr_smt
-- On ATLEAST reduce production expr_smt -> SUB expr_smt
-- On AND reduce production expr_smt -> SUB expr_smt
-- On ADD reduce production expr_smt -> SUB expr_smt

State 338:
## Known stack suffix:
## NOT
## LR(1) items:
formula_smt -> NOT . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 402
-- On expr_smt shift to state 380
## Reductions:

State 339:
## Known stack suffix:
## NEWLINE
## LR(1) items:
formula_smt -> NEWLINE . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 401
-- On expr_smt shift to state 380
## Reductions:

State 340:
## Known stack suffix:
## LPAREN
## LR(1) items:
expr_smt -> LPAREN . expr_smt RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
formula_smt -> LPAREN . formula_smt RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 398
-- On expr_smt shift to state 400
## Reductions:

State 341:
## Known stack suffix:
## LET
## LR(1) items:
let_affect(expr,formula_smt) -> LET . comma_list(var) AFFECT comma_list(expr) COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 342
## Reductions:

State 342:
## Known stack suffix:
## LET comma_list(var)
## LR(1) items:
let_affect(expr,formula_smt) -> LET comma_list(var) . AFFECT comma_list(expr) COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On AFFECT shift to state 343
## Reductions:

State 343:
## Known stack suffix:
## LET comma_list(var) AFFECT
## LR(1) items:
let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT . comma_list(expr) COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 344
## Reductions:

State 344:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr)
## LR(1) items:
let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) . COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 345
## Reductions:

State 345:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr) COLON
## LR(1) items:
let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 397
-- On expr_smt shift to state 380
## Reductions:

State 346:
## Known stack suffix:
## IF
## LR(1) items:
formula_smt -> IF . expr THEN formula_smt ELSE formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 347
## Reductions:

State 347:
## Known stack suffix:
## IF expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION THEN SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_smt -> IF expr . THEN formula_smt ELSE formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On THEN shift to state 348
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 348:
## Known stack suffix:
## IF expr THEN
## LR(1) items:
formula_smt -> IF expr THEN . formula_smt ELSE formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 393
-- On expr_smt shift to state 380
## Reductions:

State 349:
## Known stack suffix:
## EXACT
## LR(1) items:
formula_smt -> EXACT . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 350
## Reductions:

State 350:
## Known stack suffix:
## EXACT expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_smt -> EXACT expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 351
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 351:
## Known stack suffix:
## EXACT expr COMMA
## LR(1) items:
formula_smt -> EXACT expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 352
## Reductions:

State 352:
## Known stack suffix:
## EXACT expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_smt -> EXACT expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 353
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 353:
## Known stack suffix:
## EXACT expr COMMA expr RPAREN
## LR(1) items:
formula_smt -> EXACT expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_smt -> EXACT expr COMMA expr RPAREN

State 354:
## Known stack suffix:
## BIGOR
## LR(1) items:
formula_smt -> BIGOR . comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 355
## Reductions:

State 355:
## Known stack suffix:
## BIGOR comma_list(var)
## LR(1) items:
formula_smt -> BIGOR comma_list(var) . IN comma_list(expr) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On IN shift to state 356
## Reductions:

State 356:
## Known stack suffix:
## BIGOR comma_list(var) IN
## LR(1) items:
formula_smt -> BIGOR comma_list(var) IN . comma_list(expr) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 357
## Reductions:

State 357:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr)
## LR(1) items:
formula_smt -> BIGOR comma_list(var) IN comma_list(expr) . option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On WHEN shift to state 168
-- On option(when_cond) shift to state 358
## Reductions:
-- On COLON reduce production option(when_cond) ->

State 358:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond)
## LR(1) items:
formula_smt -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) . COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 359
## Reductions:

State 359:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON
## LR(1) items:
formula_smt -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON . formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 391
-- On expr_smt shift to state 380
## Reductions:

State 360:
## Known stack suffix:
## BIGAND
## LR(1) items:
formula_smt -> BIGAND . comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On var shift to state 130
-- On comma_list(var) shift to state 361
## Reductions:

State 361:
## Known stack suffix:
## BIGAND comma_list(var)
## LR(1) items:
formula_smt -> BIGAND comma_list(var) . IN comma_list(expr) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On IN shift to state 362
## Reductions:

State 362:
## Known stack suffix:
## BIGAND comma_list(var) IN
## LR(1) items:
formula_smt -> BIGAND comma_list(var) IN . comma_list(expr) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 94
-- On comma_list(expr) shift to state 363
## Reductions:

State 363:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr)
## LR(1) items:
formula_smt -> BIGAND comma_list(var) IN comma_list(expr) . option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On WHEN shift to state 168
-- On option(when_cond) shift to state 364
## Reductions:
-- On COLON reduce production option(when_cond) ->

State 364:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond)
## LR(1) items:
formula_smt -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) . COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On COLON shift to state 365
## Reductions:

State 365:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON
## LR(1) items:
formula_smt -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON . formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 377
-- On expr_smt shift to state 380
## Reductions:

State 366:
## Known stack suffix:
## ATMOST
## LR(1) items:
formula_smt -> ATMOST . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 367
## Reductions:

State 367:
## Known stack suffix:
## ATMOST expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_smt -> ATMOST expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 368
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 368:
## Known stack suffix:
## ATMOST expr COMMA
## LR(1) items:
formula_smt -> ATMOST expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 369
## Reductions:

State 369:
## Known stack suffix:
## ATMOST expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_smt -> ATMOST expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 370
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 370:
## Known stack suffix:
## ATMOST expr COMMA expr RPAREN
## LR(1) items:
formula_smt -> ATMOST expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_smt -> ATMOST expr COMMA expr RPAREN

State 371:
## Known stack suffix:
## ATLEAST
## LR(1) items:
formula_smt -> ATLEAST . expr COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 372
## Reductions:

State 372:
## Known stack suffix:
## ATLEAST expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF COMMA AND ADD ]
formula_smt -> ATLEAST expr . COMMA expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On COMMA shift to state 373
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 373:
## Known stack suffix:
## ATLEAST expr COMMA
## LR(1) items:
formula_smt -> ATLEAST expr COMMA . expr RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 374
## Reductions:

State 374:
## Known stack suffix:
## ATLEAST expr COMMA expr
## LR(1) items:
expr -> expr . ADD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUB expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MUL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . MOD expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . AND expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . OR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . XOR expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IMPLIES expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUIV expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . EQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . LE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GT expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . GE expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . SUBSET expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . IN expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . UNION expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . INTER expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
expr -> expr . DIFF expr [ XOR UNION SUBSET SUB RPAREN OR NOTEQUAL MUL MOD LT LE INTER IN IMPLIES GT GE EQUIV EQUAL DIV DIFF AND ADD ]
formula_smt -> ATLEAST expr COMMA expr . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On RPAREN shift to state 375
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:

State 375:
## Known stack suffix:
## ATLEAST expr COMMA expr RPAREN
## LR(1) items:
formula_smt -> ATLEAST expr COMMA expr RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_smt -> ATLEAST expr COMMA expr RPAREN

State 376:
## Known stack suffix:
## let_affect(expr,formula_smt)
## LR(1) items:
formula_smt -> let_affect(expr,formula_smt) . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_smt -> let_affect(expr,formula_smt)

State 377:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt . END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On NEWLINE shift to state 385
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On END shift to state 390
-- On AND shift to state 383
## Reductions:

State 378:
## Known stack suffix:
## formula_smt XOR
## LR(1) items:
formula_smt -> formula_smt XOR . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 379
-- On expr_smt shift to state 380
## Reductions:

State 379:
## Known stack suffix:
## formula_smt XOR formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt XOR formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_smt -> formula_smt XOR formula_smt

State 380:
## Known stack suffix:
## expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
formula_smt -> expr_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On SUB shift to state 316
-- On NOTEQUAL shift to state 323
-- On MUL shift to state 318
-- On LT shift to state 327
-- On LE shift to state 329
-- On GT shift to state 331
-- On GE shift to state 333
-- On EQUAL shift to state 335
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR reduce production formula_smt -> expr_smt
-- On VARTUPLE reduce production formula_smt -> expr_smt
-- On VAR reduce production formula_smt -> expr_smt
-- On TUPLE reduce production formula_smt -> expr_smt
-- On TOP reduce production formula_smt -> expr_smt
-- On TERM reduce production formula_smt -> expr_smt
-- On RPAREN reduce production formula_smt -> expr_smt
-- On OR reduce production formula_smt -> expr_smt
-- On NOT reduce production formula_smt -> expr_smt
-- On NEWLINE reduce production formula_smt -> expr_smt
-- On LPAREN reduce production formula_smt -> expr_smt
-- On LET reduce production formula_smt -> expr_smt
-- On INT reduce production formula_smt -> expr_smt
-- On IMPLIES reduce production formula_smt -> expr_smt
-- On IF reduce production formula_smt -> expr_smt
-- On FLOAT reduce production formula_smt -> expr_smt
-- On EXACT reduce production formula_smt -> expr_smt
-- On EQUIV reduce production formula_smt -> expr_smt
-- On EOF reduce production formula_smt -> expr_smt
-- On END reduce production formula_smt -> expr_smt
-- On ELSE reduce production formula_smt -> expr_smt
-- On DATA reduce production formula_smt -> expr_smt
-- On BOTTOM reduce production formula_smt -> expr_smt
-- On BIGOR reduce production formula_smt -> expr_smt
-- On BIGAND reduce production formula_smt -> expr_smt
-- On ATMOST reduce production formula_smt -> expr_smt
-- On ATLEAST reduce production formula_smt -> expr_smt
-- On AND reduce production formula_smt -> expr_smt

State 381:
## Known stack suffix:
## formula_smt OR
## LR(1) items:
formula_smt -> formula_smt OR . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 382
-- On expr_smt shift to state 380
## Reductions:

State 382:
## Known stack suffix:
## formula_smt OR formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt OR formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
-- On AND shift to state 383
## Reductions:
-- On VARTUPLE reduce production formula_smt -> formula_smt OR formula_smt
-- On VAR reduce production formula_smt -> formula_smt OR formula_smt
-- On TUPLE reduce production formula_smt -> formula_smt OR formula_smt
-- On TOP reduce production formula_smt -> formula_smt OR formula_smt
-- On TERM reduce production formula_smt -> formula_smt OR formula_smt
-- On SUB reduce production formula_smt -> formula_smt OR formula_smt
-- On RPAREN reduce production formula_smt -> formula_smt OR formula_smt
-- On OR reduce production formula_smt -> formula_smt OR formula_smt
-- On NOT reduce production formula_smt -> formula_smt OR formula_smt
-- On NEWLINE reduce production formula_smt -> formula_smt OR formula_smt
-- On LPAREN reduce production formula_smt -> formula_smt OR formula_smt
-- On LET reduce production formula_smt -> formula_smt OR formula_smt
-- On INT reduce production formula_smt -> formula_smt OR formula_smt
-- On IMPLIES reduce production formula_smt -> formula_smt OR formula_smt
-- On IF reduce production formula_smt -> formula_smt OR formula_smt
-- On FLOAT reduce production formula_smt -> formula_smt OR formula_smt
-- On EXACT reduce production formula_smt -> formula_smt OR formula_smt
-- On EQUIV reduce production formula_smt -> formula_smt OR formula_smt
-- On EOF reduce production formula_smt -> formula_smt OR formula_smt
-- On END reduce production formula_smt -> formula_smt OR formula_smt
-- On ELSE reduce production formula_smt -> formula_smt OR formula_smt
-- On DATA reduce production formula_smt -> formula_smt OR formula_smt
-- On BOTTOM reduce production formula_smt -> formula_smt OR formula_smt
-- On BIGOR reduce production formula_smt -> formula_smt OR formula_smt
-- On BIGAND reduce production formula_smt -> formula_smt OR formula_smt
-- On ATMOST reduce production formula_smt -> formula_smt OR formula_smt
-- On ATLEAST reduce production formula_smt -> formula_smt OR formula_smt

State 383:
## Known stack suffix:
## formula_smt AND
## LR(1) items:
formula_smt -> formula_smt AND . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 384
-- On expr_smt shift to state 380
## Reductions:

State 384:
## Known stack suffix:
## formula_smt AND formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt AND formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
## Reductions:
-- On VARTUPLE reduce production formula_smt -> formula_smt AND formula_smt
-- On VAR reduce production formula_smt -> formula_smt AND formula_smt
-- On TUPLE reduce production formula_smt -> formula_smt AND formula_smt
-- On TOP reduce production formula_smt -> formula_smt AND formula_smt
-- On TERM reduce production formula_smt -> formula_smt AND formula_smt
-- On SUB reduce production formula_smt -> formula_smt AND formula_smt
-- On RPAREN reduce production formula_smt -> formula_smt AND formula_smt
-- On OR reduce production formula_smt -> formula_smt AND formula_smt
-- On NOT reduce production formula_smt -> formula_smt AND formula_smt
-- On NEWLINE reduce production formula_smt -> formula_smt AND formula_smt
-- On LPAREN reduce production formula_smt -> formula_smt AND formula_smt
-- On LET reduce production formula_smt -> formula_smt AND formula_smt
-- On INT reduce production formula_smt -> formula_smt AND formula_smt
-- On IMPLIES reduce production formula_smt -> formula_smt AND formula_smt
-- On IF reduce production formula_smt -> formula_smt AND formula_smt
-- On FLOAT reduce production formula_smt -> formula_smt AND formula_smt
-- On EXACT reduce production formula_smt -> formula_smt AND formula_smt
-- On EQUIV reduce production formula_smt -> formula_smt AND formula_smt
-- On EOF reduce production formula_smt -> formula_smt AND formula_smt
-- On END reduce production formula_smt -> formula_smt AND formula_smt
-- On ELSE reduce production formula_smt -> formula_smt AND formula_smt
-- On DATA reduce production formula_smt -> formula_smt AND formula_smt
-- On BOTTOM reduce production formula_smt -> formula_smt AND formula_smt
-- On BIGOR reduce production formula_smt -> formula_smt AND formula_smt
-- On BIGAND reduce production formula_smt -> formula_smt AND formula_smt
-- On ATMOST reduce production formula_smt -> formula_smt AND formula_smt
-- On ATLEAST reduce production formula_smt -> formula_smt AND formula_smt
-- On AND reduce production formula_smt -> formula_smt AND formula_smt

State 385:
## Known stack suffix:
## formula_smt NEWLINE
## LR(1) items:
formula_smt -> formula_smt NEWLINE . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_smt -> formula_smt NEWLINE

State 386:
## Known stack suffix:
## formula_smt IMPLIES
## LR(1) items:
formula_smt -> formula_smt IMPLIES . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 387
-- On expr_smt shift to state 380
## Reductions:

State 387:
## Known stack suffix:
## formula_smt IMPLIES formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt IMPLIES formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On AND shift to state 383
## Reductions:
-- On VARTUPLE reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On VAR reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On TUPLE reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On TOP reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On TERM reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On SUB reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On RPAREN reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On NOT reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On NEWLINE reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On LPAREN reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On LET reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On INT reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On IF reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On FLOAT reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On EXACT reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On EOF reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On END reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On ELSE reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On DATA reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On BOTTOM reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On BIGOR reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On BIGAND reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On ATMOST reduce production formula_smt -> formula_smt IMPLIES formula_smt
-- On ATLEAST reduce production formula_smt -> formula_smt IMPLIES formula_smt

State 388:
## Known stack suffix:
## formula_smt EQUIV
## LR(1) items:
formula_smt -> formula_smt EQUIV . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 389
-- On expr_smt shift to state 380
## Reductions:

State 389:
## Known stack suffix:
## formula_smt EQUIV formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt EQUIV formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On AND shift to state 383
## Reductions:
-- On VARTUPLE reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On VAR reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On TUPLE reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On TOP reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On TERM reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On SUB reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On RPAREN reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On NOT reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On NEWLINE reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On LPAREN reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On LET reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On INT reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On IF reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On FLOAT reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On EXACT reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On EOF reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On END reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On ELSE reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On DATA reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On BOTTOM reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On BIGOR reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On BIGAND reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On ATMOST reduce production formula_smt -> formula_smt EQUIV formula_smt
-- On ATLEAST reduce production formula_smt -> formula_smt EQUIV formula_smt

State 390:
## Known stack suffix:
## BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END
## LR(1) items:
formula_smt -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_smt -> BIGAND comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END

State 391:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt . END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On NEWLINE shift to state 385
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On END shift to state 392
-- On AND shift to state 383
## Reductions:

State 392:
## Known stack suffix:
## BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END
## LR(1) items:
formula_smt -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_smt -> BIGOR comma_list(var) IN comma_list(expr) option(when_cond) COLON formula_smt END

State 393:
## Known stack suffix:
## IF expr THEN formula_smt
## LR(1) items:
formula_smt -> IF expr THEN formula_smt . ELSE formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . AND formula_smt [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
formula_smt -> formula_smt . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV ELSE AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On NEWLINE shift to state 385
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On ELSE shift to state 394
-- On AND shift to state 383
## Reductions:

State 394:
## Known stack suffix:
## IF expr THEN formula_smt ELSE
## LR(1) items:
formula_smt -> IF expr THEN formula_smt ELSE . formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 313
-- On prop shift to state 314
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 395
-- On expr_smt shift to state 380
## Reductions:

State 395:
## Known stack suffix:
## IF expr THEN formula_smt ELSE formula_smt
## LR(1) items:
formula_smt -> IF expr THEN formula_smt ELSE formula_smt . END [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . AND formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
formula_smt -> formula_smt . NEWLINE [ XOR OR NEWLINE IMPLIES EQUIV END AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On NEWLINE shift to state 385
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On END shift to state 396
-- On AND shift to state 383
## Reductions:

State 396:
## Known stack suffix:
## IF expr THEN formula_smt ELSE formula_smt END
## LR(1) items:
formula_smt -> IF expr THEN formula_smt ELSE formula_smt END . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_smt -> IF expr THEN formula_smt ELSE formula_smt END

State 397:
## Known stack suffix:
## LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On AND shift to state 383
## Reductions:
-- On VARTUPLE reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On VAR reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On TUPLE reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On TOP reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On TERM reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On SUB reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On RPAREN reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On NOT reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On NEWLINE reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On LPAREN reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On LET reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On INT reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On IF reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On FLOAT reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On EXACT reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On EOF reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On END reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On ELSE reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On DATA reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On BOTTOM reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On BIGOR reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On BIGAND reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On ATMOST reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt
-- On ATLEAST reduce production let_affect(expr,formula_smt) -> LET comma_list(var) AFFECT comma_list(expr) COLON formula_smt

State 398:
## Known stack suffix:
## LPAREN formula_smt
## LR(1) items:
formula_smt -> LPAREN formula_smt . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . AND formula_smt [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
formula_smt -> formula_smt . NEWLINE [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
## Transitions:
-- On XOR shift to state 378
-- On RPAREN shift to state 399
-- On OR shift to state 381
-- On NEWLINE shift to state 385
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On AND shift to state 383
## Reductions:

State 399:
## Known stack suffix:
## LPAREN formula_smt RPAREN
## LR(1) items:
formula_smt -> LPAREN formula_smt RPAREN . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_smt -> LPAREN formula_smt RPAREN

State 400:
## Known stack suffix:
## LPAREN expr_smt
## LR(1) items:
expr_smt -> expr_smt . LT expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . LE expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . GT expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . GE expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . ADD expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . SUB expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . MUL expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . DIV expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . EQUAL expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> expr_smt . NOTEQUAL expr_smt [ XOR SUB RPAREN OR NOTEQUAL NEWLINE MUL LT LE IMPLIES GT GE EQUIV EQUAL DIV AND ADD ]
expr_smt -> LPAREN expr_smt . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
formula_smt -> expr_smt . [ XOR RPAREN OR NEWLINE IMPLIES EQUIV AND ]
## Transitions:
-- On SUB shift to state 316
-- On RPAREN shift to state 322
-- On NOTEQUAL shift to state 323
-- On MUL shift to state 318
-- On LT shift to state 327
-- On LE shift to state 329
-- On GT shift to state 331
-- On GE shift to state 333
-- On EQUAL shift to state 335
-- On DIV shift to state 320
-- On ADD shift to state 325
## Reductions:
-- On XOR reduce production formula_smt -> expr_smt
-- On OR reduce production formula_smt -> expr_smt
-- On NEWLINE reduce production formula_smt -> expr_smt
-- On IMPLIES reduce production formula_smt -> expr_smt
-- On EQUIV reduce production formula_smt -> expr_smt
-- On AND reduce production formula_smt -> expr_smt

State 401:
## Known stack suffix:
## NEWLINE formula_smt
## LR(1) items:
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> NEWLINE formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On AND shift to state 383
## Reductions:
-- On VARTUPLE reduce production formula_smt -> NEWLINE formula_smt
-- On VAR reduce production formula_smt -> NEWLINE formula_smt
-- On TUPLE reduce production formula_smt -> NEWLINE formula_smt
-- On TOP reduce production formula_smt -> NEWLINE formula_smt
-- On TERM reduce production formula_smt -> NEWLINE formula_smt
-- On SUB reduce production formula_smt -> NEWLINE formula_smt
-- On RPAREN reduce production formula_smt -> NEWLINE formula_smt
-- On NOT reduce production formula_smt -> NEWLINE formula_smt
-- On NEWLINE reduce production formula_smt -> NEWLINE formula_smt
-- On LPAREN reduce production formula_smt -> NEWLINE formula_smt
-- On LET reduce production formula_smt -> NEWLINE formula_smt
-- On INT reduce production formula_smt -> NEWLINE formula_smt
-- On IF reduce production formula_smt -> NEWLINE formula_smt
-- On FLOAT reduce production formula_smt -> NEWLINE formula_smt
-- On EXACT reduce production formula_smt -> NEWLINE formula_smt
-- On EOF reduce production formula_smt -> NEWLINE formula_smt
-- On END reduce production formula_smt -> NEWLINE formula_smt
-- On ELSE reduce production formula_smt -> NEWLINE formula_smt
-- On DATA reduce production formula_smt -> NEWLINE formula_smt
-- On BOTTOM reduce production formula_smt -> NEWLINE formula_smt
-- On BIGOR reduce production formula_smt -> NEWLINE formula_smt
-- On BIGAND reduce production formula_smt -> NEWLINE formula_smt
-- On ATMOST reduce production formula_smt -> NEWLINE formula_smt
-- On ATLEAST reduce production formula_smt -> NEWLINE formula_smt

State 402:
## Known stack suffix:
## NOT formula_smt
## LR(1) items:
formula_smt -> NOT formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB RPAREN OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production formula_smt -> NOT formula_smt

State 403:
## Known stack suffix:
## var
## LR(1) items:
affect_or(formula_smt) -> var . AFFECT expr [ VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
expr_smt -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOTEQUAL NOT NEWLINE MUL LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On AFFECT shift to state 404
## Reductions:
-- On XOR reduce production expr_smt -> var
-- On VARTUPLE reduce production expr_smt -> var
-- On VAR reduce production expr_smt -> var
-- On TUPLE reduce production expr_smt -> var
-- On TOP reduce production expr_smt -> var
-- On TERM reduce production expr_smt -> var
-- On SUB reduce production expr_smt -> var
-- On OR reduce production expr_smt -> var
-- On NOTEQUAL reduce production expr_smt -> var
-- On NOT reduce production expr_smt -> var
-- On NEWLINE reduce production expr_smt -> var
-- On MUL reduce production expr_smt -> var
-- On LT reduce production expr_smt -> var
-- On LPAREN reduce production expr_smt -> var
-- On LET reduce production expr_smt -> var
-- On LE reduce production expr_smt -> var
-- On INT reduce production expr_smt -> var
-- On IMPLIES reduce production expr_smt -> var
-- On IF reduce production expr_smt -> var
-- On GT reduce production expr_smt -> var
-- On GE reduce production expr_smt -> var
-- On FLOAT reduce production expr_smt -> var
-- On EXACT reduce production expr_smt -> var
-- On EQUIV reduce production expr_smt -> var
-- On EQUAL reduce production expr_smt -> var
-- On EOF reduce production expr_smt -> var
-- On DIV reduce production expr_smt -> var
-- On DATA reduce production expr_smt -> var
-- On BOTTOM reduce production expr_smt -> var
-- On BIGOR reduce production expr_smt -> var
-- On BIGAND reduce production expr_smt -> var
-- On ATMOST reduce production expr_smt -> var
-- On ATLEAST reduce production expr_smt -> var
-- On AND reduce production expr_smt -> var
-- On ADD reduce production expr_smt -> var

State 404:
## Known stack suffix:
## var AFFECT
## LR(1) items:
affect_or(formula_smt) -> var AFFECT . expr [ VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On UNION_PR shift to state 3
-- On TUPLE shift to state 4
-- On TOINT shift to state 5
-- On TOFLOAT shift to state 6
-- On TERM shift to state 7
-- On SUBSET_PR shift to state 8
-- On SUB shift to state 9
-- On SQRT shift to state 10
-- On POWERSET shift to state 11
-- On NOT shift to state 12
-- On LPAREN shift to state 13
-- On LBRACK shift to state 14
-- On INTER_PR shift to state 16
-- On INT shift to state 17
-- On IF shift to state 18
-- On FLOAT shift to state 19
-- On EMPTY shift to state 20
-- On DIFF_PR shift to state 21
-- On CARD shift to state 22
-- On BOOL shift to state 23
-- On ABS shift to state 24
-- On var shift to state 25
-- On prop shift to state 26
-- On expr shift to state 405
## Reductions:

State 405:
## Known stack suffix:
## var AFFECT expr
## LR(1) items:
affect_or(formula_smt) -> var AFFECT expr . [ VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
expr -> expr . ADD expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUB expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MUL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIV expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . MOD expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . AND expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . OR expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . XOR expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IMPLIES expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUIV expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . EQUAL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . NOTEQUAL expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LT expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . LE expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GT expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . GE expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . SUBSET expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . IN expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . UNION expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . INTER expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
expr -> expr . DIFF expr [ XOR VARTUPLE VAR UNION TUPLE TOP TERM SUBSET SUB OR NOTEQUAL NOT NEWLINE MUL MOD LT LPAREN LET LE INTER INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DIV DIFF BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ]
## Transitions:
-- On XOR shift to state 28
-- On UNION shift to state 54
-- On SUBSET shift to state 56
-- On SUB shift to state 30
-- On OR shift to state 58
-- On NOTEQUAL shift to state 38
-- On MUL shift to state 32
-- On MOD shift to state 34
-- On LT shift to state 42
-- On LE shift to state 44
-- On INTER shift to state 67
-- On IN shift to state 46
-- On IMPLIES shift to state 62
-- On GT shift to state 48
-- On GE shift to state 50
-- On EQUIV shift to state 64
-- On EQUAL shift to state 52
-- On DIV shift to state 36
-- On DIFF shift to state 69
-- On AND shift to state 60
-- On ADD shift to state 40
## Reductions:
-- On VARTUPLE reduce production affect_or(formula_smt) -> var AFFECT expr
-- On VAR reduce production affect_or(formula_smt) -> var AFFECT expr
-- On TUPLE reduce production affect_or(formula_smt) -> var AFFECT expr
-- On TOP reduce production affect_or(formula_smt) -> var AFFECT expr
-- On TERM reduce production affect_or(formula_smt) -> var AFFECT expr
-- On NOT reduce production affect_or(formula_smt) -> var AFFECT expr
-- On NEWLINE reduce production affect_or(formula_smt) -> var AFFECT expr
-- On LPAREN reduce production affect_or(formula_smt) -> var AFFECT expr
-- On LET reduce production affect_or(formula_smt) -> var AFFECT expr
-- On INT reduce production affect_or(formula_smt) -> var AFFECT expr
-- On IF reduce production affect_or(formula_smt) -> var AFFECT expr
-- On FLOAT reduce production affect_or(formula_smt) -> var AFFECT expr
-- On EXACT reduce production affect_or(formula_smt) -> var AFFECT expr
-- On EOF reduce production affect_or(formula_smt) -> var AFFECT expr
-- On BOTTOM reduce production affect_or(formula_smt) -> var AFFECT expr
-- On BIGOR reduce production affect_or(formula_smt) -> var AFFECT expr
-- On BIGAND reduce production affect_or(formula_smt) -> var AFFECT expr
-- On ATMOST reduce production affect_or(formula_smt) -> var AFFECT expr
-- On ATLEAST reduce production affect_or(formula_smt) -> var AFFECT expr

State 406:
## Known stack suffix:
## touist_smt
## LR(1) items:
touist_smt' -> touist_smt . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, accept touist_smt

State 407:
## Known stack suffix:
## nonempty_list(affect_or(formula_smt))
## LR(1) items:
touist_smt -> nonempty_list(affect_or(formula_smt)) . EOF [ # ]
## Transitions:
-- On EOF shift to state 408
## Reductions:

State 408:
## Known stack suffix:
## nonempty_list(affect_or(formula_smt)) EOF
## LR(1) items:
touist_smt -> nonempty_list(affect_or(formula_smt)) EOF . [ # ]
## Transitions:
## Default reduction:
-- Without reading the next token, reduce production touist_smt -> nonempty_list(affect_or(formula_smt)) EOF

State 409:
## Known stack suffix:
## formula_smt
## LR(1) items:
affect_or(formula_smt) -> formula_smt . option(DATA) [ VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
formula_smt -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
formula_smt -> formula_smt . NEWLINE [ XOR VARTUPLE VAR TUPLE TOP TERM SUB OR NOT NEWLINE LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## Transitions:
-- On XOR shift to state 378
-- On OR shift to state 381
-- On NEWLINE shift to state 385
-- On IMPLIES shift to state 386
-- On EQUIV shift to state 388
-- On DATA shift to state 224
-- On AND shift to state 383
-- On option(DATA) shift to state 410
## Reductions:
-- On VARTUPLE reduce production option(DATA) ->
-- On VAR reduce production option(DATA) ->
-- On TUPLE reduce production option(DATA) ->
-- On TOP reduce production option(DATA) ->
-- On TERM reduce production option(DATA) ->
-- On SUB reduce production option(DATA) ->
-- On NOT reduce production option(DATA) ->
-- On LPAREN reduce production option(DATA) ->
-- On LET reduce production option(DATA) ->
-- On INT reduce production option(DATA) ->
-- On IF reduce production option(DATA) ->
-- On FLOAT reduce production option(DATA) ->
-- On EXACT reduce production option(DATA) ->
-- On EOF reduce production option(DATA) ->
-- On BOTTOM reduce production option(DATA) ->
-- On BIGOR reduce production option(DATA) ->
-- On BIGAND reduce production option(DATA) ->
-- On ATMOST reduce production option(DATA) ->
-- On ATLEAST reduce production option(DATA) ->

State 410:
## Known stack suffix:
## formula_smt option(DATA)
## LR(1) items:
affect_or(formula_smt) -> formula_smt option(DATA) . [ VARTUPLE VAR TUPLE TOP TERM SUB NOT NEWLINE LPAREN LET INT IF FLOAT EXACT EOF BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production affect_or(formula_smt) -> formula_smt option(DATA)

State 411:
## Known stack suffix:
## affect_or(formula_smt)
## LR(1) items:
nonempty_list(affect_or(formula_smt)) -> affect_or(formula_smt) . [ EOF ]
nonempty_list(affect_or(formula_smt)) -> affect_or(formula_smt) . nonempty_list(affect_or(formula_smt)) [ EOF ]
## Transitions:
-- On VARTUPLE shift to state 1
-- On VAR shift to state 2
-- On TUPLE shift to state 4
-- On TOP shift to state 307
-- On TERM shift to state 7
-- On SUB shift to state 308
-- On NOT shift to state 338
-- On NEWLINE shift to state 339
-- On LPAREN shift to state 340
-- On LET shift to state 341
-- On INT shift to state 310
-- On IF shift to state 346
-- On FLOAT shift to state 311
-- On EXACT shift to state 349
-- On BOTTOM shift to state 312
-- On BIGOR shift to state 354
-- On BIGAND shift to state 360
-- On ATMOST shift to state 366
-- On ATLEAST shift to state 371
-- On var shift to state 403
-- On prop shift to state 314
-- On nonempty_list(affect_or(formula_smt)) shift to state 412
-- On let_affect(expr,formula_smt) shift to state 376
-- On formula_smt shift to state 409
-- On expr_smt shift to state 380
-- On affect_or(formula_smt) shift to state 411
## Reductions:
-- On EOF reduce production nonempty_list(affect_or(formula_smt)) -> affect_or(formula_smt)

State 412:
## Known stack suffix:
## affect_or(formula_smt) nonempty_list(affect_or(formula_smt))
## LR(1) items:
nonempty_list(affect_or(formula_smt)) -> affect_or(formula_smt) nonempty_list(affect_or(formula_smt)) . [ EOF ]
## Transitions:
## Default reduction:
-- After reading the next token, reduce production nonempty_list(affect_or(formula_smt)) -> affect_or(formula_smt) nonempty_list(affect_or(formula_smt))

