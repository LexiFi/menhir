Grammar has 42 nonterminal symbols, among which 2 start symbols.
Grammar has 52 terminal symbols.
Grammar has 110 productions.
nullable(variables) = false
nullable(typ) = false
nullable(specification_alone) = false
nullable(specification) = false
nullable(set_operator) = false
nullable(set_function) = false
nullable(set_expression) = false
nullable(set_constraint) = false
nullable(separated_nonempty_list(STAR,located(atomic_layout))) = false
nullable(separated_nonempty_list(COMMA,pattern)) = false
nullable(separated_nonempty_list(COMMA,atomic_expression)) = false
nullable(separated_nonempty_list(COMMA,ID)) = false
nullable(raw_pattern) = false
nullable(raw_expression) = false
nullable(raw_atomic_expression) = false
nullable(program) = false
nullable(prefix_callee) = false
nullable(pattern) = false
nullable(optional_layout) = true
nullable(nonempty_list(branch)) = false
nullable(located(raw_pattern)) = false
nullable(located(raw_expression)) = false
nullable(located(raw_atomic_expression)) = false
nullable(located(optional_layout)) = true
nullable(located(layout)) = false
nullable(located(atomic_layout)) = false
nullable(list(preceded(WHERE,contrainte))) = true
nullable(list(definition)) = true
nullable(list(data_constructor_declaration)) = true
nullable(lenient_parenthesized_tuple(pattern)) = true
nullable(lenient_parenthesized_tuple(atomic_expression)) = true
nullable(layout) = false
nullable(kind) = true
nullable(expression) = false
nullable(definition) = false
nullable(data_constructor_declaration) = false
nullable(contraintes) = true
nullable(contrainte) = false
nullable(branch) = false
nullable(boolean_expression) = false
nullable(atomic_layout) = false
nullable(atomic_expression) = false
first(variables) = NOTHING ID
first(typ) = ID BOOL ATOMSET ATOM
first(specification_alone) = ACCEPTS
first(specification) = ACCEPTS
first(set_operator) = SUBSET DISJOINT CMPEQ
first(set_function) = SUPPORT OUTER INNER BOUND
first(set_expression) = SUPPORT OUTER LPAR INNER EMPTYSET BOUND
first(set_constraint) = SUPPORT OUTER LPAR INNER EMPTYSET BOUND
first(separated_nonempty_list(STAR,located(atomic_layout))) = OUTER LANGLE INNER ID BOOL ATOMSET ATOM
first(separated_nonempty_list(COMMA,pattern)) = WILD TRUE TAG ID FALSE
first(separated_nonempty_list(COMMA,atomic_expression)) = TRUE TAG SUPPORT OUTER NEXT MEMBER LPAR INNER ID FALSE CASE BOUND BNOT
first(separated_nonempty_list(COMMA,ID)) = ID
first(raw_pattern) = WILD TRUE TAG ID FALSE
first(raw_expression) = TRUE TAG SUPPORT OUTER NOTHING NEXT MEMBER LPAR LET INNER IF ID FRESH FALSE FAIL CASE BOUND BNOT ABSURD
first(raw_atomic_expression) = TRUE TAG SUPPORT OUTER NEXT MEMBER LPAR INNER ID FALSE CASE BOUND BNOT
first(program) = TYPE FUN EOF
first(prefix_callee) = SUPPORT OUTER MEMBER INNER ID BOUND
first(pattern) = WILD TRUE TAG ID FALSE
first(optional_layout) = OF
first(nonempty_list(branch)) = BAR
first(located(raw_pattern)) = WILD TRUE TAG ID FALSE
first(located(raw_expression)) = TRUE TAG SUPPORT OUTER NOTHING NEXT MEMBER LPAR LET INNER IF ID FRESH FALSE FAIL CASE BOUND BNOT ABSURD
first(located(raw_atomic_expression)) = TRUE TAG SUPPORT OUTER NEXT MEMBER LPAR INNER ID FALSE CASE BOUND BNOT
first(located(optional_layout)) = OF
first(located(layout)) = OUTER LANGLE INNER ID BOOL ATOMSET ATOM
first(located(atomic_layout)) = OUTER LANGLE INNER ID BOOL ATOMSET ATOM
first(list(preceded(WHERE,contrainte))) = WHERE
first(list(definition)) = TYPE FUN
first(list(data_constructor_declaration)) = BAR
first(lenient_parenthesized_tuple(pattern)) = LPAR
first(lenient_parenthesized_tuple(atomic_expression)) = LPAR
first(layout) = OUTER LANGLE INNER ID BOOL ATOMSET ATOM
first(kind) = BINDS
first(expression) = TRUE TAG SUPPORT OUTER NOTHING NEXT MEMBER LPAR LET INNER IF ID FRESH FALSE FAIL CASE BOUND BNOT ABSURD
first(definition) = TYPE FUN
first(data_constructor_declaration) = BAR
first(contraintes) = WHERE
first(contrainte) = TRUE SUPPORT OUTER LPAR INNER ID FALSE EMPTYSET BOUND BNOT
first(branch) = BAR
first(boolean_expression) = TRUE LPAR ID FALSE BNOT
first(atomic_layout) = OUTER LANGLE INNER ID BOOL ATOMSET ATOM
first(atomic_expression) = TRUE TAG SUPPORT OUTER NEXT MEMBER LPAR INNER ID FALSE CASE BOUND BNOT
minimal(variables) = (* 1 *) NOTHING
minimal(typ) = (* 1 *) ID
minimal(specification_alone) = (* 5 *) ACCEPTS NOTHING PRODUCES NOTHING EOF
minimal(specification) = (* 4 *) ACCEPTS NOTHING PRODUCES NOTHING
minimal(set_operator) = (* 1 *) SUBSET
minimal(set_function) = (* 1 *) SUPPORT
minimal(set_expression) = (* 1 *) EMPTYSET
minimal(set_constraint) = (* 3 *) EMPTYSET SUBSET EMPTYSET
minimal(separated_nonempty_list(STAR,located(atomic_layout))) = (* 1 *) ID
minimal(separated_nonempty_list(COMMA,pattern)) = (* 1 *) WILD
minimal(separated_nonempty_list(COMMA,atomic_expression)) = (* 1 *) ID
minimal(separated_nonempty_list(COMMA,ID)) = (* 1 *) ID
minimal(raw_pattern) = (* 1 *) WILD
minimal(raw_expression) = (* 1 *) ABSURD
minimal(raw_atomic_expression) = (* 1 *) ID
minimal(program) = (* 1 *) EOF
minimal(prefix_callee) = (* 1 *) ID
minimal(pattern) = (* 1 *) WILD
minimal(optional_layout) = (* 0 *)
minimal(nonempty_list(branch)) = (* 4 *) BAR WILD ARROW ABSURD
minimal(located(raw_pattern)) = (* 1 *) WILD
minimal(located(raw_expression)) = (* 1 *) ABSURD
minimal(located(raw_atomic_expression)) = (* 1 *) ID
minimal(located(optional_layout)) = (* 0 *)
minimal(located(layout)) = (* 1 *) ID
minimal(located(atomic_layout)) = (* 1 *) ID
minimal(list(preceded(WHERE,contrainte))) = (* 0 *)
minimal(list(definition)) = (* 0 *)
minimal(list(data_constructor_declaration)) = (* 0 *)
minimal(lenient_parenthesized_tuple(pattern)) = (* 0 *)
minimal(lenient_parenthesized_tuple(atomic_expression)) = (* 0 *)
minimal(layout) = (* 1 *) ID
minimal(kind) = (* 0 *)
minimal(expression) = (* 1 *) ABSURD
minimal(definition) = (* 3 *) TYPE ID DEFEQ
minimal(data_constructor_declaration) = (* 2 *) BAR TAG
minimal(contraintes) = (* 0 *)
minimal(contrainte) = (* 1 *) FALSE
minimal(branch) = (* 4 *) BAR WILD ARROW ABSURD
minimal(boolean_expression) = (* 1 *) FALSE
minimal(atomic_layout) = (* 1 *) ID
minimal(atomic_expression) = (* 1 *) ID
maximal(variables) = infinity
maximal(typ) = 1
maximal(specification_alone) = infinity
maximal(specification) = infinity
maximal(set_operator) = 1
maximal(set_function) = 1
maximal(set_expression) = infinity
maximal(set_constraint) = infinity
maximal(separated_nonempty_list(STAR,located(atomic_layout))) = infinity
maximal(separated_nonempty_list(COMMA,pattern)) = infinity
maximal(separated_nonempty_list(COMMA,atomic_expression)) = infinity
maximal(separated_nonempty_list(COMMA,ID)) = infinity
maximal(raw_pattern) = infinity
maximal(raw_expression) = infinity
maximal(raw_atomic_expression) = infinity
maximal(program) = infinity
maximal(prefix_callee) = 1
maximal(pattern) = infinity
maximal(optional_layout) = infinity
maximal(nonempty_list(branch)) = infinity
maximal(located(raw_pattern)) = infinity
maximal(located(raw_expression)) = infinity
maximal(located(raw_atomic_expression)) = infinity
maximal(located(optional_layout)) = infinity
maximal(located(layout)) = infinity
maximal(located(atomic_layout)) = infinity
maximal(list(preceded(WHERE,contrainte))) = infinity
maximal(list(definition)) = infinity
maximal(list(data_constructor_declaration)) = infinity
maximal(lenient_parenthesized_tuple(pattern)) = infinity
maximal(lenient_parenthesized_tuple(atomic_expression)) = infinity
maximal(layout) = infinity
maximal(kind) = 1
maximal(expression) = infinity
maximal(definition) = infinity
maximal(data_constructor_declaration) = infinity
maximal(contraintes) = infinity
maximal(contrainte) = infinity
maximal(branch) = infinity
maximal(boolean_expression) = infinity
maximal(atomic_layout) = infinity
maximal(atomic_expression) = infinity
follow(variables) = WHERE PRODUCES IN EOF DEFEQ
follow(typ) = WHERE TYPE STAR RANGLE FUN EOF BAR
follow(specification_alone) = #
follow(specification) = EOF DEFEQ
follow(set_operator) = SUPPORT OUTER LPAR INNER EMPTYSET BOUND
follow(set_function) = LPAR
follow(set_expression) = WHERE TYPE SUBSET SETUNION SETMINUS RPAR PRODUCES FUN EOF DISJOINT DEFEQ CMPEQ BAR
follow(set_constraint) = WHERE TYPE PRODUCES FUN EOF DEFEQ BAR
follow(separated_nonempty_list(STAR,located(atomic_layout))) = WHERE TYPE RANGLE FUN EOF BAR
follow(separated_nonempty_list(COMMA,pattern)) = RPAR ARROW
follow(separated_nonempty_list(COMMA,atomic_expression)) = TYPE THEN RPAR OF IN FUN EOF END ELSE BAR
follow(separated_nonempty_list(COMMA,ID)) = WHERE PRODUCES IN EOF DEFEQ
follow(raw_pattern) = RPAR COMMA ARROW
follow(raw_expression) = TYPE THEN RPAR OF IN FUN EOF END ELSE BAR
follow(raw_atomic_expression) = TYPE THEN RPAR OF IN FUN EOF END ELSE COMMA CMPEQ BOR BAR BAND
follow(program) = #
follow(prefix_callee) = LPAR
follow(pattern) = RPAR COMMA ARROW
follow(optional_layout) = WHERE TYPE FUN EOF BAR
follow(nonempty_list(branch)) = END
follow(located(raw_pattern)) = RPAR COMMA ARROW
follow(located(raw_expression)) = TYPE THEN RPAR OF IN FUN EOF END ELSE BAR
follow(located(raw_atomic_expression)) = TYPE THEN RPAR OF IN FUN EOF END ELSE COMMA CMPEQ BOR BAR BAND
follow(located(optional_layout)) = WHERE TYPE FUN EOF BAR
follow(located(layout)) = RANGLE
follow(located(atomic_layout)) = WHERE TYPE STAR RANGLE FUN EOF BAR
follow(list(preceded(WHERE,contrainte))) = TYPE PRODUCES FUN EOF DEFEQ BAR
follow(list(definition)) = EOF
follow(list(data_constructor_declaration)) = TYPE FUN EOF
follow(lenient_parenthesized_tuple(pattern)) = RPAR DEFEQ COMMA ARROW
follow(lenient_parenthesized_tuple(atomic_expression)) = TYPE THEN RPAR OF IN FUN EOF END ELSE COMMA CMPEQ BOR BAR BAND
follow(layout) = WHERE TYPE RANGLE FUN EOF BAR
follow(kind) = DEFEQ
follow(expression) = TYPE THEN RPAR OF IN FUN EOF END ELSE BAR
follow(definition) = TYPE FUN EOF
follow(data_constructor_declaration) = TYPE FUN EOF BAR
follow(contraintes) = TYPE PRODUCES FUN EOF DEFEQ BAR
follow(contrainte) = WHERE TYPE PRODUCES FUN EOF DEFEQ BAR
follow(branch) = END BAR
follow(boolean_expression) = WHERE TYPE RPAR PRODUCES FUN EOF DEFEQ CMPEQ BOR BAR BAND ARROW
follow(atomic_layout) = WHERE TYPE STAR RANGLE FUN EOF BAR
follow(atomic_expression) = TYPE THEN RPAR OF IN FUN EOF END ELSE COMMA CMPEQ BOR BAR BAND
Built an LR(0) automaton with 202 states.
The grammar is not SLR(1) -- 12 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 202 states.
28 shift/reduce conflicts were silently solved.
84 out of 202 states have a default reduction.
The action table is 10706 entries; 817 non-zero; 687 compressed.
The action table occupies roughly 1472 bytes.
The goto table is 8888 entries; 221 non-zero; 430 compressed.
The goto table occupies roughly 728 bytes.
The error table occupies roughly 1376 bytes.
The default_reduction table occupies roughly 240 bytes.
The lhs table occupies roughly 144 bytes.
The trace table occupies roughly 8 bytes.
