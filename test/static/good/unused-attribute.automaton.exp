State 0:
main' -> . main [ # ]
-- On A shift to state 1
-- On main shift to state 6

State 1:
main -> A . B list(C) [ # ]
-- On B shift to state 2

State 2:
main -> A B . list(C) [ # ]
-- On C shift to state 3
-- On list(C) shift to state 5
-- On # reduce production list(C) -> 

State 3:
list(C) -> C . list(C) [ # ]
-- On C shift to state 3
-- On list(C) shift to state 4
-- On # reduce production list(C) -> 

State 4:
list(C) -> C list(C) . [ # ]
-- On # reduce production list(C) -> C list(C)

State 5:
main -> A B list(C) . [ # ]
-- On # reduce production main -> A B list(C)

State 6:
main' -> main . [ # ]
-- On # accept main

State 2 has an end-of-stream conflict. There is a tension between
(1) reducing production list(C) -> 
without even requesting a lookahead token, and
(2) checking whether the lookahead token is C,
which would require some other action.

State 3 has an end-of-stream conflict. There is a tension between
(1) reducing production list(C) -> 
without even requesting a lookahead token, and
(2) checking whether the lookahead token is C,
which would require some other action.

