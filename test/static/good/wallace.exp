File "wallace.mly", line 57, characters 7-11:
Warning: the token GIVE is unused.
File "wallace.mly", line 73, characters 7-9:
Warning: the token OF is unused.
File "wallace.mly", line 91, characters 7-9:
Warning: the token TO is unused.
File "wallace.mly", line 99, characters 7-12:
Warning: the token WHERE is unused.
Grammar has 35 nonterminal symbols, among which 1 start symbols.
Grammar has 72 terminal symbols.
Grammar has 139 productions.
nullable(variant_row) = false
nullable(variance_comma_list) = false
nullable(variance) = false
nullable(variable_leader) = false
nullable(type_scheme) = false
nullable(type_comma_list) = false
nullable(type1) = false
nullable(type0) = false
nullable(try_match) = false
nullable(simple_pattern_list) = false
nullable(simple_pattern) = false
nullable(row_type) = false
nullable(record_row) = false
nullable(phrase) = false
nullable(pattern) = false
nullable(label_pattern_list) = true
nullable(label_pattern) = false
nullable(label_expression_list) = true
nullable(label_expression) = false
nullable(function_match) = false
nullable(fun_match) = false
nullable(expression3) = false
nullable(expression2) = false
nullable(expression1) = false
nullable(expression0) = false
nullable(expression) = false
nullable(expr_semi_list) = true
nullable(context_entry) = false
nullable(context) = false
nullable(constrained_type) = false
nullable(constant) = false
nullable(coercion_list) = false
nullable(coercion) = false
nullable(binding_list) = false
nullable(binding) = false
first(variant_row) = UNIT STRING QUOTE PRE PLUS PERCENT MISSING MINUS MAYBE LPAREN LBRACKET LBRACE INTCONST INT IDENT FLOAT CONSTRUCTOR CHAR BOOL ABS
first(variance_comma_list) = PLUS MINUS
first(variance) = PLUS MINUS
first(variable_leader) = QUOTE PLUS PERCENT MINUS
first(type_scheme) = UNIT STRING QUOTE PLUS PERCENT MINUS LPAREN LBRACKET LBRACE INTCONST INT IDENT FLOAT COERCE CHAR BOOL
first(type_comma_list) = UNIT STRING QUOTE PLUS PERCENT MINUS LPAREN LBRACKET LBRACE INTCONST INT IDENT FLOAT CHAR BOOL
first(type1) = UNIT STRING QUOTE PLUS PERCENT MINUS LPAREN LBRACKET LBRACE INTCONST INT IDENT FLOAT CHAR BOOL
first(type0) = UNIT STRING QUOTE PLUS PERCENT MINUS LPAREN LBRACKET LBRACE INTCONST INT IDENT FLOAT CHAR BOOL
first(try_match) = UNIT UNDERSCORE TRUE STRINGCONST REF LPAREN LBRACE INTCONST IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST
first(simple_pattern_list) = UNIT UNDERSCORE TRUE STRINGCONST LPAREN LBRACE INTCONST IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST
first(simple_pattern) = UNIT UNDERSCORE TRUE STRINGCONST LPAREN LBRACE INTCONST IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST
first(row_type) = UNIT STRING QUOTE PRE PLUS PERCENT MISSING MINUS MAYBE LPAREN LBRACKET LBRACE INTCONST INT IDENT FLOAT CHAR BOOL ABS
first(record_row) = UNIT STRING QUOTE PRE PLUS PERCENT MISSING MINUS MAYBE LPAREN LBRACKET LBRACE INTCONST INT IDENT FLOAT CHAR BOOL ABS
first(phrase) = VALUE UNIT TYPE TRY TRUE STRINGCONST SHARP REF REC RAISE MATCH LPAREN LET LBRACKETBAR LBRACKET LBRACE INTCONST INCLUDE IF IDENT FUNCTION FUN FLOATCONST FALSE CONSTRUCTOR CHARCONST BANG
first(pattern) = UNIT UNDERSCORE TRUE STRINGCONST REF LPAREN LBRACE INTCONST IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST
first(label_pattern_list) = IDENT
first(label_pattern) = IDENT
first(label_expression_list) = IDENT
first(label_expression) = IDENT
first(function_match) = UNIT UNDERSCORE TRUE STRINGCONST REF LPAREN LBRACE INTCONST IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST
first(fun_match) = UNIT UNDERSCORE TRUE STRINGCONST LPAREN LBRACE INTCONST IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST
first(expression3) = UNIT TRUE STRINGCONST REF RAISE LPAREN LBRACKETBAR LBRACKET LBRACE INTCONST IF IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST BANG
first(expression2) = UNIT TRUE STRINGCONST REF RAISE LPAREN LBRACKETBAR LBRACKET LBRACE INTCONST IF IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST BANG
first(expression1) = UNIT TRUE STRINGCONST REF RAISE LPAREN LBRACKETBAR LBRACKET LBRACE INTCONST IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST BANG
first(expression0) = UNIT TRUE STRINGCONST LPAREN LBRACKETBAR LBRACKET LBRACE INTCONST IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST BANG
first(expression) = UNIT TRY TRUE STRINGCONST REF REC RAISE MATCH LPAREN LET LBRACKETBAR LBRACKET LBRACE INTCONST IF IDENT FUNCTION FUN FLOATCONST FALSE CONSTRUCTOR CHARCONST BANG
first(expr_semi_list) = UNIT TRUE STRINGCONST REF RAISE LPAREN LBRACKETBAR LBRACKET LBRACE INTCONST IF IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST BANG
first(context_entry) = IDENT
first(context) = IDENT
first(constrained_type) = UNIT STRING QUOTE PLUS PERCENT MINUS LPAREN LBRACKET LBRACE INTCONST INT IDENT FLOAT CHAR BOOL
first(constant) = UNIT TRUE STRINGCONST INTCONST FLOATCONST FALSE CHARCONST
first(coercion_list) = UNIT STRING QUOTE PLUS PERCENT MINUS LPAREN LBRACKET LBRACE INTCONST INT IDENT FLOAT CHAR BOOL
first(coercion) = UNIT STRING QUOTE PLUS PERCENT MINUS LPAREN LBRACKET LBRACE INTCONST INT IDENT FLOAT CHAR BOOL
first(binding_list) = UNIT UNDERSCORE TRUE STRINGCONST REF LPAREN LBRACE INTCONST IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST
first(binding) = UNIT UNDERSCORE TRUE STRINGCONST REF LPAREN LBRACE INTCONST IDENT FLOATCONST FALSE CONSTRUCTOR CHARCONST
minimal(variant_row) = (* 1 *) ABS
minimal(variance_comma_list) = (* 1 *) PLUS
minimal(variance) = (* 1 *) PLUS
minimal(variable_leader) = (* 1 *) QUOTE
minimal(type_scheme) = (* 1 *) INT
minimal(type_comma_list) = (* 1 *) INT
minimal(type1) = (* 1 *) INT
minimal(type0) = (* 1 *) INT
minimal(try_match) = (* 3 *) UNDERSCORE ARROW IDENT
minimal(simple_pattern_list) = (* 1 *) UNDERSCORE
minimal(simple_pattern) = (* 1 *) UNDERSCORE
minimal(row_type) = (* 1 *) ABS
minimal(record_row) = (* 1 *) ABS
minimal(phrase) = (* 2 *) SHARP IDENT
minimal(pattern) = (* 1 *) UNDERSCORE
minimal(label_pattern_list) = (* 0 *)
minimal(label_pattern) = (* 3 *) IDENT EQUAL UNDERSCORE
minimal(label_expression_list) = (* 0 *)
minimal(label_expression) = (* 3 *) IDENT EQUAL IDENT
minimal(function_match) = (* 3 *) UNDERSCORE ARROW IDENT
minimal(fun_match) = (* 3 *) UNDERSCORE ARROW IDENT
minimal(expression3) = (* 1 *) IDENT
minimal(expression2) = (* 1 *) IDENT
minimal(expression1) = (* 1 *) IDENT
minimal(expression0) = (* 1 *) IDENT
minimal(expression) = (* 1 *) IDENT
minimal(expr_semi_list) = (* 0 *)
minimal(context_entry) = (* 3 *) IDENT COLON INT
minimal(context) = (* 3 *) IDENT COLON INT
minimal(constrained_type) = (* 1 *) INT
minimal(constant) = (* 1 *) INTCONST
minimal(coercion_list) = (* 3 *) INT COERCE INT
minimal(coercion) = (* 3 *) INT COERCE INT
minimal(binding_list) = (* 3 *) UNDERSCORE EQUAL IDENT
minimal(binding) = (* 3 *) UNDERSCORE EQUAL IDENT
follow(variant_row) = RBRACKET
follow(variance_comma_list) = RPAREN
follow(variance) = RPAREN COMMA
follow(variable_leader) = IDENT
follow(type_scheme) = SEMISEMI RPAREN
follow(type_comma_list) = SEMI RPAREN RBRACE COERCE
follow(type1) = SEMISEMI SEMI RPAREN RBRACKET RBRACE RAISES EQUAL COMMA COERCEBACK COERCE BAR
follow(type0) = STAR SEMISEMI SEMI RPAREN RBRACKET RBRACE RAISES IDENT EQUAL COMMA COERCEBACK COERCE BAR ARROW
follow(try_match) = WITH SEMISEMI RPAREN IN COLON BAR AND
follow(simple_pattern_list) = EQUAL ARROW
follow(simple_pattern) = UNIT UNDERSCORE TRUE STRINGCONST SEMI RPAREN RBRACE LPAREN LBRACE INTCONST IN IDENT FLOATCONST FALSE EQUAL CONSTRUCTOR COMMA CHARCONST BAR AS ARROW
follow(row_type) = SEMI RBRACKET RBRACE
follow(record_row) = RBRACE
follow(phrase) = #
follow(pattern) = SEMI RPAREN RBRACE IN EQUAL COMMA BAR AS ARROW
follow(label_pattern_list) = RBRACE
follow(label_pattern) = SEMI RBRACE
follow(label_expression_list) = RBRACE
follow(label_expression) = SEMI RBRACE
follow(function_match) = WITH SEMISEMI RPAREN IN COLON BAR AND
follow(fun_match) = WITH SEMISEMI RPAREN IN COLON BAR AND
follow(expression3) = WITH SEMISEMI RPAREN IN COLON BAR AND
follow(expression2) = WITH SEMISEMI SEMI RPAREN RBRACE IN ELSE COLON BARRBRACKET BAR AND
follow(expression1) = WITH UNIT TRUE THEN STRINGCONST SEMISEMI SEMI RPAREN RBRACE LPAREN LBRACKETBAR LBRACKET LBRACE INTCONST IN IDENT FLOATCONST FALSE ELSE DOT CONSTRUCTOR COMMA COLON CHARCONST BARRBRACKET BAR BANG ATAT AT ASSIGN AND
follow(expression0) = WITH UNIT TRUE THEN STRINGCONST SEMISEMI SEMI RPAREN RBRACE LPAREN LBRACKETBAR LBRACKET LBRACE INTCONST IN IDENT FLOATCONST FALSE ELSE DOT CONSTRUCTOR COMMA COLON CHARCONST BARRBRACKET BAR BANG ATAT AT ASSIGN AND
follow(expression) = WITH SEMISEMI RPAREN IN COLON BAR AND
follow(expr_semi_list) = BARRBRACKET
follow(context_entry) = SEMI COERCEBACK
follow(context) = COERCEBACK
follow(constrained_type) = RBRACKET
follow(constant) = WITH UNIT UNDERSCORE TRUE THEN STRINGCONST SEMISEMI SEMI RPAREN RBRACE LPAREN LBRACKETBAR LBRACKET LBRACE INTCONST IN IDENT FLOATCONST FALSE EQUAL ELSE DOT CONSTRUCTOR COMMA COLON CHARCONST BARRBRACKET BAR BANG ATAT AT ASSIGN AS ARROW AND
follow(coercion_list) = RBRACE
follow(coercion) = SEMI RBRACE
follow(binding_list) = SEMISEMI IN
follow(binding) = SEMISEMI IN AND
Built an LR(0) automaton with 291 states.
The grammar is not SLR(1) -- 19 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 291 states.
Warning: 16 states have shift/reduce conflicts.
Warning: 85 shift/reduce conflicts were arbitrarily resolved.
100 out of 291 states have a default reduction.
96 out of 291 states are represented.
0 out of 110 symbols keep track of their start position.
0 out of 110 symbols keep track of their end position.
64 out of 140 productions exploit shiftreduce optimization.
0 out of 291 states can peek at an error.
763 functions before inlining, 114 functions after inlining.
