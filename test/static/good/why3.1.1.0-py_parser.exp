Grammar has 44 nonterminal symbols, among which 1 start symbols.
Grammar has 55 terminal symbols.
Grammar has 122 productions.
nullable(variant) = false
nullable(term_sub_) = false
nullable(term_arg_) = false
nullable(term_arg) = false
nullable(term_) = false
nullable(term) = false
nullable(suite) = false
nullable(stmt_desc) = false
nullable(stmt) = false
nullable(spec) = true
nullable(single_spec) = false
nullable(simple_stmt_desc) = false
nullable(simple_stmt) = false
nullable(separated_nonempty_list(COMMA,term)) = false
nullable(separated_nonempty_list(COMMA,ident)) = false
nullable(separated_nonempty_list(COMMA,expr)) = false
nullable(quant) = false
nullable(option(NEWLINE)) = true
nullable(nonempty_list(stmt)) = false
nullable(nonempty_list(decl)) = false
nullable(mk_term(term_arg_)) = false
nullable(mk_term(term_)) = false
nullable(loption(separated_nonempty_list(COMMA,term))) = true
nullable(loption(separated_nonempty_list(COMMA,ident))) = true
nullable(loption(separated_nonempty_list(COMMA,expr))) = true
nullable(loop_body) = false
nullable(loop_annotation) = true
nullable(located(stmt_desc)) = false
nullable(located(simple_stmt_desc)) = false
nullable(list(NEWLINE)) = true
nullable(invariant) = false
nullable(import) = false
nullable(ident) = false
nullable(func) = false
nullable(file) = false
nullable(expr_desc) = false
nullable(expr) = false
nullable(ensures) = false
nullable(else_branch) = true
nullable(def) = false
nullable(decl) = false
nullable(comma_list1(term)) = false
nullable(comma_list1(ident)) = false
nullable(assertion_kind) = false
first(variant) = VARIANT
first(term_sub_) = TRUE NONE LEFTPAR INTEGER IDENT FALSE
first(term_arg_) = TRUE NONE LEFTPAR INTEGER IDENT FALSE
first(term_arg) = TRUE NONE LEFTPAR INTEGER IDENT FALSE
first(term_) = TRUE NOT NONE MINUS LET LEFTPAR INTEGER IF IDENT FORALL FALSE EXISTS
first(term) = TRUE NOT NONE MINUS LET LEFTPAR INTEGER IF IDENT FORALL FALSE EXISTS
first(suite) = TRUE STRING RETURN NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IDENT FALSE CHECK BREAK ASSUME ASSERT
first(stmt_desc) = WHILE IF FOR
first(stmt) = WHILE TRUE STRING RETURN NOT NONE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FOR FALSE CHECK BREAK ASSUME ASSERT
first(spec) = VARIANT REQUIRES ENSURES
first(single_spec) = VARIANT REQUIRES ENSURES
first(simple_stmt_desc) = TRUE STRING RETURN NOT NONE MINUS LEFTSQ LEFTPAR LABEL INTEGER IDENT FALSE CHECK BREAK ASSUME ASSERT
first(simple_stmt) = TRUE STRING RETURN NOT NONE MINUS LEFTSQ LEFTPAR LABEL INTEGER IDENT FALSE CHECK BREAK ASSUME ASSERT
first(separated_nonempty_list(COMMA,term)) = TRUE NOT NONE MINUS LET LEFTPAR INTEGER IF IDENT FORALL FALSE EXISTS
first(separated_nonempty_list(COMMA,ident)) = IDENT
first(separated_nonempty_list(COMMA,expr)) = TRUE STRING NOT NONE MINUS LEFTSQ LEFTPAR INTEGER IDENT FALSE
first(quant) = FORALL EXISTS
first(option(NEWLINE)) = NEWLINE
first(nonempty_list(stmt)) = WHILE TRUE STRING RETURN NOT NONE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FOR FALSE CHECK BREAK ASSUME ASSERT
first(nonempty_list(decl)) = WHILE TRUE STRING RETURN PREDICATE NOT NONE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE DEF CHECK BREAK ASSUME ASSERT
first(mk_term(term_arg_)) = TRUE NONE LEFTPAR INTEGER IDENT FALSE
first(mk_term(term_)) = TRUE NOT NONE MINUS LET LEFTPAR INTEGER IF IDENT FORALL FALSE EXISTS
first(loption(separated_nonempty_list(COMMA,term))) = TRUE NOT NONE MINUS LET LEFTPAR INTEGER IF IDENT FORALL FALSE EXISTS
first(loption(separated_nonempty_list(COMMA,ident))) = IDENT
first(loption(separated_nonempty_list(COMMA,expr))) = TRUE STRING NOT NONE MINUS LEFTSQ LEFTPAR INTEGER IDENT FALSE
first(loop_body) = TRUE STRING RETURN NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IDENT FALSE CHECK BREAK ASSUME ASSERT
first(loop_annotation) = VARIANT INVARIANT
first(located(stmt_desc)) = WHILE IF FOR
first(located(simple_stmt_desc)) = TRUE STRING RETURN NOT NONE MINUS LEFTSQ LEFTPAR LABEL INTEGER IDENT FALSE CHECK BREAK ASSUME ASSERT
first(list(NEWLINE)) = NEWLINE
first(invariant) = INVARIANT
first(import) = FROM
first(ident) = IDENT
first(func) = PREDICATE FUNCTION
first(file) = WHILE TRUE STRING RETURN PREDICATE NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE EOF DEF CHECK BREAK ASSUME ASSERT
first(expr_desc) = TRUE STRING NOT NONE MINUS LEFTSQ LEFTPAR INTEGER IDENT FALSE
first(expr) = TRUE STRING NOT NONE MINUS LEFTSQ LEFTPAR INTEGER IDENT FALSE
first(ensures) = TRUE NOT NONE MINUS LET LEFTPAR INTEGER IF IDENT FORALL FALSE EXISTS
first(else_branch) = ELSE ELIF
first(def) = DEF
first(decl) = WHILE TRUE STRING RETURN PREDICATE NOT NONE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE DEF CHECK BREAK ASSUME ASSERT
first(comma_list1(term)) = TRUE NOT NONE MINUS LET LEFTPAR INTEGER IF IDENT FORALL FALSE EXISTS
first(comma_list1(ident)) = IDENT
first(assertion_kind) = CHECK ASSUME ASSERT
minimal(variant) = (* 3 *) VARIANT IDENT NEWLINE
minimal(term_sub_) = (* 3 *) LEFTPAR IDENT RIGHTPAR
minimal(term_arg_) = (* 1 *) IDENT
minimal(term_arg) = (* 1 *) IDENT
minimal(term_) = (* 1 *) IDENT
minimal(term) = (* 1 *) IDENT
minimal(suite) = (* 2 *) NONE NEWLINE
minimal(stmt_desc) = (* 5 *) WHILE NONE COLON NONE NEWLINE
minimal(stmt) = (* 2 *) NONE NEWLINE
minimal(spec) = (* 0 *)
minimal(single_spec) = (* 3 *) REQUIRES IDENT NEWLINE
minimal(simple_stmt_desc) = (* 1 *) NONE
minimal(simple_stmt) = (* 1 *) NONE
minimal(separated_nonempty_list(COMMA,term)) = (* 1 *) IDENT
minimal(separated_nonempty_list(COMMA,ident)) = (* 1 *) IDENT
minimal(separated_nonempty_list(COMMA,expr)) = (* 1 *) NONE
minimal(quant) = (* 1 *) FORALL
minimal(option(NEWLINE)) = (* 0 *)
minimal(nonempty_list(stmt)) = (* 2 *) NONE NEWLINE
minimal(nonempty_list(decl)) = (* 2 *) NONE NEWLINE
minimal(mk_term(term_arg_)) = (* 1 *) IDENT
minimal(mk_term(term_)) = (* 1 *) IDENT
minimal(loption(separated_nonempty_list(COMMA,term))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,ident))) = (* 0 *)
minimal(loption(separated_nonempty_list(COMMA,expr))) = (* 0 *)
minimal(loop_body) = (* 2 *) NONE NEWLINE
minimal(loop_annotation) = (* 0 *)
minimal(located(stmt_desc)) = (* 5 *) WHILE NONE COLON NONE NEWLINE
minimal(located(simple_stmt_desc)) = (* 1 *) NONE
minimal(list(NEWLINE)) = (* 0 *)
minimal(invariant) = (* 3 *) INVARIANT IDENT NEWLINE
minimal(import) = (* 4 *) FROM IDENT IMPORT NEWLINE
minimal(ident) = (* 1 *) IDENT
minimal(func) = (* 5 *) FUNCTION IDENT LEFTPAR RIGHTPAR NEWLINE
minimal(file) = (* 1 *) EOF
minimal(expr_desc) = (* 1 *) NONE
minimal(expr) = (* 1 *) NONE
minimal(ensures) = (* 1 *) IDENT
minimal(else_branch) = (* 0 *)
minimal(def) = (* 10 *) DEF IDENT LEFTPAR RIGHTPAR COLON NEWLINE BEGIN NONE NEWLINE END
minimal(decl) = (* 2 *) NONE NEWLINE
minimal(comma_list1(term)) = (* 1 *) IDENT
minimal(comma_list1(ident)) = (* 1 *) IDENT
minimal(assertion_kind) = (* 1 *) ASSERT
maximal(variant) = infinity
maximal(term_sub_) = infinity
maximal(term_arg_) = infinity
maximal(term_arg) = infinity
maximal(term_) = infinity
maximal(term) = infinity
maximal(suite) = infinity
maximal(stmt_desc) = infinity
maximal(stmt) = infinity
maximal(spec) = infinity
maximal(single_spec) = infinity
maximal(simple_stmt_desc) = infinity
maximal(simple_stmt) = infinity
maximal(separated_nonempty_list(COMMA,term)) = infinity
maximal(separated_nonempty_list(COMMA,ident)) = infinity
maximal(separated_nonempty_list(COMMA,expr)) = infinity
maximal(quant) = 1
maximal(option(NEWLINE)) = 1
maximal(nonempty_list(stmt)) = infinity
maximal(nonempty_list(decl)) = infinity
maximal(mk_term(term_arg_)) = infinity
maximal(mk_term(term_)) = infinity
maximal(loption(separated_nonempty_list(COMMA,term))) = infinity
maximal(loption(separated_nonempty_list(COMMA,ident))) = infinity
maximal(loption(separated_nonempty_list(COMMA,expr))) = infinity
maximal(loop_body) = infinity
maximal(loop_annotation) = infinity
maximal(located(stmt_desc)) = infinity
maximal(located(simple_stmt_desc)) = infinity
maximal(list(NEWLINE)) = infinity
maximal(invariant) = infinity
maximal(import) = infinity
maximal(ident) = 1
maximal(func) = infinity
maximal(file) = infinity
maximal(expr_desc) = infinity
maximal(expr) = infinity
maximal(ensures) = infinity
maximal(else_branch) = infinity
maximal(def) = infinity
maximal(decl) = infinity
maximal(comma_list1(term)) = infinity
maximal(comma_list1(ident)) = infinity
maximal(assertion_kind) = 1
follow(variant) = WHILE VARIANT TRUE STRING RETURN REQUIRES NOT NONE MINUS LEFTSQ LEFTPAR LABEL INVARIANT INTEGER IF IDENT FOR FALSE ENSURES CHECK BREAK ASSUME ASSERT
follow(term_sub_) = TIMES THEN RIGHTSQ RIGHTPAR PLUS OR NEWLINE MOD MINUS LRARROW LEFTSQ LARROW IN ELSE DIV COMMA CMP ARROW AND
follow(term_arg_) = TIMES THEN RIGHTSQ RIGHTPAR PLUS OR NEWLINE MOD MINUS LRARROW LEFTSQ LARROW IN ELSE DIV COMMA CMP ARROW AND
follow(term_arg) = LEFTSQ
follow(term_) = TIMES THEN RIGHTSQ RIGHTPAR PLUS OR NEWLINE MOD MINUS LRARROW LARROW IN ELSE DIV COMMA CMP ARROW AND
follow(term) = TIMES THEN RIGHTSQ RIGHTPAR PLUS OR NEWLINE MOD MINUS LRARROW LARROW IN ELSE DIV COMMA CMP ARROW AND
follow(suite) = WHILE TRUE STRING RETURN PREDICATE NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE EOF END ELSE ELIF DEF CHECK BREAK ASSUME ASSERT
follow(stmt_desc) = WHILE TRUE STRING RETURN PREDICATE NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE EOF END DEF CHECK BREAK ASSUME ASSERT
follow(stmt) = WHILE TRUE STRING RETURN PREDICATE NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE EOF END DEF CHECK BREAK ASSUME ASSERT
follow(spec) = WHILE TRUE STRING RETURN NOT NONE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FOR FALSE CHECK BREAK ASSUME ASSERT
follow(single_spec) = WHILE VARIANT TRUE STRING RETURN REQUIRES NOT NONE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FOR FALSE ENSURES CHECK BREAK ASSUME ASSERT
follow(simple_stmt_desc) = NEWLINE
follow(simple_stmt) = NEWLINE
follow(separated_nonempty_list(COMMA,term)) = RIGHTPAR NEWLINE
follow(separated_nonempty_list(COMMA,ident)) = RIGHTPAR NEWLINE DOT
follow(separated_nonempty_list(COMMA,expr)) = RIGHTSQ RIGHTPAR
follow(quant) = IDENT
follow(option(NEWLINE)) = WHILE TRUE STRING RETURN PREDICATE NOT NONE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE EOF DEF CHECK BREAK ASSUME ASSERT
follow(nonempty_list(stmt)) = END
follow(nonempty_list(decl)) = NEWLINE EOF
follow(mk_term(term_arg_)) = LEFTSQ
follow(mk_term(term_)) = TIMES THEN RIGHTSQ RIGHTPAR PLUS OR NEWLINE MOD MINUS LRARROW LARROW IN ELSE DIV COMMA CMP ARROW AND
follow(loption(separated_nonempty_list(COMMA,term))) = RIGHTPAR
follow(loption(separated_nonempty_list(COMMA,ident))) = RIGHTPAR NEWLINE
follow(loption(separated_nonempty_list(COMMA,expr))) = RIGHTSQ RIGHTPAR
follow(loop_body) = WHILE TRUE STRING RETURN PREDICATE NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE EOF END DEF CHECK BREAK ASSUME ASSERT
follow(loop_annotation) = WHILE TRUE STRING RETURN NOT NONE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FOR FALSE CHECK BREAK ASSUME ASSERT
follow(located(stmt_desc)) = WHILE TRUE STRING RETURN PREDICATE NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE EOF END DEF CHECK BREAK ASSUME ASSERT
follow(located(simple_stmt_desc)) = NEWLINE
follow(list(NEWLINE)) = EOF
follow(invariant) = WHILE VARIANT TRUE STRING RETURN NOT NONE MINUS LEFTSQ LEFTPAR LABEL INVARIANT INTEGER IF IDENT FOR FALSE CHECK BREAK ASSUME ASSERT
follow(import) = WHILE TRUE STRING RETURN PREDICATE NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE EOF DEF CHECK BREAK ASSUME ASSERT
follow(ident) = TIMES THEN RIGHTSQ RIGHTPAR PLUS OR NEWLINE MOD MINUS LRARROW LEFTSQ LEFTPAR LARROW IN IMPORT EQUAL ELSE DOT DIV COMMA COLON CMP ARROW AND
follow(func) = WHILE TRUE STRING RETURN PREDICATE NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE EOF DEF CHECK BREAK ASSUME ASSERT
follow(file) = #
follow(expr_desc) = TIMES RIGHTSQ RIGHTPAR PLUS OR NEWLINE MOD MINUS LEFTSQ DIV COMMA COLON CMP AND
follow(expr) = TIMES RIGHTSQ RIGHTPAR PLUS OR NEWLINE MOD MINUS LEFTSQ DIV COMMA COLON CMP AND
follow(ensures) = NEWLINE
follow(else_branch) = WHILE TRUE STRING RETURN PREDICATE NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE EOF END DEF CHECK BREAK ASSUME ASSERT
follow(def) = WHILE TRUE STRING RETURN PREDICATE NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE EOF DEF CHECK BREAK ASSUME ASSERT
follow(decl) = WHILE TRUE STRING RETURN PREDICATE NOT NONE NEWLINE MINUS LEFTSQ LEFTPAR LABEL INTEGER IF IDENT FUNCTION FROM FOR FALSE EOF DEF CHECK BREAK ASSUME ASSERT
follow(comma_list1(term)) = NEWLINE
follow(comma_list1(ident)) = DOT
follow(assertion_kind) = TRUE NOT NONE MINUS LET LEFTPAR INTEGER IF IDENT FORALL FALSE EXISTS
Built an LR(0) automaton with 248 states.
The grammar is not SLR(1) -- 27 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 248 states.
240 shift/reduce conflicts were silently solved.
79 out of 248 states have a default reduction.
86 out of 248 states are represented.
43 out of 102 symbols keep track of their start position.
32 out of 102 symbols keep track of their end position.
63 out of 123 productions exploit shiftreduce optimization.
0 out of 248 states can peek at an error.
668 functions before inlining, 105 functions after inlining.
