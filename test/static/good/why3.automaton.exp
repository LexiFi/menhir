State 0:
## Known stack suffix:
##
## LR(1) items:
ident_comma_list_eof' -> . ident_comma_list_eof [ # ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 40
-- On separated_nonempty_list(COMMA,ident) shift to state 41
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident_comma_list_eof shift to state 45
-- On ident shift to state 46
-- On comma_list1(ident) shift to state 49
## Reductions:

State 1:
## Known stack suffix:
## UIDENT
## LR(1) items:
uident -> UIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL GHOST FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL GHOST FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production uident -> UIDENT

State 2:
## Known stack suffix:
## RANGE
## LR(1) items:
lident_keyword -> RANGE . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production lident_keyword -> RANGE

State 3:
## Known stack suffix:
## LIDENT
## LR(1) items:
lident -> LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production lident -> LIDENT

State 4:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
lident_op -> LEFTPAR . lident_op_str RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR_USCORE [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR_QUOTE [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On OPPREF shift to state 5
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On MINUS shift to state 12
-- On LT shift to state 14
-- On LEFTSQ shift to state 15
-- On GT shift to state 29
-- On EQUAL shift to state 30
-- On op_symbol shift to state 31
-- On lident_op_str shift to state 33
## Reductions:

State 5:
## Known stack suffix:
## OPPREF
## LR(1) items:
lident_op_str -> OPPREF . option(UNDERSCORE) [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 6
-- On option(UNDERSCORE) shift to state 7
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production option(UNDERSCORE) ->

State 6:
## Known stack suffix:
## UNDERSCORE
## LR(1) items:
option(UNDERSCORE) -> UNDERSCORE . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production option(UNDERSCORE) -> UNDERSCORE

State 7:
## Known stack suffix:
## OPPREF option(UNDERSCORE)
## LR(1) items:
lident_op_str -> OPPREF option(UNDERSCORE) . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> OPPREF option(UNDERSCORE)

State 8:
## Known stack suffix:
## OP4
## LR(1) items:
op_symbol -> OP4 . [ WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production op_symbol -> OP4

State 9:
## Known stack suffix:
## OP3
## LR(1) items:
op_symbol -> OP3 . [ WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production op_symbol -> OP3

State 10:
## Known stack suffix:
## OP2
## LR(1) items:
op_symbol -> OP2 . [ WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production op_symbol -> OP2

State 11:
## Known stack suffix:
## OP1
## LR(1) items:
op_symbol -> OP1 . [ WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production op_symbol -> OP1

State 12:
## Known stack suffix:
## MINUS
## LR(1) items:
lident_op_str -> MINUS . UNDERSCORE [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> MINUS . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 13
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> MINUS

State 13:
## Known stack suffix:
## MINUS UNDERSCORE
## LR(1) items:
lident_op_str -> MINUS UNDERSCORE . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> MINUS UNDERSCORE

State 14:
## Known stack suffix:
## LT
## LR(1) items:
op_symbol -> LT . [ WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production op_symbol -> LT

State 15:
## Known stack suffix:
## LEFTSQ
## LR(1) items:
lident_op_str -> LEFTSQ . rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ . rightsq LARROW [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ . LARROW rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ . DOTDOT rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ . UNDERSCORE DOTDOT rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ . DOTDOT UNDERSCORE rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 16
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On LARROW shift to state 21
-- On DOTDOT shift to state 23
-- On rightsq shift to state 27
## Reductions:

State 16:
## Known stack suffix:
## LEFTSQ UNDERSCORE
## LR(1) items:
lident_op_str -> LEFTSQ UNDERSCORE . DOTDOT rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On DOTDOT shift to state 17
## Reductions:

State 17:
## Known stack suffix:
## LEFTSQ UNDERSCORE DOTDOT
## LR(1) items:
lident_op_str -> LEFTSQ UNDERSCORE DOTDOT . rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 20
## Reductions:

State 18:
## Known stack suffix:
## RIGHTSQ_QUOTE
## LR(1) items:
rightsq -> RIGHTSQ_QUOTE . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production rightsq -> RIGHTSQ_QUOTE

State 19:
## Known stack suffix:
## RIGHTSQ
## LR(1) items:
rightsq -> RIGHTSQ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production rightsq -> RIGHTSQ

State 20:
## Known stack suffix:
## LEFTSQ UNDERSCORE DOTDOT rightsq
## LR(1) items:
lident_op_str -> LEFTSQ UNDERSCORE DOTDOT rightsq . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> LEFTSQ UNDERSCORE DOTDOT rightsq

State 21:
## Known stack suffix:
## LEFTSQ LARROW
## LR(1) items:
lident_op_str -> LEFTSQ LARROW . rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 22
## Reductions:

State 22:
## Known stack suffix:
## LEFTSQ LARROW rightsq
## LR(1) items:
lident_op_str -> LEFTSQ LARROW rightsq . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> LEFTSQ LARROW rightsq

State 23:
## Known stack suffix:
## LEFTSQ DOTDOT
## LR(1) items:
lident_op_str -> LEFTSQ DOTDOT . rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ DOTDOT . UNDERSCORE rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 24
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 26
## Reductions:

State 24:
## Known stack suffix:
## LEFTSQ DOTDOT UNDERSCORE
## LR(1) items:
lident_op_str -> LEFTSQ DOTDOT UNDERSCORE . rightsq [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 25
## Reductions:

State 25:
## Known stack suffix:
## LEFTSQ DOTDOT UNDERSCORE rightsq
## LR(1) items:
lident_op_str -> LEFTSQ DOTDOT UNDERSCORE rightsq . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> LEFTSQ DOTDOT UNDERSCORE rightsq

State 26:
## Known stack suffix:
## LEFTSQ DOTDOT rightsq
## LR(1) items:
lident_op_str -> LEFTSQ DOTDOT rightsq . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> LEFTSQ DOTDOT rightsq

State 27:
## Known stack suffix:
## LEFTSQ rightsq
## LR(1) items:
lident_op_str -> LEFTSQ rightsq . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> LEFTSQ rightsq . LARROW [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On LARROW shift to state 28
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> LEFTSQ rightsq

State 28:
## Known stack suffix:
## LEFTSQ rightsq LARROW
## LR(1) items:
lident_op_str -> LEFTSQ rightsq LARROW . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> LEFTSQ rightsq LARROW

State 29:
## Known stack suffix:
## GT
## LR(1) items:
op_symbol -> GT . [ WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production op_symbol -> GT

State 30:
## Known stack suffix:
## EQUAL
## LR(1) items:
lident_op_str -> EQUAL . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> EQUAL

State 31:
## Known stack suffix:
## op_symbol
## LR(1) items:
lident_op_str -> op_symbol . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> op_symbol . UNDERSCORE [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 32
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> op_symbol

State 32:
## Known stack suffix:
## op_symbol UNDERSCORE
## LR(1) items:
lident_op_str -> op_symbol UNDERSCORE . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> op_symbol UNDERSCORE

State 33:
## Known stack suffix:
## LEFTPAR lident_op_str
## LR(1) items:
lident_op -> LEFTPAR lident_op_str . RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
lident_op -> LEFTPAR lident_op_str . RIGHTPAR_USCORE [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
lident_op -> LEFTPAR lident_op_str . RIGHTPAR_QUOTE [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR_USCORE shift to state 34
-- On RIGHTPAR_QUOTE shift to state 35
-- On RIGHTPAR shift to state 36
## Reductions:

State 34:
## Known stack suffix:
## LEFTPAR lident_op_str RIGHTPAR_USCORE
## LR(1) items:
lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_USCORE

State 35:
## Known stack suffix:
## LEFTPAR lident_op_str RIGHTPAR_QUOTE
## LR(1) items:
lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR_QUOTE

State 36:
## Known stack suffix:
## LEFTPAR lident_op_str RIGHTPAR
## LR(1) items:
lident_op -> LEFTPAR lident_op_str RIGHTPAR . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production lident_op -> LEFTPAR lident_op_str RIGHTPAR

State 37:
## Known stack suffix:
## FLOAT
## LR(1) items:
lident_keyword -> FLOAT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production lident_keyword -> FLOAT

State 38:
## Known stack suffix:
## CORE_UIDENT
## LR(1) items:
uident -> CORE_UIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL GHOST FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL GHOST FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production uident -> CORE_UIDENT

State 39:
## Known stack suffix:
## CORE_LIDENT
## LR(1) items:
lident -> CORE_LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production lident -> CORE_LIDENT

State 40:
## Known stack suffix:
## uident
## LR(1) items:
ident -> uident . [ RIGHTBRC EOF COMMA ]
## Transitions:
## Reductions:
-- On RIGHTBRC EOF COMMA
--   reduce production ident -> uident

State 41:
## Known stack suffix:
## separated_nonempty_list(COMMA,ident)
## LR(1) items:
comma_list1(ident) -> separated_nonempty_list(COMMA,ident) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production comma_list1(ident) -> separated_nonempty_list(COMMA,ident)

State 42:
## Known stack suffix:
## lident_op
## LR(1) items:
ident -> lident_op . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production ident -> lident_op

State 43:
## Known stack suffix:
## lident_keyword
## LR(1) items:
lident -> lident_keyword . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production lident -> lident_keyword

State 44:
## Known stack suffix:
## lident
## LR(1) items:
ident -> lident . [ VAL USE TYPE SCOPE RIGHTBRC QUOTE_LIDENT PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE RIGHTBRC QUOTE_LIDENT PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production ident -> lident

State 45:
## Known stack suffix:
## ident_comma_list_eof
## LR(1) items:
ident_comma_list_eof' -> ident_comma_list_eof . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept ident_comma_list_eof

State 46:
## Known stack suffix:
## ident
## LR(1) items:
separated_nonempty_list(COMMA,ident) -> ident . [ EOF ]
separated_nonempty_list(COMMA,ident) -> ident . COMMA separated_nonempty_list(COMMA,ident) [ EOF ]
## Transitions:
-- On COMMA shift to state 47
## Reductions:
-- On EOF
--   reduce production separated_nonempty_list(COMMA,ident) -> ident

State 47:
## Known stack suffix:
## ident COMMA
## LR(1) items:
separated_nonempty_list(COMMA,ident) -> ident COMMA . separated_nonempty_list(COMMA,ident) [ EOF ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 40
-- On separated_nonempty_list(COMMA,ident) shift to state 48
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 46
## Reductions:

State 48:
## Known stack suffix:
## ident COMMA separated_nonempty_list(COMMA,ident)
## LR(1) items:
separated_nonempty_list(COMMA,ident) -> ident COMMA separated_nonempty_list(COMMA,ident) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production separated_nonempty_list(COMMA,ident) -> ident COMMA separated_nonempty_list(COMMA,ident)

State 49:
## Known stack suffix:
## comma_list1(ident)
## LR(1) items:
ident_comma_list_eof -> comma_list1(ident) . EOF [ # ]
## Transitions:
-- On EOF shift to state 50
## Reductions:

State 50:
## Known stack suffix:
## comma_list1(ident) EOF
## LR(1) items:
ident_comma_list_eof -> comma_list1(ident) EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production ident_comma_list_eof -> comma_list1(ident) EOF

State 51:
## Known stack suffix:
##
## LR(1) items:
mlw_file' -> . mlw_file [ # ]
## Transitions:
-- On VAL shift to state 52
-- On USE shift to state 576
-- On TYPE shift to state 598
-- On THEORY shift to state 995
-- On SCOPE shift to state 997
-- On PREDICATE shift to state 1000
-- On MODULE shift to state 1015
-- On META shift to state 1017
-- On LET shift to state 1041
-- On LEMMA shift to state 1054
-- On INDUCTIVE shift to state 1063
-- On IMPORT shift to state 1083
-- On GOAL shift to state 1085
-- On FUNCTION shift to state 1089
-- On EXCEPTION shift to state 1096
-- On CONSTANT shift to state 1099
-- On COINDUCTIVE shift to state 1104
-- On CLONE shift to state 1106
-- On AXIOM shift to state 1154
-- On use_clone shift to state 1158
-- On scope_head shift to state 1159
-- On pure_decl shift to state 1160
-- On prog_decl shift to state 1161
-- On nonempty_list(module_decl) shift to state 1167
-- On module_head shift to state 1169
-- On module_decl shift to state 1172
-- On mlw_module shift to state 1174
-- On mlw_file shift to state 1176
-- On meta_decl shift to state 1163
-- On list(mlw_module) shift to state 1177
## Reductions:
-- On EOF
--   reduce production list(mlw_module) ->

State 52:
## Known stack suffix:
## VAL
## LR(1) items:
prog_decl -> VAL . ghost kind attrs(lident_rich) mk_expr(val_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On GHOST shift to state 53
-- On ghost shift to state 54
## Reductions:
-- On RANGE PREDICATE LIDENT LEMMA LEFTPAR FUNCTION FLOAT CORE_LIDENT CONSTANT
--   reduce production ghost ->

State 53:
## Known stack suffix:
## GHOST
## LR(1) items:
ghost -> GHOST . [ UNDERSCORE UIDENT RANGE PREDICATE LIDENT LEMMA LEFTPAR LEFTBRC FUNCTION FLOAT CORE_UIDENT CORE_LIDENT CONSTANT ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT RANGE PREDICATE LIDENT LEMMA LEFTPAR LEFTBRC FUNCTION FLOAT CORE_UIDENT CORE_LIDENT CONSTANT
--   reduce production ghost -> GHOST

State 54:
## Known stack suffix:
## VAL ghost
## LR(1) items:
prog_decl -> VAL ghost . kind attrs(lident_rich) mk_expr(val_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On PREDICATE shift to state 55
-- On LEMMA shift to state 56
-- On FUNCTION shift to state 57
-- On CONSTANT shift to state 58
-- On kind shift to state 59
## Reductions:
-- On RANGE LIDENT LEFTPAR FLOAT CORE_LIDENT
--   reduce production kind ->

State 55:
## Known stack suffix:
## PREDICATE
## LR(1) items:
kind -> PREDICATE . [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
--   reduce production kind -> PREDICATE

State 56:
## Known stack suffix:
## LEMMA
## LR(1) items:
kind -> LEMMA . [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
--   reduce production kind -> LEMMA

State 57:
## Known stack suffix:
## FUNCTION
## LR(1) items:
kind -> FUNCTION . [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
--   reduce production kind -> FUNCTION

State 58:
## Known stack suffix:
## CONSTANT
## LR(1) items:
kind -> CONSTANT . [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
--   reduce production kind -> CONSTANT

State 59:
## Known stack suffix:
## VAL ghost kind
## LR(1) items:
prog_decl -> VAL ghost kind . attrs(lident_rich) mk_expr(val_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On attrs(lident_rich) shift to state 76
## Reductions:

State 60:
## Known stack suffix:
## LIDENT
## LR(1) items:
lident_nq -> LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE AS ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE AS ARROW ALIAS
--   reduce production lident_nq -> LIDENT

State 61:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
lident_op_nq -> LEFTPAR . lident_op_str RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
lident_op_nq -> LEFTPAR . lident_op_str RIGHTPAR_USCORE [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
lident_op_nq -> LEFTPAR . lident_op_str RIGHTPAR_QUOTE [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
-- On OPPREF shift to state 5
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On MINUS shift to state 12
-- On LT shift to state 14
-- On LEFTSQ shift to state 15
-- On GT shift to state 29
-- On EQUAL shift to state 30
-- On op_symbol shift to state 31
-- On lident_op_str shift to state 62
## Reductions:

State 62:
## Known stack suffix:
## LEFTPAR lident_op_str
## LR(1) items:
lident_op_nq -> LEFTPAR lident_op_str . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
lident_op_nq -> LEFTPAR lident_op_str . RIGHTPAR_USCORE [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
lident_op_nq -> LEFTPAR lident_op_str . RIGHTPAR_QUOTE [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
-- On RIGHTPAR_USCORE shift to state 63
-- On RIGHTPAR_QUOTE shift to state 64
-- On RIGHTPAR shift to state 65
## Reductions:

State 63:
## Known stack suffix:
## LEFTPAR lident_op_str RIGHTPAR_USCORE
## LR(1) items:
lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS
--   reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_USCORE

State 64:
## Known stack suffix:
## LEFTPAR lident_op_str RIGHTPAR_QUOTE
## LR(1) items:
lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS
--   reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR_QUOTE

State 65:
## Known stack suffix:
## LEFTPAR lident_op_str RIGHTPAR
## LR(1) items:
lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS
--   reduce production lident_op_nq -> LEFTPAR lident_op_str RIGHTPAR

State 66:
## Known stack suffix:
## CORE_LIDENT
## LR(1) items:
lident_nq -> CORE_LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE AS ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE AS ARROW ALIAS
--   reduce production lident_nq -> CORE_LIDENT

State 67:
## Known stack suffix:
## lident_rich
## LR(1) items:
attrs(lident_rich) -> lident_rich . list(attr) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ALIAS ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 70
-- On attr shift to state 71
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ALIAS
--   reduce production list(attr) ->

State 68:
## Known stack suffix:
## POSITION
## LR(1) items:
attr -> POSITION . [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT TYPE TRY TRUE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE QUOTE_LIDENT PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EQUAL EPSILON EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BY BREAK BEGIN BAR AXIOM ATTRIBUTE ASSUME ASSERT AS ARROW ANY ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT TYPE TRY TRUE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE QUOTE_LIDENT PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EQUAL EPSILON EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BY BREAK BEGIN BAR AXIOM ATTRIBUTE ASSUME ASSERT AS ARROW ANY ALIAS ABSURD
--   reduce production attr -> POSITION

State 69:
## Known stack suffix:
## ATTRIBUTE
## LR(1) items:
attr -> ATTRIBUTE . [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT TYPE TRY TRUE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE QUOTE_LIDENT PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EQUAL EPSILON EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BY BREAK BEGIN BAR AXIOM ATTRIBUTE ASSUME ASSERT AS ARROW ANY ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT TYPE TRY TRUE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE QUOTE_LIDENT PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EQUAL EPSILON EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BY BREAK BEGIN BAR AXIOM ATTRIBUTE ASSUME ASSERT AS ARROW ANY ALIAS ABSURD
--   reduce production attr -> ATTRIBUTE

State 70:
## Known stack suffix:
## lident_rich list(attr)
## LR(1) items:
attrs(lident_rich) -> lident_rich list(attr) . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ALIAS
--   reduce production attrs(lident_rich) -> lident_rich list(attr)

State 71:
## Known stack suffix:
## attr
## LR(1) items:
list(attr) -> attr . list(attr) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ALIAS ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 72
-- On attr shift to state 71
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ALIAS
--   reduce production list(attr) ->

State 72:
## Known stack suffix:
## attr list(attr)
## LR(1) items:
list(attr) -> attr list(attr) . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ALIAS
--   reduce production list(attr) -> attr list(attr)

State 73:
## Known stack suffix:
## lident_op_nq
## LR(1) items:
lident_rich -> lident_op_nq . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS
--   reduce production lident_rich -> lident_op_nq

State 74:
## Known stack suffix:
## lident_nq
## LR(1) items:
lident_rich -> lident_nq . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS
--   reduce production lident_rich -> lident_nq

State 75:
## Known stack suffix:
## lident_keyword
## LR(1) items:
lident_nq -> lident_keyword . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE AS ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE AS ARROW ALIAS
--   reduce production lident_nq -> lident_keyword

State 76:
## Known stack suffix:
## VAL ghost kind attrs(lident_rich)
## LR(1) items:
prog_decl -> VAL ghost kind attrs(lident_rich) . mk_expr(val_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On val_defn shift to state 145
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 147
-- On param shift to state 569
-- On mk_expr(val_defn) shift to state 574
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WRITES VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE AXIOM ALIAS
--   reduce production list(param) ->

State 77:
## Known stack suffix:
## UNDERSCORE
## LR(1) items:
anon_binder -> UNDERSCORE . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS
--   reduce production anon_binder -> UNDERSCORE

State 78:
## Known stack suffix:
## QUOTE_LIDENT
## LR(1) items:
quote_lident -> QUOTE_LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production quote_lident -> QUOTE_LIDENT

State 79:
## Known stack suffix:
## LIDENT
## LR(1) items:
lident -> LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
lident_nq -> LIDENT . [ POSITION ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS
--   reduce production lident -> LIDENT
-- On POSITION ATTRIBUTE
--   reduce production lident_nq -> LIDENT

State 80:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
param -> LEFTPAR . GHOST ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
param -> LEFTPAR . binder_vars_rest RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
param -> LEFTPAR . GHOST binder_vars_rest RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
param -> LEFTPAR . binder_vars cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
param -> LEFTPAR . GHOST binder_vars cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
ty_block -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
ty_block -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
ty_block -> LEFTPAR . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 81
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 113
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 138
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list2(ty) shift to state 111
-- On binder_vars_rest shift to state 139
-- On binder_vars_head shift to state 118
-- On binder_vars shift to state 141
-- On anon_binder shift to state 136
## Reductions:

State 81:
## Known stack suffix:
## LEFTPAR RIGHTPAR
## LR(1) items:
ty_block -> LEFTPAR RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production ty_block -> LEFTPAR RIGHTPAR

State 82:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
ty_block -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
ty_block -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
ty_block -> LEFTPAR . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 81
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 103
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list2(ty) shift to state 111
## Reductions:

State 83:
## Known stack suffix:
## LEFTBRC
## LR(1) items:
ty_block -> LEFTBRC . ty RIGHTBRC [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 92
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 84:
## Known stack suffix:
## uqualid
## LR(1) items:
lqualid -> uqualid . DOT lident [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
ty_arg -> uqualid . DOT ty_block [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 85
## Reductions:

State 85:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
lqualid -> uqualid DOT . lident [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
ty_arg -> uqualid DOT . ty_block [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 86
-- On ty_block shift to state 87
-- On lident_keyword shift to state 43
-- On lident shift to state 88
## Reductions:

State 86:
## Known stack suffix:
## uqualid DOT uident
## LR(1) items:
uqualid -> uqualid DOT uident . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AS ARROW AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AS ARROW AMPAMP ALIAS
--   reduce production uqualid -> uqualid DOT uident

State 87:
## Known stack suffix:
## uqualid DOT ty_block
## LR(1) items:
ty_arg -> uqualid DOT ty_block . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production ty_arg -> uqualid DOT ty_block

State 88:
## Known stack suffix:
## uqualid DOT lident
## LR(1) items:
lqualid -> uqualid DOT lident . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production lqualid -> uqualid DOT lident

State 89:
## Known stack suffix:
## uident
## LR(1) items:
uqualid -> uident . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AS ARROW AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AS ARROW AMPAMP ALIAS
--   reduce production uqualid -> uident

State 90:
## Known stack suffix:
## ty_block
## LR(1) items:
ty_arg -> ty_block . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production ty_arg -> ty_block

State 91:
## Known stack suffix:
## ty_arg
## LR(1) items:
ty -> ty_arg . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production ty -> ty_arg

State 92:
## Known stack suffix:
## LEFTBRC ty
## LR(1) items:
ty -> ty . ARROW ty [ RIGHTBRC ARROW ]
ty_block -> LEFTBRC ty . RIGHTBRC [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 93
-- On ARROW shift to state 94
## Reductions:

State 93:
## Known stack suffix:
## LEFTBRC ty RIGHTBRC
## LR(1) items:
ty_block -> LEFTBRC ty RIGHTBRC . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production ty_block -> LEFTBRC ty RIGHTBRC

State 94:
## Known stack suffix:
## ty ARROW
## LR(1) items:
ty -> ty ARROW . ty [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 95
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 95:
## Known stack suffix:
## ty ARROW ty
## LR(1) items:
ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
ty -> ty ARROW ty . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS AND AMPAMP ALIAS
--   reduce production ty -> ty ARROW ty

State 96:
## Known stack suffix:
## quote_lident
## LR(1) items:
ty_arg -> quote_lident . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production ty_arg -> quote_lident

State 97:
## Known stack suffix:
## lqualid
## LR(1) items:
ty -> lqualid . nonempty_list(ty_arg) [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
ty_arg -> lqualid . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 98
-- On quote_lident shift to state 96
-- On nonempty_list(ty_arg) shift to state 102
-- On lqualid shift to state 100
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production ty_arg -> lqualid

State 98:
## Known stack suffix:
## ty_arg
## LR(1) items:
nonempty_list(ty_arg) -> ty_arg . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
nonempty_list(ty_arg) -> ty_arg . nonempty_list(ty_arg) [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 98
-- On quote_lident shift to state 96
-- On nonempty_list(ty_arg) shift to state 99
-- On lqualid shift to state 100
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production nonempty_list(ty_arg) -> ty_arg

State 99:
## Known stack suffix:
## ty_arg nonempty_list(ty_arg)
## LR(1) items:
nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg) . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production nonempty_list(ty_arg) -> ty_arg nonempty_list(ty_arg)

State 100:
## Known stack suffix:
## lqualid
## LR(1) items:
ty_arg -> lqualid . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production ty_arg -> lqualid

State 101:
## Known stack suffix:
## lident
## LR(1) items:
lqualid -> lident . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production lqualid -> lident

State 102:
## Known stack suffix:
## lqualid nonempty_list(ty_arg)
## LR(1) items:
ty -> lqualid nonempty_list(ty_arg) . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production ty -> lqualid nonempty_list(ty_arg)

State 103:
## Known stack suffix:
## LEFTPAR ty
## LR(1) items:
comma_list2(ty) -> ty . COMMA comma_list1(ty) [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
ty_block -> LEFTPAR ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 104
-- On COMMA shift to state 105
-- On ARROW shift to state 94
## Reductions:

State 104:
## Known stack suffix:
## LEFTPAR ty RIGHTPAR
## LR(1) items:
ty_block -> LEFTPAR ty RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production ty_block -> LEFTPAR ty RIGHTPAR

State 105:
## Known stack suffix:
## ty COMMA
## LR(1) items:
comma_list2(ty) -> ty COMMA . comma_list1(ty) [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 106
-- On separated_nonempty_list(COMMA,ty) shift to state 109
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list1(ty) shift to state 110
## Reductions:

State 106:
## Known stack suffix:
## ty
## LR(1) items:
separated_nonempty_list(COMMA,ty) -> ty . [ RIGHTPAR ]
separated_nonempty_list(COMMA,ty) -> ty . COMMA separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## Transitions:
-- On COMMA shift to state 107
-- On ARROW shift to state 94
## Reductions:
-- On RIGHTPAR
--   reduce production separated_nonempty_list(COMMA,ty) -> ty

State 107:
## Known stack suffix:
## ty COMMA
## LR(1) items:
separated_nonempty_list(COMMA,ty) -> ty COMMA . separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 106
-- On separated_nonempty_list(COMMA,ty) shift to state 108
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 108:
## Known stack suffix:
## ty COMMA separated_nonempty_list(COMMA,ty)
## LR(1) items:
separated_nonempty_list(COMMA,ty) -> ty COMMA separated_nonempty_list(COMMA,ty) . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR
--   reduce production separated_nonempty_list(COMMA,ty) -> ty COMMA separated_nonempty_list(COMMA,ty)

State 109:
## Known stack suffix:
## separated_nonempty_list(COMMA,ty)
## LR(1) items:
comma_list1(ty) -> separated_nonempty_list(COMMA,ty) . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR
--   reduce production comma_list1(ty) -> separated_nonempty_list(COMMA,ty)

State 110:
## Known stack suffix:
## ty COMMA comma_list1(ty)
## LR(1) items:
comma_list2(ty) -> ty COMMA comma_list1(ty) . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR
--   reduce production comma_list2(ty) -> ty COMMA comma_list1(ty)

State 111:
## Known stack suffix:
## LEFTPAR comma_list2(ty)
## LR(1) items:
ty_block -> LEFTPAR comma_list2(ty) . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 112
## Reductions:

State 112:
## Known stack suffix:
## LEFTPAR comma_list2(ty) RIGHTPAR
## LR(1) items:
ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
--   reduce production ty_block -> LEFTPAR comma_list2(ty) RIGHTPAR

State 113:
## Known stack suffix:
## LEFTPAR GHOST
## LR(1) items:
param -> LEFTPAR GHOST . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
param -> LEFTPAR GHOST . binder_vars_rest RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
param -> LEFTPAR GHOST . binder_vars cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 114
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On binder_vars_rest shift to state 116
-- On binder_vars_head shift to state 118
-- On binder_vars shift to state 131
-- On anon_binder shift to state 136
## Reductions:

State 114:
## Known stack suffix:
## LEFTPAR GHOST ty
## LR(1) items:
binder_vars_head -> ty . [ UNDERSCORE POSITION COLON ATTRIBUTE ]
param -> LEFTPAR GHOST ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
ty -> ty . ARROW ty [ UNDERSCORE RIGHTPAR POSITION COLON ATTRIBUTE ARROW ]
## Transitions:
-- On RIGHTPAR shift to state 115
-- On ARROW shift to state 94
## Reductions:
-- On UNDERSCORE POSITION COLON ATTRIBUTE
--   reduce production binder_vars_head -> ty

State 115:
## Known stack suffix:
## LEFTPAR GHOST ty RIGHTPAR
## LR(1) items:
param -> LEFTPAR GHOST ty RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
--   reduce production param -> LEFTPAR GHOST ty RIGHTPAR

State 116:
## Known stack suffix:
## LEFTPAR GHOST binder_vars_rest
## LR(1) items:
binder_vars -> binder_vars_rest . [ COLON ]
param -> LEFTPAR GHOST binder_vars_rest . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 117
## Reductions:
-- On COLON
--   reduce production binder_vars -> binder_vars_rest

State 117:
## Known stack suffix:
## LEFTPAR GHOST binder_vars_rest RIGHTPAR
## LR(1) items:
param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
--   reduce production param -> LEFTPAR GHOST binder_vars_rest RIGHTPAR

State 118:
## Known stack suffix:
## binder_vars_head
## LR(1) items:
binder_vars -> binder_vars_head . [ COLON ]
binder_vars_rest -> binder_vars_head . nonempty_list(attr) list(binder_var) [ RIGHTPAR COLON ]
binder_vars_rest -> binder_vars_head . anon_binder list(binder_var) [ RIGHTPAR COLON ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On nonempty_list(attr) shift to state 119
-- On attr shift to state 127
-- On anon_binder shift to state 129
## Reductions:
-- On COLON
--   reduce production binder_vars -> binder_vars_head

State 119:
## Known stack suffix:
## binder_vars_head nonempty_list(attr)
## LR(1) items:
binder_vars_rest -> binder_vars_head nonempty_list(attr) . list(binder_var) [ RIGHTPAR COLON ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On list(binder_var) shift to state 120
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On binder_var shift to state 123
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:
-- On RIGHTPAR COLON
--   reduce production list(binder_var) ->

State 120:
## Known stack suffix:
## binder_vars_head nonempty_list(attr) list(binder_var)
## LR(1) items:
binder_vars_rest -> binder_vars_head nonempty_list(attr) list(binder_var) . [ RIGHTPAR COLON ]
## Transitions:
## Reductions:
-- On RIGHTPAR COLON
--   reduce production binder_vars_rest -> binder_vars_head nonempty_list(attr) list(binder_var)

State 121:
## Known stack suffix:
## lident_nq
## LR(1) items:
attrs(lident_nq) -> lident_nq . list(attr) [ WITH VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF END DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 122
-- On attr shift to state 71
## Reductions:
-- On WITH VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF END DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW
--   reduce production list(attr) ->

State 122:
## Known stack suffix:
## lident_nq list(attr)
## LR(1) items:
attrs(lident_nq) -> lident_nq list(attr) . [ WITH VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF END DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ]
## Transitions:
## Reductions:
-- On WITH VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF END DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW
--   reduce production attrs(lident_nq) -> lident_nq list(attr)

State 123:
## Known stack suffix:
## binder_var
## LR(1) items:
list(binder_var) -> binder_var . list(binder_var) [ RIGHTPAR COLON ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On list(binder_var) shift to state 124
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On binder_var shift to state 123
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:
-- On RIGHTPAR COLON
--   reduce production list(binder_var) ->

State 124:
## Known stack suffix:
## binder_var list(binder_var)
## LR(1) items:
list(binder_var) -> binder_var list(binder_var) . [ RIGHTPAR COLON ]
## Transitions:
## Reductions:
-- On RIGHTPAR COLON
--   reduce production list(binder_var) -> binder_var list(binder_var)

State 125:
## Known stack suffix:
## attrs(lident_nq)
## LR(1) items:
binder_var -> attrs(lident_nq) . [ UNDERSCORE RIGHTPAR RANGE LIDENT LEFTSQ FLOAT DOT CORE_LIDENT COMMA COLON ]
## Transitions:
## Reductions:
-- On UNDERSCORE RIGHTPAR RANGE LIDENT LEFTSQ FLOAT DOT CORE_LIDENT COMMA COLON
--   reduce production binder_var -> attrs(lident_nq)

State 126:
## Known stack suffix:
## anon_binder
## LR(1) items:
binder_var -> anon_binder . [ UNDERSCORE RIGHTPAR RANGE LIDENT LEFTSQ FLOAT DOT CORE_LIDENT COMMA COLON ]
## Transitions:
## Reductions:
-- On UNDERSCORE RIGHTPAR RANGE LIDENT LEFTSQ FLOAT DOT CORE_LIDENT COMMA COLON
--   reduce production binder_var -> anon_binder

State 127:
## Known stack suffix:
## attr
## LR(1) items:
nonempty_list(attr) -> attr . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
nonempty_list(attr) -> attr . nonempty_list(attr) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On nonempty_list(attr) shift to state 128
-- On attr shift to state 127
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS
--   reduce production nonempty_list(attr) -> attr

State 128:
## Known stack suffix:
## attr nonempty_list(attr)
## LR(1) items:
nonempty_list(attr) -> attr nonempty_list(attr) . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS
--   reduce production nonempty_list(attr) -> attr nonempty_list(attr)

State 129:
## Known stack suffix:
## binder_vars_head anon_binder
## LR(1) items:
binder_vars_rest -> binder_vars_head anon_binder . list(binder_var) [ RIGHTPAR COLON ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On list(binder_var) shift to state 130
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On binder_var shift to state 123
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:
-- On RIGHTPAR COLON
--   reduce production list(binder_var) ->

State 130:
## Known stack suffix:
## binder_vars_head anon_binder list(binder_var)
## LR(1) items:
binder_vars_rest -> binder_vars_head anon_binder list(binder_var) . [ RIGHTPAR COLON ]
## Transitions:
## Reductions:
-- On RIGHTPAR COLON
--   reduce production binder_vars_rest -> binder_vars_head anon_binder list(binder_var)

State 131:
## Known stack suffix:
## LEFTPAR GHOST binder_vars
## LR(1) items:
param -> LEFTPAR GHOST binder_vars . cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 134
## Reductions:

State 132:
## Known stack suffix:
## COLON
## LR(1) items:
cast -> COLON . ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 133
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 133:
## Known stack suffix:
## COLON ty
## LR(1) items:
cast -> COLON ty . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT AS ARROW AND AMPAMP ALIAS ]
ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT AS ARROW AND AMPAMP ALIAS ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT AS AND AMPAMP ALIAS
--   reduce production cast -> COLON ty

State 134:
## Known stack suffix:
## LEFTPAR GHOST binder_vars cast
## LR(1) items:
param -> LEFTPAR GHOST binder_vars cast . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 135
## Reductions:

State 135:
## Known stack suffix:
## LEFTPAR GHOST binder_vars cast RIGHTPAR
## LR(1) items:
param -> LEFTPAR GHOST binder_vars cast RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
--   reduce production param -> LEFTPAR GHOST binder_vars cast RIGHTPAR

State 136:
## Known stack suffix:
## anon_binder
## LR(1) items:
binder_vars_rest -> anon_binder . list(binder_var) [ RIGHTPAR COLON ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On list(binder_var) shift to state 137
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On binder_var shift to state 123
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:
-- On RIGHTPAR COLON
--   reduce production list(binder_var) ->

State 137:
## Known stack suffix:
## anon_binder list(binder_var)
## LR(1) items:
binder_vars_rest -> anon_binder list(binder_var) . [ RIGHTPAR COLON ]
## Transitions:
## Reductions:
-- On RIGHTPAR COLON
--   reduce production binder_vars_rest -> anon_binder list(binder_var)

State 138:
## Known stack suffix:
## LEFTPAR ty
## LR(1) items:
binder_vars_head -> ty . [ UNDERSCORE POSITION COLON ATTRIBUTE ]
comma_list2(ty) -> ty . COMMA comma_list1(ty) [ RIGHTPAR ]
ty -> ty . ARROW ty [ UNDERSCORE RIGHTPAR POSITION COMMA COLON ATTRIBUTE ARROW ]
ty_block -> LEFTPAR ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 104
-- On COMMA shift to state 105
-- On ARROW shift to state 94
## Reductions:
-- On UNDERSCORE POSITION COLON ATTRIBUTE
--   reduce production binder_vars_head -> ty

State 139:
## Known stack suffix:
## LEFTPAR binder_vars_rest
## LR(1) items:
binder_vars -> binder_vars_rest . [ COLON ]
param -> LEFTPAR binder_vars_rest . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 140
## Reductions:
-- On COLON
--   reduce production binder_vars -> binder_vars_rest

State 140:
## Known stack suffix:
## LEFTPAR binder_vars_rest RIGHTPAR
## LR(1) items:
param -> LEFTPAR binder_vars_rest RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
--   reduce production param -> LEFTPAR binder_vars_rest RIGHTPAR

State 141:
## Known stack suffix:
## LEFTPAR binder_vars
## LR(1) items:
param -> LEFTPAR binder_vars . cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 142
## Reductions:

State 142:
## Known stack suffix:
## LEFTPAR binder_vars cast
## LR(1) items:
param -> LEFTPAR binder_vars cast . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 143
## Reductions:

State 143:
## Known stack suffix:
## LEFTPAR binder_vars cast RIGHTPAR
## LR(1) items:
param -> LEFTPAR binder_vars cast RIGHTPAR . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
--   reduce production param -> LEFTPAR binder_vars cast RIGHTPAR

State 144:
## Known stack suffix:
## CORE_LIDENT
## LR(1) items:
lident -> CORE_LIDENT . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
lident_nq -> CORE_LIDENT . [ POSITION ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS
--   reduce production lident -> CORE_LIDENT
-- On POSITION ATTRIBUTE
--   reduce production lident_nq -> CORE_LIDENT

State 145:
## Known stack suffix:
## val_defn
## LR(1) items:
mk_expr(val_defn) -> val_defn . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production mk_expr(val_defn) -> val_defn

State 146:
## Known stack suffix:
## ty_arg
## LR(1) items:
param -> ty_arg . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
--   reduce production param -> ty_arg

State 147:
## Known stack suffix:
## params
## LR(1) items:
val_defn -> params . return_opt spec [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 148
-- On return_opt shift to state 196
## Reductions:
-- On WRITES VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END DIVERGES CONSTANT COINDUCTIVE CLONE AXIOM ALIAS
--   reduce production return_opt ->

State 148:
## Known stack suffix:
## COLON
## LR(1) items:
return_opt -> COLON . return_named [ WRITES VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COINDUCTIVE CLONE AXIOM ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 149
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 191
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 193
-- On return_named shift to state 194
-- On return shift to state 195
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 149:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
return -> LEFTPAR . GHOST ty RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
return -> LEFTPAR . ret_ghost RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
return_named -> LEFTPAR . ret_cast RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
return_named -> LEFTPAR . comma_list2(ret_cast) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
ty_block -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
ty_block -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
ty_block -> LEFTPAR . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 150
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 81
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 151
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 152
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 153
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 169
-- On ret_ident shift to state 176
-- On ret_ghost shift to state 178
-- On ret_cast shift to state 180
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 167
-- On lident shift to state 101
-- On comma_list2(ty) shift to state 111
-- On comma_list2(ret_cast) shift to state 189
-- On attrs(lident_nq) shift to state 168
## Reductions:

State 150:
## Known stack suffix:
## UNDERSCORE
## LR(1) items:
ret_ident -> UNDERSCORE . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production ret_ident -> UNDERSCORE

State 151:
## Known stack suffix:
## LIDENT
## LR(1) items:
lident -> LIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF CORE_UIDENT CORE_LIDENT CONSTANT COMMA COINDUCTIVE CLONE BY BAR AXIOM ARROW ]
lident_nq -> LIDENT . [ POSITION COLON ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF CORE_UIDENT CORE_LIDENT CONSTANT COMMA COINDUCTIVE CLONE BY BAR AXIOM ARROW
--   reduce production lident -> LIDENT
-- On POSITION COLON ATTRIBUTE
--   reduce production lident_nq -> LIDENT

State 152:
## Known stack suffix:
## LEFTPAR GHOST
## LR(1) items:
ret_cast -> GHOST . ret_ident cast [ RIGHTPAR COMMA ]
ret_ghost -> GHOST . ty COMMA ret_rest [ RIGHTPAR ]
return -> LEFTPAR GHOST . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 150
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 151
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 153
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 154
-- On ret_ident shift to state 165
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 167
-- On lident shift to state 101
-- On attrs(lident_nq) shift to state 168
## Reductions:

State 153:
## Known stack suffix:
## CORE_LIDENT
## LR(1) items:
lident -> CORE_LIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF CORE_UIDENT CORE_LIDENT CONSTANT COMMA COINDUCTIVE CLONE BY BAR AXIOM ARROW ]
lident_nq -> CORE_LIDENT . [ POSITION COLON ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF CORE_UIDENT CORE_LIDENT CONSTANT COMMA COINDUCTIVE CLONE BY BAR AXIOM ARROW
--   reduce production lident -> CORE_LIDENT
-- On POSITION COLON ATTRIBUTE
--   reduce production lident_nq -> CORE_LIDENT

State 154:
## Known stack suffix:
## LEFTPAR GHOST ty
## LR(1) items:
ret_ghost -> GHOST ty . COMMA ret_rest [ RIGHTPAR ]
return -> LEFTPAR GHOST ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## Transitions:
-- On RIGHTPAR shift to state 155
-- On COMMA shift to state 156
-- On ARROW shift to state 94
## Reductions:

State 155:
## Known stack suffix:
## LEFTPAR GHOST ty RIGHTPAR
## LR(1) items:
return -> LEFTPAR GHOST ty RIGHTPAR . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production return -> LEFTPAR GHOST ty RIGHTPAR

State 156:
## Known stack suffix:
## GHOST ty COMMA
## LR(1) items:
ret_ghost -> GHOST ty COMMA . ret_rest [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 157
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 160
-- On ret_rest shift to state 164
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 157:
## Known stack suffix:
## GHOST
## LR(1) items:
ret_rest -> GHOST . ty COMMA ret_rest [ RIGHTPAR ]
ret_rest -> GHOST . ty [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 158
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 158:
## Known stack suffix:
## GHOST ty
## LR(1) items:
ret_rest -> GHOST ty . COMMA ret_rest [ RIGHTPAR ]
ret_rest -> GHOST ty . [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## Transitions:
-- On COMMA shift to state 159
-- On ARROW shift to state 94
## Reductions:
-- On RIGHTPAR
--   reduce production ret_rest -> GHOST ty

State 159:
## Known stack suffix:
## GHOST ty COMMA
## LR(1) items:
ret_rest -> GHOST ty COMMA . ret_rest [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 157
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 160
-- On ret_rest shift to state 163
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 160:
## Known stack suffix:
## ty
## LR(1) items:
ret_rest -> ty . COMMA ret_rest [ RIGHTPAR ]
ret_rest -> ty . [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## Transitions:
-- On COMMA shift to state 161
-- On ARROW shift to state 94
## Reductions:
-- On RIGHTPAR
--   reduce production ret_rest -> ty

State 161:
## Known stack suffix:
## ty COMMA
## LR(1) items:
ret_rest -> ty COMMA . ret_rest [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 157
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 160
-- On ret_rest shift to state 162
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 162:
## Known stack suffix:
## ty COMMA ret_rest
## LR(1) items:
ret_rest -> ty COMMA ret_rest . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR
--   reduce production ret_rest -> ty COMMA ret_rest

State 163:
## Known stack suffix:
## GHOST ty COMMA ret_rest
## LR(1) items:
ret_rest -> GHOST ty COMMA ret_rest . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR
--   reduce production ret_rest -> GHOST ty COMMA ret_rest

State 164:
## Known stack suffix:
## GHOST ty COMMA ret_rest
## LR(1) items:
ret_ghost -> GHOST ty COMMA ret_rest . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR
--   reduce production ret_ghost -> GHOST ty COMMA ret_rest

State 165:
## Known stack suffix:
## GHOST ret_ident
## LR(1) items:
ret_cast -> GHOST ret_ident . cast [ RIGHTPAR COMMA ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 166
## Reductions:

State 166:
## Known stack suffix:
## GHOST ret_ident cast
## LR(1) items:
ret_cast -> GHOST ret_ident cast . [ RIGHTPAR COMMA ]
## Transitions:
## Reductions:
-- On RIGHTPAR COMMA
--   reduce production ret_cast -> GHOST ret_ident cast

State 167:
## Known stack suffix:
## lident_keyword
## LR(1) items:
lident -> lident_keyword . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF CORE_UIDENT CORE_LIDENT CONSTANT COMMA COINDUCTIVE CLONE BY BAR AXIOM ARROW ]
lident_nq -> lident_keyword . [ POSITION COLON ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF CORE_UIDENT CORE_LIDENT CONSTANT COMMA COINDUCTIVE CLONE BY BAR AXIOM ARROW
--   reduce production lident -> lident_keyword
-- On POSITION COLON ATTRIBUTE
--   reduce production lident_nq -> lident_keyword

State 168:
## Known stack suffix:
## attrs(lident_nq)
## LR(1) items:
ret_ident -> attrs(lident_nq) . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production ret_ident -> attrs(lident_nq)

State 169:
## Known stack suffix:
## LEFTPAR ty
## LR(1) items:
comma_list2(ty) -> ty . COMMA comma_list1(ty) [ RIGHTPAR ]
ret_ghost -> ty . COMMA GHOST ty [ RIGHTPAR ]
ret_ghost -> ty . COMMA ret_ghost [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
ty_block -> LEFTPAR ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 104
-- On COMMA shift to state 170
-- On ARROW shift to state 94
## Reductions:

State 170:
## Known stack suffix:
## ty COMMA
## LR(1) items:
comma_list2(ty) -> ty COMMA . comma_list1(ty) [ RIGHTPAR ]
ret_ghost -> ty COMMA . GHOST ty [ RIGHTPAR ]
ret_ghost -> ty COMMA . ret_ghost [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 171
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 173
-- On separated_nonempty_list(COMMA,ty) shift to state 109
-- On ret_ghost shift to state 175
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list1(ty) shift to state 110
## Reductions:

State 171:
## Known stack suffix:
## ty COMMA GHOST
## LR(1) items:
ret_ghost -> ty COMMA GHOST . ty [ RIGHTPAR ]
ret_ghost -> GHOST . ty COMMA ret_rest [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 172
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 172:
## Known stack suffix:
## ty COMMA GHOST ty
## LR(1) items:
ret_ghost -> ty COMMA GHOST ty . [ RIGHTPAR ]
ret_ghost -> GHOST ty . COMMA ret_rest [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## Transitions:
-- On COMMA shift to state 156
-- On ARROW shift to state 94
## Reductions:
-- On RIGHTPAR
--   reduce production ret_ghost -> ty COMMA GHOST ty

State 173:
## Known stack suffix:
## ty
## LR(1) items:
ret_ghost -> ty . COMMA GHOST ty [ RIGHTPAR ]
ret_ghost -> ty . COMMA ret_ghost [ RIGHTPAR ]
separated_nonempty_list(COMMA,ty) -> ty . [ RIGHTPAR ]
separated_nonempty_list(COMMA,ty) -> ty . COMMA separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## Transitions:
-- On COMMA shift to state 174
-- On ARROW shift to state 94
## Reductions:
-- On RIGHTPAR
--   reduce production separated_nonempty_list(COMMA,ty) -> ty

State 174:
## Known stack suffix:
## ty COMMA
## LR(1) items:
ret_ghost -> ty COMMA . GHOST ty [ RIGHTPAR ]
ret_ghost -> ty COMMA . ret_ghost [ RIGHTPAR ]
separated_nonempty_list(COMMA,ty) -> ty COMMA . separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 171
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 173
-- On separated_nonempty_list(COMMA,ty) shift to state 108
-- On ret_ghost shift to state 175
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 175:
## Known stack suffix:
## ty COMMA ret_ghost
## LR(1) items:
ret_ghost -> ty COMMA ret_ghost . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR
--   reduce production ret_ghost -> ty COMMA ret_ghost

State 176:
## Known stack suffix:
## ret_ident
## LR(1) items:
ret_cast -> ret_ident . cast [ RIGHTPAR COMMA ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 177
## Reductions:

State 177:
## Known stack suffix:
## ret_ident cast
## LR(1) items:
ret_cast -> ret_ident cast . [ RIGHTPAR COMMA ]
## Transitions:
## Reductions:
-- On RIGHTPAR COMMA
--   reduce production ret_cast -> ret_ident cast

State 178:
## Known stack suffix:
## LEFTPAR ret_ghost
## LR(1) items:
return -> LEFTPAR ret_ghost . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 179
## Reductions:

State 179:
## Known stack suffix:
## LEFTPAR ret_ghost RIGHTPAR
## LR(1) items:
return -> LEFTPAR ret_ghost RIGHTPAR . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production return -> LEFTPAR ret_ghost RIGHTPAR

State 180:
## Known stack suffix:
## LEFTPAR ret_cast
## LR(1) items:
comma_list2(ret_cast) -> ret_cast . COMMA comma_list1(ret_cast) [ RIGHTPAR ]
return_named -> LEFTPAR ret_cast . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 181
-- On COMMA shift to state 182
## Reductions:

State 181:
## Known stack suffix:
## LEFTPAR ret_cast RIGHTPAR
## LR(1) items:
return_named -> LEFTPAR ret_cast RIGHTPAR . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production return_named -> LEFTPAR ret_cast RIGHTPAR

State 182:
## Known stack suffix:
## ret_cast COMMA
## LR(1) items:
comma_list2(ret_cast) -> ret_cast COMMA . comma_list1(ret_cast) [ RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 150
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On GHOST shift to state 183
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On separated_nonempty_list(COMMA,ret_cast) shift to state 184
-- On ret_ident shift to state 176
-- On ret_cast shift to state 185
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list1(ret_cast) shift to state 188
-- On attrs(lident_nq) shift to state 168
## Reductions:

State 183:
## Known stack suffix:
## GHOST
## LR(1) items:
ret_cast -> GHOST . ret_ident cast [ RIGHTPAR COMMA ]
## Transitions:
-- On UNDERSCORE shift to state 150
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On ret_ident shift to state 165
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 168
## Reductions:

State 184:
## Known stack suffix:
## separated_nonempty_list(COMMA,ret_cast)
## LR(1) items:
comma_list1(ret_cast) -> separated_nonempty_list(COMMA,ret_cast) . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR
--   reduce production comma_list1(ret_cast) -> separated_nonempty_list(COMMA,ret_cast)

State 185:
## Known stack suffix:
## ret_cast
## LR(1) items:
separated_nonempty_list(COMMA,ret_cast) -> ret_cast . [ RIGHTPAR ]
separated_nonempty_list(COMMA,ret_cast) -> ret_cast . COMMA separated_nonempty_list(COMMA,ret_cast) [ RIGHTPAR ]
## Transitions:
-- On COMMA shift to state 186
## Reductions:
-- On RIGHTPAR
--   reduce production separated_nonempty_list(COMMA,ret_cast) -> ret_cast

State 186:
## Known stack suffix:
## ret_cast COMMA
## LR(1) items:
separated_nonempty_list(COMMA,ret_cast) -> ret_cast COMMA . separated_nonempty_list(COMMA,ret_cast) [ RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 150
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On GHOST shift to state 183
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On separated_nonempty_list(COMMA,ret_cast) shift to state 187
-- On ret_ident shift to state 176
-- On ret_cast shift to state 185
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 168
## Reductions:

State 187:
## Known stack suffix:
## ret_cast COMMA separated_nonempty_list(COMMA,ret_cast)
## LR(1) items:
separated_nonempty_list(COMMA,ret_cast) -> ret_cast COMMA separated_nonempty_list(COMMA,ret_cast) . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR
--   reduce production separated_nonempty_list(COMMA,ret_cast) -> ret_cast COMMA separated_nonempty_list(COMMA,ret_cast)

State 188:
## Known stack suffix:
## ret_cast COMMA comma_list1(ret_cast)
## LR(1) items:
comma_list2(ret_cast) -> ret_cast COMMA comma_list1(ret_cast) . [ RIGHTPAR ]
## Transitions:
## Reductions:
-- On RIGHTPAR
--   reduce production comma_list2(ret_cast) -> ret_cast COMMA comma_list1(ret_cast)

State 189:
## Known stack suffix:
## LEFTPAR comma_list2(ret_cast)
## LR(1) items:
return_named -> LEFTPAR comma_list2(ret_cast) . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 190
## Reductions:

State 190:
## Known stack suffix:
## LEFTPAR comma_list2(ret_cast) RIGHTPAR
## LR(1) items:
return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production return_named -> LEFTPAR comma_list2(ret_cast) RIGHTPAR

State 191:
## Known stack suffix:
## GHOST
## LR(1) items:
return -> GHOST . ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 192
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 192:
## Known stack suffix:
## GHOST ty
## LR(1) items:
return -> GHOST ty . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production return -> GHOST ty

State 193:
## Known stack suffix:
## ty
## LR(1) items:
return -> ty . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production return -> ty

State 194:
## Known stack suffix:
## COLON return_named
## LR(1) items:
return_opt -> COLON return_named . [ WRITES VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COINDUCTIVE CLONE AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COINDUCTIVE CLONE AXIOM ALIAS
--   reduce production return_opt -> COLON return_named

State 195:
## Known stack suffix:
## return
## LR(1) items:
return_named -> return . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production return_named -> return

State 196:
## Known stack suffix:
## params return_opt
## LR(1) items:
val_defn -> params return_opt . spec [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 566
-- On single_spec shift to state 567
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production spec ->

State 197:
## Known stack suffix:
## WRITES
## LR(1) items:
single_spec -> WRITES . LEFTBRC comma_list0(single_term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 198
## Reductions:

State 198:
## Known stack suffix:
## WRITES LEFTBRC
## LR(1) items:
single_spec -> WRITES LEFTBRC . comma_list0(single_term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 342
-- On separated_nonempty_list(COMMA,single_term) shift to state 489
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On loption(separated_nonempty_list(COMMA,single_term)) shift to state 490
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On comma_list0(single_term) shift to state 491
-- On attr shift to state 356
## Reductions:
-- On RIGHTBRC
--   reduce production loption(separated_nonempty_list(COMMA,single_term)) ->

State 199:
## Known stack suffix:
## TRUE
## LR(1) items:
term_arg_ -> TRUE . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_arg_ -> TRUE

State 200:
## Known stack suffix:
## REAL
## LR(1) items:
numeral -> REAL . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production numeral -> REAL

State 201:
## Known stack suffix:
## OPPREF
## LR(1) items:
term_arg_ -> OPPREF . term_arg [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_dot_ -> OPPREF . term_dot [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On OPPREF shift to state 201
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 483
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 411
-- On term_arg shift to state 484
-- On qualid shift to state 345
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
## Reductions:

State 202:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
lident_op -> LEFTPAR . lident_op_str RIGHTPAR [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR_USCORE [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR_QUOTE [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_block_ -> LEFTPAR . term RIGHTPAR [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_block_ -> LEFTPAR . RIGHTPAR [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On RIGHTPAR shift to state 203
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 204
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 485
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTSQ shift to state 15
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EQUAL shift to state 30
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 486
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 488
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op_str shift to state 33
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 203:
## Known stack suffix:
## LEFTPAR RIGHTPAR
## LR(1) items:
term_block_ -> LEFTPAR RIGHTPAR . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_block_ -> LEFTPAR RIGHTPAR

State 204:
## Known stack suffix:
## OPPREF
## LR(1) items:
lident_op_str -> OPPREF . option(UNDERSCORE) [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
term_arg_ -> OPPREF . term_arg [ UIDENT TRUE SO RIGHTPAR REAL RANGE OR OPPREF OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW LIDENT LEFTSQ LEFTPAR LEFTBRC INTEGER GT FLOAT FALSE EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BY BEGIN BARBAR AT ARROW AND AMPAMP ]
term_dot_ -> OPPREF . term_dot [ DOT ]
## Transitions:
-- On UNDERSCORE shift to state 6
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On OPPREF shift to state 201
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 483
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 411
-- On term_arg shift to state 484
-- On qualid shift to state 345
-- On option(UNDERSCORE) shift to state 7
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production option(UNDERSCORE) ->

State 205:
## Known stack suffix:
## LEFTBRC
## LR(1) items:
term_block_ -> LEFTBRC . field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_block_ -> LEFTBRC . term_arg WITH field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On OPPREF shift to state 201
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uqualid shift to state 466
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 411
-- On term_arg shift to state 469
-- On semicolon_list1(separated_pair(lqualid,EQUAL,term)) shift to state 471
-- On qualid shift to state 345
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On lqualid shift to state 479
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 480
-- On ident shift to state 355
-- On field_list1(term) shift to state 481
## Reductions:

State 206:
## Known stack suffix:
## INTEGER
## LR(1) items:
numeral -> INTEGER . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production numeral -> INTEGER

State 207:
## Known stack suffix:
## FALSE
## LR(1) items:
term_arg_ -> FALSE . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_arg_ -> FALSE

State 208:
## Known stack suffix:
## BEGIN
## LR(1) items:
term_block_ -> BEGIN . term END [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_block_ -> BEGIN . END [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On END shift to state 463
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 464
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 209:
## Known stack suffix:
## OLD
## LR(1) items:
single_term_ -> OLD . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 462
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 210:
## Known stack suffix:
## NOT
## LR(1) items:
single_term_ -> NOT . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 461
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 211:
## Known stack suffix:
## MINUS
## LR(1) items:
prefix_op -> MINUS . [ UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE ]
single_term_ -> MINUS . INTEGER [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> MINUS . REAL [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On REAL shift to state 212
-- On INTEGER shift to state 213
## Reductions:
-- On UIDENT TRUE RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
--   reduce production prefix_op -> MINUS

State 212:
## Known stack suffix:
## MINUS REAL
## LR(1) items:
single_term_ -> MINUS REAL . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> MINUS REAL

State 213:
## Known stack suffix:
## MINUS INTEGER
## LR(1) items:
single_term_ -> MINUS INTEGER . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> MINUS INTEGER

State 214:
## Known stack suffix:
## MATCH
## LR(1) items:
single_term_ -> MATCH . term WITH match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 447
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 215:
## Known stack suffix:
## LET
## LR(1) items:
single_term_ -> LET . pattern EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> LET . attrs(lident_op_nq) EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> LET . attrs(lident_nq) mk_term(lam_defn) IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> LET . attrs(lident_op_nq) mk_term(lam_defn) IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 217
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 268
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On lident_op_nq shift to state 429
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_op_nq) shift to state 431
-- On attrs(lident_nq) shift to state 443
## Reductions:

State 216:
## Known stack suffix:
## UNDERSCORE
## LR(1) items:
pat_arg_ -> UNDERSCORE . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
--   reduce production pat_arg_ -> UNDERSCORE

State 217:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
lident_op_nq -> LEFTPAR . lident_op_str RIGHTPAR [ UNDERSCORE UIDENT RANGE QUOTE_LIDENT POSITION LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT ATTRIBUTE ]
lident_op_nq -> LEFTPAR . lident_op_str RIGHTPAR_USCORE [ UNDERSCORE UIDENT RANGE QUOTE_LIDENT POSITION LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT ATTRIBUTE ]
lident_op_nq -> LEFTPAR . lident_op_str RIGHTPAR_QUOTE [ UNDERSCORE UIDENT RANGE QUOTE_LIDENT POSITION LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT ATTRIBUTE ]
pat_block_ -> LEFTPAR . RIGHTPAR [ EQUAL COMMA COLON BAR AS ]
pat_block_ -> LEFTPAR . pattern RIGHTPAR [ EQUAL COMMA COLON BAR AS ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 218
-- On RANGE shift to state 2
-- On OPPREF shift to state 5
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On MINUS shift to state 12
-- On LT shift to state 14
-- On LIDENT shift to state 60
-- On LEFTSQ shift to state 15
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GT shift to state 29
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On EQUAL shift to state 30
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 266
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On op_symbol shift to state 31
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On lident_op_str shift to state 62
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 218:
## Known stack suffix:
## LEFTPAR RIGHTPAR
## LR(1) items:
pat_block_ -> LEFTPAR RIGHTPAR . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
--   reduce production pat_block_ -> LEFTPAR RIGHTPAR

State 219:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
pat_block_ -> LEFTPAR . RIGHTPAR [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
pat_block_ -> LEFTPAR . pattern RIGHTPAR [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 218
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 266
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 220:
## Known stack suffix:
## LEFTBRC
## LR(1) items:
pat_block_ -> LEFTBRC . field_list1(pattern) RIGHTBRC [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) shift to state 223
-- On lqualid shift to state 224
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On field_list1(pattern) shift to state 264
## Reductions:

State 221:
## Known stack suffix:
## uqualid
## LR(1) items:
lqualid -> uqualid . DOT lident [ RIGHTBRC EQUAL COMMA ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 222
## Reductions:

State 222:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
lqualid -> uqualid DOT . lident [ RIGHTBRC EQUAL COMMA ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 86
-- On lident_keyword shift to state 43
-- On lident shift to state 88
## Reductions:

State 223:
## Known stack suffix:
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern))
## LR(1) items:
field_list1(pattern) -> semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production field_list1(pattern) -> semicolon_list1(separated_pair(lqualid,EQUAL,pattern))

State 224:
## Known stack suffix:
## lqualid
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid . EQUAL pattern [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid . EQUAL pattern SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid . EQUAL pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
## Transitions:
-- On EQUAL shift to state 225
## Reductions:

State 225:
## Known stack suffix:
## lqualid EQUAL
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL . pattern [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL . pattern SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL . pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 244
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 226:
## Known stack suffix:
## GHOST
## LR(1) items:
pat_uni_ -> GHOST . mk_pat(pat_uni_) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pat_uni_ shift to state 239
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pat_uni_) shift to state 241
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 227:
## Known stack suffix:
## uqualid
## LR(1) items:
pat_arg_ -> uqualid . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
pat_arg_ -> uqualid . DOT mk_pat(pat_block_) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
pat_uni_ -> uqualid . nonempty_list(pat_arg) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On DOT shift to state 228
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 231
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 233
-- On pat_arg shift to state 234
-- On nonempty_list(pat_arg) shift to state 238
-- On mk_pat(pat_arg_) shift to state 236
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
--   reduce production pat_arg_ -> uqualid

State 228:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
pat_arg_ -> uqualid DOT . mk_pat(pat_block_) [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
uqualid -> uqualid DOT . uident [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On UIDENT shift to state 1
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 86
-- On pat_block_ shift to state 229
-- On mk_pat(pat_block_) shift to state 230
## Reductions:

State 229:
## Known stack suffix:
## pat_block_
## LR(1) items:
mk_pat(pat_block_) -> pat_block_ . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
--   reduce production mk_pat(pat_block_) -> pat_block_

State 230:
## Known stack suffix:
## uqualid DOT mk_pat(pat_block_)
## LR(1) items:
pat_arg_ -> uqualid DOT mk_pat(pat_block_) . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
--   reduce production pat_arg_ -> uqualid DOT mk_pat(pat_block_)

State 231:
## Known stack suffix:
## uqualid
## LR(1) items:
pat_arg_ -> uqualid . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
pat_arg_ -> uqualid . DOT mk_pat(pat_block_) [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On DOT shift to state 228
## Reductions:
-- On UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
--   reduce production pat_arg_ -> uqualid

State 232:
## Known stack suffix:
## pat_block_
## LR(1) items:
pat_arg_ -> pat_block_ . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
--   reduce production pat_arg_ -> pat_block_

State 233:
## Known stack suffix:
## pat_arg_
## LR(1) items:
mk_pat(pat_arg_) -> pat_arg_ . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
--   reduce production mk_pat(pat_arg_) -> pat_arg_

State 234:
## Known stack suffix:
## pat_arg
## LR(1) items:
nonempty_list(pat_arg) -> pat_arg . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
nonempty_list(pat_arg) -> pat_arg . nonempty_list(pat_arg) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 231
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 233
-- On pat_arg shift to state 234
-- On nonempty_list(pat_arg) shift to state 235
-- On mk_pat(pat_arg_) shift to state 236
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
--   reduce production nonempty_list(pat_arg) -> pat_arg

State 235:
## Known stack suffix:
## pat_arg nonempty_list(pat_arg)
## LR(1) items:
nonempty_list(pat_arg) -> pat_arg nonempty_list(pat_arg) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
--   reduce production nonempty_list(pat_arg) -> pat_arg nonempty_list(pat_arg)

State 236:
## Known stack suffix:
## mk_pat(pat_arg_)
## LR(1) items:
pat_arg -> mk_pat(pat_arg_) . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
--   reduce production pat_arg -> mk_pat(pat_arg_)

State 237:
## Known stack suffix:
## attrs(lident_nq)
## LR(1) items:
pat_arg_ -> attrs(lident_nq) . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
--   reduce production pat_arg_ -> attrs(lident_nq)

State 238:
## Known stack suffix:
## uqualid nonempty_list(pat_arg)
## LR(1) items:
pat_uni_ -> uqualid nonempty_list(pat_arg) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
--   reduce production pat_uni_ -> uqualid nonempty_list(pat_arg)

State 239:
## Known stack suffix:
## pat_uni_
## LR(1) items:
mk_pat(pat_uni_) -> pat_uni_ . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
--   reduce production mk_pat(pat_uni_) -> pat_uni_

State 240:
## Known stack suffix:
## pat_arg_
## LR(1) items:
pat_uni_ -> pat_arg_ . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
--   reduce production pat_uni_ -> pat_arg_

State 241:
## Known stack suffix:
## GHOST mk_pat(pat_uni_)
## LR(1) items:
pat_uni_ -> GHOST mk_pat(pat_uni_) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
pat_uni_ -> mk_pat(pat_uni_) . AS ghost attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
pat_uni_ -> mk_pat(pat_uni_) . cast [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 242
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA BAR AS ARROW
--   reduce production pat_uni_ -> GHOST mk_pat(pat_uni_)

State 242:
## Known stack suffix:
## mk_pat(pat_uni_) cast
## LR(1) items:
pat_uni_ -> mk_pat(pat_uni_) cast . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
--   reduce production pat_uni_ -> mk_pat(pat_uni_) cast

State 243:
## Known stack suffix:
## pattern_
## LR(1) items:
mk_pat(pattern_) -> pattern_ . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW
--   reduce production mk_pat(pattern_) -> pattern_

State 244:
## Known stack suffix:
## lqualid EQUAL pattern
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern . [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern . SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern . SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
## Transitions:
-- On SEMICOLON shift to state 245
## Reductions:
-- On RIGHTBRC
--   reduce production semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern

State 245:
## Known stack suffix:
## lqualid EQUAL pattern SEMICOLON
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON . [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON . semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) shift to state 246
-- On lqualid shift to state 224
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:
-- On RIGHTBRC
--   reduce production semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON

State 246:
## Known stack suffix:
## lqualid EQUAL pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern))
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern))

State 247:
## Known stack suffix:
## pat_uni_
## LR(1) items:
mk_pat(pat_uni_) -> pat_uni_ . [ COMMA COLON AS ]
pat_conj_ -> pat_uni_ . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
## Reductions:
-- On COMMA COLON AS
--   reduce production mk_pat(pat_uni_) -> pat_uni_
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
--   reduce production pat_conj_ -> pat_uni_

State 248:
## Known stack suffix:
## pat_conj_
## LR(1) items:
mk_pat(pat_conj_) -> pat_conj_ . [ BAR ]
pattern_ -> pat_conj_ . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
## Transitions:
## Reductions:
-- On BAR
--   reduce production mk_pat(pat_conj_) -> pat_conj_
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW
--   reduce production pattern_ -> pat_conj_

State 249:
## Known stack suffix:
## mk_pat(pattern_)
## LR(1) items:
pattern -> mk_pat(pattern_) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW
--   reduce production pattern -> mk_pat(pattern_)

State 250:
## Known stack suffix:
## mk_pat(pat_uni_)
## LR(1) items:
comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) . COMMA comma_list1(mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
pat_uni_ -> mk_pat(pat_uni_) . AS ghost attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
pat_uni_ -> mk_pat(pat_uni_) . cast [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
-- On COMMA shift to state 251
-- On COLON shift to state 132
-- On AS shift to state 256
-- On cast shift to state 242
## Reductions:

State 251:
## Known stack suffix:
## mk_pat(pat_uni_) COMMA
## LR(1) items:
comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA . comma_list1(mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,mk_pat(pat_uni_)) shift to state 252
-- On pat_uni_ shift to state 239
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pat_uni_) shift to state 253
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list1(mk_pat(pat_uni_)) shift to state 259
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 252:
## Known stack suffix:
## separated_nonempty_list(COMMA,mk_pat(pat_uni_))
## LR(1) items:
comma_list1(mk_pat(pat_uni_)) -> separated_nonempty_list(COMMA,mk_pat(pat_uni_)) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
--   reduce production comma_list1(mk_pat(pat_uni_)) -> separated_nonempty_list(COMMA,mk_pat(pat_uni_))

State 253:
## Known stack suffix:
## mk_pat(pat_uni_)
## LR(1) items:
pat_uni_ -> mk_pat(pat_uni_) . AS ghost attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
pat_uni_ -> mk_pat(pat_uni_) . cast [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) . COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
-- On COMMA shift to state 254
-- On COLON shift to state 132
-- On AS shift to state 256
-- On cast shift to state 242
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
--   reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_)

State 254:
## Known stack suffix:
## mk_pat(pat_uni_) COMMA
## LR(1) items:
separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA . separated_nonempty_list(COMMA,mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,mk_pat(pat_uni_)) shift to state 255
-- On pat_uni_ shift to state 239
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pat_uni_) shift to state 253
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 255:
## Known stack suffix:
## mk_pat(pat_uni_) COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_))
## LR(1) items:
separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_)) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
--   reduce production separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_))

State 256:
## Known stack suffix:
## mk_pat(pat_uni_) AS
## LR(1) items:
pat_uni_ -> mk_pat(pat_uni_) AS . ghost attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
-- On GHOST shift to state 53
-- On ghost shift to state 257
## Reductions:
-- On RANGE LIDENT FLOAT CORE_LIDENT
--   reduce production ghost ->

State 257:
## Known stack suffix:
## mk_pat(pat_uni_) AS ghost
## LR(1) items:
pat_uni_ -> mk_pat(pat_uni_) AS ghost . attrs(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 258
## Reductions:

State 258:
## Known stack suffix:
## mk_pat(pat_uni_) AS ghost attrs(lident_nq)
## LR(1) items:
pat_uni_ -> mk_pat(pat_uni_) AS ghost attrs(lident_nq) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
--   reduce production pat_uni_ -> mk_pat(pat_uni_) AS ghost attrs(lident_nq)

State 259:
## Known stack suffix:
## mk_pat(pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))
## LR(1) items:
comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA comma_list1(mk_pat(pat_uni_)) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
--   reduce production comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))

State 260:
## Known stack suffix:
## mk_pat(pat_conj_)
## LR(1) items:
pattern_ -> mk_pat(pat_conj_) . BAR pattern [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
## Transitions:
-- On BAR shift to state 261
## Reductions:

State 261:
## Known stack suffix:
## mk_pat(pat_conj_) BAR
## LR(1) items:
pattern_ -> mk_pat(pat_conj_) BAR . pattern [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 262
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 262:
## Known stack suffix:
## mk_pat(pat_conj_) BAR pattern
## LR(1) items:
pattern_ -> mk_pat(pat_conj_) BAR pattern . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW
--   reduce production pattern_ -> mk_pat(pat_conj_) BAR pattern

State 263:
## Known stack suffix:
## comma_list2(mk_pat(pat_uni_))
## LR(1) items:
pat_conj_ -> comma_list2(mk_pat(pat_uni_)) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
--   reduce production pat_conj_ -> comma_list2(mk_pat(pat_uni_))

State 264:
## Known stack suffix:
## LEFTBRC field_list1(pattern)
## LR(1) items:
pat_block_ -> LEFTBRC field_list1(pattern) . RIGHTBRC [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On RIGHTBRC shift to state 265
## Reductions:

State 265:
## Known stack suffix:
## LEFTBRC field_list1(pattern) RIGHTBRC
## LR(1) items:
pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
--   reduce production pat_block_ -> LEFTBRC field_list1(pattern) RIGHTBRC

State 266:
## Known stack suffix:
## LEFTPAR pattern
## LR(1) items:
pat_block_ -> LEFTPAR pattern . RIGHTPAR [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
-- On RIGHTPAR shift to state 267
## Reductions:

State 267:
## Known stack suffix:
## LEFTPAR pattern RIGHTPAR
## LR(1) items:
pat_block_ -> LEFTPAR pattern RIGHTPAR . [ UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
--   reduce production pat_block_ -> LEFTPAR pattern RIGHTPAR

State 268:
## Known stack suffix:
## LET pattern
## LR(1) items:
single_term_ -> LET pattern . EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On EQUAL shift to state 269
## Reductions:

State 269:
## Known stack suffix:
## LET pattern EQUAL
## LR(1) items:
single_term_ -> LET pattern EQUAL . term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 426
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 270:
## Known stack suffix:
## IF
## LR(1) items:
single_term_ -> IF . term THEN term ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 421
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 271:
## Known stack suffix:
## FUN
## LR(1) items:
single_term_ -> FUN . binders ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 151
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 153
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 167
-- On lident shift to state 101
-- On binders shift to state 290
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:

State 272:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
binder -> LEFTPAR . GHOST ty RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder -> LEFTPAR . binder_vars_rest RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder -> LEFTPAR . GHOST binder_vars_rest RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder -> LEFTPAR . binder_vars cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder -> LEFTPAR . GHOST binder_vars cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
ty_block -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
ty_block -> LEFTPAR . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
ty_block -> LEFTPAR . ty RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 81
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 273
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 138
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list2(ty) shift to state 111
-- On binder_vars_rest shift to state 281
-- On binder_vars_head shift to state 118
-- On binder_vars shift to state 283
-- On anon_binder shift to state 136
## Reductions:

State 273:
## Known stack suffix:
## LEFTPAR GHOST
## LR(1) items:
binder -> LEFTPAR GHOST . ty RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder -> LEFTPAR GHOST . binder_vars_rest RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder -> LEFTPAR GHOST . binder_vars cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 274
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On binder_vars_rest shift to state 276
-- On binder_vars_head shift to state 118
-- On binder_vars shift to state 278
-- On anon_binder shift to state 136
## Reductions:

State 274:
## Known stack suffix:
## LEFTPAR GHOST ty
## LR(1) items:
binder -> LEFTPAR GHOST ty . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder_vars_head -> ty . [ UNDERSCORE POSITION COLON ATTRIBUTE ]
ty -> ty . ARROW ty [ UNDERSCORE RIGHTPAR POSITION COLON ATTRIBUTE ARROW ]
## Transitions:
-- On RIGHTPAR shift to state 275
-- On ARROW shift to state 94
## Reductions:
-- On UNDERSCORE POSITION COLON ATTRIBUTE
--   reduce production binder_vars_head -> ty

State 275:
## Known stack suffix:
## LEFTPAR GHOST ty RIGHTPAR
## LR(1) items:
binder -> LEFTPAR GHOST ty RIGHTPAR . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS
--   reduce production binder -> LEFTPAR GHOST ty RIGHTPAR

State 276:
## Known stack suffix:
## LEFTPAR GHOST binder_vars_rest
## LR(1) items:
binder -> LEFTPAR GHOST binder_vars_rest . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder_vars -> binder_vars_rest . [ COLON ]
## Transitions:
-- On RIGHTPAR shift to state 277
## Reductions:
-- On COLON
--   reduce production binder_vars -> binder_vars_rest

State 277:
## Known stack suffix:
## LEFTPAR GHOST binder_vars_rest RIGHTPAR
## LR(1) items:
binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS
--   reduce production binder -> LEFTPAR GHOST binder_vars_rest RIGHTPAR

State 278:
## Known stack suffix:
## LEFTPAR GHOST binder_vars
## LR(1) items:
binder -> LEFTPAR GHOST binder_vars . cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 279
## Reductions:

State 279:
## Known stack suffix:
## LEFTPAR GHOST binder_vars cast
## LR(1) items:
binder -> LEFTPAR GHOST binder_vars cast . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 280
## Reductions:

State 280:
## Known stack suffix:
## LEFTPAR GHOST binder_vars cast RIGHTPAR
## LR(1) items:
binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS
--   reduce production binder -> LEFTPAR GHOST binder_vars cast RIGHTPAR

State 281:
## Known stack suffix:
## LEFTPAR binder_vars_rest
## LR(1) items:
binder -> LEFTPAR binder_vars_rest . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
binder_vars -> binder_vars_rest . [ COLON ]
## Transitions:
-- On RIGHTPAR shift to state 282
## Reductions:
-- On COLON
--   reduce production binder_vars -> binder_vars_rest

State 282:
## Known stack suffix:
## LEFTPAR binder_vars_rest RIGHTPAR
## LR(1) items:
binder -> LEFTPAR binder_vars_rest RIGHTPAR . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS
--   reduce production binder -> LEFTPAR binder_vars_rest RIGHTPAR

State 283:
## Known stack suffix:
## LEFTPAR binder_vars
## LR(1) items:
binder -> LEFTPAR binder_vars . cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 284
## Reductions:

State 284:
## Known stack suffix:
## LEFTPAR binder_vars cast
## LR(1) items:
binder -> LEFTPAR binder_vars cast . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 285
## Reductions:

State 285:
## Known stack suffix:
## LEFTPAR binder_vars cast RIGHTPAR
## LR(1) items:
binder -> LEFTPAR binder_vars cast RIGHTPAR . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS
--   reduce production binder -> LEFTPAR binder_vars cast RIGHTPAR

State 286:
## Known stack suffix:
## ty_arg
## LR(1) items:
binder -> ty_arg . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS
--   reduce production binder -> ty_arg

State 287:
## Known stack suffix:
## nonempty_list(binder)
## LR(1) items:
binders -> nonempty_list(binder) . [ WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS
--   reduce production binders -> nonempty_list(binder)

State 288:
## Known stack suffix:
## lident_nq
## LR(1) items:
binder -> lident_nq . nonempty_list(attr) [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On nonempty_list(attr) shift to state 289
-- On attr shift to state 127
## Reductions:

State 289:
## Known stack suffix:
## lident_nq nonempty_list(attr)
## LR(1) items:
binder -> lident_nq nonempty_list(attr) . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS
--   reduce production binder -> lident_nq nonempty_list(attr)

State 290:
## Known stack suffix:
## FUN binders
## LR(1) items:
single_term_ -> FUN binders . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On ARROW shift to state 291
## Reductions:

State 291:
## Known stack suffix:
## FUN binders ARROW
## LR(1) items:
single_term_ -> FUN binders ARROW . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 416
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 292:
## Known stack suffix:
## FORALL
## LR(1) items:
quant -> FORALL . [ UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT
--   reduce production quant -> FORALL

State 293:
## Known stack suffix:
## EXISTS
## LR(1) items:
quant -> EXISTS . [ UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT
--   reduce production quant -> EXISTS

State 294:
## Known stack suffix:
## EPSILON
## LR(1) items:
single_term_ -> EPSILON . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> EPSILON

State 295:
## Known stack suffix:
## uqualid
## LR(1) items:
lqualid -> uqualid . DOT lident [ DOT ]
qualid -> uqualid . DOT ident [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> uqualid . DOT mk_term(term_block_) [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 296
## Reductions:

State 296:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
lqualid -> uqualid DOT . lident [ DOT ]
qualid -> uqualid DOT . ident [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> uqualid DOT . mk_term(term_block_) [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uident shift to state 297
-- On term_block_ shift to state 298
-- On mk_term(term_block_) shift to state 299
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 300
-- On ident shift to state 301
## Reductions:

State 297:
## Known stack suffix:
## uqualid DOT uident
## LR(1) items:
ident -> uident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
uqualid -> uqualid DOT uident . [ DOT ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production ident -> uident
-- On DOT
--   reduce production uqualid -> uqualid DOT uident

State 298:
## Known stack suffix:
## term_block_
## LR(1) items:
mk_term(term_block_) -> term_block_ . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production mk_term(term_block_) -> term_block_

State 299:
## Known stack suffix:
## uqualid DOT mk_term(term_block_)
## LR(1) items:
term_sub_ -> uqualid DOT mk_term(term_block_) . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_sub_ -> uqualid DOT mk_term(term_block_)

State 300:
## Known stack suffix:
## uqualid DOT lident
## LR(1) items:
ident -> lident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
lqualid -> uqualid DOT lident . [ DOT ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production ident -> lident
-- On DOT
--   reduce production lqualid -> uqualid DOT lident

State 301:
## Known stack suffix:
## uqualid DOT ident
## LR(1) items:
qualid -> uqualid DOT ident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production qualid -> uqualid DOT ident

State 302:
## Known stack suffix:
## uident
## LR(1) items:
ident -> uident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
uqualid -> uident . [ DOT ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production ident -> uident
-- On DOT
--   reduce production uqualid -> uident

State 303:
## Known stack suffix:
## term_sub_
## LR(1) items:
term_arg_ -> term_sub_ . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_dot_ -> term_sub_ . [ DOT ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_arg_ -> term_sub_
-- On DOT
--   reduce production term_dot_ -> term_sub_

State 304:
## Known stack suffix:
## term_dot_
## LR(1) items:
mk_term(term_dot_) -> term_dot_ . [ DOT ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production mk_term(term_dot_) -> term_dot_

State 305:
## Known stack suffix:
## term_dot
## LR(1) items:
term_sub_ -> term_dot . DOT lqualid_rich [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On DOT shift to state 306
## Reductions:

State 306:
## Known stack suffix:
## term_dot DOT
## LR(1) items:
term_sub_ -> term_dot DOT . lqualid_rich [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 307
-- On uident shift to state 89
-- On lqualid_rich shift to state 311
-- On lident_op shift to state 312
-- On lident_keyword shift to state 43
-- On lident shift to state 313
## Reductions:

State 307:
## Known stack suffix:
## uqualid
## LR(1) items:
lqualid_rich -> uqualid . DOT lident [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
lqualid_rich -> uqualid . DOT lident_op [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 308
## Reductions:

State 308:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
lqualid_rich -> uqualid DOT . lident [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
lqualid_rich -> uqualid DOT . lident_op [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 86
-- On lident_op shift to state 309
-- On lident_keyword shift to state 43
-- On lident shift to state 310
## Reductions:

State 309:
## Known stack suffix:
## uqualid DOT lident_op
## LR(1) items:
lqualid_rich -> uqualid DOT lident_op . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production lqualid_rich -> uqualid DOT lident_op

State 310:
## Known stack suffix:
## uqualid DOT lident
## LR(1) items:
lqualid_rich -> uqualid DOT lident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production lqualid_rich -> uqualid DOT lident

State 311:
## Known stack suffix:
## term_dot DOT lqualid_rich
## LR(1) items:
term_sub_ -> term_dot DOT lqualid_rich . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_sub_ -> term_dot DOT lqualid_rich

State 312:
## Known stack suffix:
## lident_op
## LR(1) items:
lqualid_rich -> lident_op . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production lqualid_rich -> lident_op

State 313:
## Known stack suffix:
## lident
## LR(1) items:
lqualid_rich -> lident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production lqualid_rich -> lident

State 314:
## Known stack suffix:
## term_block_
## LR(1) items:
term_sub_ -> term_block_ . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_sub_ -> term_block_

State 315:
## Known stack suffix:
## term_arg_
## LR(1) items:
mk_term(term_arg_) -> term_arg_ . [ UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTSQ LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN ]
single_term_ -> term_arg_ . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTSQ LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
--   reduce production mk_term(term_arg_) -> term_arg_
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> term_arg_

State 316:
## Known stack suffix:
## term_arg
## LR(1) items:
single_term_ -> term_arg . nonempty_list(located(term_arg)) [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term LARROW term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On OPPREF shift to state 201
-- On LIDENT shift to state 3
-- On LEFTSQ shift to state 317
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 411
-- On term_arg shift to state 412
-- On qualid shift to state 345
-- On numeral shift to state 349
-- On nonempty_list(located(term_arg)) shift to state 413
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On lqualid shift to state 353
-- On located(term_arg) shift to state 414
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
## Reductions:

State 317:
## Known stack suffix:
## term_arg LEFTSQ
## LR(1) items:
term_sub_ -> term_arg LEFTSQ . term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ . term LARROW term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ . term DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ . term DOTDOT rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ . DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On DOTDOT shift to state 318
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 402
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 318:
## Known stack suffix:
## term_arg LEFTSQ DOTDOT
## LR(1) items:
term_sub_ -> term_arg LEFTSQ DOTDOT . term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 319
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 319:
## Known stack suffix:
## term_arg LEFTSQ DOTDOT term
## LR(1) items:
term_sub_ -> term_arg LEFTSQ DOTDOT term . rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 320
## Reductions:

State 320:
## Known stack suffix:
## term_arg LEFTSQ DOTDOT term rightsq
## LR(1) items:
term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_sub_ -> term_arg LEFTSQ DOTDOT term rightsq

State 321:
## Known stack suffix:
## single_term_
## LR(1) items:
mk_term(single_term_) -> single_term_ . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production mk_term(single_term_) -> single_term_

State 322:
## Known stack suffix:
## single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term -> single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term -> single_term . COMMA term_ [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On COMMA shift to state 397
-- On COLON shift to state 132
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COINDUCTIVE CLONE BAR AXIOM
--   reduce production term -> single_term

State 323:
## Known stack suffix:
## single_term SO
## LR(1) items:
single_term_ -> single_term SO . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 324
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 324:
## Known stack suffix:
## single_term SO single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term SO single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BAR AXIOM
--   reduce production single_term_ -> single_term SO single_term

State 325:
## Known stack suffix:
## single_term OR
## LR(1) items:
single_term_ -> single_term OR . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 326
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 326:
## Known stack suffix:
## single_term OR single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term OR single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE META LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW
--   reduce production single_term_ -> single_term OR single_term

State 327:
## Known stack suffix:
## single_term OP4
## LR(1) items:
single_term_ -> single_term OP4 . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 328
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 328:
## Known stack suffix:
## single_term OP4 single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term OP4 single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> single_term OP4 single_term

State 329:
## Known stack suffix:
## single_term cast
## LR(1) items:
single_term_ -> single_term cast . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> single_term cast

State 330:
## Known stack suffix:
## quant
## LR(1) items:
single_term_ -> quant . comma_list1(quant_vars) triggers DOT term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On separated_nonempty_list(COMMA,quant_vars) shift to state 331
-- On quant_vars shift to state 332
-- On nonempty_list(binder_var) shift to state 335
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list1(quant_vars) shift to state 340
-- On binder_var shift to state 338
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:

State 331:
## Known stack suffix:
## separated_nonempty_list(COMMA,quant_vars)
## LR(1) items:
comma_list1(quant_vars) -> separated_nonempty_list(COMMA,quant_vars) . [ LEFTSQ DOT ]
## Transitions:
## Reductions:
-- On LEFTSQ DOT
--   reduce production comma_list1(quant_vars) -> separated_nonempty_list(COMMA,quant_vars)

State 332:
## Known stack suffix:
## quant_vars
## LR(1) items:
separated_nonempty_list(COMMA,quant_vars) -> quant_vars . [ LEFTSQ DOT ]
separated_nonempty_list(COMMA,quant_vars) -> quant_vars . COMMA separated_nonempty_list(COMMA,quant_vars) [ LEFTSQ DOT ]
## Transitions:
-- On COMMA shift to state 333
## Reductions:
-- On LEFTSQ DOT
--   reduce production separated_nonempty_list(COMMA,quant_vars) -> quant_vars

State 333:
## Known stack suffix:
## quant_vars COMMA
## LR(1) items:
separated_nonempty_list(COMMA,quant_vars) -> quant_vars COMMA . separated_nonempty_list(COMMA,quant_vars) [ LEFTSQ DOT ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On separated_nonempty_list(COMMA,quant_vars) shift to state 334
-- On quant_vars shift to state 332
-- On nonempty_list(binder_var) shift to state 335
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On binder_var shift to state 338
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:

State 334:
## Known stack suffix:
## quant_vars COMMA separated_nonempty_list(COMMA,quant_vars)
## LR(1) items:
separated_nonempty_list(COMMA,quant_vars) -> quant_vars COMMA separated_nonempty_list(COMMA,quant_vars) . [ LEFTSQ DOT ]
## Transitions:
## Reductions:
-- On LEFTSQ DOT
--   reduce production separated_nonempty_list(COMMA,quant_vars) -> quant_vars COMMA separated_nonempty_list(COMMA,quant_vars)

State 335:
## Known stack suffix:
## nonempty_list(binder_var)
## LR(1) items:
quant_vars -> nonempty_list(binder_var) . option(cast) [ LEFTSQ DOT COMMA ]
## Transitions:
-- On COLON shift to state 132
-- On option(cast) shift to state 336
-- On cast shift to state 337
## Reductions:
-- On LEFTSQ DOT COMMA
--   reduce production option(cast) ->

State 336:
## Known stack suffix:
## nonempty_list(binder_var) option(cast)
## LR(1) items:
quant_vars -> nonempty_list(binder_var) option(cast) . [ LEFTSQ DOT COMMA ]
## Transitions:
## Reductions:
-- On LEFTSQ DOT COMMA
--   reduce production quant_vars -> nonempty_list(binder_var) option(cast)

State 337:
## Known stack suffix:
## cast
## LR(1) items:
option(cast) -> cast . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA LEFTSQ INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END DOT CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA LEFTSQ INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END DOT CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production option(cast) -> cast

State 338:
## Known stack suffix:
## binder_var
## LR(1) items:
nonempty_list(binder_var) -> binder_var . [ LEFTSQ DOT COMMA COLON ]
nonempty_list(binder_var) -> binder_var . nonempty_list(binder_var) [ LEFTSQ DOT COMMA COLON ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On nonempty_list(binder_var) shift to state 339
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On binder_var shift to state 338
-- On attrs(lident_nq) shift to state 125
-- On anon_binder shift to state 126
## Reductions:
-- On LEFTSQ DOT COMMA COLON
--   reduce production nonempty_list(binder_var) -> binder_var

State 339:
## Known stack suffix:
## binder_var nonempty_list(binder_var)
## LR(1) items:
nonempty_list(binder_var) -> binder_var nonempty_list(binder_var) . [ LEFTSQ DOT COMMA COLON ]
## Transitions:
## Reductions:
-- On LEFTSQ DOT COMMA COLON
--   reduce production nonempty_list(binder_var) -> binder_var nonempty_list(binder_var)

State 340:
## Known stack suffix:
## quant comma_list1(quant_vars)
## LR(1) items:
single_term_ -> quant comma_list1(quant_vars) . triggers DOT term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On LEFTSQ shift to state 341
-- On triggers shift to state 394
## Reductions:
-- On DOT
--   reduce production triggers ->

State 341:
## Known stack suffix:
## LEFTSQ
## LR(1) items:
triggers -> LEFTSQ . separated_nonempty_list(BAR,comma_list1(single_term)) RIGHTSQ [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 342
-- On separated_nonempty_list(COMMA,single_term) shift to state 388
-- On separated_nonempty_list(BAR,comma_list1(single_term)) shift to state 389
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On comma_list1(single_term) shift to state 391
-- On attr shift to state 356
## Reductions:

State 342:
## Known stack suffix:
## single_term
## LR(1) items:
separated_nonempty_list(COMMA,single_term) -> single_term . [ RIGHTSQ RIGHTBRC EOF BAR ]
separated_nonempty_list(COMMA,single_term) -> single_term . COMMA separated_nonempty_list(COMMA,single_term) [ RIGHTSQ RIGHTBRC EOF BAR ]
single_term_ -> single_term . AT uident [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ SO RIGHTSQ RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL EOF COMMA COLON BY BARBAR BAR AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On COMMA shift to state 386
-- On COLON shift to state 132
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On RIGHTSQ RIGHTBRC EOF BAR
--   reduce production separated_nonempty_list(COMMA,single_term) -> single_term

State 343:
## Known stack suffix:
## single_term OP3
## LR(1) items:
single_term_ -> single_term OP3 . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 344
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 344:
## Known stack suffix:
## single_term OP3 single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term OP3 single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> single_term OP3 single_term

State 345:
## Known stack suffix:
## qualid
## LR(1) items:
term_arg_ -> qualid . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_arg_ -> qualid

State 346:
## Known stack suffix:
## prefix_op
## LR(1) items:
single_term_ -> prefix_op . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 347
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 347:
## Known stack suffix:
## prefix_op single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> prefix_op single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> prefix_op single_term

State 348:
## Known stack suffix:
## op_symbol
## LR(1) items:
prefix_op -> op_symbol . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production prefix_op -> op_symbol

State 349:
## Known stack suffix:
## numeral
## LR(1) items:
term_arg_ -> numeral . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_arg_ -> numeral

State 350:
## Known stack suffix:
## mk_term(term_dot_)
## LR(1) items:
term_dot -> mk_term(term_dot_) . [ DOT ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production term_dot -> mk_term(term_dot_)

State 351:
## Known stack suffix:
## mk_term(term_arg_)
## LR(1) items:
term_arg -> mk_term(term_arg_) . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_arg -> mk_term(term_arg_)

State 352:
## Known stack suffix:
## mk_term(single_term_)
## LR(1) items:
single_term -> mk_term(single_term_) . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term -> mk_term(single_term_)

State 353:
## Known stack suffix:
## lqualid
## LR(1) items:
term_dot_ -> lqualid . [ DOT ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production term_dot_ -> lqualid

State 354:
## Known stack suffix:
## lident
## LR(1) items:
ident -> lident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
lqualid -> lident . [ DOT ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production ident -> lident
-- On DOT
--   reduce production lqualid -> lident

State 355:
## Known stack suffix:
## ident
## LR(1) items:
qualid -> ident . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
--   reduce production qualid -> ident

State 356:
## Known stack suffix:
## attr
## LR(1) items:
single_term_ -> attr . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 357
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 357:
## Known stack suffix:
## attr single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> attr single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On COLON shift to state 132
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COINDUCTIVE CLONE BAR AXIOM
--   reduce production single_term_ -> attr single_term

State 358:
## Known stack suffix:
## single_term OP2
## LR(1) items:
single_term_ -> single_term OP2 . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 359
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 359:
## Known stack suffix:
## single_term OP2 single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term OP2 single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> single_term OP2 single_term

State 360:
## Known stack suffix:
## single_term OP1
## LR(1) items:
single_term_ -> single_term OP1 . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 361
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 361:
## Known stack suffix:
## single_term OP1 single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term OP1 single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR META LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP
--   reduce production single_term_ -> single_term OP1 single_term

State 362:
## Known stack suffix:
## single_term MINUS
## LR(1) items:
single_term_ -> single_term MINUS . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 363
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 363:
## Known stack suffix:
## single_term MINUS single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term MINUS single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> single_term MINUS single_term

State 364:
## Known stack suffix:
## single_term LTGT
## LR(1) items:
single_term_ -> single_term LTGT . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 365
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 365:
## Known stack suffix:
## single_term LTGT single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term LTGT single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR META LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP
--   reduce production single_term_ -> single_term LTGT single_term

State 366:
## Known stack suffix:
## single_term LT
## LR(1) items:
single_term_ -> single_term LT . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 367
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 367:
## Known stack suffix:
## single_term LT single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term LT single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR META LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP
--   reduce production single_term_ -> single_term LT single_term

State 368:
## Known stack suffix:
## single_term GT
## LR(1) items:
single_term_ -> single_term GT . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 369
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 369:
## Known stack suffix:
## single_term GT single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term GT single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR META LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP
--   reduce production single_term_ -> single_term GT single_term

State 370:
## Known stack suffix:
## single_term EQUAL
## LR(1) items:
single_term_ -> single_term EQUAL . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 371
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 371:
## Known stack suffix:
## single_term EQUAL single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term EQUAL single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR META LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP
--   reduce production single_term_ -> single_term EQUAL single_term

State 372:
## Known stack suffix:
## single_term AT
## LR(1) items:
single_term_ -> single_term AT . uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 373
## Reductions:

State 373:
## Known stack suffix:
## single_term AT uident
## LR(1) items:
single_term_ -> single_term AT uident . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> single_term AT uident

State 374:
## Known stack suffix:
## single_term LRARROW
## LR(1) items:
single_term_ -> single_term LRARROW . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 375
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 375:
## Known stack suffix:
## single_term LRARROW single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term LRARROW single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BAR AXIOM
--   reduce production single_term_ -> single_term LRARROW single_term

State 376:
## Known stack suffix:
## single_term BY
## LR(1) items:
single_term_ -> single_term BY . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 377
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 377:
## Known stack suffix:
## single_term BY single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term BY single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BAR AXIOM
--   reduce production single_term_ -> single_term BY single_term

State 378:
## Known stack suffix:
## single_term BARBAR
## LR(1) items:
single_term_ -> single_term BARBAR . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 379
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 379:
## Known stack suffix:
## single_term BARBAR single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term BARBAR single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE META LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW
--   reduce production single_term_ -> single_term BARBAR single_term

State 380:
## Known stack suffix:
## single_term AND
## LR(1) items:
single_term_ -> single_term AND . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 381
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 381:
## Known stack suffix:
## single_term AND single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term AND single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR META LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW
--   reduce production single_term_ -> single_term AND single_term

State 382:
## Known stack suffix:
## single_term AMPAMP
## LR(1) items:
single_term_ -> single_term AMPAMP . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 383
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 383:
## Known stack suffix:
## single_term AMPAMP single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term AMPAMP single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR META LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW
--   reduce production single_term_ -> single_term AMPAMP single_term

State 384:
## Known stack suffix:
## single_term ARROW
## LR(1) items:
single_term_ -> single_term ARROW . single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 385
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 385:
## Known stack suffix:
## single_term ARROW single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term ARROW single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BAR AXIOM
--   reduce production single_term_ -> single_term ARROW single_term

State 386:
## Known stack suffix:
## single_term COMMA
## LR(1) items:
separated_nonempty_list(COMMA,single_term) -> single_term COMMA . separated_nonempty_list(COMMA,single_term) [ RIGHTSQ RIGHTBRC EOF BAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 342
-- On separated_nonempty_list(COMMA,single_term) shift to state 387
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 387:
## Known stack suffix:
## single_term COMMA separated_nonempty_list(COMMA,single_term)
## LR(1) items:
separated_nonempty_list(COMMA,single_term) -> single_term COMMA separated_nonempty_list(COMMA,single_term) . [ RIGHTSQ RIGHTBRC EOF BAR ]
## Transitions:
## Reductions:
-- On RIGHTSQ RIGHTBRC EOF BAR
--   reduce production separated_nonempty_list(COMMA,single_term) -> single_term COMMA separated_nonempty_list(COMMA,single_term)

State 388:
## Known stack suffix:
## separated_nonempty_list(COMMA,single_term)
## LR(1) items:
comma_list1(single_term) -> separated_nonempty_list(COMMA,single_term) . [ RIGHTSQ EOF BAR ]
## Transitions:
## Reductions:
-- On RIGHTSQ EOF BAR
--   reduce production comma_list1(single_term) -> separated_nonempty_list(COMMA,single_term)

State 389:
## Known stack suffix:
## LEFTSQ separated_nonempty_list(BAR,comma_list1(single_term))
## LR(1) items:
triggers -> LEFTSQ separated_nonempty_list(BAR,comma_list1(single_term)) . RIGHTSQ [ DOT ]
## Transitions:
-- On RIGHTSQ shift to state 390
## Reductions:

State 390:
## Known stack suffix:
## LEFTSQ separated_nonempty_list(BAR,comma_list1(single_term)) RIGHTSQ
## LR(1) items:
triggers -> LEFTSQ separated_nonempty_list(BAR,comma_list1(single_term)) RIGHTSQ . [ DOT ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production triggers -> LEFTSQ separated_nonempty_list(BAR,comma_list1(single_term)) RIGHTSQ

State 391:
## Known stack suffix:
## comma_list1(single_term)
## LR(1) items:
separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) . [ RIGHTSQ ]
separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) . BAR separated_nonempty_list(BAR,comma_list1(single_term)) [ RIGHTSQ ]
## Transitions:
-- On BAR shift to state 392
## Reductions:
-- On RIGHTSQ
--   reduce production separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term)

State 392:
## Known stack suffix:
## comma_list1(single_term) BAR
## LR(1) items:
separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) BAR . separated_nonempty_list(BAR,comma_list1(single_term)) [ RIGHTSQ ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 342
-- On separated_nonempty_list(COMMA,single_term) shift to state 388
-- On separated_nonempty_list(BAR,comma_list1(single_term)) shift to state 393
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On comma_list1(single_term) shift to state 391
-- On attr shift to state 356
## Reductions:

State 393:
## Known stack suffix:
## comma_list1(single_term) BAR separated_nonempty_list(BAR,comma_list1(single_term))
## LR(1) items:
separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) BAR separated_nonempty_list(BAR,comma_list1(single_term)) . [ RIGHTSQ ]
## Transitions:
## Reductions:
-- On RIGHTSQ
--   reduce production separated_nonempty_list(BAR,comma_list1(single_term)) -> comma_list1(single_term) BAR separated_nonempty_list(BAR,comma_list1(single_term))

State 394:
## Known stack suffix:
## quant comma_list1(quant_vars) triggers
## LR(1) items:
single_term_ -> quant comma_list1(quant_vars) triggers . DOT term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On DOT shift to state 395
## Reductions:

State 395:
## Known stack suffix:
## quant comma_list1(quant_vars) triggers DOT
## LR(1) items:
single_term_ -> quant comma_list1(quant_vars) triggers DOT . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 396
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 396:
## Known stack suffix:
## quant comma_list1(quant_vars) triggers DOT term
## LR(1) items:
single_term_ -> quant comma_list1(quant_vars) triggers DOT term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> quant comma_list1(quant_vars) triggers DOT term

State 397:
## Known stack suffix:
## single_term COMMA
## LR(1) items:
term -> single_term COMMA . term_ [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term_ shift to state 398
-- On single_term_ shift to state 321
-- On single_term shift to state 399
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 398:
## Known stack suffix:
## single_term COMMA term_
## LR(1) items:
term -> single_term COMMA term_ . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term -> single_term COMMA term_

State 399:
## Known stack suffix:
## single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_ -> single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_ -> single_term . COMMA term_ [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On COMMA shift to state 400
-- On COLON shift to state 132
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COINDUCTIVE CLONE BAR AXIOM
--   reduce production term_ -> single_term

State 400:
## Known stack suffix:
## single_term COMMA
## LR(1) items:
term_ -> single_term COMMA . term_ [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term_ shift to state 401
-- On single_term_ shift to state 321
-- On single_term shift to state 399
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 401:
## Known stack suffix:
## single_term COMMA term_
## LR(1) items:
term_ -> single_term COMMA term_ . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_ -> single_term COMMA term_

State 402:
## Known stack suffix:
## term_arg LEFTSQ term
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term . rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ term . LARROW term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ term . DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ term . DOTDOT rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On LARROW shift to state 403
-- On DOTDOT shift to state 406
-- On rightsq shift to state 410
## Reductions:

State 403:
## Known stack suffix:
## term_arg LEFTSQ term LARROW
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term LARROW . term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 404
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 404:
## Known stack suffix:
## term_arg LEFTSQ term LARROW term
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term LARROW term . rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 405
## Reductions:

State 405:
## Known stack suffix:
## term_arg LEFTSQ term LARROW term rightsq
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term LARROW term rightsq . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_sub_ -> term_arg LEFTSQ term LARROW term rightsq

State 406:
## Known stack suffix:
## term_arg LEFTSQ term DOTDOT
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term DOTDOT . term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg LEFTSQ term DOTDOT . rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 407
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On rightsq shift to state 409
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 407:
## Known stack suffix:
## term_arg LEFTSQ term DOTDOT term
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term DOTDOT term . rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 408
## Reductions:

State 408:
## Known stack suffix:
## term_arg LEFTSQ term DOTDOT term rightsq
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT term rightsq

State 409:
## Known stack suffix:
## term_arg LEFTSQ term DOTDOT rightsq
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_sub_ -> term_arg LEFTSQ term DOTDOT rightsq

State 410:
## Known stack suffix:
## term_arg LEFTSQ term rightsq
## LR(1) items:
term_sub_ -> term_arg LEFTSQ term rightsq . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_sub_ -> term_arg LEFTSQ term rightsq

State 411:
## Known stack suffix:
## term_arg_
## LR(1) items:
mk_term(term_arg_) -> term_arg_ . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production mk_term(term_arg_) -> term_arg_

State 412:
## Known stack suffix:
## term_arg
## LR(1) items:
located(term_arg) -> term_arg . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term LARROW term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On LEFTSQ shift to state 317
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production located(term_arg) -> term_arg

State 413:
## Known stack suffix:
## term_arg nonempty_list(located(term_arg))
## LR(1) items:
single_term_ -> term_arg nonempty_list(located(term_arg)) . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> term_arg nonempty_list(located(term_arg))

State 414:
## Known stack suffix:
## located(term_arg)
## LR(1) items:
nonempty_list(located(term_arg)) -> located(term_arg) . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
nonempty_list(located(term_arg)) -> located(term_arg) . nonempty_list(located(term_arg)) [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On OPPREF shift to state 201
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 411
-- On term_arg shift to state 412
-- On qualid shift to state 345
-- On numeral shift to state 349
-- On nonempty_list(located(term_arg)) shift to state 415
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On lqualid shift to state 353
-- On located(term_arg) shift to state 414
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production nonempty_list(located(term_arg)) -> located(term_arg)

State 415:
## Known stack suffix:
## located(term_arg) nonempty_list(located(term_arg))
## LR(1) items:
nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg)) . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production nonempty_list(located(term_arg)) -> located(term_arg) nonempty_list(located(term_arg))

State 416:
## Known stack suffix:
## FUN binders ARROW term
## LR(1) items:
single_term_ -> FUN binders ARROW term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> FUN binders ARROW term

State 417:
## Known stack suffix:
## binder
## LR(1) items:
nonempty_list(binder) -> binder . [ WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS ]
nonempty_list(binder) -> binder . nonempty_list(binder) [ WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 418
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:
-- On WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS
--   reduce production nonempty_list(binder) -> binder

State 418:
## Known stack suffix:
## binder nonempty_list(binder)
## LR(1) items:
nonempty_list(binder) -> binder nonempty_list(binder) . [ WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS
--   reduce production nonempty_list(binder) -> binder nonempty_list(binder)

State 419:
## Known stack suffix:
## lident_keyword
## LR(1) items:
lident -> lident_keyword . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS ]
lident_nq -> lident_keyword . [ POSITION ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS
--   reduce production lident -> lident_keyword
-- On POSITION ATTRIBUTE
--   reduce production lident_nq -> lident_keyword

State 420:
## Known stack suffix:
## anon_binder
## LR(1) items:
binder -> anon_binder . [ WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS ]
## Transitions:
## Reductions:
-- On WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS
--   reduce production binder -> anon_binder

State 421:
## Known stack suffix:
## IF term
## LR(1) items:
single_term_ -> IF term . THEN term ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On THEN shift to state 422
## Reductions:

State 422:
## Known stack suffix:
## IF term THEN
## LR(1) items:
single_term_ -> IF term THEN . term ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 423
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 423:
## Known stack suffix:
## IF term THEN term
## LR(1) items:
single_term_ -> IF term THEN term . ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On ELSE shift to state 424
## Reductions:

State 424:
## Known stack suffix:
## IF term THEN term ELSE
## LR(1) items:
single_term_ -> IF term THEN term ELSE . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 425
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 425:
## Known stack suffix:
## IF term THEN term ELSE term
## LR(1) items:
single_term_ -> IF term THEN term ELSE term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> IF term THEN term ELSE term

State 426:
## Known stack suffix:
## LET pattern EQUAL term
## LR(1) items:
single_term_ -> LET pattern EQUAL term . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On IN shift to state 427
## Reductions:

State 427:
## Known stack suffix:
## LET pattern EQUAL term IN
## LR(1) items:
single_term_ -> LET pattern EQUAL term IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 428
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 428:
## Known stack suffix:
## LET pattern EQUAL term IN term
## LR(1) items:
single_term_ -> LET pattern EQUAL term IN term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> LET pattern EQUAL term IN term

State 429:
## Known stack suffix:
## lident_op_nq
## LR(1) items:
attrs(lident_op_nq) -> lident_op_nq . list(attr) [ UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 430
-- On attr shift to state 71
## Reductions:
-- On UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT
--   reduce production list(attr) ->

State 430:
## Known stack suffix:
## lident_op_nq list(attr)
## LR(1) items:
attrs(lident_op_nq) -> lident_op_nq list(attr) . [ UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT
--   reduce production attrs(lident_op_nq) -> lident_op_nq list(attr)

State 431:
## Known stack suffix:
## LET attrs(lident_op_nq)
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) . EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> LET attrs(lident_op_nq) . mk_term(lam_defn) IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On EQUAL shift to state 432
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On mk_term(lam_defn) shift to state 436
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On lam_defn shift to state 439
-- On binders shift to state 440
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:

State 432:
## Known stack suffix:
## LET attrs(lident_op_nq) EQUAL
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) EQUAL . term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 433
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 433:
## Known stack suffix:
## LET attrs(lident_op_nq) EQUAL term
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) EQUAL term . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On IN shift to state 434
## Reductions:

State 434:
## Known stack suffix:
## LET attrs(lident_op_nq) EQUAL term IN
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) EQUAL term IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 435
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 435:
## Known stack suffix:
## LET attrs(lident_op_nq) EQUAL term IN term
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> LET attrs(lident_op_nq) EQUAL term IN term

State 436:
## Known stack suffix:
## LET attrs(lident_op_nq) mk_term(lam_defn)
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On IN shift to state 437
## Reductions:

State 437:
## Known stack suffix:
## LET attrs(lident_op_nq) mk_term(lam_defn) IN
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 438
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 438:
## Known stack suffix:
## LET attrs(lident_op_nq) mk_term(lam_defn) IN term
## LR(1) items:
single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> LET attrs(lident_op_nq) mk_term(lam_defn) IN term

State 439:
## Known stack suffix:
## lam_defn
## LR(1) items:
mk_term(lam_defn) -> lam_defn . [ IN ]
## Transitions:
## Reductions:
-- On IN
--   reduce production mk_term(lam_defn) -> lam_defn

State 440:
## Known stack suffix:
## binders
## LR(1) items:
lam_defn -> binders . EQUAL term [ IN ]
## Transitions:
-- On EQUAL shift to state 441
## Reductions:

State 441:
## Known stack suffix:
## binders EQUAL
## LR(1) items:
lam_defn -> binders EQUAL . term [ IN ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 442
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 442:
## Known stack suffix:
## binders EQUAL term
## LR(1) items:
lam_defn -> binders EQUAL term . [ IN ]
## Transitions:
## Reductions:
-- On IN
--   reduce production lam_defn -> binders EQUAL term

State 443:
## Known stack suffix:
## LET attrs(lident_nq)
## LR(1) items:
pat_arg_ -> attrs(lident_nq) . [ EQUAL COMMA COLON BAR AS ]
single_term_ -> LET attrs(lident_nq) . mk_term(lam_defn) IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On mk_term(lam_defn) shift to state 444
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On lam_defn shift to state 439
-- On binders shift to state 440
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:
-- On EQUAL COMMA COLON BAR AS
--   reduce production pat_arg_ -> attrs(lident_nq)

State 444:
## Known stack suffix:
## LET attrs(lident_nq) mk_term(lam_defn)
## LR(1) items:
single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On IN shift to state 445
## Reductions:

State 445:
## Known stack suffix:
## LET attrs(lident_nq) mk_term(lam_defn) IN
## LR(1) items:
single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 446
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 446:
## Known stack suffix:
## LET attrs(lident_nq) mk_term(lam_defn) IN term
## LR(1) items:
single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> LET attrs(lident_nq) mk_term(lam_defn) IN term

State 447:
## Known stack suffix:
## MATCH term
## LR(1) items:
single_term_ -> MATCH term . WITH match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On WITH shift to state 448
## Reductions:

State 448:
## Known stack suffix:
## MATCH term WITH
## LR(1) items:
single_term_ -> MATCH term WITH . match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On BAR shift to state 449
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,match_case(term)) shift to state 457
-- On pattern_ shift to state 243
-- On pattern shift to state 451
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_cases(term) shift to state 458
-- On match_case(term) shift to state 454
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On bar_list1(match_case(term)) shift to state 460
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 449:
## Known stack suffix:
## BAR
## LR(1) items:
bar_list1(match_case(term)) -> BAR . separated_nonempty_list(BAR,match_case(term)) [ RIGHTBRC END ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,match_case(term)) shift to state 450
-- On pattern_ shift to state 243
-- On pattern shift to state 451
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_case(term) shift to state 454
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 450:
## Known stack suffix:
## BAR separated_nonempty_list(BAR,match_case(term))
## LR(1) items:
bar_list1(match_case(term)) -> BAR separated_nonempty_list(BAR,match_case(term)) . [ RIGHTBRC END ]
## Transitions:
## Reductions:
-- On RIGHTBRC END
--   reduce production bar_list1(match_case(term)) -> BAR separated_nonempty_list(BAR,match_case(term))

State 451:
## Known stack suffix:
## pattern
## LR(1) items:
match_case(term) -> pattern . ARROW term [ RIGHTBRC END BAR ]
## Transitions:
-- On ARROW shift to state 452
## Reductions:

State 452:
## Known stack suffix:
## pattern ARROW
## LR(1) items:
match_case(term) -> pattern ARROW . term [ RIGHTBRC END BAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 453
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 453:
## Known stack suffix:
## pattern ARROW term
## LR(1) items:
match_case(term) -> pattern ARROW term . [ RIGHTBRC END BAR ]
## Transitions:
## Reductions:
-- On RIGHTBRC END BAR
--   reduce production match_case(term) -> pattern ARROW term

State 454:
## Known stack suffix:
## match_case(term)
## LR(1) items:
separated_nonempty_list(BAR,match_case(term)) -> match_case(term) . [ RIGHTBRC END ]
separated_nonempty_list(BAR,match_case(term)) -> match_case(term) . BAR separated_nonempty_list(BAR,match_case(term)) [ RIGHTBRC END ]
## Transitions:
-- On BAR shift to state 455
## Reductions:
-- On RIGHTBRC END
--   reduce production separated_nonempty_list(BAR,match_case(term)) -> match_case(term)

State 455:
## Known stack suffix:
## match_case(term) BAR
## LR(1) items:
separated_nonempty_list(BAR,match_case(term)) -> match_case(term) BAR . separated_nonempty_list(BAR,match_case(term)) [ RIGHTBRC END ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,match_case(term)) shift to state 456
-- On pattern_ shift to state 243
-- On pattern shift to state 451
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_case(term) shift to state 454
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 456:
## Known stack suffix:
## match_case(term) BAR separated_nonempty_list(BAR,match_case(term))
## LR(1) items:
separated_nonempty_list(BAR,match_case(term)) -> match_case(term) BAR separated_nonempty_list(BAR,match_case(term)) . [ RIGHTBRC END ]
## Transitions:
## Reductions:
-- On RIGHTBRC END
--   reduce production separated_nonempty_list(BAR,match_case(term)) -> match_case(term) BAR separated_nonempty_list(BAR,match_case(term))

State 457:
## Known stack suffix:
## separated_nonempty_list(BAR,match_case(term))
## LR(1) items:
bar_list1(match_case(term)) -> separated_nonempty_list(BAR,match_case(term)) . [ RIGHTBRC END ]
## Transitions:
## Reductions:
-- On RIGHTBRC END
--   reduce production bar_list1(match_case(term)) -> separated_nonempty_list(BAR,match_case(term))

State 458:
## Known stack suffix:
## MATCH term WITH match_cases(term)
## LR(1) items:
single_term_ -> MATCH term WITH match_cases(term) . END [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On END shift to state 459
## Reductions:

State 459:
## Known stack suffix:
## MATCH term WITH match_cases(term) END
## LR(1) items:
single_term_ -> MATCH term WITH match_cases(term) END . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production single_term_ -> MATCH term WITH match_cases(term) END

State 460:
## Known stack suffix:
## bar_list1(match_case(term))
## LR(1) items:
match_cases(term) -> bar_list1(match_case(term)) . [ RIGHTBRC END ]
## Transitions:
## Reductions:
-- On RIGHTBRC END
--   reduce production match_cases(term) -> bar_list1(match_case(term))

State 461:
## Known stack suffix:
## NOT single_term
## LR(1) items:
single_term_ -> NOT single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On AT shift to state 372
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR META LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP
--   reduce production single_term_ -> NOT single_term

State 462:
## Known stack suffix:
## OLD single_term
## LR(1) items:
single_term_ -> OLD single_term . [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AT uident [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On MINUS shift to state 362
-- On cast shift to state 329
## Reductions:
-- On WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP1 META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP
--   reduce production single_term_ -> OLD single_term

State 463:
## Known stack suffix:
## BEGIN END
## LR(1) items:
term_block_ -> BEGIN END . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_block_ -> BEGIN END

State 464:
## Known stack suffix:
## BEGIN term
## LR(1) items:
term_block_ -> BEGIN term . END [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On END shift to state 465
## Reductions:

State 465:
## Known stack suffix:
## BEGIN term END
## LR(1) items:
term_block_ -> BEGIN term END . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_block_ -> BEGIN term END

State 466:
## Known stack suffix:
## uqualid
## LR(1) items:
lqualid -> uqualid . DOT lident [ EQUAL DOT ]
qualid -> uqualid . DOT ident [ WITH LEFTSQ ]
term_sub_ -> uqualid . DOT mk_term(term_block_) [ WITH LEFTSQ DOT ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 467
## Reductions:

State 467:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
lqualid -> uqualid DOT . lident [ EQUAL DOT ]
qualid -> uqualid DOT . ident [ WITH LEFTSQ ]
term_sub_ -> uqualid DOT . mk_term(term_block_) [ WITH LEFTSQ DOT ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On uident shift to state 297
-- On term_block_ shift to state 298
-- On mk_term(term_block_) shift to state 299
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 468
-- On ident shift to state 301
## Reductions:

State 468:
## Known stack suffix:
## uqualid DOT lident
## LR(1) items:
ident -> lident . [ WITH RIGHTBRC LEFTSQ ]
lqualid -> uqualid DOT lident . [ EQUAL DOT ]
## Transitions:
## Reductions:
-- On WITH RIGHTBRC LEFTSQ
--   reduce production ident -> lident
-- On EQUAL DOT
--   reduce production lqualid -> uqualid DOT lident

State 469:
## Known stack suffix:
## LEFTBRC term_arg
## LR(1) items:
term_block_ -> LEFTBRC term_arg . WITH field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term rightsq [ WITH LEFTSQ DOT ]
term_sub_ -> term_arg . LEFTSQ term LARROW term rightsq [ WITH LEFTSQ DOT ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT term rightsq [ WITH LEFTSQ DOT ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT rightsq [ WITH LEFTSQ DOT ]
term_sub_ -> term_arg . LEFTSQ DOTDOT term rightsq [ WITH LEFTSQ DOT ]
## Transitions:
-- On WITH shift to state 470
-- On LEFTSQ shift to state 317
## Reductions:

State 470:
## Known stack suffix:
## LEFTBRC term_arg WITH
## LR(1) items:
term_block_ -> LEFTBRC term_arg WITH . field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,term)) shift to state 471
-- On lqualid shift to state 472
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On field_list1(term) shift to state 477
## Reductions:

State 471:
## Known stack suffix:
## semicolon_list1(separated_pair(lqualid,EQUAL,term))
## LR(1) items:
field_list1(term) -> semicolon_list1(separated_pair(lqualid,EQUAL,term)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production field_list1(term) -> semicolon_list1(separated_pair(lqualid,EQUAL,term))

State 472:
## Known stack suffix:
## lqualid
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
## Transitions:
-- On EQUAL shift to state 473
## Reductions:

State 473:
## Known stack suffix:
## lqualid EQUAL
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL . term [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL . term SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL . term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 474
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 474:
## Known stack suffix:
## lqualid EQUAL term
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term . [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term . SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term . SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
## Transitions:
-- On SEMICOLON shift to state 475
## Reductions:
-- On RIGHTBRC
--   reduce production semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term

State 475:
## Known stack suffix:
## lqualid EQUAL term SEMICOLON
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON . [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON . semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,term)) shift to state 476
-- On lqualid shift to state 472
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:
-- On RIGHTBRC
--   reduce production semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON

State 476:
## Known stack suffix:
## lqualid EQUAL term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term))
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term))

State 477:
## Known stack suffix:
## LEFTBRC term_arg WITH field_list1(term)
## LR(1) items:
term_block_ -> LEFTBRC term_arg WITH field_list1(term) . RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTBRC shift to state 478
## Reductions:

State 478:
## Known stack suffix:
## LEFTBRC term_arg WITH field_list1(term) RIGHTBRC
## LR(1) items:
term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_block_ -> LEFTBRC term_arg WITH field_list1(term) RIGHTBRC

State 479:
## Known stack suffix:
## lqualid
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
term_dot_ -> lqualid . [ DOT ]
## Transitions:
-- On EQUAL shift to state 473
## Reductions:
-- On DOT
--   reduce production term_dot_ -> lqualid

State 480:
## Known stack suffix:
## lident
## LR(1) items:
ident -> lident . [ WITH RIGHTBRC LEFTSQ ]
lqualid -> lident . [ EQUAL DOT ]
## Transitions:
## Reductions:
-- On WITH RIGHTBRC LEFTSQ
--   reduce production ident -> lident
-- On EQUAL DOT
--   reduce production lqualid -> lident

State 481:
## Known stack suffix:
## LEFTBRC field_list1(term)
## LR(1) items:
term_block_ -> LEFTBRC field_list1(term) . RIGHTBRC [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTBRC shift to state 482
## Reductions:

State 482:
## Known stack suffix:
## LEFTBRC field_list1(term) RIGHTBRC
## LR(1) items:
term_block_ -> LEFTBRC field_list1(term) RIGHTBRC . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_block_ -> LEFTBRC field_list1(term) RIGHTBRC

State 483:
## Known stack suffix:
## OPPREF term_dot
## LR(1) items:
term_dot_ -> OPPREF term_dot . [ DOT ]
term_sub_ -> term_dot . DOT lqualid_rich [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production term_dot_ -> OPPREF term_dot

State 484:
## Known stack suffix:
## OPPREF term_arg
## LR(1) items:
term_arg_ -> OPPREF term_arg . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term LARROW term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ term DOTDOT rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
term_sub_ -> term_arg . LEFTSQ DOTDOT term rightsq [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_arg_ -> OPPREF term_arg

State 485:
## Known stack suffix:
## MINUS
## LR(1) items:
lident_op_str -> MINUS . UNDERSCORE [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> MINUS . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
prefix_op -> MINUS . [ UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE ]
single_term_ -> MINUS . INTEGER [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> MINUS . REAL [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
## Transitions:
-- On UNDERSCORE shift to state 13
-- On REAL shift to state 212
-- On INTEGER shift to state 213
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> MINUS
-- On UIDENT TRUE RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
--   reduce production prefix_op -> MINUS

State 486:
## Known stack suffix:
## LEFTPAR term
## LR(1) items:
term_block_ -> LEFTPAR term . RIGHTPAR [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
-- On RIGHTPAR shift to state 487
## Reductions:

State 487:
## Known stack suffix:
## LEFTPAR term RIGHTPAR
## LR(1) items:
term_block_ -> LEFTPAR term RIGHTPAR . [ WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ]
## Transitions:
## Reductions:
-- On WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
--   reduce production term_block_ -> LEFTPAR term RIGHTPAR

State 488:
## Known stack suffix:
## op_symbol
## LR(1) items:
lident_op_str -> op_symbol . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> op_symbol . UNDERSCORE [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
prefix_op -> op_symbol . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On UNDERSCORE shift to state 32
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> op_symbol
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production prefix_op -> op_symbol

State 489:
## Known stack suffix:
## separated_nonempty_list(COMMA,single_term)
## LR(1) items:
loption(separated_nonempty_list(COMMA,single_term)) -> separated_nonempty_list(COMMA,single_term) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production loption(separated_nonempty_list(COMMA,single_term)) -> separated_nonempty_list(COMMA,single_term)

State 490:
## Known stack suffix:
## loption(separated_nonempty_list(COMMA,single_term))
## LR(1) items:
comma_list0(single_term) -> loption(separated_nonempty_list(COMMA,single_term)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production comma_list0(single_term) -> loption(separated_nonempty_list(COMMA,single_term))

State 491:
## Known stack suffix:
## WRITES LEFTBRC comma_list0(single_term)
## LR(1) items:
single_spec -> WRITES LEFTBRC comma_list0(single_term) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 492
## Reductions:

State 492:
## Known stack suffix:
## WRITES LEFTBRC comma_list0(single_term) RIGHTBRC
## LR(1) items:
single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
--   reduce production single_spec -> WRITES LEFTBRC comma_list0(single_term) RIGHTBRC

State 493:
## Known stack suffix:
## VARIANT
## LR(1) items:
variant -> VARIANT . LEFTBRC comma_list1(single_variant) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 494
## Reductions:

State 494:
## Known stack suffix:
## VARIANT LEFTBRC
## LR(1) items:
variant -> VARIANT LEFTBRC . comma_list1(single_variant) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_variant shift to state 495
-- On single_term_ shift to state 321
-- On single_term shift to state 497
-- On separated_nonempty_list(COMMA,single_variant) shift to state 502
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On comma_list1(single_variant) shift to state 503
-- On attr shift to state 356
## Reductions:

State 495:
## Known stack suffix:
## single_variant
## LR(1) items:
separated_nonempty_list(COMMA,single_variant) -> single_variant . [ RIGHTBRC ]
separated_nonempty_list(COMMA,single_variant) -> single_variant . COMMA separated_nonempty_list(COMMA,single_variant) [ RIGHTBRC ]
## Transitions:
-- On COMMA shift to state 496
## Reductions:
-- On RIGHTBRC
--   reduce production separated_nonempty_list(COMMA,single_variant) -> single_variant

State 496:
## Known stack suffix:
## single_variant COMMA
## LR(1) items:
separated_nonempty_list(COMMA,single_variant) -> single_variant COMMA . separated_nonempty_list(COMMA,single_variant) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_variant shift to state 495
-- On single_term_ shift to state 321
-- On single_term shift to state 497
-- On separated_nonempty_list(COMMA,single_variant) shift to state 501
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 497:
## Known stack suffix:
## single_term
## LR(1) items:
single_term_ -> single_term . AT uident [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . ARROW single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . LRARROW single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OR single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . BARBAR single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . AND single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . AMPAMP single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . BY single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . SO single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP1 single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . EQUAL single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . LTGT single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . LT single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . GT single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP2 single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP3 single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . OP4 single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . MINUS single_term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_term_ -> single_term . cast [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 MINUS LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR AT ARROW AND AMPAMP ]
single_variant -> single_term . option(preceded(WITH,lqualid)) [ RIGHTBRC COMMA ]
## Transitions:
-- On WITH shift to state 498
-- On SO shift to state 323
-- On OR shift to state 325
-- On OP4 shift to state 327
-- On OP3 shift to state 343
-- On OP2 shift to state 358
-- On OP1 shift to state 360
-- On MINUS shift to state 362
-- On LTGT shift to state 364
-- On LT shift to state 366
-- On LRARROW shift to state 374
-- On GT shift to state 368
-- On EQUAL shift to state 370
-- On COLON shift to state 132
-- On BY shift to state 376
-- On BARBAR shift to state 378
-- On AT shift to state 372
-- On ARROW shift to state 384
-- On AND shift to state 380
-- On AMPAMP shift to state 382
-- On option(preceded(WITH,lqualid)) shift to state 500
-- On cast shift to state 329
## Reductions:
-- On RIGHTBRC COMMA
--   reduce production option(preceded(WITH,lqualid)) ->

State 498:
## Known stack suffix:
## WITH
## LR(1) items:
option(preceded(WITH,lqualid)) -> WITH . lqualid [ RIGHTBRC COMMA ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On lqualid shift to state 499
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 499:
## Known stack suffix:
## WITH lqualid
## LR(1) items:
option(preceded(WITH,lqualid)) -> WITH lqualid . [ RIGHTBRC COMMA ]
## Transitions:
## Reductions:
-- On RIGHTBRC COMMA
--   reduce production option(preceded(WITH,lqualid)) -> WITH lqualid

State 500:
## Known stack suffix:
## single_term option(preceded(WITH,lqualid))
## LR(1) items:
single_variant -> single_term option(preceded(WITH,lqualid)) . [ RIGHTBRC COMMA ]
## Transitions:
## Reductions:
-- On RIGHTBRC COMMA
--   reduce production single_variant -> single_term option(preceded(WITH,lqualid))

State 501:
## Known stack suffix:
## single_variant COMMA separated_nonempty_list(COMMA,single_variant)
## LR(1) items:
separated_nonempty_list(COMMA,single_variant) -> single_variant COMMA separated_nonempty_list(COMMA,single_variant) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production separated_nonempty_list(COMMA,single_variant) -> single_variant COMMA separated_nonempty_list(COMMA,single_variant)

State 502:
## Known stack suffix:
## separated_nonempty_list(COMMA,single_variant)
## LR(1) items:
comma_list1(single_variant) -> separated_nonempty_list(COMMA,single_variant) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production comma_list1(single_variant) -> separated_nonempty_list(COMMA,single_variant)

State 503:
## Known stack suffix:
## VARIANT LEFTBRC comma_list1(single_variant)
## LR(1) items:
variant -> VARIANT LEFTBRC comma_list1(single_variant) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 504
## Reductions:

State 504:
## Known stack suffix:
## VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC
## LR(1) items:
variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
--   reduce production variant -> VARIANT LEFTBRC comma_list1(single_variant) RIGHTBRC

State 505:
## Known stack suffix:
## RETURNS
## LR(1) items:
single_spec -> RETURNS . LEFTBRC match_cases(term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 506
## Reductions:

State 506:
## Known stack suffix:
## RETURNS LEFTBRC
## LR(1) items:
single_spec -> RETURNS LEFTBRC . match_cases(term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On BAR shift to state 449
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,match_case(term)) shift to state 457
-- On pattern_ shift to state 243
-- On pattern shift to state 451
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_cases(term) shift to state 507
-- On match_case(term) shift to state 454
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On bar_list1(match_case(term)) shift to state 460
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 507:
## Known stack suffix:
## RETURNS LEFTBRC match_cases(term)
## LR(1) items:
single_spec -> RETURNS LEFTBRC match_cases(term) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 508
## Reductions:

State 508:
## Known stack suffix:
## RETURNS LEFTBRC match_cases(term) RIGHTBRC
## LR(1) items:
single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
--   reduce production single_spec -> RETURNS LEFTBRC match_cases(term) RIGHTBRC

State 509:
## Known stack suffix:
## REQUIRES
## LR(1) items:
single_spec -> REQUIRES . LEFTBRC term RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 510
## Reductions:

State 510:
## Known stack suffix:
## REQUIRES LEFTBRC
## LR(1) items:
single_spec -> REQUIRES LEFTBRC . term RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 511
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 511:
## Known stack suffix:
## REQUIRES LEFTBRC term
## LR(1) items:
single_spec -> REQUIRES LEFTBRC term . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 512
## Reductions:

State 512:
## Known stack suffix:
## REQUIRES LEFTBRC term RIGHTBRC
## LR(1) items:
single_spec -> REQUIRES LEFTBRC term RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
--   reduce production single_spec -> REQUIRES LEFTBRC term RIGHTBRC

State 513:
## Known stack suffix:
## READS
## LR(1) items:
single_spec -> READS . LEFTBRC comma_list0(lqualid) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 514
## Reductions:

State 514:
## Known stack suffix:
## READS LEFTBRC
## LR(1) items:
single_spec -> READS LEFTBRC . comma_list0(lqualid) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,lqualid) shift to state 515
-- On lqualid shift to state 516
-- On loption(separated_nonempty_list(COMMA,lqualid)) shift to state 519
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list0(lqualid) shift to state 520
## Reductions:
-- On RIGHTBRC
--   reduce production loption(separated_nonempty_list(COMMA,lqualid)) ->

State 515:
## Known stack suffix:
## separated_nonempty_list(COMMA,lqualid)
## LR(1) items:
loption(separated_nonempty_list(COMMA,lqualid)) -> separated_nonempty_list(COMMA,lqualid) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production loption(separated_nonempty_list(COMMA,lqualid)) -> separated_nonempty_list(COMMA,lqualid)

State 516:
## Known stack suffix:
## lqualid
## LR(1) items:
separated_nonempty_list(COMMA,lqualid) -> lqualid . [ RIGHTBRC ]
separated_nonempty_list(COMMA,lqualid) -> lqualid . COMMA separated_nonempty_list(COMMA,lqualid) [ RIGHTBRC ]
## Transitions:
-- On COMMA shift to state 517
## Reductions:
-- On RIGHTBRC
--   reduce production separated_nonempty_list(COMMA,lqualid) -> lqualid

State 517:
## Known stack suffix:
## lqualid COMMA
## LR(1) items:
separated_nonempty_list(COMMA,lqualid) -> lqualid COMMA . separated_nonempty_list(COMMA,lqualid) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,lqualid) shift to state 518
-- On lqualid shift to state 516
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 518:
## Known stack suffix:
## lqualid COMMA separated_nonempty_list(COMMA,lqualid)
## LR(1) items:
separated_nonempty_list(COMMA,lqualid) -> lqualid COMMA separated_nonempty_list(COMMA,lqualid) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production separated_nonempty_list(COMMA,lqualid) -> lqualid COMMA separated_nonempty_list(COMMA,lqualid)

State 519:
## Known stack suffix:
## loption(separated_nonempty_list(COMMA,lqualid))
## LR(1) items:
comma_list0(lqualid) -> loption(separated_nonempty_list(COMMA,lqualid)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production comma_list0(lqualid) -> loption(separated_nonempty_list(COMMA,lqualid))

State 520:
## Known stack suffix:
## READS LEFTBRC comma_list0(lqualid)
## LR(1) items:
single_spec -> READS LEFTBRC comma_list0(lqualid) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 521
## Reductions:

State 521:
## Known stack suffix:
## READS LEFTBRC comma_list0(lqualid) RIGHTBRC
## LR(1) items:
single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
--   reduce production single_spec -> READS LEFTBRC comma_list0(lqualid) RIGHTBRC

State 522:
## Known stack suffix:
## RAISES
## LR(1) items:
single_spec -> RAISES . LEFTBRC bar_list1(raises) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
single_spec -> RAISES . LEFTBRC comma_list1(xsymbol) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 523
## Reductions:

State 523:
## Known stack suffix:
## RAISES LEFTBRC
## LR(1) items:
single_spec -> RAISES LEFTBRC . bar_list1(raises) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
single_spec -> RAISES LEFTBRC . comma_list1(xsymbol) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On BAR shift to state 524
-- On xsymbol shift to state 536
-- On uqualid shift to state 540
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,xsymbol) shift to state 541
-- On separated_nonempty_list(BAR,raises) shift to state 542
-- On raises shift to state 533
-- On comma_list1(xsymbol) shift to state 543
-- On bar_list1(raises) shift to state 545
## Reductions:

State 524:
## Known stack suffix:
## BAR
## LR(1) items:
bar_list1(raises) -> BAR . separated_nonempty_list(BAR,raises) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 525
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,raises) shift to state 532
-- On raises shift to state 533
## Reductions:

State 525:
## Known stack suffix:
## uqualid
## LR(1) items:
raises -> uqualid . ARROW term [ RIGHTBRC BAR ]
raises -> uqualid . pat_arg ARROW term [ RIGHTBRC BAR ]
uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT DOT CORE_UIDENT CORE_LIDENT ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On DOT shift to state 526
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On ARROW shift to state 527
-- On uqualid shift to state 231
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 233
-- On pat_arg shift to state 529
-- On mk_pat(pat_arg_) shift to state 236
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 526:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
uqualid -> uqualid DOT . uident [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM ARROW AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 86
## Reductions:

State 527:
## Known stack suffix:
## uqualid ARROW
## LR(1) items:
raises -> uqualid ARROW . term [ RIGHTBRC BAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 528
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 528:
## Known stack suffix:
## uqualid ARROW term
## LR(1) items:
raises -> uqualid ARROW term . [ RIGHTBRC BAR ]
## Transitions:
## Reductions:
-- On RIGHTBRC BAR
--   reduce production raises -> uqualid ARROW term

State 529:
## Known stack suffix:
## uqualid pat_arg
## LR(1) items:
raises -> uqualid pat_arg . ARROW term [ RIGHTBRC BAR ]
## Transitions:
-- On ARROW shift to state 530
## Reductions:

State 530:
## Known stack suffix:
## uqualid pat_arg ARROW
## LR(1) items:
raises -> uqualid pat_arg ARROW . term [ RIGHTBRC BAR ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 531
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 531:
## Known stack suffix:
## uqualid pat_arg ARROW term
## LR(1) items:
raises -> uqualid pat_arg ARROW term . [ RIGHTBRC BAR ]
## Transitions:
## Reductions:
-- On RIGHTBRC BAR
--   reduce production raises -> uqualid pat_arg ARROW term

State 532:
## Known stack suffix:
## BAR separated_nonempty_list(BAR,raises)
## LR(1) items:
bar_list1(raises) -> BAR separated_nonempty_list(BAR,raises) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production bar_list1(raises) -> BAR separated_nonempty_list(BAR,raises)

State 533:
## Known stack suffix:
## raises
## LR(1) items:
separated_nonempty_list(BAR,raises) -> raises . [ RIGHTBRC ]
separated_nonempty_list(BAR,raises) -> raises . BAR separated_nonempty_list(BAR,raises) [ RIGHTBRC ]
## Transitions:
-- On BAR shift to state 534
## Reductions:
-- On RIGHTBRC
--   reduce production separated_nonempty_list(BAR,raises) -> raises

State 534:
## Known stack suffix:
## raises BAR
## LR(1) items:
separated_nonempty_list(BAR,raises) -> raises BAR . separated_nonempty_list(BAR,raises) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 525
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,raises) shift to state 535
-- On raises shift to state 533
## Reductions:

State 535:
## Known stack suffix:
## raises BAR separated_nonempty_list(BAR,raises)
## LR(1) items:
separated_nonempty_list(BAR,raises) -> raises BAR separated_nonempty_list(BAR,raises) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production separated_nonempty_list(BAR,raises) -> raises BAR separated_nonempty_list(BAR,raises)

State 536:
## Known stack suffix:
## xsymbol
## LR(1) items:
separated_nonempty_list(COMMA,xsymbol) -> xsymbol . [ RIGHTBRC ]
separated_nonempty_list(COMMA,xsymbol) -> xsymbol . COMMA separated_nonempty_list(COMMA,xsymbol) [ RIGHTBRC ]
## Transitions:
-- On COMMA shift to state 537
## Reductions:
-- On RIGHTBRC
--   reduce production separated_nonempty_list(COMMA,xsymbol) -> xsymbol

State 537:
## Known stack suffix:
## xsymbol COMMA
## LR(1) items:
separated_nonempty_list(COMMA,xsymbol) -> xsymbol COMMA . separated_nonempty_list(COMMA,xsymbol) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On xsymbol shift to state 536
-- On uqualid shift to state 538
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,xsymbol) shift to state 539
## Reductions:

State 538:
## Known stack suffix:
## uqualid
## LR(1) items:
uqualid -> uqualid . DOT uident [ RIGHTBRC DOT COMMA ]
xsymbol -> uqualid . [ RIGHTBRC COMMA ]
## Transitions:
-- On DOT shift to state 526
## Reductions:
-- On RIGHTBRC COMMA
--   reduce production xsymbol -> uqualid

State 539:
## Known stack suffix:
## xsymbol COMMA separated_nonempty_list(COMMA,xsymbol)
## LR(1) items:
separated_nonempty_list(COMMA,xsymbol) -> xsymbol COMMA separated_nonempty_list(COMMA,xsymbol) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production separated_nonempty_list(COMMA,xsymbol) -> xsymbol COMMA separated_nonempty_list(COMMA,xsymbol)

State 540:
## Known stack suffix:
## uqualid
## LR(1) items:
raises -> uqualid . ARROW term [ RIGHTBRC BAR ]
raises -> uqualid . pat_arg ARROW term [ RIGHTBRC BAR ]
uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT DOT CORE_UIDENT CORE_LIDENT COMMA ARROW ]
xsymbol -> uqualid . [ RIGHTBRC COMMA ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On DOT shift to state 526
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On ARROW shift to state 527
-- On uqualid shift to state 231
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 233
-- On pat_arg shift to state 529
-- On mk_pat(pat_arg_) shift to state 236
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:
-- On RIGHTBRC COMMA
--   reduce production xsymbol -> uqualid

State 541:
## Known stack suffix:
## separated_nonempty_list(COMMA,xsymbol)
## LR(1) items:
comma_list1(xsymbol) -> separated_nonempty_list(COMMA,xsymbol) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production comma_list1(xsymbol) -> separated_nonempty_list(COMMA,xsymbol)

State 542:
## Known stack suffix:
## separated_nonempty_list(BAR,raises)
## LR(1) items:
bar_list1(raises) -> separated_nonempty_list(BAR,raises) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production bar_list1(raises) -> separated_nonempty_list(BAR,raises)

State 543:
## Known stack suffix:
## RAISES LEFTBRC comma_list1(xsymbol)
## LR(1) items:
single_spec -> RAISES LEFTBRC comma_list1(xsymbol) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 544
## Reductions:

State 544:
## Known stack suffix:
## RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC
## LR(1) items:
single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
--   reduce production single_spec -> RAISES LEFTBRC comma_list1(xsymbol) RIGHTBRC

State 545:
## Known stack suffix:
## RAISES LEFTBRC bar_list1(raises)
## LR(1) items:
single_spec -> RAISES LEFTBRC bar_list1(raises) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 546
## Reductions:

State 546:
## Known stack suffix:
## RAISES LEFTBRC bar_list1(raises) RIGHTBRC
## LR(1) items:
single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
--   reduce production single_spec -> RAISES LEFTBRC bar_list1(raises) RIGHTBRC

State 547:
## Known stack suffix:
## ENSURES
## LR(1) items:
single_spec -> ENSURES . LEFTBRC ensures RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 548
## Reductions:

State 548:
## Known stack suffix:
## ENSURES LEFTBRC
## LR(1) items:
single_spec -> ENSURES LEFTBRC . ensures RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 549
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On ensures shift to state 550
-- On attr shift to state 356
## Reductions:

State 549:
## Known stack suffix:
## term
## LR(1) items:
ensures -> term . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production ensures -> term

State 550:
## Known stack suffix:
## ENSURES LEFTBRC ensures
## LR(1) items:
single_spec -> ENSURES LEFTBRC ensures . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 551
## Reductions:

State 551:
## Known stack suffix:
## ENSURES LEFTBRC ensures RIGHTBRC
## LR(1) items:
single_spec -> ENSURES LEFTBRC ensures RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
--   reduce production single_spec -> ENSURES LEFTBRC ensures RIGHTBRC

State 552:
## Known stack suffix:
## DIVERGES
## LR(1) items:
single_spec -> DIVERGES . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
--   reduce production single_spec -> DIVERGES

State 553:
## Known stack suffix:
## ALIAS
## LR(1) items:
single_spec -> ALIAS . LEFTBRC comma_list0(alias) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 554
## Reductions:

State 554:
## Known stack suffix:
## ALIAS LEFTBRC
## LR(1) items:
single_spec -> ALIAS LEFTBRC . comma_list0(alias) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 555
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On separated_nonempty_list(COMMA,alias) shift to state 558
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On loption(separated_nonempty_list(COMMA,alias)) shift to state 559
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On comma_list0(alias) shift to state 560
-- On attr shift to state 356
-- On alias shift to state 562
## Reductions:
-- On RIGHTBRC
--   reduce production loption(separated_nonempty_list(COMMA,alias)) ->

State 555:
## Known stack suffix:
## term
## LR(1) items:
alias -> term . WITH term [ RIGHTBRC COMMA ]
## Transitions:
-- On WITH shift to state 556
## Reductions:

State 556:
## Known stack suffix:
## term WITH
## LR(1) items:
alias -> term WITH . term [ RIGHTBRC COMMA ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 557
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 557:
## Known stack suffix:
## term WITH term
## LR(1) items:
alias -> term WITH term . [ RIGHTBRC COMMA ]
## Transitions:
## Reductions:
-- On RIGHTBRC COMMA
--   reduce production alias -> term WITH term

State 558:
## Known stack suffix:
## separated_nonempty_list(COMMA,alias)
## LR(1) items:
loption(separated_nonempty_list(COMMA,alias)) -> separated_nonempty_list(COMMA,alias) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production loption(separated_nonempty_list(COMMA,alias)) -> separated_nonempty_list(COMMA,alias)

State 559:
## Known stack suffix:
## loption(separated_nonempty_list(COMMA,alias))
## LR(1) items:
comma_list0(alias) -> loption(separated_nonempty_list(COMMA,alias)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production comma_list0(alias) -> loption(separated_nonempty_list(COMMA,alias))

State 560:
## Known stack suffix:
## ALIAS LEFTBRC comma_list0(alias)
## LR(1) items:
single_spec -> ALIAS LEFTBRC comma_list0(alias) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 561
## Reductions:

State 561:
## Known stack suffix:
## ALIAS LEFTBRC comma_list0(alias) RIGHTBRC
## LR(1) items:
single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
--   reduce production single_spec -> ALIAS LEFTBRC comma_list0(alias) RIGHTBRC

State 562:
## Known stack suffix:
## alias
## LR(1) items:
separated_nonempty_list(COMMA,alias) -> alias . [ RIGHTBRC ]
separated_nonempty_list(COMMA,alias) -> alias . COMMA separated_nonempty_list(COMMA,alias) [ RIGHTBRC ]
## Transitions:
-- On COMMA shift to state 563
## Reductions:
-- On RIGHTBRC
--   reduce production separated_nonempty_list(COMMA,alias) -> alias

State 563:
## Known stack suffix:
## alias COMMA
## LR(1) items:
separated_nonempty_list(COMMA,alias) -> alias COMMA . separated_nonempty_list(COMMA,alias) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 555
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On separated_nonempty_list(COMMA,alias) shift to state 564
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
-- On alias shift to state 562
## Reductions:

State 564:
## Known stack suffix:
## alias COMMA separated_nonempty_list(COMMA,alias)
## LR(1) items:
separated_nonempty_list(COMMA,alias) -> alias COMMA separated_nonempty_list(COMMA,alias) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production separated_nonempty_list(COMMA,alias) -> alias COMMA separated_nonempty_list(COMMA,alias)

State 565:
## Known stack suffix:
## variant
## LR(1) items:
single_spec -> variant . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
--   reduce production single_spec -> variant

State 566:
## Known stack suffix:
## params return_opt spec
## LR(1) items:
val_defn -> params return_opt spec . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production val_defn -> params return_opt spec

State 567:
## Known stack suffix:
## single_spec
## LR(1) items:
spec -> single_spec . spec [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 568
-- On single_spec shift to state 567
## Reductions:
-- On WITH WHILE VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOWNTO DOTDOT DONE DO CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ABSURD
--   reduce production spec ->

State 568:
## Known stack suffix:
## single_spec spec
## LR(1) items:
spec -> single_spec spec . [ WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD ]
## Transitions:
## Reductions:
-- On WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
--   reduce production spec -> single_spec spec

State 569:
## Known stack suffix:
## param
## LR(1) items:
list(param) -> param . list(param) [ WRITES WITH VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On param shift to state 569
-- On lqualid shift to state 100
-- On list(param) shift to state 570
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
--   reduce production list(param) ->

State 570:
## Known stack suffix:
## param list(param)
## LR(1) items:
list(param) -> param list(param) . [ WRITES WITH VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
--   reduce production list(param) -> param list(param)

State 571:
## Known stack suffix:
## lident_nq
## LR(1) items:
param -> lident_nq . nonempty_list(attr) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On nonempty_list(attr) shift to state 572
-- On attr shift to state 127
## Reductions:

State 572:
## Known stack suffix:
## lident_nq nonempty_list(attr)
## LR(1) items:
param -> lident_nq nonempty_list(attr) . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
--   reduce production param -> lident_nq nonempty_list(attr)

State 573:
## Known stack suffix:
## anon_binder
## LR(1) items:
param -> anon_binder . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
--   reduce production param -> anon_binder

State 574:
## Known stack suffix:
## VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
## LR(1) items:
prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production prog_decl -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn)

State 575:
## Known stack suffix:
## list(param)
## LR(1) items:
params -> list(param) . [ WRITES WITH VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
--   reduce production params -> list(param)

State 576:
## Known stack suffix:
## USE
## LR(1) items:
use_clone -> USE . EXPORT tqualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
use_clone -> USE . boption(IMPORT) comma_list1(use_as) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On IMPORT shift to state 577
-- On EXPORT shift to state 578
-- On boption(IMPORT) shift to state 588
## Reductions:
-- On UIDENT STRING RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
--   reduce production boption(IMPORT) ->

State 577:
## Known stack suffix:
## IMPORT
## LR(1) items:
boption(IMPORT) -> IMPORT . [ UIDENT STRING RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UIDENT STRING RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
--   reduce production boption(IMPORT) -> IMPORT

State 578:
## Known stack suffix:
## USE EXPORT
## LR(1) items:
use_clone -> USE EXPORT . tqualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 580
-- On tqualid shift to state 581
-- On squalid shift to state 582
-- On sident shift to state 587
-- On lident_keyword shift to state 43
-- On lident shift to state 586
## Reductions:

State 579:
## Known stack suffix:
## STRING
## LR(1) items:
sident -> STRING . [ TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION DOT CONSTANT AXIOM ]
## Transitions:
## Reductions:
-- On TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION DOT CONSTANT AXIOM
--   reduce production sident -> STRING

State 580:
## Known stack suffix:
## uident
## LR(1) items:
sident -> uident . [ DOT ]
tqualid -> uident . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production sident -> uident
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS
--   reduce production tqualid -> uident

State 581:
## Known stack suffix:
## USE EXPORT tqualid
## LR(1) items:
use_clone -> USE EXPORT tqualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production use_clone -> USE EXPORT tqualid

State 582:
## Known stack suffix:
## squalid
## LR(1) items:
squalid -> squalid . DOT sident [ DOT ]
tqualid -> squalid . DOT uident [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS ]
## Transitions:
-- On DOT shift to state 583
## Reductions:

State 583:
## Known stack suffix:
## squalid DOT
## LR(1) items:
squalid -> squalid DOT . sident [ DOT ]
tqualid -> squalid DOT . uident [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 584
-- On sident shift to state 585
-- On lident_keyword shift to state 43
-- On lident shift to state 586
## Reductions:

State 584:
## Known stack suffix:
## squalid DOT uident
## LR(1) items:
sident -> uident . [ DOT ]
tqualid -> squalid DOT uident . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production sident -> uident
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS
--   reduce production tqualid -> squalid DOT uident

State 585:
## Known stack suffix:
## squalid DOT sident
## LR(1) items:
squalid -> squalid DOT sident . [ DOT ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production squalid -> squalid DOT sident

State 586:
## Known stack suffix:
## lident
## LR(1) items:
sident -> lident . [ TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION DOT CONSTANT AXIOM ]
## Transitions:
## Reductions:
-- On TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION DOT CONSTANT AXIOM
--   reduce production sident -> lident

State 587:
## Known stack suffix:
## sident
## LR(1) items:
squalid -> sident . [ DOT ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production squalid -> sident

State 588:
## Known stack suffix:
## USE boption(IMPORT)
## LR(1) items:
use_clone -> USE boption(IMPORT) . comma_list1(use_as) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On use_as shift to state 589
-- On uident shift to state 580
-- On tqualid shift to state 591
-- On squalid shift to state 582
-- On sident shift to state 587
-- On separated_nonempty_list(COMMA,use_as) shift to state 596
-- On lident_keyword shift to state 43
-- On lident shift to state 586
-- On comma_list1(use_as) shift to state 597
## Reductions:

State 589:
## Known stack suffix:
## use_as
## LR(1) items:
separated_nonempty_list(COMMA,use_as) -> use_as . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(COMMA,use_as) -> use_as . COMMA separated_nonempty_list(COMMA,use_as) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COMMA shift to state 590
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(COMMA,use_as) -> use_as

State 590:
## Known stack suffix:
## use_as COMMA
## LR(1) items:
separated_nonempty_list(COMMA,use_as) -> use_as COMMA . separated_nonempty_list(COMMA,use_as) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On use_as shift to state 589
-- On uident shift to state 580
-- On tqualid shift to state 591
-- On squalid shift to state 582
-- On sident shift to state 587
-- On separated_nonempty_list(COMMA,use_as) shift to state 595
-- On lident_keyword shift to state 43
-- On lident shift to state 586
## Reductions:

State 591:
## Known stack suffix:
## tqualid
## LR(1) items:
use_as -> tqualid . option(preceded(AS,uident)) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On AS shift to state 592
-- On option(preceded(AS,uident)) shift to state 594
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production option(preceded(AS,uident)) ->

State 592:
## Known stack suffix:
## AS
## LR(1) items:
option(preceded(AS,uident)) -> AS . uident [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 593
## Reductions:

State 593:
## Known stack suffix:
## AS uident
## LR(1) items:
option(preceded(AS,uident)) -> AS uident . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production option(preceded(AS,uident)) -> AS uident

State 594:
## Known stack suffix:
## tqualid option(preceded(AS,uident))
## LR(1) items:
use_as -> tqualid option(preceded(AS,uident)) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production use_as -> tqualid option(preceded(AS,uident))

State 595:
## Known stack suffix:
## use_as COMMA separated_nonempty_list(COMMA,use_as)
## LR(1) items:
separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(COMMA,use_as) -> use_as COMMA separated_nonempty_list(COMMA,use_as)

State 596:
## Known stack suffix:
## separated_nonempty_list(COMMA,use_as)
## LR(1) items:
comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production comma_list1(use_as) -> separated_nonempty_list(COMMA,use_as)

State 597:
## Known stack suffix:
## USE boption(IMPORT) comma_list1(use_as)
## LR(1) items:
use_clone -> USE boption(IMPORT) comma_list1(use_as) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production use_clone -> USE boption(IMPORT) comma_list1(use_as)

State 598:
## Known stack suffix:
## TYPE
## LR(1) items:
pure_decl -> TYPE . with_list1(type_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On with_list1(type_decl) shift to state 599
-- On type_decl shift to state 600
-- On separated_nonempty_list(WITH,type_decl) shift to state 994
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 603
## Reductions:

State 599:
## Known stack suffix:
## TYPE with_list1(type_decl)
## LR(1) items:
pure_decl -> TYPE with_list1(type_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production pure_decl -> TYPE with_list1(type_decl)

State 600:
## Known stack suffix:
## type_decl
## LR(1) items:
separated_nonempty_list(WITH,type_decl) -> type_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(WITH,type_decl) -> type_decl . WITH separated_nonempty_list(WITH,type_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 601
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(WITH,type_decl) -> type_decl

State 601:
## Known stack suffix:
## type_decl WITH
## LR(1) items:
separated_nonempty_list(WITH,type_decl) -> type_decl WITH . separated_nonempty_list(WITH,type_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On type_decl shift to state 600
-- On separated_nonempty_list(WITH,type_decl) shift to state 602
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 603
## Reductions:

State 602:
## Known stack suffix:
## type_decl WITH separated_nonempty_list(WITH,type_decl)
## LR(1) items:
separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(WITH,type_decl) -> type_decl WITH separated_nonempty_list(WITH,type_decl)

State 603:
## Known stack suffix:
## attrs(lident_nq)
## LR(1) items:
type_decl -> attrs(lident_nq) . list(ty_var) typedefn list(invariant) type_witness [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On QUOTE_LIDENT shift to state 78
-- On ty_var shift to state 604
-- On quote_lident shift to state 605
-- On list(ty_var) shift to state 609
-- On attrs(quote_lident) shift to state 608
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production list(ty_var) ->

State 604:
## Known stack suffix:
## ty_var
## LR(1) items:
list(ty_var) -> ty_var . list(ty_var) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On QUOTE_LIDENT shift to state 78
-- On ty_var shift to state 604
-- On quote_lident shift to state 605
-- On list(ty_var) shift to state 607
-- On attrs(quote_lident) shift to state 608
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production list(ty_var) ->

State 605:
## Known stack suffix:
## quote_lident
## LR(1) items:
attrs(quote_lident) -> quote_lident . list(attr) [ WITH VAL USE TYPE SCOPE QUOTE_LIDENT PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 606
-- On attr shift to state 71
## Reductions:
-- On WITH VAL USE TYPE SCOPE QUOTE_LIDENT PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production list(attr) ->

State 606:
## Known stack suffix:
## quote_lident list(attr)
## LR(1) items:
attrs(quote_lident) -> quote_lident list(attr) . [ WITH VAL USE TYPE SCOPE QUOTE_LIDENT PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE QUOTE_LIDENT PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production attrs(quote_lident) -> quote_lident list(attr)

State 607:
## Known stack suffix:
## ty_var list(ty_var)
## LR(1) items:
list(ty_var) -> ty_var list(ty_var) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production list(ty_var) -> ty_var list(ty_var)

State 608:
## Known stack suffix:
## attrs(quote_lident)
## LR(1) items:
ty_var -> attrs(quote_lident) . [ WITH VAL USE TYPE SCOPE QUOTE_LIDENT PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE QUOTE_LIDENT PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production ty_var -> attrs(quote_lident)

State 609:
## Known stack suffix:
## attrs(lident_nq) list(ty_var)
## LR(1) items:
type_decl -> attrs(lident_nq) list(ty_var) . typedefn list(invariant) type_witness [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 610
-- On typedefn shift to state 662
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production typedefn ->

State 610:
## Known stack suffix:
## EQUAL
## LR(1) items:
typedefn -> EQUAL . vis_mut bar_list1(type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL . vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL . vis_mut ty [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL . LT RANGE int_constant int_constant GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL . LT FLOAT INTEGER INTEGER GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On PRIVATE shift to state 611
-- On MUTABLE shift to state 612
-- On LT shift to state 615
-- On ABSTRACT shift to state 613
-- On vis_mut shift to state 627
-- On abstract shift to state 660
## Reductions:
-- On UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR
--   reduce production vis_mut ->

State 611:
## Known stack suffix:
## PRIVATE
## LR(1) items:
abstract -> PRIVATE . [ UIDENT RANGE QUOTE_LIDENT MUTABLE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## Transitions:
## Reductions:
-- On UIDENT RANGE QUOTE_LIDENT MUTABLE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR
--   reduce production abstract -> PRIVATE

State 612:
## Known stack suffix:
## MUTABLE
## LR(1) items:
vis_mut -> MUTABLE . [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
vis_mut -> MUTABLE . abstract [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## Transitions:
-- On PRIVATE shift to state 611
-- On ABSTRACT shift to state 613
-- On abstract shift to state 614
## Reductions:
-- On UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR
--   reduce production vis_mut -> MUTABLE

State 613:
## Known stack suffix:
## ABSTRACT
## LR(1) items:
abstract -> ABSTRACT . [ UIDENT RANGE QUOTE_LIDENT MUTABLE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## Transitions:
## Reductions:
-- On UIDENT RANGE QUOTE_LIDENT MUTABLE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR
--   reduce production abstract -> ABSTRACT

State 614:
## Known stack suffix:
## MUTABLE abstract
## LR(1) items:
vis_mut -> MUTABLE abstract . [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## Transitions:
## Reductions:
-- On UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR
--   reduce production vis_mut -> MUTABLE abstract

State 615:
## Known stack suffix:
## EQUAL LT
## LR(1) items:
typedefn -> EQUAL LT . RANGE int_constant int_constant GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL LT . FLOAT INTEGER INTEGER GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On RANGE shift to state 616
-- On FLOAT shift to state 623
## Reductions:

State 616:
## Known stack suffix:
## EQUAL LT RANGE
## LR(1) items:
typedefn -> EQUAL LT RANGE . int_constant int_constant GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On MINUS shift to state 617
-- On INTEGER shift to state 619
-- On int_constant shift to state 620
## Reductions:

State 617:
## Known stack suffix:
## MINUS
## LR(1) items:
int_constant -> MINUS . INTEGER [ MINUS INTEGER GT ]
## Transitions:
-- On INTEGER shift to state 618
## Reductions:

State 618:
## Known stack suffix:
## MINUS INTEGER
## LR(1) items:
int_constant -> MINUS INTEGER . [ MINUS INTEGER GT ]
## Transitions:
## Reductions:
-- On MINUS INTEGER GT
--   reduce production int_constant -> MINUS INTEGER

State 619:
## Known stack suffix:
## INTEGER
## LR(1) items:
int_constant -> INTEGER . [ MINUS INTEGER GT ]
## Transitions:
## Reductions:
-- On MINUS INTEGER GT
--   reduce production int_constant -> INTEGER

State 620:
## Known stack suffix:
## EQUAL LT RANGE int_constant
## LR(1) items:
typedefn -> EQUAL LT RANGE int_constant . int_constant GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On MINUS shift to state 617
-- On INTEGER shift to state 619
-- On int_constant shift to state 621
## Reductions:

State 621:
## Known stack suffix:
## EQUAL LT RANGE int_constant int_constant
## LR(1) items:
typedefn -> EQUAL LT RANGE int_constant int_constant . GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On GT shift to state 622
## Reductions:

State 622:
## Known stack suffix:
## EQUAL LT RANGE int_constant int_constant GT
## LR(1) items:
typedefn -> EQUAL LT RANGE int_constant int_constant GT . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production typedefn -> EQUAL LT RANGE int_constant int_constant GT

State 623:
## Known stack suffix:
## EQUAL LT FLOAT
## LR(1) items:
typedefn -> EQUAL LT FLOAT . INTEGER INTEGER GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On INTEGER shift to state 624
## Reductions:

State 624:
## Known stack suffix:
## EQUAL LT FLOAT INTEGER
## LR(1) items:
typedefn -> EQUAL LT FLOAT INTEGER . INTEGER GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On INTEGER shift to state 625
## Reductions:

State 625:
## Known stack suffix:
## EQUAL LT FLOAT INTEGER INTEGER
## LR(1) items:
typedefn -> EQUAL LT FLOAT INTEGER INTEGER . GT [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On GT shift to state 626
## Reductions:

State 626:
## Known stack suffix:
## EQUAL LT FLOAT INTEGER INTEGER GT
## LR(1) items:
typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production typedefn -> EQUAL LT FLOAT INTEGER INTEGER GT

State 627:
## Known stack suffix:
## EQUAL vis_mut
## LR(1) items:
typedefn -> EQUAL vis_mut . bar_list1(type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL vis_mut . LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
typedefn -> EQUAL vis_mut . ty [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On UIDENT shift to state 628
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 629
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 645
-- On CORE_LIDENT shift to state 39
-- On BAR shift to state 646
-- On uqualid shift to state 84
-- On uident_nq shift to state 649
-- On uident shift to state 89
-- On type_case shift to state 651
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 657
-- On separated_nonempty_list(BAR,type_case) shift to state 658
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On bar_list1(type_case) shift to state 659
-- On attrs(uident_nq) shift to state 654
## Reductions:

State 628:
## Known stack suffix:
## UIDENT
## LR(1) items:
uident -> UIDENT . [ DOT ]
uident_nq -> UIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production uident -> UIDENT
-- On WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE
--   reduce production uident_nq -> UIDENT

State 629:
## Known stack suffix:
## EQUAL vis_mut LEFTBRC
## LR(1) items:
ty_block -> LEFTBRC . ty RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ARROW ]
typedefn -> EQUAL vis_mut LEFTBRC . loption(semicolon_list1(type_field)) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On MUTABLE shift to state 630
-- On LIDENT shift to state 151
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 632
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 153
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On type_field shift to state 634
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 92
-- On semicolon_list1(type_field) shift to state 642
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On loption(semicolon_list1(type_field)) shift to state 643
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 167
-- On lident shift to state 101
-- On field_modifiers shift to state 637
-- On attrs(lident_nq) shift to state 640
## Reductions:
-- On RIGHTBRC
--   reduce production loption(semicolon_list1(type_field)) ->

State 630:
## Known stack suffix:
## MUTABLE
## LR(1) items:
field_modifiers -> MUTABLE . [ RANGE LIDENT FLOAT CORE_LIDENT ]
field_modifiers -> MUTABLE . GHOST [ RANGE LIDENT FLOAT CORE_LIDENT ]
## Transitions:
-- On GHOST shift to state 631
## Reductions:
-- On RANGE LIDENT FLOAT CORE_LIDENT
--   reduce production field_modifiers -> MUTABLE

State 631:
## Known stack suffix:
## MUTABLE GHOST
## LR(1) items:
field_modifiers -> MUTABLE GHOST . [ RANGE LIDENT FLOAT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On RANGE LIDENT FLOAT CORE_LIDENT
--   reduce production field_modifiers -> MUTABLE GHOST

State 632:
## Known stack suffix:
## GHOST
## LR(1) items:
field_modifiers -> GHOST . [ RANGE LIDENT FLOAT CORE_LIDENT ]
field_modifiers -> GHOST . MUTABLE [ RANGE LIDENT FLOAT CORE_LIDENT ]
## Transitions:
-- On MUTABLE shift to state 633
## Reductions:
-- On RANGE LIDENT FLOAT CORE_LIDENT
--   reduce production field_modifiers -> GHOST

State 633:
## Known stack suffix:
## GHOST MUTABLE
## LR(1) items:
field_modifiers -> GHOST MUTABLE . [ RANGE LIDENT FLOAT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On RANGE LIDENT FLOAT CORE_LIDENT
--   reduce production field_modifiers -> GHOST MUTABLE

State 634:
## Known stack suffix:
## type_field
## LR(1) items:
semicolon_list1(type_field) -> type_field . [ RIGHTBRC ]
semicolon_list1(type_field) -> type_field . SEMICOLON [ RIGHTBRC ]
semicolon_list1(type_field) -> type_field . SEMICOLON semicolon_list1(type_field) [ RIGHTBRC ]
## Transitions:
-- On SEMICOLON shift to state 635
## Reductions:
-- On RIGHTBRC
--   reduce production semicolon_list1(type_field) -> type_field

State 635:
## Known stack suffix:
## type_field SEMICOLON
## LR(1) items:
semicolon_list1(type_field) -> type_field SEMICOLON . [ RIGHTBRC ]
semicolon_list1(type_field) -> type_field SEMICOLON . semicolon_list1(type_field) [ RIGHTBRC ]
## Transitions:
-- On RANGE shift to state 2
-- On MUTABLE shift to state 630
-- On LIDENT shift to state 60
-- On GHOST shift to state 632
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On type_field shift to state 634
-- On semicolon_list1(type_field) shift to state 636
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On field_modifiers shift to state 637
-- On attrs(lident_nq) shift to state 640
## Reductions:
-- On RIGHTBRC
--   reduce production semicolon_list1(type_field) -> type_field SEMICOLON

State 636:
## Known stack suffix:
## type_field SEMICOLON semicolon_list1(type_field)
## LR(1) items:
semicolon_list1(type_field) -> type_field SEMICOLON semicolon_list1(type_field) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production semicolon_list1(type_field) -> type_field SEMICOLON semicolon_list1(type_field)

State 637:
## Known stack suffix:
## field_modifiers
## LR(1) items:
type_field -> field_modifiers . attrs(lident_nq) cast [ SEMICOLON RIGHTBRC ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 638
## Reductions:

State 638:
## Known stack suffix:
## field_modifiers attrs(lident_nq)
## LR(1) items:
type_field -> field_modifiers attrs(lident_nq) . cast [ SEMICOLON RIGHTBRC ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 639
## Reductions:

State 639:
## Known stack suffix:
## field_modifiers attrs(lident_nq) cast
## LR(1) items:
type_field -> field_modifiers attrs(lident_nq) cast . [ SEMICOLON RIGHTBRC ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTBRC
--   reduce production type_field -> field_modifiers attrs(lident_nq) cast

State 640:
## Known stack suffix:
## attrs(lident_nq)
## LR(1) items:
type_field -> attrs(lident_nq) . cast [ SEMICOLON RIGHTBRC ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 641
## Reductions:

State 641:
## Known stack suffix:
## attrs(lident_nq) cast
## LR(1) items:
type_field -> attrs(lident_nq) cast . [ SEMICOLON RIGHTBRC ]
## Transitions:
## Reductions:
-- On SEMICOLON RIGHTBRC
--   reduce production type_field -> attrs(lident_nq) cast

State 642:
## Known stack suffix:
## semicolon_list1(type_field)
## LR(1) items:
loption(semicolon_list1(type_field)) -> semicolon_list1(type_field) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production loption(semicolon_list1(type_field)) -> semicolon_list1(type_field)

State 643:
## Known stack suffix:
## EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field))
## LR(1) items:
typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) . RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On RIGHTBRC shift to state 644
## Reductions:

State 644:
## Known stack suffix:
## EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC
## LR(1) items:
typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production typedefn -> EQUAL vis_mut LEFTBRC loption(semicolon_list1(type_field)) RIGHTBRC

State 645:
## Known stack suffix:
## CORE_UIDENT
## LR(1) items:
uident -> CORE_UIDENT . [ DOT ]
uident_nq -> CORE_UIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production uident -> CORE_UIDENT
-- On WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE
--   reduce production uident_nq -> CORE_UIDENT

State 646:
## Known stack suffix:
## BAR
## LR(1) items:
bar_list1(type_case) -> BAR . separated_nonempty_list(BAR,type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On CORE_UIDENT shift to state 648
-- On uident_nq shift to state 649
-- On type_case shift to state 651
-- On separated_nonempty_list(BAR,type_case) shift to state 656
-- On attrs(uident_nq) shift to state 654
## Reductions:

State 647:
## Known stack suffix:
## UIDENT
## LR(1) items:
uident_nq -> UIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE
--   reduce production uident_nq -> UIDENT

State 648:
## Known stack suffix:
## CORE_UIDENT
## LR(1) items:
uident_nq -> CORE_UIDENT . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE ]
## Transitions:
## Reductions:
-- On WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE
--   reduce production uident_nq -> CORE_UIDENT

State 649:
## Known stack suffix:
## uident_nq
## LR(1) items:
attrs(uident_nq) -> uident_nq . list(attr) [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 650
-- On attr shift to state 71
## Reductions:
-- On WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM
--   reduce production list(attr) ->

State 650:
## Known stack suffix:
## uident_nq list(attr)
## LR(1) items:
attrs(uident_nq) -> uident_nq list(attr) . [ WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM
--   reduce production attrs(uident_nq) -> uident_nq list(attr)

State 651:
## Known stack suffix:
## type_case
## LR(1) items:
separated_nonempty_list(BAR,type_case) -> type_case . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
separated_nonempty_list(BAR,type_case) -> type_case . BAR separated_nonempty_list(BAR,type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On BAR shift to state 652
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production separated_nonempty_list(BAR,type_case) -> type_case

State 652:
## Known stack suffix:
## type_case BAR
## LR(1) items:
separated_nonempty_list(BAR,type_case) -> type_case BAR . separated_nonempty_list(BAR,type_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On CORE_UIDENT shift to state 648
-- On uident_nq shift to state 649
-- On type_case shift to state 651
-- On separated_nonempty_list(BAR,type_case) shift to state 653
-- On attrs(uident_nq) shift to state 654
## Reductions:

State 653:
## Known stack suffix:
## type_case BAR separated_nonempty_list(BAR,type_case)
## LR(1) items:
separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production separated_nonempty_list(BAR,type_case) -> type_case BAR separated_nonempty_list(BAR,type_case)

State 654:
## Known stack suffix:
## attrs(uident_nq)
## LR(1) items:
type_case -> attrs(uident_nq) . params [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 655
-- On param shift to state 569
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY BAR AXIOM
--   reduce production list(param) ->

State 655:
## Known stack suffix:
## attrs(uident_nq) params
## LR(1) items:
type_case -> attrs(uident_nq) params . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY BAR AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY BAR AXIOM
--   reduce production type_case -> attrs(uident_nq) params

State 656:
## Known stack suffix:
## BAR separated_nonempty_list(BAR,type_case)
## LR(1) items:
bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production bar_list1(type_case) -> BAR separated_nonempty_list(BAR,type_case)

State 657:
## Known stack suffix:
## EQUAL vis_mut ty
## LR(1) items:
ty -> ty . ARROW ty [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ARROW ]
typedefn -> EQUAL vis_mut ty . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production typedefn -> EQUAL vis_mut ty

State 658:
## Known stack suffix:
## separated_nonempty_list(BAR,type_case)
## LR(1) items:
bar_list1(type_case) -> separated_nonempty_list(BAR,type_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production bar_list1(type_case) -> separated_nonempty_list(BAR,type_case)

State 659:
## Known stack suffix:
## EQUAL vis_mut bar_list1(type_case)
## LR(1) items:
typedefn -> EQUAL vis_mut bar_list1(type_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production typedefn -> EQUAL vis_mut bar_list1(type_case)

State 660:
## Known stack suffix:
## abstract
## LR(1) items:
vis_mut -> abstract . [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
vis_mut -> abstract . MUTABLE [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## Transitions:
-- On MUTABLE shift to state 661
## Reductions:
-- On UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR
--   reduce production vis_mut -> abstract

State 661:
## Known stack suffix:
## abstract MUTABLE
## LR(1) items:
vis_mut -> abstract MUTABLE . [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR ]
## Transitions:
## Reductions:
-- On UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR
--   reduce production vis_mut -> abstract MUTABLE

State 662:
## Known stack suffix:
## attrs(lident_nq) list(ty_var) typedefn
## LR(1) items:
type_decl -> attrs(lident_nq) list(ty_var) typedefn . list(invariant) type_witness [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On INVARIANT shift to state 663
-- On list(invariant) shift to state 667
-- On invariant shift to state 858
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
--   reduce production list(invariant) ->

State 663:
## Known stack suffix:
## INVARIANT
## LR(1) items:
invariant -> INVARIANT . LEFTBRC term RIGHTBRC [ WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On LEFTBRC shift to state 664
## Reductions:

State 664:
## Known stack suffix:
## INVARIANT LEFTBRC
## LR(1) items:
invariant -> INVARIANT LEFTBRC . term RIGHTBRC [ WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 665
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 665:
## Known stack suffix:
## INVARIANT LEFTBRC term
## LR(1) items:
invariant -> INVARIANT LEFTBRC term . RIGHTBRC [ WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On RIGHTBRC shift to state 666
## Reductions:

State 666:
## Known stack suffix:
## INVARIANT LEFTBRC term RIGHTBRC
## LR(1) items:
invariant -> INVARIANT LEFTBRC term RIGHTBRC . [ WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production invariant -> INVARIANT LEFTBRC term RIGHTBRC

State 667:
## Known stack suffix:
## attrs(lident_nq) list(ty_var) typedefn list(invariant)
## LR(1) items:
type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) . type_witness [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On BY shift to state 668
-- On type_witness shift to state 993
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production type_witness ->

State 668:
## Known stack suffix:
## BY
## LR(1) items:
type_witness -> BY . LEFTBRC field_list1(expr) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On LEFTBRC shift to state 669
## Reductions:

State 669:
## Known stack suffix:
## BY LEFTBRC
## LR(1) items:
type_witness -> BY LEFTBRC . field_list1(expr) RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,expr)) shift to state 670
-- On lqualid shift to state 671
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On field_list1(expr) shift to state 991
## Reductions:

State 670:
## Known stack suffix:
## semicolon_list1(separated_pair(lqualid,EQUAL,expr))
## LR(1) items:
field_list1(expr) -> semicolon_list1(separated_pair(lqualid,EQUAL,expr)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production field_list1(expr) -> semicolon_list1(separated_pair(lqualid,EQUAL,expr))

State 671:
## Known stack suffix:
## lqualid
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
## Transitions:
-- On EQUAL shift to state 672
## Reductions:

State 672:
## Known stack suffix:
## lqualid EQUAL
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL . expr [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL . expr SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL . expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 988
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 673:
## Known stack suffix:
## WHILE
## LR(1) items:
single_expr_ -> WHILE . seq_expr DO loop_annotation loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 979
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 674:
## Known stack suffix:
## VAL
## LR(1) items:
single_expr_ -> VAL . ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On GHOST shift to state 53
-- On ghost shift to state 675
## Reductions:
-- On RANGE PREDICATE LIDENT LEMMA LEFTPAR FUNCTION FLOAT CORE_LIDENT CONSTANT
--   reduce production ghost ->

State 675:
## Known stack suffix:
## VAL ghost
## LR(1) items:
single_expr_ -> VAL ghost . kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On PREDICATE shift to state 55
-- On LEMMA shift to state 56
-- On FUNCTION shift to state 57
-- On CONSTANT shift to state 58
-- On kind shift to state 676
## Reductions:
-- On RANGE LIDENT LEFTPAR FLOAT CORE_LIDENT
--   reduce production kind ->

State 676:
## Known stack suffix:
## VAL ghost kind
## LR(1) items:
single_expr_ -> VAL ghost kind . attrs(lident_rich) mk_expr(val_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On attrs(lident_rich) shift to state 677
## Reductions:

State 677:
## Known stack suffix:
## VAL ghost kind attrs(lident_rich)
## LR(1) items:
single_expr_ -> VAL ghost kind attrs(lident_rich) . mk_expr(val_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On val_defn shift to state 145
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 147
-- On param shift to state 569
-- On mk_expr(val_defn) shift to state 678
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WRITES VARIANT RETURNS REQUIRES READS RAISES IN ENSURES DIVERGES COLON ALIAS
--   reduce production list(param) ->

State 678:
## Known stack suffix:
## VAL ghost kind attrs(lident_rich) mk_expr(val_defn)
## LR(1) items:
single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 679
## Reductions:

State 679:
## Known stack suffix:
## VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN
## LR(1) items:
single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 978
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 680:
## Known stack suffix:
## TRY
## LR(1) items:
single_expr_ -> TRY . seq_expr WITH bar_list1(exn_handler) END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 968
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 681:
## Known stack suffix:
## TRUE
## LR(1) items:
expr_arg_ -> TRUE . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_arg_ -> TRUE

State 682:
## Known stack suffix:
## RETURN
## LR(1) items:
single_expr_ -> RETURN . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> RETURN . contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 967
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LTGT LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> RETURN

State 683:
## Known stack suffix:
## RAISE
## LR(1) items:
single_expr_ -> RAISE . uqualid option(expr_arg) [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> RAISE . LEFTPAR uqualid option(expr_arg) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On LEFTPAR shift to state 684
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 965
-- On uident shift to state 89
## Reductions:

State 684:
## Known stack suffix:
## RAISE LEFTPAR
## LR(1) items:
single_expr_ -> RAISE LEFTPAR . uqualid option(expr_arg) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 685
-- On uident shift to state 89
## Reductions:

State 685:
## Known stack suffix:
## RAISE LEFTPAR uqualid
## LR(1) items:
single_expr_ -> RAISE LEFTPAR uqualid . option(expr_arg) RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
uqualid -> uqualid . DOT uident [ UIDENT TRUE RIGHTPAR REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE DOT CORE_UIDENT CORE_LIDENT BEGIN ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On DOT shift to state 526
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On qualid shift to state 744
-- On option(expr_arg) shift to state 962
-- On numeral shift to state 745
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 964
## Reductions:
-- On RIGHTPAR
--   reduce production option(expr_arg) ->

State 686:
## Known stack suffix:
## PURE
## LR(1) items:
expr_sub_ -> PURE . LEFTBRC term RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On LEFTBRC shift to state 687
## Reductions:

State 687:
## Known stack suffix:
## PURE LEFTBRC
## LR(1) items:
expr_sub_ -> PURE LEFTBRC . term RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 688
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 688:
## Known stack suffix:
## PURE LEFTBRC term
## LR(1) items:
expr_sub_ -> PURE LEFTBRC term . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 689
## Reductions:

State 689:
## Known stack suffix:
## PURE LEFTBRC term RIGHTBRC
## LR(1) items:
expr_sub_ -> PURE LEFTBRC term RIGHTBRC . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_sub_ -> PURE LEFTBRC term RIGHTBRC

State 690:
## Known stack suffix:
## OPPREF
## LR(1) items:
expr_arg_ -> OPPREF . expr_arg [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_dot_ -> OPPREF . expr_dot [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On qualid shift to state 744
-- On numeral shift to state 745
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 957
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 958
## Reductions:

State 691:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
expr_block_ -> LEFTPAR . seq_expr RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR_USCORE [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lident_op -> LEFTPAR . lident_op_str RIGHTPAR_QUOTE [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RIGHTPAR shift to state 692
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 693
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 959
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTSQ shift to state 15
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On EQUAL shift to state 30
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 960
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 488
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op_str shift to state 33
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 692:
## Known stack suffix:
## LEFTPAR RIGHTPAR
## LR(1) items:
expr_block_ -> LEFTPAR RIGHTPAR . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_block_ -> LEFTPAR RIGHTPAR

State 693:
## Known stack suffix:
## OPPREF
## LR(1) items:
expr_arg_ -> OPPREF . expr_arg [ WRITES VARIANT UIDENT TRUE SEMICOLON RIGHTPAR RETURNS REQUIRES REAL READS RANGE RAISES PURE OPPREF OP4 OP3 OP2 OP1 MINUS LTGT LT LIDENT LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER GT FLOAT FALSE EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COMMA COLON BEGIN BARBAR AMPAMP ALIAS ]
expr_dot_ -> OPPREF . expr_dot [ DOT ]
lident_op_str -> OPPREF . option(UNDERSCORE) [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
## Transitions:
-- On UNDERSCORE shift to state 6
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On qualid shift to state 744
-- On option(UNDERSCORE) shift to state 7
-- On numeral shift to state 745
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 957
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 958
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production option(UNDERSCORE) ->

State 694:
## Known stack suffix:
## LEFTBRC
## LR(1) items:
expr_block_ -> LEFTBRC . field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> LEFTBRC . expr_arg WITH field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_pure_ -> LEFTBRC . qualid RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 740
-- On uident shift to state 302
-- On semicolon_list1(separated_pair(lqualid,EQUAL,expr)) shift to state 670
-- On qualid shift to state 956
-- On numeral shift to state 745
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 748
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 480
-- On ident shift to state 355
-- On field_list1(expr) shift to state 751
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 772
## Reductions:

State 695:
## Known stack suffix:
## FALSE
## LR(1) items:
expr_arg_ -> FALSE . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_arg_ -> FALSE

State 696:
## Known stack suffix:
## BEGIN
## LR(1) items:
expr_block_ -> BEGIN . single_spec spec seq_expr END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> BEGIN . single_spec spec END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> BEGIN . seq_expr END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> BEGIN . END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On WHILE shift to state 673
-- On VARIANT shift to state 493
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURNS shift to state 505
-- On RETURN shift to state 682
-- On REQUIRES shift to state 509
-- On REAL shift to state 200
-- On READS shift to state 513
-- On RANGE shift to state 2
-- On RAISES shift to state 522
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On ENSURES shift to state 547
-- On END shift to state 948
-- On DIVERGES shift to state 552
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ALIAS shift to state 553
-- On ABSURD shift to state 736
-- On variant shift to state 565
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_spec shift to state 949
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 954
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 697:
## Known stack suffix:
## NOT
## LR(1) items:
single_expr_ -> NOT . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 947
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 698:
## Known stack suffix:
## MINUS
## LR(1) items:
prefix_op -> MINUS . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
single_expr_ -> MINUS . INTEGER [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> MINUS . REAL [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On REAL shift to state 699
-- On INTEGER shift to state 700
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production prefix_op -> MINUS

State 699:
## Known stack suffix:
## MINUS REAL
## LR(1) items:
single_expr_ -> MINUS REAL . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> MINUS REAL

State 700:
## Known stack suffix:
## MINUS INTEGER
## LR(1) items:
single_expr_ -> MINUS INTEGER . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> MINUS INTEGER

State 701:
## Known stack suffix:
## MATCH
## LR(1) items:
single_expr_ -> MATCH . seq_expr WITH ext_match_cases END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 925
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 702:
## Known stack suffix:
## LET
## LR(1) items:
single_expr_ -> LET . ghost kind let_pattern EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET . ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET . ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET . ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET . REC with_list1(rec_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On REC shift to state 703
-- On GHOST shift to state 53
-- On ghost shift to state 882
## Reductions:
-- On UNDERSCORE UIDENT RANGE PREDICATE LIDENT LEMMA LEFTPAR LEFTBRC FUNCTION FLOAT CORE_UIDENT CORE_LIDENT CONSTANT
--   reduce production ghost ->

State 703:
## Known stack suffix:
## LET REC
## LR(1) items:
single_expr_ -> LET REC . with_list1(rec_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On GHOST shift to state 53
-- On with_list1(rec_defn) shift to state 704
-- On separated_nonempty_list(WITH,rec_defn) shift to state 869
-- On rec_defn shift to state 870
-- On ghost shift to state 873
## Reductions:
-- On RANGE PREDICATE LIDENT LEMMA LEFTPAR FUNCTION FLOAT CORE_LIDENT CONSTANT
--   reduce production ghost ->

State 704:
## Known stack suffix:
## LET REC with_list1(rec_defn)
## LR(1) items:
single_expr_ -> LET REC with_list1(rec_defn) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 705
## Reductions:

State 705:
## Known stack suffix:
## LET REC with_list1(rec_defn) IN
## LR(1) items:
single_expr_ -> LET REC with_list1(rec_defn) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 868
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 706:
## Known stack suffix:
## LABEL
## LR(1) items:
single_expr_ -> LABEL . attrs(uident) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 707
-- On attrs(uident) shift to state 709
## Reductions:

State 707:
## Known stack suffix:
## uident
## LR(1) items:
attrs(uident) -> uident . list(attr) [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC IN GHOST FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 708
-- On attr shift to state 71
## Reductions:
-- On UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC IN GHOST FLOAT CORE_UIDENT CORE_LIDENT
--   reduce production list(attr) ->

State 708:
## Known stack suffix:
## uident list(attr)
## LR(1) items:
attrs(uident) -> uident list(attr) . [ UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC IN GHOST FLOAT CORE_UIDENT CORE_LIDENT ]
## Transitions:
## Reductions:
-- On UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC IN GHOST FLOAT CORE_UIDENT CORE_LIDENT
--   reduce production attrs(uident) -> uident list(attr)

State 709:
## Known stack suffix:
## LABEL attrs(uident)
## LR(1) items:
single_expr_ -> LABEL attrs(uident) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 710
## Reductions:

State 710:
## Known stack suffix:
## LABEL attrs(uident) IN
## LR(1) items:
single_expr_ -> LABEL attrs(uident) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 867
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 711:
## Known stack suffix:
## IF
## LR(1) items:
single_expr_ -> IF . seq_expr THEN contract_expr ELSE contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> IF . seq_expr THEN contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 862
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 712:
## Known stack suffix:
## GHOST
## LR(1) items:
single_expr_ -> GHOST . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 861
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 713:
## Known stack suffix:
## FUN
## LR(1) items:
single_expr_ -> FUN . binders spec ARROW spec seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On binders shift to state 714
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:

State 714:
## Known stack suffix:
## FUN binders
## LR(1) items:
single_expr_ -> FUN binders . spec ARROW spec seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 715
-- On single_spec shift to state 567
## Reductions:
-- On ARROW
--   reduce production spec ->

State 715:
## Known stack suffix:
## FUN binders spec
## LR(1) items:
single_expr_ -> FUN binders spec . ARROW spec seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On ARROW shift to state 716
## Reductions:

State 716:
## Known stack suffix:
## FUN binders spec ARROW
## LR(1) items:
single_expr_ -> FUN binders spec ARROW . spec seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 717
-- On single_spec shift to state 567
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production spec ->

State 717:
## Known stack suffix:
## FUN binders spec ARROW spec
## LR(1) items:
single_expr_ -> FUN binders spec ARROW spec . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 860
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 718:
## Known stack suffix:
## FOR
## LR(1) items:
single_expr_ -> FOR . lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_nq shift to state 719
-- On lident_keyword shift to state 75
## Reductions:

State 719:
## Known stack suffix:
## FOR lident_nq
## LR(1) items:
single_expr_ -> FOR lident_nq . EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On EQUAL shift to state 720
## Reductions:

State 720:
## Known stack suffix:
## FOR lident_nq EQUAL
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL . seq_expr for_direction seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 848
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 721:
## Known stack suffix:
## EXCEPTION
## LR(1) items:
single_expr_ -> EXCEPTION . attrs(uident) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> EXCEPTION . attrs(uident) return IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 707
-- On attrs(uident) shift to state 722
## Reductions:

State 722:
## Known stack suffix:
## EXCEPTION attrs(uident)
## LR(1) items:
single_expr_ -> EXCEPTION attrs(uident) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> EXCEPTION attrs(uident) . return IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 723
-- On LEFTBRC shift to state 83
-- On IN shift to state 725
-- On GHOST shift to state 191
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 193
-- On return shift to state 845
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 723:
## Known stack suffix:
## LEFTPAR
## LR(1) items:
return -> LEFTPAR . GHOST ty RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
return -> LEFTPAR . ret_ghost RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
ty_block -> LEFTPAR . comma_list2(ty) RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ARROW ]
ty_block -> LEFTPAR . RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ARROW ]
ty_block -> LEFTPAR . ty RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ARROW ]
## Transitions:
-- On UIDENT shift to state 1
-- On RIGHTPAR shift to state 81
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 724
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 169
-- On ret_ghost shift to state 178
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On comma_list2(ty) shift to state 111
## Reductions:

State 724:
## Known stack suffix:
## LEFTPAR GHOST
## LR(1) items:
ret_ghost -> GHOST . ty COMMA ret_rest [ RIGHTPAR ]
return -> LEFTPAR GHOST . ty RIGHTPAR [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 154
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 725:
## Known stack suffix:
## EXCEPTION attrs(uident) IN
## LR(1) items:
single_expr_ -> EXCEPTION attrs(uident) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 835
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 726:
## Known stack suffix:
## CONTINUE
## LR(1) items:
single_expr_ -> CONTINUE . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> CONTINUE . uident [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 727
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> CONTINUE

State 727:
## Known stack suffix:
## CONTINUE uident
## LR(1) items:
single_expr_ -> CONTINUE uident . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> CONTINUE uident

State 728:
## Known stack suffix:
## CHECK
## LR(1) items:
assertion_kind -> CHECK . [ LEFTBRC ]
## Transitions:
## Reductions:
-- On LEFTBRC
--   reduce production assertion_kind -> CHECK

State 729:
## Known stack suffix:
## BREAK
## LR(1) items:
single_expr_ -> BREAK . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> BREAK . uident [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 730
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> BREAK

State 730:
## Known stack suffix:
## BREAK uident
## LR(1) items:
single_expr_ -> BREAK uident . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> BREAK uident

State 731:
## Known stack suffix:
## ASSUME
## LR(1) items:
assertion_kind -> ASSUME . [ LEFTBRC ]
## Transitions:
## Reductions:
-- On LEFTBRC
--   reduce production assertion_kind -> ASSUME

State 732:
## Known stack suffix:
## ASSERT
## LR(1) items:
assertion_kind -> ASSERT . [ LEFTBRC ]
## Transitions:
## Reductions:
-- On LEFTBRC
--   reduce production assertion_kind -> ASSERT

State 733:
## Known stack suffix:
## ANY
## LR(1) items:
single_expr_ -> ANY . return_named spec [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 149
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 191
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 193
-- On return_named shift to state 734
-- On return shift to state 195
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 734:
## Known stack suffix:
## ANY return_named
## LR(1) items:
single_expr_ -> ANY return_named . spec [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 735
-- On single_spec shift to state 567
## Reductions:
-- On WITH VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP
--   reduce production spec ->

State 735:
## Known stack suffix:
## ANY return_named spec
## LR(1) items:
single_expr_ -> ANY return_named spec . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> ANY return_named spec

State 736:
## Known stack suffix:
## ABSURD
## LR(1) items:
single_expr_ -> ABSURD . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> ABSURD

State 737:
## Known stack suffix:
## uqualid
## LR(1) items:
expr_pure_ -> uqualid . DOT LEFTBRC ident RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> uqualid . DOT mk_expr(expr_block_) [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lqualid -> uqualid . DOT lident [ DOT ]
qualid -> uqualid . DOT ident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 738
## Reductions:

State 738:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
expr_pure_ -> uqualid DOT . LEFTBRC ident RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> uqualid DOT . mk_expr(expr_block_) [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lqualid -> uqualid DOT . lident [ DOT ]
qualid -> uqualid DOT . ident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 739
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uident shift to state 297
-- On mk_expr(expr_block_) shift to state 742
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 300
-- On ident shift to state 301
-- On expr_block_ shift to state 743
## Reductions:

State 739:
## Known stack suffix:
## uqualid DOT LEFTBRC
## LR(1) items:
expr_block_ -> LEFTBRC . field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> LEFTBRC . expr_arg WITH field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_pure_ -> uqualid DOT LEFTBRC . ident RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 740
-- On uident shift to state 302
-- On semicolon_list1(separated_pair(lqualid,EQUAL,expr)) shift to state 670
-- On qualid shift to state 744
-- On numeral shift to state 745
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 748
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 480
-- On ident shift to state 749
-- On field_list1(expr) shift to state 751
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 772
## Reductions:

State 740:
## Known stack suffix:
## uqualid
## LR(1) items:
expr_pure_ -> uqualid . DOT LEFTBRC ident RIGHTBRC [ WITH LEFTSQ DOT ]
expr_sub_ -> uqualid . DOT mk_expr(expr_block_) [ WITH LEFTSQ DOT ]
lqualid -> uqualid . DOT lident [ EQUAL DOT ]
qualid -> uqualid . DOT ident [ WITH RIGHTBRC LEFTSQ ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 741
## Reductions:

State 741:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
expr_pure_ -> uqualid DOT . LEFTBRC ident RIGHTBRC [ WITH LEFTSQ DOT ]
expr_sub_ -> uqualid DOT . mk_expr(expr_block_) [ WITH LEFTSQ DOT ]
lqualid -> uqualid DOT . lident [ EQUAL DOT ]
qualid -> uqualid DOT . ident [ WITH RIGHTBRC LEFTSQ ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 739
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uident shift to state 297
-- On mk_expr(expr_block_) shift to state 742
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 468
-- On ident shift to state 301
-- On expr_block_ shift to state 743
## Reductions:

State 742:
## Known stack suffix:
## uqualid DOT mk_expr(expr_block_)
## LR(1) items:
expr_sub_ -> uqualid DOT mk_expr(expr_block_) . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_sub_ -> uqualid DOT mk_expr(expr_block_)

State 743:
## Known stack suffix:
## expr_block_
## LR(1) items:
mk_expr(expr_block_) -> expr_block_ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production mk_expr(expr_block_) -> expr_block_

State 744:
## Known stack suffix:
## qualid
## LR(1) items:
expr_arg_ -> qualid . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_arg_ -> qualid

State 745:
## Known stack suffix:
## numeral
## LR(1) items:
expr_arg_ -> numeral . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_arg_ -> numeral

State 746:
## Known stack suffix:
## mk_expr(expr_dot_)
## LR(1) items:
expr_dot -> mk_expr(expr_dot_) . [ DOT ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production expr_dot -> mk_expr(expr_dot_)

State 747:
## Known stack suffix:
## mk_expr(expr_arg_)
## LR(1) items:
expr_arg -> mk_expr(expr_arg_) . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_arg -> mk_expr(expr_arg_)

State 748:
## Known stack suffix:
## lqualid
## LR(1) items:
expr_dot_ -> lqualid . [ DOT ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
## Transitions:
-- On EQUAL shift to state 672
## Reductions:
-- On DOT
--   reduce production expr_dot_ -> lqualid

State 749:
## Known stack suffix:
## uqualid DOT LEFTBRC ident
## LR(1) items:
expr_pure_ -> uqualid DOT LEFTBRC ident . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
qualid -> ident . [ WITH LEFTSQ ]
## Transitions:
-- On RIGHTBRC shift to state 750
## Reductions:
-- On WITH LEFTSQ
--   reduce production qualid -> ident

State 750:
## Known stack suffix:
## uqualid DOT LEFTBRC ident RIGHTBRC
## LR(1) items:
expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_pure_ -> uqualid DOT LEFTBRC ident RIGHTBRC

State 751:
## Known stack suffix:
## LEFTBRC field_list1(expr)
## LR(1) items:
expr_block_ -> LEFTBRC field_list1(expr) . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 752
## Reductions:

State 752:
## Known stack suffix:
## LEFTBRC field_list1(expr) RIGHTBRC
## LR(1) items:
expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_block_ -> LEFTBRC field_list1(expr) RIGHTBRC

State 753:
## Known stack suffix:
## expr_sub_
## LR(1) items:
expr_arg_ -> expr_sub_ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_dot_ -> expr_sub_ . [ DOT ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_arg_ -> expr_sub_
-- On DOT
--   reduce production expr_dot_ -> expr_sub_

State 754:
## Known stack suffix:
## expr_pure_
## LR(1) items:
expr_sub_ -> expr_pure_ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_sub_ -> expr_pure_

State 755:
## Known stack suffix:
## expr_dot_
## LR(1) items:
mk_expr(expr_dot_) -> expr_dot_ . [ DOT ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production mk_expr(expr_dot_) -> expr_dot_

State 756:
## Known stack suffix:
## expr_dot
## LR(1) items:
expr_sub_ -> expr_dot . DOT mk_expr(expr_pure_) [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_dot . DOT lqualid_rich [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On DOT shift to state 757
## Reductions:

State 757:
## Known stack suffix:
## expr_dot DOT
## LR(1) items:
expr_sub_ -> expr_dot DOT . mk_expr(expr_pure_) [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_dot DOT . lqualid_rich [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On LEFTBRC shift to state 758
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 763
-- On uident shift to state 89
-- On mk_expr(expr_pure_) shift to state 767
-- On lqualid_rich shift to state 768
-- On lident_op shift to state 312
-- On lident_keyword shift to state 43
-- On lident shift to state 313
-- On expr_pure_ shift to state 769
## Reductions:

State 758:
## Known stack suffix:
## LEFTBRC
## LR(1) items:
expr_pure_ -> LEFTBRC . qualid RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 761
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 759:
## Known stack suffix:
## uqualid
## LR(1) items:
qualid -> uqualid . DOT ident [ VAL USE TYPE SCOPE RIGHTBRC QUOTE_LIDENT PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 760
## Reductions:

State 760:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
qualid -> uqualid DOT . ident [ VAL USE TYPE SCOPE RIGHTBRC QUOTE_LIDENT PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 297
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 301
## Reductions:

State 761:
## Known stack suffix:
## LEFTBRC qualid
## LR(1) items:
expr_pure_ -> LEFTBRC qualid . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 762
## Reductions:

State 762:
## Known stack suffix:
## LEFTBRC qualid RIGHTBRC
## LR(1) items:
expr_pure_ -> LEFTBRC qualid RIGHTBRC . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_pure_ -> LEFTBRC qualid RIGHTBRC

State 763:
## Known stack suffix:
## uqualid
## LR(1) items:
expr_pure_ -> uqualid . DOT LEFTBRC ident RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lqualid_rich -> uqualid . DOT lident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lqualid_rich -> uqualid . DOT lident_op [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
uqualid -> uqualid . DOT uident [ DOT ]
## Transitions:
-- On DOT shift to state 764
## Reductions:

State 764:
## Known stack suffix:
## uqualid DOT
## LR(1) items:
expr_pure_ -> uqualid DOT . LEFTBRC ident RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lqualid_rich -> uqualid DOT . lident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
lqualid_rich -> uqualid DOT . lident_op [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
uqualid -> uqualid DOT . uident [ DOT ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On LEFTBRC shift to state 765
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 86
-- On lident_op shift to state 309
-- On lident_keyword shift to state 43
-- On lident shift to state 310
## Reductions:

State 765:
## Known stack suffix:
## uqualid DOT LEFTBRC
## LR(1) items:
expr_pure_ -> uqualid DOT LEFTBRC . ident RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 40
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 766
## Reductions:

State 766:
## Known stack suffix:
## uqualid DOT LEFTBRC ident
## LR(1) items:
expr_pure_ -> uqualid DOT LEFTBRC ident . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 750
## Reductions:

State 767:
## Known stack suffix:
## expr_dot DOT mk_expr(expr_pure_)
## LR(1) items:
expr_sub_ -> expr_dot DOT mk_expr(expr_pure_) . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_sub_ -> expr_dot DOT mk_expr(expr_pure_)

State 768:
## Known stack suffix:
## expr_dot DOT lqualid_rich
## LR(1) items:
expr_sub_ -> expr_dot DOT lqualid_rich . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_sub_ -> expr_dot DOT lqualid_rich

State 769:
## Known stack suffix:
## expr_pure_
## LR(1) items:
mk_expr(expr_pure_) -> expr_pure_ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production mk_expr(expr_pure_) -> expr_pure_

State 770:
## Known stack suffix:
## expr_block_
## LR(1) items:
expr_sub_ -> expr_block_ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_sub_ -> expr_block_

State 771:
## Known stack suffix:
## expr_arg_
## LR(1) items:
mk_expr(expr_arg_) -> expr_arg_ . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production mk_expr(expr_arg_) -> expr_arg_

State 772:
## Known stack suffix:
## LEFTBRC expr_arg
## LR(1) items:
expr_block_ -> LEFTBRC expr_arg . WITH field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr rightsq [ WITH LEFTSQ DOT ]
expr_sub_ -> expr_arg . LEFTSQ expr LARROW expr rightsq [ WITH LEFTSQ DOT ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT expr rightsq [ WITH LEFTSQ DOT ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT rightsq [ WITH LEFTSQ DOT ]
expr_sub_ -> expr_arg . LEFTSQ DOTDOT expr rightsq [ WITH LEFTSQ DOT ]
## Transitions:
-- On WITH shift to state 773
-- On LEFTSQ shift to state 776
## Reductions:

State 773:
## Known stack suffix:
## LEFTBRC expr_arg WITH
## LR(1) items:
expr_block_ -> LEFTBRC expr_arg WITH . field_list1(expr) RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,expr)) shift to state 670
-- On lqualid shift to state 671
-- On lident_keyword shift to state 43
-- On lident shift to state 101
-- On field_list1(expr) shift to state 774
## Reductions:

State 774:
## Known stack suffix:
## LEFTBRC expr_arg WITH field_list1(expr)
## LR(1) items:
expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 775
## Reductions:

State 775:
## Known stack suffix:
## LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC
## LR(1) items:
expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_block_ -> LEFTBRC expr_arg WITH field_list1(expr) RIGHTBRC

State 776:
## Known stack suffix:
## expr_arg LEFTSQ
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ . expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ . expr LARROW expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ . expr DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ . expr DOTDOT rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ . DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On DOTDOT shift to state 777
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 826
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 777:
## Known stack suffix:
## expr_arg LEFTSQ DOTDOT
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ DOTDOT . expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 824
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 778:
## Known stack suffix:
## single_expr_
## LR(1) items:
mk_expr(single_expr_) -> single_expr_ . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production mk_expr(single_expr_) -> single_expr_

State 779:
## Known stack suffix:
## single_expr
## LR(1) items:
expr -> single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
expr -> single_expr . COMMA expr_list1 [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On COMMA shift to state 819
-- On COLON shift to state 132
-- On BARBAR shift to state 815
-- On AMPAMP shift to state 817
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COINDUCTIVE CLONE BAR AXIOM ALIAS
--   reduce production expr -> single_expr

State 780:
## Known stack suffix:
## single_expr OP4
## LR(1) items:
single_expr_ -> single_expr OP4 . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 781
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 781:
## Known stack suffix:
## single_expr OP4 single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr OP4 single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> single_expr OP4 single_expr

State 782:
## Known stack suffix:
## single_expr cast
## LR(1) items:
single_expr_ -> single_expr cast . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> single_expr cast

State 783:
## Known stack suffix:
## prefix_op
## LR(1) items:
single_expr_ -> prefix_op . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 784
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 784:
## Known stack suffix:
## prefix_op single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> prefix_op single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> prefix_op single_expr

State 785:
## Known stack suffix:
## mk_expr(single_expr_)
## LR(1) items:
single_expr -> mk_expr(single_expr_) . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr -> mk_expr(single_expr_)

State 786:
## Known stack suffix:
## lqualid
## LR(1) items:
expr_dot_ -> lqualid . [ DOT ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production expr_dot_ -> lqualid

State 787:
## Known stack suffix:
## expr_arg_
## LR(1) items:
mk_expr(expr_arg_) -> expr_arg_ . [ UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTSQ LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN ]
single_expr_ -> expr_arg_ . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTSQ LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
--   reduce production mk_expr(expr_arg_) -> expr_arg_
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> expr_arg_

State 788:
## Known stack suffix:
## expr_arg
## LR(1) items:
expr_sub_ -> expr_arg . LEFTSQ expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr LARROW expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> expr_arg . nonempty_list(located(expr_arg)) [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTSQ shift to state 776
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On qualid shift to state 744
-- On numeral shift to state 745
-- On nonempty_list(located(expr_arg)) shift to state 789
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On located(expr_arg) shift to state 790
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 792
## Reductions:

State 789:
## Known stack suffix:
## expr_arg nonempty_list(located(expr_arg))
## LR(1) items:
single_expr_ -> expr_arg nonempty_list(located(expr_arg)) . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> expr_arg nonempty_list(located(expr_arg))

State 790:
## Known stack suffix:
## located(expr_arg)
## LR(1) items:
nonempty_list(located(expr_arg)) -> located(expr_arg) . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
nonempty_list(located(expr_arg)) -> located(expr_arg) . nonempty_list(located(expr_arg)) [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On qualid shift to state 744
-- On numeral shift to state 745
-- On nonempty_list(located(expr_arg)) shift to state 791
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On located(expr_arg) shift to state 790
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 792
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production nonempty_list(located(expr_arg)) -> located(expr_arg)

State 791:
## Known stack suffix:
## located(expr_arg) nonempty_list(located(expr_arg))
## LR(1) items:
nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg)) . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production nonempty_list(located(expr_arg)) -> located(expr_arg) nonempty_list(located(expr_arg))

State 792:
## Known stack suffix:
## expr_arg
## LR(1) items:
expr_sub_ -> expr_arg . LEFTSQ expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr LARROW expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
located(expr_arg) -> expr_arg . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On LEFTSQ shift to state 776
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production located(expr_arg) -> expr_arg

State 793:
## Known stack suffix:
## attr
## LR(1) items:
single_expr_ -> attr . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 794
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 794:
## Known stack suffix:
## attr single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> attr single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On COLON shift to state 132
-- On BARBAR shift to state 815
-- On AMPAMP shift to state 817
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COINDUCTIVE CLONE BAR AXIOM ALIAS
--   reduce production single_expr_ -> attr single_expr

State 795:
## Known stack suffix:
## single_expr OP3
## LR(1) items:
single_expr_ -> single_expr OP3 . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 796
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 796:
## Known stack suffix:
## single_expr OP3 single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr OP3 single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> single_expr OP3 single_expr

State 797:
## Known stack suffix:
## assertion_kind
## LR(1) items:
single_expr_ -> assertion_kind . LEFTBRC term RIGHTBRC [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On LEFTBRC shift to state 798
## Reductions:

State 798:
## Known stack suffix:
## assertion_kind LEFTBRC
## LR(1) items:
single_expr_ -> assertion_kind LEFTBRC . term RIGHTBRC [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 799
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 799:
## Known stack suffix:
## assertion_kind LEFTBRC term
## LR(1) items:
single_expr_ -> assertion_kind LEFTBRC term . RIGHTBRC [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 800
## Reductions:

State 800:
## Known stack suffix:
## assertion_kind LEFTBRC term RIGHTBRC
## LR(1) items:
single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> assertion_kind LEFTBRC term RIGHTBRC

State 801:
## Known stack suffix:
## single_expr OP2
## LR(1) items:
single_expr_ -> single_expr OP2 . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 802
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 802:
## Known stack suffix:
## single_expr OP2 single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr OP2 single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> single_expr OP2 single_expr

State 803:
## Known stack suffix:
## single_expr OP1
## LR(1) items:
single_expr_ -> single_expr OP1 . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 804
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 804:
## Known stack suffix:
## single_expr OP1 single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr OP1 single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> single_expr OP1 single_expr

State 805:
## Known stack suffix:
## single_expr MINUS
## LR(1) items:
single_expr_ -> single_expr MINUS . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 806
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 806:
## Known stack suffix:
## single_expr MINUS single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr MINUS single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> single_expr MINUS single_expr

State 807:
## Known stack suffix:
## single_expr LTGT
## LR(1) items:
single_expr_ -> single_expr LTGT . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 808
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 808:
## Known stack suffix:
## single_expr LTGT single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr LTGT single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> single_expr LTGT single_expr

State 809:
## Known stack suffix:
## single_expr LT
## LR(1) items:
single_expr_ -> single_expr LT . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 810
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 810:
## Known stack suffix:
## single_expr LT single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr LT single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> single_expr LT single_expr

State 811:
## Known stack suffix:
## single_expr GT
## LR(1) items:
single_expr_ -> single_expr GT . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 812
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 812:
## Known stack suffix:
## single_expr GT single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr GT single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> single_expr GT single_expr

State 813:
## Known stack suffix:
## single_expr EQUAL
## LR(1) items:
single_expr_ -> single_expr EQUAL . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 814
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 814:
## Known stack suffix:
## single_expr EQUAL single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr EQUAL single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> single_expr EQUAL single_expr

State 815:
## Known stack suffix:
## single_expr BARBAR
## LR(1) items:
single_expr_ -> single_expr BARBAR . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 816
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 816:
## Known stack suffix:
## single_expr BARBAR single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr BARBAR single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On BARBAR shift to state 815
-- On AMPAMP shift to state 817
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BAR AXIOM ALIAS
--   reduce production single_expr_ -> single_expr BARBAR single_expr

State 817:
## Known stack suffix:
## single_expr AMPAMP
## LR(1) items:
single_expr_ -> single_expr AMPAMP . single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 818
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 818:
## Known stack suffix:
## single_expr AMPAMP single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr AMPAMP single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On AMPAMP shift to state 817
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ALIAS
--   reduce production single_expr_ -> single_expr AMPAMP single_expr

State 819:
## Known stack suffix:
## single_expr COMMA
## LR(1) items:
expr -> single_expr COMMA . expr_list1 [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 820
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_list1 shift to state 823
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 820:
## Known stack suffix:
## single_expr
## LR(1) items:
expr_list1 -> single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_list1 -> single_expr . COMMA expr_list1 [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On COMMA shift to state 821
-- On COLON shift to state 132
-- On BARBAR shift to state 815
-- On AMPAMP shift to state 817
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COINDUCTIVE CLONE BAR AXIOM ALIAS
--   reduce production expr_list1 -> single_expr

State 821:
## Known stack suffix:
## single_expr COMMA
## LR(1) items:
expr_list1 -> single_expr COMMA . expr_list1 [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 820
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_list1 shift to state 822
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 822:
## Known stack suffix:
## single_expr COMMA expr_list1
## LR(1) items:
expr_list1 -> single_expr COMMA expr_list1 . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_list1 -> single_expr COMMA expr_list1

State 823:
## Known stack suffix:
## single_expr COMMA expr_list1
## LR(1) items:
expr -> single_expr COMMA expr_list1 . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr -> single_expr COMMA expr_list1

State 824:
## Known stack suffix:
## expr_arg LEFTSQ DOTDOT expr
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ DOTDOT expr . rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 825
## Reductions:

State 825:
## Known stack suffix:
## expr_arg LEFTSQ DOTDOT expr rightsq
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_sub_ -> expr_arg LEFTSQ DOTDOT expr rightsq

State 826:
## Known stack suffix:
## expr_arg LEFTSQ expr
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr . rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ expr . LARROW expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ expr . DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ expr . DOTDOT rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On LARROW shift to state 827
-- On DOTDOT shift to state 830
-- On rightsq shift to state 834
## Reductions:

State 827:
## Known stack suffix:
## expr_arg LEFTSQ expr LARROW
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr LARROW . expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 828
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 828:
## Known stack suffix:
## expr_arg LEFTSQ expr LARROW expr
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr LARROW expr . rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 829
## Reductions:

State 829:
## Known stack suffix:
## expr_arg LEFTSQ expr LARROW expr rightsq
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_sub_ -> expr_arg LEFTSQ expr LARROW expr rightsq

State 830:
## Known stack suffix:
## expr_arg LEFTSQ expr DOTDOT
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr DOTDOT . expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg LEFTSQ expr DOTDOT . rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On rightsq shift to state 831
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 832
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 831:
## Known stack suffix:
## expr_arg LEFTSQ expr DOTDOT rightsq
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT rightsq

State 832:
## Known stack suffix:
## expr_arg LEFTSQ expr DOTDOT expr
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr . rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTSQ_QUOTE shift to state 18
-- On RIGHTSQ shift to state 19
-- On rightsq shift to state 833
## Reductions:

State 833:
## Known stack suffix:
## expr_arg LEFTSQ expr DOTDOT expr rightsq
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_sub_ -> expr_arg LEFTSQ expr DOTDOT expr rightsq

State 834:
## Known stack suffix:
## expr_arg LEFTSQ expr rightsq
## LR(1) items:
expr_sub_ -> expr_arg LEFTSQ expr rightsq . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_sub_ -> expr_arg LEFTSQ expr rightsq

State 835:
## Known stack suffix:
## EXCEPTION attrs(uident) IN seq_expr
## LR(1) items:
single_expr_ -> EXCEPTION attrs(uident) IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> EXCEPTION attrs(uident) IN seq_expr

State 836:
## Known stack suffix:
## expr
## LR(1) items:
assign_expr -> expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
assign_expr -> expr . LARROW expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On LARROW shift to state 837
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production assign_expr -> expr

State 837:
## Known stack suffix:
## expr LARROW
## LR(1) items:
assign_expr -> expr LARROW . expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 838
-- On attr shift to state 793
-- On assertion_kind shift to state 797
## Reductions:

State 838:
## Known stack suffix:
## expr LARROW expr
## LR(1) items:
assign_expr -> expr LARROW expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production assign_expr -> expr LARROW expr

State 839:
## Known stack suffix:
## contract_expr
## LR(1) items:
seq_expr -> contract_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
seq_expr -> contract_expr . SEMICOLON [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
seq_expr -> contract_expr . SEMICOLON seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On SEMICOLON shift to state 840
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production seq_expr -> contract_expr

State 840:
## Known stack suffix:
## contract_expr SEMICOLON
## LR(1) items:
seq_expr -> contract_expr SEMICOLON . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
seq_expr -> contract_expr SEMICOLON . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 841
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:
-- On WRITES WITH VARIANT USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LTGT LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production seq_expr -> contract_expr SEMICOLON

State 841:
## Known stack suffix:
## contract_expr SEMICOLON seq_expr
## LR(1) items:
seq_expr -> contract_expr SEMICOLON seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production seq_expr -> contract_expr SEMICOLON seq_expr

State 842:
## Known stack suffix:
## assign_expr
## LR(1) items:
contract_expr -> assign_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
contract_expr -> assign_expr . single_spec spec [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On single_spec shift to state 843
## Reductions:
-- On WITH VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP
--   reduce production contract_expr -> assign_expr

State 843:
## Known stack suffix:
## assign_expr single_spec
## LR(1) items:
contract_expr -> assign_expr single_spec . spec [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 844
-- On single_spec shift to state 567
## Reductions:
-- On WITH VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP
--   reduce production spec ->

State 844:
## Known stack suffix:
## assign_expr single_spec spec
## LR(1) items:
contract_expr -> assign_expr single_spec spec . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production contract_expr -> assign_expr single_spec spec

State 845:
## Known stack suffix:
## EXCEPTION attrs(uident) return
## LR(1) items:
single_expr_ -> EXCEPTION attrs(uident) return . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 846
## Reductions:

State 846:
## Known stack suffix:
## EXCEPTION attrs(uident) return IN
## LR(1) items:
single_expr_ -> EXCEPTION attrs(uident) return IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 847
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 847:
## Known stack suffix:
## EXCEPTION attrs(uident) return IN seq_expr
## LR(1) items:
single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> EXCEPTION attrs(uident) return IN seq_expr

State 848:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr . for_direction seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On TO shift to state 849
-- On DOWNTO shift to state 850
-- On for_direction shift to state 851
## Reductions:

State 849:
## Known stack suffix:
## TO
## LR(1) items:
for_direction -> TO . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production for_direction -> TO

State 850:
## Known stack suffix:
## DOWNTO
## LR(1) items:
for_direction -> DOWNTO . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production for_direction -> DOWNTO

State 851:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr for_direction
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction . seq_expr DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 852
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 852:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr . DO list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On DO shift to state 853
## Reductions:

State 853:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr DO
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO . list(invariant) loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On INVARIANT shift to state 663
-- On list(invariant) shift to state 854
-- On invariant shift to state 858
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production list(invariant) ->

State 854:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant)
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) . loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 855
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On loop_body shift to state 856
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:
-- On DONE
--   reduce production loop_body ->

State 855:
## Known stack suffix:
## seq_expr
## LR(1) items:
loop_body -> seq_expr . [ DONE ]
## Transitions:
## Reductions:
-- On DONE
--   reduce production loop_body -> seq_expr

State 856:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body . DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On DONE shift to state 857
## Reductions:

State 857:
## Known stack suffix:
## FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE
## LR(1) items:
single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> FOR lident_nq EQUAL seq_expr for_direction seq_expr DO list(invariant) loop_body DONE

State 858:
## Known stack suffix:
## invariant
## LR(1) items:
list(invariant) -> invariant . list(invariant) [ WITH WHILE VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On INVARIANT shift to state 663
-- On list(invariant) shift to state 859
-- On invariant shift to state 858
## Reductions:
-- On WITH WHILE VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production list(invariant) ->

State 859:
## Known stack suffix:
## invariant list(invariant)
## LR(1) items:
list(invariant) -> invariant list(invariant) . [ WITH WHILE VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WITH WHILE VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production list(invariant) -> invariant list(invariant)

State 860:
## Known stack suffix:
## FUN binders spec ARROW spec seq_expr
## LR(1) items:
single_expr_ -> FUN binders spec ARROW spec seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> FUN binders spec ARROW spec seq_expr

State 861:
## Known stack suffix:
## GHOST single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> GHOST single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On COLON shift to state 132
-- On BARBAR shift to state 815
-- On AMPAMP shift to state 817
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COINDUCTIVE CLONE BAR AXIOM ALIAS
--   reduce production single_expr_ -> GHOST single_expr

State 862:
## Known stack suffix:
## IF seq_expr
## LR(1) items:
single_expr_ -> IF seq_expr . THEN contract_expr ELSE contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> IF seq_expr . THEN contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On THEN shift to state 863
## Reductions:

State 863:
## Known stack suffix:
## IF seq_expr THEN
## LR(1) items:
single_expr_ -> IF seq_expr THEN . contract_expr ELSE contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> IF seq_expr THEN . contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 864
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 864:
## Known stack suffix:
## IF seq_expr THEN contract_expr
## LR(1) items:
single_expr_ -> IF seq_expr THEN contract_expr . ELSE contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> IF seq_expr THEN contract_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On ELSE shift to state 865
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> IF seq_expr THEN contract_expr

State 865:
## Known stack suffix:
## IF seq_expr THEN contract_expr ELSE
## LR(1) items:
single_expr_ -> IF seq_expr THEN contract_expr ELSE . contract_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 866
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 866:
## Known stack suffix:
## IF seq_expr THEN contract_expr ELSE contract_expr
## LR(1) items:
single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> IF seq_expr THEN contract_expr ELSE contract_expr

State 867:
## Known stack suffix:
## LABEL attrs(uident) IN seq_expr
## LR(1) items:
single_expr_ -> LABEL attrs(uident) IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> LABEL attrs(uident) IN seq_expr

State 868:
## Known stack suffix:
## LET REC with_list1(rec_defn) IN seq_expr
## LR(1) items:
single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> LET REC with_list1(rec_defn) IN seq_expr

State 869:
## Known stack suffix:
## separated_nonempty_list(WITH,rec_defn)
## LR(1) items:
with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)

State 870:
## Known stack suffix:
## rec_defn
## LR(1) items:
separated_nonempty_list(WITH,rec_defn) -> rec_defn . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(WITH,rec_defn) -> rec_defn . WITH separated_nonempty_list(WITH,rec_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 871
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn

State 871:
## Known stack suffix:
## rec_defn WITH
## LR(1) items:
separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH . separated_nonempty_list(WITH,rec_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On GHOST shift to state 53
-- On separated_nonempty_list(WITH,rec_defn) shift to state 872
-- On rec_defn shift to state 870
-- On ghost shift to state 873
## Reductions:
-- On RANGE PREDICATE LIDENT LEMMA LEFTPAR FUNCTION FLOAT CORE_LIDENT CONSTANT
--   reduce production ghost ->

State 872:
## Known stack suffix:
## rec_defn WITH separated_nonempty_list(WITH,rec_defn)
## LR(1) items:
separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH separated_nonempty_list(WITH,rec_defn)

State 873:
## Known stack suffix:
## ghost
## LR(1) items:
rec_defn -> ghost . kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On PREDICATE shift to state 55
-- On LEMMA shift to state 56
-- On FUNCTION shift to state 57
-- On CONSTANT shift to state 58
-- On kind shift to state 874
## Reductions:
-- On RANGE LIDENT LEFTPAR FLOAT CORE_LIDENT
--   reduce production kind ->

State 874:
## Known stack suffix:
## ghost kind
## LR(1) items:
rec_defn -> ghost kind . attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On attrs(lident_rich) shift to state 875
## Reductions:

State 875:
## Known stack suffix:
## ghost kind attrs(lident_rich)
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) . binders return_opt spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On binders shift to state 876
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:

State 876:
## Known stack suffix:
## ghost kind attrs(lident_rich) binders
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) binders . return_opt spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 148
-- On return_opt shift to state 877
## Reductions:
-- On WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES ALIAS
--   reduce production return_opt ->

State 877:
## Known stack suffix:
## ghost kind attrs(lident_rich) binders return_opt
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) binders return_opt . spec EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 878
-- On single_spec shift to state 567
## Reductions:
-- On EQUAL
--   reduce production spec ->

State 878:
## Known stack suffix:
## ghost kind attrs(lident_rich) binders return_opt spec
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec . EQUAL spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 879
## Reductions:

State 879:
## Known stack suffix:
## ghost kind attrs(lident_rich) binders return_opt spec EQUAL
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL . spec seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 880
-- On single_spec shift to state 567
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production spec ->

State 880:
## Known stack suffix:
## ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec . seq_expr [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 881
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 881:
## Known stack suffix:
## ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr
## LR(1) items:
rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production rec_defn -> ghost kind attrs(lident_rich) binders return_opt spec EQUAL spec seq_expr

State 882:
## Known stack suffix:
## LET ghost
## LR(1) items:
single_expr_ -> LET ghost . kind let_pattern EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost . kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost . kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost . kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On PREDICATE shift to state 55
-- On LEMMA shift to state 56
-- On FUNCTION shift to state 57
-- On CONSTANT shift to state 58
-- On kind shift to state 883
## Reductions:
-- On UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
--   reduce production kind ->

State 883:
## Known stack suffix:
## LET ghost kind
## LR(1) items:
single_expr_ -> LET ghost kind . let_pattern EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost kind . attrs(lident_op_nq) EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost kind . attrs(lident_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost kind . attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 217
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 884
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 886
-- On mk_pat(let_pattern_) shift to state 887
-- On mk_pat(let_pat_uni_) shift to state 888
-- On mk_pat(let_pat_conj_) shift to state 895
-- On lident_op_nq shift to state 429
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On let_pattern_ shift to state 898
-- On let_pattern shift to state 899
-- On let_pat_uni_ shift to state 904
-- On let_pat_conj_ shift to state 905
-- On attrs(lident_op_nq) shift to state 906
-- On attrs(lident_nq) shift to state 921
## Reductions:

State 884:
## Known stack suffix:
## uqualid
## LR(1) items:
let_pat_uni_ -> uqualid . nonempty_list(pat_arg) [ EQUAL COMMA COLON BAR AS ]
pat_arg_ -> uqualid . [ EQUAL COMMA COLON BAR AS ]
pat_arg_ -> uqualid . DOT mk_pat(pat_block_) [ EQUAL COMMA COLON BAR AS ]
uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On DOT shift to state 228
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 231
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 233
-- On pat_arg shift to state 234
-- On nonempty_list(pat_arg) shift to state 885
-- On mk_pat(pat_arg_) shift to state 236
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:
-- On EQUAL COMMA COLON BAR AS
--   reduce production pat_arg_ -> uqualid

State 885:
## Known stack suffix:
## uqualid nonempty_list(pat_arg)
## LR(1) items:
let_pat_uni_ -> uqualid nonempty_list(pat_arg) . [ EQUAL COMMA COLON BAR AS ]
## Transitions:
## Reductions:
-- On EQUAL COMMA COLON BAR AS
--   reduce production let_pat_uni_ -> uqualid nonempty_list(pat_arg)

State 886:
## Known stack suffix:
## pat_arg_
## LR(1) items:
let_pat_uni_ -> pat_arg_ . [ EQUAL COMMA COLON BAR AS ]
## Transitions:
## Reductions:
-- On EQUAL COMMA COLON BAR AS
--   reduce production let_pat_uni_ -> pat_arg_

State 887:
## Known stack suffix:
## mk_pat(let_pattern_)
## LR(1) items:
let_pattern -> mk_pat(let_pattern_) . [ EQUAL ]
## Transitions:
## Reductions:
-- On EQUAL
--   reduce production let_pattern -> mk_pat(let_pattern_)

State 888:
## Known stack suffix:
## mk_pat(let_pat_uni_)
## LR(1) items:
let_pat_conj_ -> mk_pat(let_pat_uni_) . COMMA comma_list1(mk_pat(pat_uni_)) [ EQUAL BAR ]
let_pat_uni_ -> mk_pat(let_pat_uni_) . AS ghost attrs(lident_nq) [ EQUAL COMMA COLON BAR AS ]
let_pat_uni_ -> mk_pat(let_pat_uni_) . cast [ EQUAL COMMA COLON BAR AS ]
## Transitions:
-- On COMMA shift to state 889
-- On COLON shift to state 132
-- On AS shift to state 891
-- On cast shift to state 894
## Reductions:

State 889:
## Known stack suffix:
## mk_pat(let_pat_uni_) COMMA
## LR(1) items:
let_pat_conj_ -> mk_pat(let_pat_uni_) COMMA . comma_list1(mk_pat(pat_uni_)) [ EQUAL BAR ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On separated_nonempty_list(COMMA,mk_pat(pat_uni_)) shift to state 252
-- On pat_uni_ shift to state 239
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pat_uni_) shift to state 253
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list1(mk_pat(pat_uni_)) shift to state 890
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 890:
## Known stack suffix:
## mk_pat(let_pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))
## LR(1) items:
let_pat_conj_ -> mk_pat(let_pat_uni_) COMMA comma_list1(mk_pat(pat_uni_)) . [ EQUAL BAR ]
## Transitions:
## Reductions:
-- On EQUAL BAR
--   reduce production let_pat_conj_ -> mk_pat(let_pat_uni_) COMMA comma_list1(mk_pat(pat_uni_))

State 891:
## Known stack suffix:
## mk_pat(let_pat_uni_) AS
## LR(1) items:
let_pat_uni_ -> mk_pat(let_pat_uni_) AS . ghost attrs(lident_nq) [ EQUAL COMMA COLON BAR AS ]
## Transitions:
-- On GHOST shift to state 53
-- On ghost shift to state 892
## Reductions:
-- On RANGE LIDENT FLOAT CORE_LIDENT
--   reduce production ghost ->

State 892:
## Known stack suffix:
## mk_pat(let_pat_uni_) AS ghost
## LR(1) items:
let_pat_uni_ -> mk_pat(let_pat_uni_) AS ghost . attrs(lident_nq) [ EQUAL COMMA COLON BAR AS ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 893
## Reductions:

State 893:
## Known stack suffix:
## mk_pat(let_pat_uni_) AS ghost attrs(lident_nq)
## LR(1) items:
let_pat_uni_ -> mk_pat(let_pat_uni_) AS ghost attrs(lident_nq) . [ EQUAL COMMA COLON BAR AS ]
## Transitions:
## Reductions:
-- On EQUAL COMMA COLON BAR AS
--   reduce production let_pat_uni_ -> mk_pat(let_pat_uni_) AS ghost attrs(lident_nq)

State 894:
## Known stack suffix:
## mk_pat(let_pat_uni_) cast
## LR(1) items:
let_pat_uni_ -> mk_pat(let_pat_uni_) cast . [ EQUAL COMMA COLON BAR AS ]
## Transitions:
## Reductions:
-- On EQUAL COMMA COLON BAR AS
--   reduce production let_pat_uni_ -> mk_pat(let_pat_uni_) cast

State 895:
## Known stack suffix:
## mk_pat(let_pat_conj_)
## LR(1) items:
let_pattern_ -> mk_pat(let_pat_conj_) . BAR pattern [ EQUAL ]
## Transitions:
-- On BAR shift to state 896
## Reductions:

State 896:
## Known stack suffix:
## mk_pat(let_pat_conj_) BAR
## LR(1) items:
let_pattern_ -> mk_pat(let_pat_conj_) BAR . pattern [ EQUAL ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 897
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 897:
## Known stack suffix:
## mk_pat(let_pat_conj_) BAR pattern
## LR(1) items:
let_pattern_ -> mk_pat(let_pat_conj_) BAR pattern . [ EQUAL ]
## Transitions:
## Reductions:
-- On EQUAL
--   reduce production let_pattern_ -> mk_pat(let_pat_conj_) BAR pattern

State 898:
## Known stack suffix:
## let_pattern_
## LR(1) items:
mk_pat(let_pattern_) -> let_pattern_ . [ EQUAL ]
## Transitions:
## Reductions:
-- On EQUAL
--   reduce production mk_pat(let_pattern_) -> let_pattern_

State 899:
## Known stack suffix:
## LET ghost kind let_pattern
## LR(1) items:
single_expr_ -> LET ghost kind let_pattern . EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On EQUAL shift to state 900
## Reductions:

State 900:
## Known stack suffix:
## LET ghost kind let_pattern EQUAL
## LR(1) items:
single_expr_ -> LET ghost kind let_pattern EQUAL . seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 901
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 901:
## Known stack suffix:
## LET ghost kind let_pattern EQUAL seq_expr
## LR(1) items:
single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 902
## Reductions:

State 902:
## Known stack suffix:
## LET ghost kind let_pattern EQUAL seq_expr IN
## LR(1) items:
single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 903
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 903:
## Known stack suffix:
## LET ghost kind let_pattern EQUAL seq_expr IN seq_expr
## LR(1) items:
single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> LET ghost kind let_pattern EQUAL seq_expr IN seq_expr

State 904:
## Known stack suffix:
## let_pat_uni_
## LR(1) items:
let_pat_conj_ -> let_pat_uni_ . [ EQUAL BAR ]
mk_pat(let_pat_uni_) -> let_pat_uni_ . [ COMMA COLON AS ]
## Transitions:
## Reductions:
-- On EQUAL BAR
--   reduce production let_pat_conj_ -> let_pat_uni_
-- On COMMA COLON AS
--   reduce production mk_pat(let_pat_uni_) -> let_pat_uni_

State 905:
## Known stack suffix:
## let_pat_conj_
## LR(1) items:
let_pattern_ -> let_pat_conj_ . [ EQUAL ]
mk_pat(let_pat_conj_) -> let_pat_conj_ . [ BAR ]
## Transitions:
## Reductions:
-- On EQUAL
--   reduce production let_pattern_ -> let_pat_conj_
-- On BAR
--   reduce production mk_pat(let_pat_conj_) -> let_pat_conj_

State 906:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq)
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) . EQUAL seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> LET ghost kind attrs(lident_op_nq) . mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On EQUAL shift to state 907
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On mk_expr(fun_defn) shift to state 911
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On fun_defn shift to state 914
-- On binders shift to state 915
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:

State 907:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) EQUAL
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL . seq_expr IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 908
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 908:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) EQUAL seq_expr
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 909
## Reductions:

State 909:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 910
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 910:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) EQUAL seq_expr IN seq_expr

State 911:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn)
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 912
## Reductions:

State 912:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 913
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 913:
## Known stack suffix:
## LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> LET ghost kind attrs(lident_op_nq) mk_expr(fun_defn) IN seq_expr

State 914:
## Known stack suffix:
## fun_defn
## LR(1) items:
mk_expr(fun_defn) -> fun_defn . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production mk_expr(fun_defn) -> fun_defn

State 915:
## Known stack suffix:
## binders
## LR(1) items:
fun_defn -> binders . return_opt spec EQUAL spec seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 148
-- On return_opt shift to state 916
## Reductions:
-- On WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES ALIAS
--   reduce production return_opt ->

State 916:
## Known stack suffix:
## binders return_opt
## LR(1) items:
fun_defn -> binders return_opt . spec EQUAL spec seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 917
-- On single_spec shift to state 567
## Reductions:
-- On EQUAL
--   reduce production spec ->

State 917:
## Known stack suffix:
## binders return_opt spec
## LR(1) items:
fun_defn -> binders return_opt spec . EQUAL spec seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 918
## Reductions:

State 918:
## Known stack suffix:
## binders return_opt spec EQUAL
## LR(1) items:
fun_defn -> binders return_opt spec EQUAL . spec seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 919
-- On single_spec shift to state 567
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production spec ->

State 919:
## Known stack suffix:
## binders return_opt spec EQUAL spec
## LR(1) items:
fun_defn -> binders return_opt spec EQUAL spec . seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 920
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 920:
## Known stack suffix:
## binders return_opt spec EQUAL spec seq_expr
## LR(1) items:
fun_defn -> binders return_opt spec EQUAL spec seq_expr . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production fun_defn -> binders return_opt spec EQUAL spec seq_expr

State 921:
## Known stack suffix:
## LET ghost kind attrs(lident_nq)
## LR(1) items:
pat_arg_ -> attrs(lident_nq) . [ EQUAL COMMA COLON BAR AS ]
single_expr_ -> LET ghost kind attrs(lident_nq) . mk_expr(fun_defn) IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On mk_expr(fun_defn) shift to state 922
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On fun_defn shift to state 914
-- On binders shift to state 915
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:
-- On EQUAL COMMA COLON BAR AS
--   reduce production pat_arg_ -> attrs(lident_nq)

State 922:
## Known stack suffix:
## LET ghost kind attrs(lident_nq) mk_expr(fun_defn)
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) . IN seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On IN shift to state 923
## Reductions:

State 923:
## Known stack suffix:
## LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN . seq_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 924
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 924:
## Known stack suffix:
## LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr
## LR(1) items:
single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> LET ghost kind attrs(lident_nq) mk_expr(fun_defn) IN seq_expr

State 925:
## Known stack suffix:
## MATCH seq_expr
## LR(1) items:
single_expr_ -> MATCH seq_expr . WITH ext_match_cases END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WITH shift to state 926
## Reductions:

State 926:
## Known stack suffix:
## MATCH seq_expr WITH
## LR(1) items:
single_expr_ -> MATCH seq_expr WITH . ext_match_cases END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On EXCEPTION shift to state 927
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On BAR shift to state 942
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 935
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_case(seq_expr) shift to state 938
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On ext_match_cases1 shift to state 944
-- On ext_match_cases shift to state 945
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 927:
## Known stack suffix:
## EXCEPTION
## LR(1) items:
ext_match_cases1 -> EXCEPTION . exn_handler ext_match_cases0 [ END ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 928
-- On uident shift to state 89
-- On exn_handler shift to state 933
## Reductions:

State 928:
## Known stack suffix:
## uqualid
## LR(1) items:
exn_handler -> uqualid . option(pat_arg) ARROW seq_expr [ END BAR ]
uqualid -> uqualid . DOT uident [ UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT DOT CORE_UIDENT CORE_LIDENT ARROW ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On FLOAT shift to state 37
-- On DOT shift to state 526
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 231
-- On uident shift to state 89
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 233
-- On pat_arg shift to state 929
-- On option(pat_arg) shift to state 930
-- On mk_pat(pat_arg_) shift to state 236
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On attrs(lident_nq) shift to state 237
## Reductions:
-- On ARROW
--   reduce production option(pat_arg) ->

State 929:
## Known stack suffix:
## pat_arg
## LR(1) items:
option(pat_arg) -> pat_arg . [ ARROW ]
## Transitions:
## Reductions:
-- On ARROW
--   reduce production option(pat_arg) -> pat_arg

State 930:
## Known stack suffix:
## uqualid option(pat_arg)
## LR(1) items:
exn_handler -> uqualid option(pat_arg) . ARROW seq_expr [ END BAR ]
## Transitions:
-- On ARROW shift to state 931
## Reductions:

State 931:
## Known stack suffix:
## uqualid option(pat_arg) ARROW
## LR(1) items:
exn_handler -> uqualid option(pat_arg) ARROW . seq_expr [ END BAR ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 932
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 932:
## Known stack suffix:
## uqualid option(pat_arg) ARROW seq_expr
## LR(1) items:
exn_handler -> uqualid option(pat_arg) ARROW seq_expr . [ END BAR ]
## Transitions:
## Reductions:
-- On END BAR
--   reduce production exn_handler -> uqualid option(pat_arg) ARROW seq_expr

State 933:
## Known stack suffix:
## EXCEPTION exn_handler
## LR(1) items:
ext_match_cases1 -> EXCEPTION exn_handler . ext_match_cases0 [ END ]
## Transitions:
-- On BAR shift to state 934
-- On ext_match_cases0 shift to state 941
## Reductions:
-- On END
--   reduce production ext_match_cases0 ->

State 934:
## Known stack suffix:
## BAR
## LR(1) items:
ext_match_cases0 -> BAR . ext_match_cases1 [ END ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On EXCEPTION shift to state 927
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 935
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_case(seq_expr) shift to state 938
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On ext_match_cases1 shift to state 940
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 935:
## Known stack suffix:
## pattern
## LR(1) items:
match_case(seq_expr) -> pattern . ARROW seq_expr [ END BAR ]
## Transitions:
-- On ARROW shift to state 936
## Reductions:

State 936:
## Known stack suffix:
## pattern ARROW
## LR(1) items:
match_case(seq_expr) -> pattern ARROW . seq_expr [ END BAR ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 937
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 937:
## Known stack suffix:
## pattern ARROW seq_expr
## LR(1) items:
match_case(seq_expr) -> pattern ARROW seq_expr . [ END BAR ]
## Transitions:
## Reductions:
-- On END BAR
--   reduce production match_case(seq_expr) -> pattern ARROW seq_expr

State 938:
## Known stack suffix:
## match_case(seq_expr)
## LR(1) items:
ext_match_cases1 -> match_case(seq_expr) . ext_match_cases0 [ END ]
## Transitions:
-- On BAR shift to state 934
-- On ext_match_cases0 shift to state 939
## Reductions:
-- On END
--   reduce production ext_match_cases0 ->

State 939:
## Known stack suffix:
## match_case(seq_expr) ext_match_cases0
## LR(1) items:
ext_match_cases1 -> match_case(seq_expr) ext_match_cases0 . [ END ]
## Transitions:
## Reductions:
-- On END
--   reduce production ext_match_cases1 -> match_case(seq_expr) ext_match_cases0

State 940:
## Known stack suffix:
## BAR ext_match_cases1
## LR(1) items:
ext_match_cases0 -> BAR ext_match_cases1 . [ END ]
## Transitions:
## Reductions:
-- On END
--   reduce production ext_match_cases0 -> BAR ext_match_cases1

State 941:
## Known stack suffix:
## EXCEPTION exn_handler ext_match_cases0
## LR(1) items:
ext_match_cases1 -> EXCEPTION exn_handler ext_match_cases0 . [ END ]
## Transitions:
## Reductions:
-- On END
--   reduce production ext_match_cases1 -> EXCEPTION exn_handler ext_match_cases0

State 942:
## Known stack suffix:
## BAR
## LR(1) items:
ext_match_cases -> BAR . ext_match_cases1 [ END ]
## Transitions:
-- On UNDERSCORE shift to state 216
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 219
-- On LEFTBRC shift to state 220
-- On GHOST shift to state 226
-- On FLOAT shift to state 37
-- On EXCEPTION shift to state 927
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 66
-- On uqualid shift to state 227
-- On uident shift to state 89
-- On pattern_ shift to state 243
-- On pattern shift to state 935
-- On pat_uni_ shift to state 247
-- On pat_conj_ shift to state 248
-- On pat_block_ shift to state 232
-- On pat_arg_ shift to state 240
-- On mk_pat(pattern_) shift to state 249
-- On mk_pat(pat_uni_) shift to state 250
-- On mk_pat(pat_conj_) shift to state 260
-- On match_case(seq_expr) shift to state 938
-- On lident_nq shift to state 121
-- On lident_keyword shift to state 75
-- On ext_match_cases1 shift to state 943
-- On comma_list2(mk_pat(pat_uni_)) shift to state 263
-- On attrs(lident_nq) shift to state 237
## Reductions:

State 943:
## Known stack suffix:
## BAR ext_match_cases1
## LR(1) items:
ext_match_cases -> BAR ext_match_cases1 . [ END ]
## Transitions:
## Reductions:
-- On END
--   reduce production ext_match_cases -> BAR ext_match_cases1

State 944:
## Known stack suffix:
## ext_match_cases1
## LR(1) items:
ext_match_cases -> ext_match_cases1 . [ END ]
## Transitions:
## Reductions:
-- On END
--   reduce production ext_match_cases -> ext_match_cases1

State 945:
## Known stack suffix:
## MATCH seq_expr WITH ext_match_cases
## LR(1) items:
single_expr_ -> MATCH seq_expr WITH ext_match_cases . END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On END shift to state 946
## Reductions:

State 946:
## Known stack suffix:
## MATCH seq_expr WITH ext_match_cases END
## LR(1) items:
single_expr_ -> MATCH seq_expr WITH ext_match_cases END . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> MATCH seq_expr WITH ext_match_cases END

State 947:
## Known stack suffix:
## NOT single_expr
## LR(1) items:
single_expr_ -> single_expr . AMPAMP single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . BARBAR single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> NOT single_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP1 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . EQUAL single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LTGT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . LT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . GT single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP2 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP3 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . OP4 single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . MINUS single_expr [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
single_expr_ -> single_expr . cast [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On OP4 shift to state 780
-- On OP3 shift to state 795
-- On OP2 shift to state 801
-- On OP1 shift to state 803
-- On MINUS shift to state 805
-- On LTGT shift to state 807
-- On LT shift to state 809
-- On GT shift to state 811
-- On EQUAL shift to state 813
-- On cast shift to state 782
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA LARROW INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> NOT single_expr

State 948:
## Known stack suffix:
## BEGIN END
## LR(1) items:
expr_block_ -> BEGIN END . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_block_ -> BEGIN END

State 949:
## Known stack suffix:
## BEGIN single_spec
## LR(1) items:
expr_block_ -> BEGIN single_spec . spec seq_expr END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> BEGIN single_spec . spec END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WRITES shift to state 197
-- On VARIANT shift to state 493
-- On RETURNS shift to state 505
-- On REQUIRES shift to state 509
-- On READS shift to state 513
-- On RAISES shift to state 522
-- On ENSURES shift to state 547
-- On DIVERGES shift to state 552
-- On ALIAS shift to state 553
-- On variant shift to state 565
-- On spec shift to state 950
-- On single_spec shift to state 567
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION END CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production spec ->

State 950:
## Known stack suffix:
## BEGIN single_spec spec
## LR(1) items:
expr_block_ -> BEGIN single_spec spec . seq_expr END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_block_ -> BEGIN single_spec spec . END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On END shift to state 951
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 952
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 951:
## Known stack suffix:
## BEGIN single_spec spec END
## LR(1) items:
expr_block_ -> BEGIN single_spec spec END . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_block_ -> BEGIN single_spec spec END

State 952:
## Known stack suffix:
## BEGIN single_spec spec seq_expr
## LR(1) items:
expr_block_ -> BEGIN single_spec spec seq_expr . END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On END shift to state 953
## Reductions:

State 953:
## Known stack suffix:
## BEGIN single_spec spec seq_expr END
## LR(1) items:
expr_block_ -> BEGIN single_spec spec seq_expr END . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_block_ -> BEGIN single_spec spec seq_expr END

State 954:
## Known stack suffix:
## BEGIN seq_expr
## LR(1) items:
expr_block_ -> BEGIN seq_expr . END [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On END shift to state 955
## Reductions:

State 955:
## Known stack suffix:
## BEGIN seq_expr END
## LR(1) items:
expr_block_ -> BEGIN seq_expr END . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_block_ -> BEGIN seq_expr END

State 956:
## Known stack suffix:
## LEFTBRC qualid
## LR(1) items:
expr_arg_ -> qualid . [ WITH LEFTSQ ]
expr_pure_ -> LEFTBRC qualid . RIGHTBRC [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTBRC shift to state 762
## Reductions:
-- On WITH LEFTSQ
--   reduce production expr_arg_ -> qualid

State 957:
## Known stack suffix:
## OPPREF expr_dot
## LR(1) items:
expr_dot_ -> OPPREF expr_dot . [ DOT ]
expr_sub_ -> expr_dot . DOT mk_expr(expr_pure_) [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_dot . DOT lqualid_rich [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On DOT
--   reduce production expr_dot_ -> OPPREF expr_dot

State 958:
## Known stack suffix:
## OPPREF expr_arg
## LR(1) items:
expr_arg_ -> OPPREF expr_arg . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr LARROW expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_arg_ -> OPPREF expr_arg

State 959:
## Known stack suffix:
## MINUS
## LR(1) items:
lident_op_str -> MINUS . UNDERSCORE [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
lident_op_str -> MINUS . [ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR ]
prefix_op -> MINUS . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
single_expr_ -> MINUS . INTEGER [ WRITES VARIANT SEMICOLON RIGHTPAR RETURNS REQUIRES READS RAISES OP4 OP3 OP2 OP1 MINUS LTGT LT LARROW GT EQUAL ENSURES DIVERGES COMMA COLON BARBAR AMPAMP ALIAS ]
single_expr_ -> MINUS . REAL [ WRITES VARIANT SEMICOLON RIGHTPAR RETURNS REQUIRES READS RAISES OP4 OP3 OP2 OP1 MINUS LTGT LT LARROW GT EQUAL ENSURES DIVERGES COMMA COLON BARBAR AMPAMP ALIAS ]
## Transitions:
-- On UNDERSCORE shift to state 13
-- On REAL shift to state 699
-- On INTEGER shift to state 700
## Reductions:
-- On RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
--   reduce production lident_op_str -> MINUS
-- On WHILE VAL UIDENT TRY TRUE RETURN RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production prefix_op -> MINUS

State 960:
## Known stack suffix:
## LEFTPAR seq_expr
## LR(1) items:
expr_block_ -> LEFTPAR seq_expr . RIGHTPAR [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 961
## Reductions:

State 961:
## Known stack suffix:
## LEFTPAR seq_expr RIGHTPAR
## LR(1) items:
expr_block_ -> LEFTPAR seq_expr RIGHTPAR . [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production expr_block_ -> LEFTPAR seq_expr RIGHTPAR

State 962:
## Known stack suffix:
## RAISE LEFTPAR uqualid option(expr_arg)
## LR(1) items:
single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) . RIGHTPAR [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On RIGHTPAR shift to state 963
## Reductions:

State 963:
## Known stack suffix:
## RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR
## LR(1) items:
single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> RAISE LEFTPAR uqualid option(expr_arg) RIGHTPAR

State 964:
## Known stack suffix:
## expr_arg
## LR(1) items:
expr_sub_ -> expr_arg . LEFTSQ expr rightsq [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr LARROW expr rightsq [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ expr DOTDOT rightsq [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
expr_sub_ -> expr_arg . LEFTSQ DOTDOT expr rightsq [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
option(expr_arg) -> expr_arg . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On LEFTSQ shift to state 776
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production option(expr_arg) -> expr_arg

State 965:
## Known stack suffix:
## RAISE uqualid
## LR(1) items:
single_expr_ -> RAISE uqualid . option(expr_arg) [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
uqualid -> uqualid . DOT uident [ WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 681
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On PURE shift to state 686
-- On OPPREF shift to state 690
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On INTEGER shift to state 206
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On DOT shift to state 526
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 696
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On qualid shift to state 744
-- On option(expr_arg) shift to state 966
-- On numeral shift to state 745
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 771
-- On expr_arg shift to state 964
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production option(expr_arg) ->

State 966:
## Known stack suffix:
## RAISE uqualid option(expr_arg)
## LR(1) items:
single_expr_ -> RAISE uqualid option(expr_arg) . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> RAISE uqualid option(expr_arg)

State 967:
## Known stack suffix:
## RETURN contract_expr
## LR(1) items:
single_expr_ -> RETURN contract_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> RETURN contract_expr

State 968:
## Known stack suffix:
## TRY seq_expr
## LR(1) items:
single_expr_ -> TRY seq_expr . WITH bar_list1(exn_handler) END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WITH shift to state 969
## Reductions:

State 969:
## Known stack suffix:
## TRY seq_expr WITH
## LR(1) items:
single_expr_ -> TRY seq_expr WITH . bar_list1(exn_handler) END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On BAR shift to state 970
-- On uqualid shift to state 928
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,exn_handler) shift to state 975
-- On exn_handler shift to state 972
-- On bar_list1(exn_handler) shift to state 976
## Reductions:

State 970:
## Known stack suffix:
## BAR
## LR(1) items:
bar_list1(exn_handler) -> BAR . separated_nonempty_list(BAR,exn_handler) [ END ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 928
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,exn_handler) shift to state 971
-- On exn_handler shift to state 972
## Reductions:

State 971:
## Known stack suffix:
## BAR separated_nonempty_list(BAR,exn_handler)
## LR(1) items:
bar_list1(exn_handler) -> BAR separated_nonempty_list(BAR,exn_handler) . [ END ]
## Transitions:
## Reductions:
-- On END
--   reduce production bar_list1(exn_handler) -> BAR separated_nonempty_list(BAR,exn_handler)

State 972:
## Known stack suffix:
## exn_handler
## LR(1) items:
separated_nonempty_list(BAR,exn_handler) -> exn_handler . [ END ]
separated_nonempty_list(BAR,exn_handler) -> exn_handler . BAR separated_nonempty_list(BAR,exn_handler) [ END ]
## Transitions:
-- On BAR shift to state 973
## Reductions:
-- On END
--   reduce production separated_nonempty_list(BAR,exn_handler) -> exn_handler

State 973:
## Known stack suffix:
## exn_handler BAR
## LR(1) items:
separated_nonempty_list(BAR,exn_handler) -> exn_handler BAR . separated_nonempty_list(BAR,exn_handler) [ END ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 928
-- On uident shift to state 89
-- On separated_nonempty_list(BAR,exn_handler) shift to state 974
-- On exn_handler shift to state 972
## Reductions:

State 974:
## Known stack suffix:
## exn_handler BAR separated_nonempty_list(BAR,exn_handler)
## LR(1) items:
separated_nonempty_list(BAR,exn_handler) -> exn_handler BAR separated_nonempty_list(BAR,exn_handler) . [ END ]
## Transitions:
## Reductions:
-- On END
--   reduce production separated_nonempty_list(BAR,exn_handler) -> exn_handler BAR separated_nonempty_list(BAR,exn_handler)

State 975:
## Known stack suffix:
## separated_nonempty_list(BAR,exn_handler)
## LR(1) items:
bar_list1(exn_handler) -> separated_nonempty_list(BAR,exn_handler) . [ END ]
## Transitions:
## Reductions:
-- On END
--   reduce production bar_list1(exn_handler) -> separated_nonempty_list(BAR,exn_handler)

State 976:
## Known stack suffix:
## TRY seq_expr WITH bar_list1(exn_handler)
## LR(1) items:
single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) . END [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On END shift to state 977
## Reductions:

State 977:
## Known stack suffix:
## TRY seq_expr WITH bar_list1(exn_handler) END
## LR(1) items:
single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> TRY seq_expr WITH bar_list1(exn_handler) END

State 978:
## Known stack suffix:
## VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr
## LR(1) items:
single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> VAL ghost kind attrs(lident_rich) mk_expr(val_defn) IN seq_expr

State 979:
## Known stack suffix:
## WHILE seq_expr
## LR(1) items:
single_expr_ -> WHILE seq_expr . DO loop_annotation loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On DO shift to state 980
## Reductions:

State 980:
## Known stack suffix:
## WHILE seq_expr DO
## LR(1) items:
single_expr_ -> WHILE seq_expr DO . loop_annotation loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On VARIANT shift to state 493
-- On INVARIANT shift to state 663
-- On variant shift to state 981
-- On loop_annotation shift to state 985
-- On invariant shift to state 983
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production loop_annotation ->

State 981:
## Known stack suffix:
## variant
## LR(1) items:
loop_annotation -> variant . loop_annotation [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On VARIANT shift to state 493
-- On INVARIANT shift to state 663
-- On variant shift to state 981
-- On loop_annotation shift to state 982
-- On invariant shift to state 983
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production loop_annotation ->

State 982:
## Known stack suffix:
## variant loop_annotation
## LR(1) items:
loop_annotation -> variant loop_annotation . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production loop_annotation -> variant loop_annotation

State 983:
## Known stack suffix:
## invariant
## LR(1) items:
loop_annotation -> invariant . loop_annotation [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
-- On VARIANT shift to state 493
-- On INVARIANT shift to state 663
-- On variant shift to state 981
-- On loop_annotation shift to state 984
-- On invariant shift to state 983
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production loop_annotation ->

State 984:
## Known stack suffix:
## invariant loop_annotation
## LR(1) items:
loop_annotation -> invariant loop_annotation . [ WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD ]
## Transitions:
## Reductions:
-- On WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
--   reduce production loop_annotation -> invariant loop_annotation

State 985:
## Known stack suffix:
## WHILE seq_expr DO loop_annotation
## LR(1) items:
single_expr_ -> WHILE seq_expr DO loop_annotation . loop_body DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 855
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On loop_body shift to state 986
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:
-- On DONE
--   reduce production loop_body ->

State 986:
## Known stack suffix:
## WHILE seq_expr DO loop_annotation loop_body
## LR(1) items:
single_expr_ -> WHILE seq_expr DO loop_annotation loop_body . DONE [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
-- On DONE shift to state 987
## Reductions:

State 987:
## Known stack suffix:
## WHILE seq_expr DO loop_annotation loop_body DONE
## LR(1) items:
single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS ]
## Transitions:
## Reductions:
-- On WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
--   reduce production single_expr_ -> WHILE seq_expr DO loop_annotation loop_body DONE

State 988:
## Known stack suffix:
## lqualid EQUAL expr
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr . [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr . SEMICOLON [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr . SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
## Transitions:
-- On SEMICOLON shift to state 989
## Reductions:
-- On RIGHTBRC
--   reduce production semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr

State 989:
## Known stack suffix:
## lqualid EQUAL expr SEMICOLON
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON . [ RIGHTBRC ]
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON . semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 221
-- On uident shift to state 89
-- On semicolon_list1(separated_pair(lqualid,EQUAL,expr)) shift to state 990
-- On lqualid shift to state 671
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:
-- On RIGHTBRC
--   reduce production semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON

State 990:
## Known stack suffix:
## lqualid EQUAL expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr))
## LR(1) items:
semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) . [ RIGHTBRC ]
## Transitions:
## Reductions:
-- On RIGHTBRC
--   reduce production semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr))

State 991:
## Known stack suffix:
## BY LEFTBRC field_list1(expr)
## LR(1) items:
type_witness -> BY LEFTBRC field_list1(expr) . RIGHTBRC [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RIGHTBRC shift to state 992
## Reductions:

State 992:
## Known stack suffix:
## BY LEFTBRC field_list1(expr) RIGHTBRC
## LR(1) items:
type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production type_witness -> BY LEFTBRC field_list1(expr) RIGHTBRC

State 993:
## Known stack suffix:
## attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness
## LR(1) items:
type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production type_decl -> attrs(lident_nq) list(ty_var) typedefn list(invariant) type_witness

State 994:
## Known stack suffix:
## separated_nonempty_list(WITH,type_decl)
## LR(1) items:
with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production with_list1(type_decl) -> separated_nonempty_list(WITH,type_decl)

State 995:
## Known stack suffix:
## THEORY
## LR(1) items:
module_head -> THEORY . attrs(uident_nq) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On CORE_UIDENT shift to state 648
-- On uident_nq shift to state 649
-- On attrs(uident_nq) shift to state 996
## Reductions:

State 996:
## Known stack suffix:
## THEORY attrs(uident_nq)
## LR(1) items:
module_head -> THEORY attrs(uident_nq) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production module_head -> THEORY attrs(uident_nq)

State 997:
## Known stack suffix:
## SCOPE
## LR(1) items:
scope_head -> SCOPE . boption(IMPORT) uident [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On IMPORT shift to state 577
-- On boption(IMPORT) shift to state 998
## Reductions:
-- On UIDENT CORE_UIDENT
--   reduce production boption(IMPORT) ->

State 998:
## Known stack suffix:
## SCOPE boption(IMPORT)
## LR(1) items:
scope_head -> SCOPE boption(IMPORT) . uident [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uident shift to state 999
## Reductions:

State 999:
## Known stack suffix:
## SCOPE boption(IMPORT) uident
## LR(1) items:
scope_head -> SCOPE boption(IMPORT) uident . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production scope_head -> SCOPE boption(IMPORT) uident

State 1000:
## Known stack suffix:
## PREDICATE
## LR(1) items:
pure_decl -> PREDICATE . predicate_decl list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On predicate_decl shift to state 1001
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On attrs(lident_rich) shift to state 1012
## Reductions:

State 1001:
## Known stack suffix:
## PREDICATE predicate_decl
## LR(1) items:
pure_decl -> PREDICATE predicate_decl . list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 1002
-- On with_logic_decl shift to state 1009
-- On list(with_logic_decl) shift to state 1011
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production list(with_logic_decl) ->

State 1002:
## Known stack suffix:
## WITH
## LR(1) items:
with_logic_decl -> WITH . attrs(lident_rich) params option(cast) option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On attrs(lident_rich) shift to state 1003
## Reductions:

State 1003:
## Known stack suffix:
## WITH attrs(lident_rich)
## LR(1) items:
with_logic_decl -> WITH attrs(lident_rich) . params option(cast) option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 1004
-- On param shift to state 569
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COLON COINDUCTIVE CLONE AXIOM
--   reduce production list(param) ->

State 1004:
## Known stack suffix:
## WITH attrs(lident_rich) params
## LR(1) items:
with_logic_decl -> WITH attrs(lident_rich) params . option(cast) option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 132
-- On option(cast) shift to state 1005
-- On cast shift to state 337
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production option(cast) ->

State 1005:
## Known stack suffix:
## WITH attrs(lident_rich) params option(cast)
## LR(1) items:
with_logic_decl -> WITH attrs(lident_rich) params option(cast) . option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1006
-- On option(preceded(EQUAL,term)) shift to state 1008
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production option(preceded(EQUAL,term)) ->

State 1006:
## Known stack suffix:
## EQUAL
## LR(1) items:
option(preceded(EQUAL,term)) -> EQUAL . term [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 1007
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 1007:
## Known stack suffix:
## EQUAL term
## LR(1) items:
option(preceded(EQUAL,term)) -> EQUAL term . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production option(preceded(EQUAL,term)) -> EQUAL term

State 1008:
## Known stack suffix:
## WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))
## LR(1) items:
with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term)) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production with_logic_decl -> WITH attrs(lident_rich) params option(cast) option(preceded(EQUAL,term))

State 1009:
## Known stack suffix:
## with_logic_decl
## LR(1) items:
list(with_logic_decl) -> with_logic_decl . list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 1002
-- On with_logic_decl shift to state 1009
-- On list(with_logic_decl) shift to state 1010
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production list(with_logic_decl) ->

State 1010:
## Known stack suffix:
## with_logic_decl list(with_logic_decl)
## LR(1) items:
list(with_logic_decl) -> with_logic_decl list(with_logic_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production list(with_logic_decl) -> with_logic_decl list(with_logic_decl)

State 1011:
## Known stack suffix:
## PREDICATE predicate_decl list(with_logic_decl)
## LR(1) items:
pure_decl -> PREDICATE predicate_decl list(with_logic_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production pure_decl -> PREDICATE predicate_decl list(with_logic_decl)

State 1012:
## Known stack suffix:
## attrs(lident_rich)
## LR(1) items:
predicate_decl -> attrs(lident_rich) . params option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 1013
-- On param shift to state 569
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production list(param) ->

State 1013:
## Known stack suffix:
## attrs(lident_rich) params
## LR(1) items:
predicate_decl -> attrs(lident_rich) params . option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1006
-- On option(preceded(EQUAL,term)) shift to state 1014
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production option(preceded(EQUAL,term)) ->

State 1014:
## Known stack suffix:
## attrs(lident_rich) params option(preceded(EQUAL,term))
## LR(1) items:
predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term)) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production predicate_decl -> attrs(lident_rich) params option(preceded(EQUAL,term))

State 1015:
## Known stack suffix:
## MODULE
## LR(1) items:
module_head -> MODULE . attrs(uident_nq) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On CORE_UIDENT shift to state 648
-- On uident_nq shift to state 649
-- On attrs(uident_nq) shift to state 1016
## Reductions:

State 1016:
## Known stack suffix:
## MODULE attrs(uident_nq)
## LR(1) items:
module_head -> MODULE attrs(uident_nq) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production module_head -> MODULE attrs(uident_nq)

State 1017:
## Known stack suffix:
## META
## LR(1) items:
meta_decl -> META . sident comma_list1(meta_arg) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 1018
-- On sident shift to state 1019
-- On lident_keyword shift to state 43
-- On lident shift to state 586
## Reductions:

State 1018:
## Known stack suffix:
## uident
## LR(1) items:
sident -> uident . [ TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION CONSTANT AXIOM ]
## Transitions:
## Reductions:
-- On TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION CONSTANT AXIOM
--   reduce production sident -> uident

State 1019:
## Known stack suffix:
## META sident
## LR(1) items:
meta_decl -> META sident . comma_list1(meta_arg) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On TYPE shift to state 1020
-- On STRING shift to state 1022
-- On PREDICATE shift to state 1023
-- On LEMMA shift to state 1025
-- On INTEGER shift to state 1027
-- On GOAL shift to state 1028
-- On FUNCTION shift to state 1030
-- On CONSTANT shift to state 1032
-- On AXIOM shift to state 1034
-- On separated_nonempty_list(COMMA,meta_arg) shift to state 1036
-- On meta_arg shift to state 1037
-- On comma_list1(meta_arg) shift to state 1040
## Reductions:

State 1020:
## Known stack suffix:
## TYPE
## LR(1) items:
meta_arg -> TYPE . ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 1021
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 1021:
## Known stack suffix:
## TYPE ty
## LR(1) items:
meta_arg -> TYPE ty . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
ty -> ty . ARROW ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ARROW ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production meta_arg -> TYPE ty

State 1022:
## Known stack suffix:
## STRING
## LR(1) items:
meta_arg -> STRING . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production meta_arg -> STRING

State 1023:
## Known stack suffix:
## PREDICATE
## LR(1) items:
meta_arg -> PREDICATE . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1024
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1024:
## Known stack suffix:
## PREDICATE qualid
## LR(1) items:
meta_arg -> PREDICATE qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production meta_arg -> PREDICATE qualid

State 1025:
## Known stack suffix:
## LEMMA
## LR(1) items:
meta_arg -> LEMMA . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1026
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1026:
## Known stack suffix:
## LEMMA qualid
## LR(1) items:
meta_arg -> LEMMA qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production meta_arg -> LEMMA qualid

State 1027:
## Known stack suffix:
## INTEGER
## LR(1) items:
meta_arg -> INTEGER . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production meta_arg -> INTEGER

State 1028:
## Known stack suffix:
## GOAL
## LR(1) items:
meta_arg -> GOAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1029
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1029:
## Known stack suffix:
## GOAL qualid
## LR(1) items:
meta_arg -> GOAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production meta_arg -> GOAL qualid

State 1030:
## Known stack suffix:
## FUNCTION
## LR(1) items:
meta_arg -> FUNCTION . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1031
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1031:
## Known stack suffix:
## FUNCTION qualid
## LR(1) items:
meta_arg -> FUNCTION qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production meta_arg -> FUNCTION qualid

State 1032:
## Known stack suffix:
## CONSTANT
## LR(1) items:
meta_arg -> CONSTANT . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1033
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1033:
## Known stack suffix:
## CONSTANT qualid
## LR(1) items:
meta_arg -> CONSTANT qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production meta_arg -> CONSTANT qualid

State 1034:
## Known stack suffix:
## AXIOM
## LR(1) items:
meta_arg -> AXIOM . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1035
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1035:
## Known stack suffix:
## AXIOM qualid
## LR(1) items:
meta_arg -> AXIOM qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production meta_arg -> AXIOM qualid

State 1036:
## Known stack suffix:
## separated_nonempty_list(COMMA,meta_arg)
## LR(1) items:
comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production comma_list1(meta_arg) -> separated_nonempty_list(COMMA,meta_arg)

State 1037:
## Known stack suffix:
## meta_arg
## LR(1) items:
separated_nonempty_list(COMMA,meta_arg) -> meta_arg . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(COMMA,meta_arg) -> meta_arg . COMMA separated_nonempty_list(COMMA,meta_arg) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COMMA shift to state 1038
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg

State 1038:
## Known stack suffix:
## meta_arg COMMA
## LR(1) items:
separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA . separated_nonempty_list(COMMA,meta_arg) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On TYPE shift to state 1020
-- On STRING shift to state 1022
-- On PREDICATE shift to state 1023
-- On LEMMA shift to state 1025
-- On INTEGER shift to state 1027
-- On GOAL shift to state 1028
-- On FUNCTION shift to state 1030
-- On CONSTANT shift to state 1032
-- On AXIOM shift to state 1034
-- On separated_nonempty_list(COMMA,meta_arg) shift to state 1039
-- On meta_arg shift to state 1037
## Reductions:

State 1039:
## Known stack suffix:
## meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)
## LR(1) items:
separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA separated_nonempty_list(COMMA,meta_arg)

State 1040:
## Known stack suffix:
## META sident comma_list1(meta_arg)
## LR(1) items:
meta_decl -> META sident comma_list1(meta_arg) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production meta_decl -> META sident comma_list1(meta_arg)

State 1041:
## Known stack suffix:
## LET
## LR(1) items:
prog_decl -> LET . ghost kind attrs(lident_rich) mk_expr(fun_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> LET . ghost kind attrs(lident_rich) const_defn [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> LET . REC with_list1(rec_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On REC shift to state 1042
-- On GHOST shift to state 53
-- On ghost shift to state 1044
## Reductions:
-- On RANGE PREDICATE LIDENT LEMMA LEFTPAR FUNCTION FLOAT CORE_LIDENT CONSTANT
--   reduce production ghost ->

State 1042:
## Known stack suffix:
## LET REC
## LR(1) items:
prog_decl -> LET REC . with_list1(rec_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On GHOST shift to state 53
-- On with_list1(rec_defn) shift to state 1043
-- On separated_nonempty_list(WITH,rec_defn) shift to state 869
-- On rec_defn shift to state 870
-- On ghost shift to state 873
## Reductions:
-- On RANGE PREDICATE LIDENT LEMMA LEFTPAR FUNCTION FLOAT CORE_LIDENT CONSTANT
--   reduce production ghost ->

State 1043:
## Known stack suffix:
## LET REC with_list1(rec_defn)
## LR(1) items:
prog_decl -> LET REC with_list1(rec_defn) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production prog_decl -> LET REC with_list1(rec_defn)

State 1044:
## Known stack suffix:
## LET ghost
## LR(1) items:
prog_decl -> LET ghost . kind attrs(lident_rich) mk_expr(fun_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> LET ghost . kind attrs(lident_rich) const_defn [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On PREDICATE shift to state 55
-- On LEMMA shift to state 56
-- On FUNCTION shift to state 57
-- On CONSTANT shift to state 58
-- On kind shift to state 1045
## Reductions:
-- On RANGE LIDENT LEFTPAR FLOAT CORE_LIDENT
--   reduce production kind ->

State 1045:
## Known stack suffix:
## LET ghost kind
## LR(1) items:
prog_decl -> LET ghost kind . attrs(lident_rich) mk_expr(fun_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> LET ghost kind . attrs(lident_rich) const_defn [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On attrs(lident_rich) shift to state 1046
## Reductions:

State 1046:
## Known stack suffix:
## LET ghost kind attrs(lident_rich)
## LR(1) items:
prog_decl -> LET ghost kind attrs(lident_rich) . mk_expr(fun_defn) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> LET ghost kind attrs(lident_rich) . const_defn [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 272
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On EQUAL shift to state 1047
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On COLON shift to state 132
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 286
-- On quote_lident shift to state 96
-- On nonempty_list(binder) shift to state 287
-- On mk_expr(fun_defn) shift to state 1049
-- On lqualid shift to state 100
-- On lident_nq shift to state 288
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On fun_defn shift to state 914
-- On const_defn shift to state 1050
-- On cast shift to state 1051
-- On binders shift to state 915
-- On binder shift to state 417
-- On anon_binder shift to state 420
## Reductions:

State 1047:
## Known stack suffix:
## EQUAL
## LR(1) items:
const_defn -> EQUAL . seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 1048
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 1048:
## Known stack suffix:
## EQUAL seq_expr
## LR(1) items:
const_defn -> EQUAL seq_expr . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production const_defn -> EQUAL seq_expr

State 1049:
## Known stack suffix:
## LET ghost kind attrs(lident_rich) mk_expr(fun_defn)
## LR(1) items:
prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production prog_decl -> LET ghost kind attrs(lident_rich) mk_expr(fun_defn)

State 1050:
## Known stack suffix:
## LET ghost kind attrs(lident_rich) const_defn
## LR(1) items:
prog_decl -> LET ghost kind attrs(lident_rich) const_defn . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production prog_decl -> LET ghost kind attrs(lident_rich) const_defn

State 1051:
## Known stack suffix:
## cast
## LR(1) items:
const_defn -> cast . EQUAL seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1052
## Reductions:

State 1052:
## Known stack suffix:
## cast EQUAL
## LR(1) items:
const_defn -> cast EQUAL . seq_expr [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WHILE shift to state 673
-- On VAL shift to state 674
-- On UIDENT shift to state 1
-- On TRY shift to state 680
-- On TRUE shift to state 681
-- On RETURN shift to state 682
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On RAISE shift to state 683
-- On PURE shift to state 686
-- On POSITION shift to state 68
-- On OPPREF shift to state 690
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On NOT shift to state 697
-- On MINUS shift to state 698
-- On MATCH shift to state 701
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 702
-- On LEFTPAR shift to state 691
-- On LEFTBRC shift to state 694
-- On LABEL shift to state 706
-- On INTEGER shift to state 206
-- On IF shift to state 711
-- On GT shift to state 29
-- On GHOST shift to state 712
-- On FUN shift to state 713
-- On FOR shift to state 718
-- On FLOAT shift to state 37
-- On FALSE shift to state 695
-- On EXCEPTION shift to state 721
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On CONTINUE shift to state 726
-- On CHECK shift to state 728
-- On BREAK shift to state 729
-- On BEGIN shift to state 696
-- On ATTRIBUTE shift to state 69
-- On ASSUME shift to state 731
-- On ASSERT shift to state 732
-- On ANY shift to state 733
-- On ABSURD shift to state 736
-- On uqualid shift to state 737
-- On uident shift to state 302
-- On single_expr_ shift to state 778
-- On single_expr shift to state 779
-- On seq_expr shift to state 1053
-- On qualid shift to state 744
-- On prefix_op shift to state 783
-- On op_symbol shift to state 348
-- On numeral shift to state 745
-- On mk_expr(single_expr_) shift to state 785
-- On mk_expr(expr_dot_) shift to state 746
-- On mk_expr(expr_arg_) shift to state 747
-- On lqualid shift to state 786
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On expr_sub_ shift to state 753
-- On expr_pure_ shift to state 754
-- On expr_dot_ shift to state 755
-- On expr_dot shift to state 756
-- On expr_block_ shift to state 770
-- On expr_arg_ shift to state 787
-- On expr_arg shift to state 788
-- On expr shift to state 836
-- On contract_expr shift to state 839
-- On attr shift to state 793
-- On assign_expr shift to state 842
-- On assertion_kind shift to state 797
## Reductions:

State 1053:
## Known stack suffix:
## cast EQUAL seq_expr
## LR(1) items:
const_defn -> cast EQUAL seq_expr . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production const_defn -> cast EQUAL seq_expr

State 1054:
## Known stack suffix:
## LEMMA
## LR(1) items:
pure_decl -> LEMMA . attrs(ident_nq) COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 648
-- On CORE_LIDENT shift to state 66
-- On uident_nq shift to state 1055
-- On lident_op_nq shift to state 1056
-- On lident_nq shift to state 1057
-- On lident_keyword shift to state 75
-- On ident_nq shift to state 1058
-- On attrs(ident_nq) shift to state 1060
## Reductions:

State 1055:
## Known stack suffix:
## uident_nq
## LR(1) items:
ident_nq -> uident_nq . [ POSITION COLON ATTRIBUTE ]
## Transitions:
## Reductions:
-- On POSITION COLON ATTRIBUTE
--   reduce production ident_nq -> uident_nq

State 1056:
## Known stack suffix:
## lident_op_nq
## LR(1) items:
ident_nq -> lident_op_nq . [ POSITION COLON ATTRIBUTE ]
## Transitions:
## Reductions:
-- On POSITION COLON ATTRIBUTE
--   reduce production ident_nq -> lident_op_nq

State 1057:
## Known stack suffix:
## lident_nq
## LR(1) items:
ident_nq -> lident_nq . [ POSITION COLON ATTRIBUTE ]
## Transitions:
## Reductions:
-- On POSITION COLON ATTRIBUTE
--   reduce production ident_nq -> lident_nq

State 1058:
## Known stack suffix:
## ident_nq
## LR(1) items:
attrs(ident_nq) -> ident_nq . list(attr) [ COLON ]
## Transitions:
-- On POSITION shift to state 68
-- On ATTRIBUTE shift to state 69
-- On list(attr) shift to state 1059
-- On attr shift to state 71
## Reductions:
-- On COLON
--   reduce production list(attr) ->

State 1059:
## Known stack suffix:
## ident_nq list(attr)
## LR(1) items:
attrs(ident_nq) -> ident_nq list(attr) . [ COLON ]
## Transitions:
## Reductions:
-- On COLON
--   reduce production attrs(ident_nq) -> ident_nq list(attr)

State 1060:
## Known stack suffix:
## LEMMA attrs(ident_nq)
## LR(1) items:
pure_decl -> LEMMA attrs(ident_nq) . COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 1061
## Reductions:

State 1061:
## Known stack suffix:
## LEMMA attrs(ident_nq) COLON
## LR(1) items:
pure_decl -> LEMMA attrs(ident_nq) COLON . term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 1062
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 1062:
## Known stack suffix:
## LEMMA attrs(ident_nq) COLON term
## LR(1) items:
pure_decl -> LEMMA attrs(ident_nq) COLON term . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production pure_decl -> LEMMA attrs(ident_nq) COLON term

State 1063:
## Known stack suffix:
## INDUCTIVE
## LR(1) items:
pure_decl -> INDUCTIVE . with_list1(inductive_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On with_list1(inductive_decl) shift to state 1064
-- On separated_nonempty_list(WITH,inductive_decl) shift to state 1065
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On inductive_decl shift to state 1066
-- On attrs(lident_rich) shift to state 1069
## Reductions:

State 1064:
## Known stack suffix:
## INDUCTIVE with_list1(inductive_decl)
## LR(1) items:
pure_decl -> INDUCTIVE with_list1(inductive_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production pure_decl -> INDUCTIVE with_list1(inductive_decl)

State 1065:
## Known stack suffix:
## separated_nonempty_list(WITH,inductive_decl)
## LR(1) items:
with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production with_list1(inductive_decl) -> separated_nonempty_list(WITH,inductive_decl)

State 1066:
## Known stack suffix:
## inductive_decl
## LR(1) items:
separated_nonempty_list(WITH,inductive_decl) -> inductive_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(WITH,inductive_decl) -> inductive_decl . WITH separated_nonempty_list(WITH,inductive_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 1067
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl

State 1067:
## Known stack suffix:
## inductive_decl WITH
## LR(1) items:
separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH . separated_nonempty_list(WITH,inductive_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On separated_nonempty_list(WITH,inductive_decl) shift to state 1068
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On inductive_decl shift to state 1066
-- On attrs(lident_rich) shift to state 1069
## Reductions:

State 1068:
## Known stack suffix:
## inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)
## LR(1) items:
separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH separated_nonempty_list(WITH,inductive_decl)

State 1069:
## Known stack suffix:
## attrs(lident_rich)
## LR(1) items:
inductive_decl -> attrs(lident_rich) . params ind_defn [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 1070
-- On param shift to state 569
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production list(param) ->

State 1070:
## Known stack suffix:
## attrs(lident_rich) params
## LR(1) items:
inductive_decl -> attrs(lident_rich) params . ind_defn [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1071
-- On ind_defn shift to state 1082
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production ind_defn ->

State 1071:
## Known stack suffix:
## EQUAL
## LR(1) items:
ind_defn -> EQUAL . bar_list1(ind_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 648
-- On CORE_LIDENT shift to state 66
-- On BAR shift to state 1072
-- On uident_nq shift to state 1055
-- On separated_nonempty_list(BAR,ind_case) shift to state 1080
-- On lident_op_nq shift to state 1056
-- On lident_nq shift to state 1057
-- On lident_keyword shift to state 75
-- On ind_case shift to state 1074
-- On ident_nq shift to state 1058
-- On bar_list1(ind_case) shift to state 1081
-- On attrs(ident_nq) shift to state 1077
## Reductions:

State 1072:
## Known stack suffix:
## BAR
## LR(1) items:
bar_list1(ind_case) -> BAR . separated_nonempty_list(BAR,ind_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 648
-- On CORE_LIDENT shift to state 66
-- On uident_nq shift to state 1055
-- On separated_nonempty_list(BAR,ind_case) shift to state 1073
-- On lident_op_nq shift to state 1056
-- On lident_nq shift to state 1057
-- On lident_keyword shift to state 75
-- On ind_case shift to state 1074
-- On ident_nq shift to state 1058
-- On attrs(ident_nq) shift to state 1077
## Reductions:

State 1073:
## Known stack suffix:
## BAR separated_nonempty_list(BAR,ind_case)
## LR(1) items:
bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production bar_list1(ind_case) -> BAR separated_nonempty_list(BAR,ind_case)

State 1074:
## Known stack suffix:
## ind_case
## LR(1) items:
separated_nonempty_list(BAR,ind_case) -> ind_case . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(BAR,ind_case) -> ind_case . BAR separated_nonempty_list(BAR,ind_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On BAR shift to state 1075
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(BAR,ind_case) -> ind_case

State 1075:
## Known stack suffix:
## ind_case BAR
## LR(1) items:
separated_nonempty_list(BAR,ind_case) -> ind_case BAR . separated_nonempty_list(BAR,ind_case) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 648
-- On CORE_LIDENT shift to state 66
-- On uident_nq shift to state 1055
-- On separated_nonempty_list(BAR,ind_case) shift to state 1076
-- On lident_op_nq shift to state 1056
-- On lident_nq shift to state 1057
-- On lident_keyword shift to state 75
-- On ind_case shift to state 1074
-- On ident_nq shift to state 1058
-- On attrs(ident_nq) shift to state 1077
## Reductions:

State 1076:
## Known stack suffix:
## ind_case BAR separated_nonempty_list(BAR,ind_case)
## LR(1) items:
separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(BAR,ind_case) -> ind_case BAR separated_nonempty_list(BAR,ind_case)

State 1077:
## Known stack suffix:
## attrs(ident_nq)
## LR(1) items:
ind_case -> attrs(ident_nq) . COLON term [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
## Transitions:
-- On COLON shift to state 1078
## Reductions:

State 1078:
## Known stack suffix:
## attrs(ident_nq) COLON
## LR(1) items:
ind_case -> attrs(ident_nq) COLON . term [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 1079
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 1079:
## Known stack suffix:
## attrs(ident_nq) COLON term
## LR(1) items:
ind_case -> attrs(ident_nq) COLON term . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BAR AXIOM
--   reduce production ind_case -> attrs(ident_nq) COLON term

State 1080:
## Known stack suffix:
## separated_nonempty_list(BAR,ind_case)
## LR(1) items:
bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production bar_list1(ind_case) -> separated_nonempty_list(BAR,ind_case)

State 1081:
## Known stack suffix:
## EQUAL bar_list1(ind_case)
## LR(1) items:
ind_defn -> EQUAL bar_list1(ind_case) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production ind_defn -> EQUAL bar_list1(ind_case)

State 1082:
## Known stack suffix:
## attrs(lident_rich) params ind_defn
## LR(1) items:
inductive_decl -> attrs(lident_rich) params ind_defn . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production inductive_decl -> attrs(lident_rich) params ind_defn

State 1083:
## Known stack suffix:
## IMPORT
## LR(1) items:
module_decl -> IMPORT . uqualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On CORE_UIDENT shift to state 38
-- On uqualid shift to state 1084
-- On uident shift to state 89
## Reductions:

State 1084:
## Known stack suffix:
## IMPORT uqualid
## LR(1) items:
module_decl -> IMPORT uqualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
uqualid -> uqualid . DOT uident [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END DOT CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On DOT shift to state 526
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production module_decl -> IMPORT uqualid

State 1085:
## Known stack suffix:
## GOAL
## LR(1) items:
pure_decl -> GOAL . attrs(ident_nq) COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 648
-- On CORE_LIDENT shift to state 66
-- On uident_nq shift to state 1055
-- On lident_op_nq shift to state 1056
-- On lident_nq shift to state 1057
-- On lident_keyword shift to state 75
-- On ident_nq shift to state 1058
-- On attrs(ident_nq) shift to state 1086
## Reductions:

State 1086:
## Known stack suffix:
## GOAL attrs(ident_nq)
## LR(1) items:
pure_decl -> GOAL attrs(ident_nq) . COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 1087
## Reductions:

State 1087:
## Known stack suffix:
## GOAL attrs(ident_nq) COLON
## LR(1) items:
pure_decl -> GOAL attrs(ident_nq) COLON . term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 1088
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 1088:
## Known stack suffix:
## GOAL attrs(ident_nq) COLON term
## LR(1) items:
pure_decl -> GOAL attrs(ident_nq) COLON term . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production pure_decl -> GOAL attrs(ident_nq) COLON term

State 1089:
## Known stack suffix:
## FUNCTION
## LR(1) items:
pure_decl -> FUNCTION . function_decl list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On function_decl shift to state 1090
-- On attrs(lident_rich) shift to state 1092
## Reductions:

State 1090:
## Known stack suffix:
## FUNCTION function_decl
## LR(1) items:
pure_decl -> FUNCTION function_decl . list(with_logic_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 1002
-- On with_logic_decl shift to state 1009
-- On list(with_logic_decl) shift to state 1091
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production list(with_logic_decl) ->

State 1091:
## Known stack suffix:
## FUNCTION function_decl list(with_logic_decl)
## LR(1) items:
pure_decl -> FUNCTION function_decl list(with_logic_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production pure_decl -> FUNCTION function_decl list(with_logic_decl)

State 1092:
## Known stack suffix:
## attrs(lident_rich)
## LR(1) items:
function_decl -> attrs(lident_rich) . params cast option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UNDERSCORE shift to state 77
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 79
-- On LEFTPAR shift to state 80
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 144
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 146
-- On quote_lident shift to state 96
-- On params shift to state 1093
-- On param shift to state 569
-- On lqualid shift to state 100
-- On list(param) shift to state 575
-- On lident_nq shift to state 571
-- On lident_keyword shift to state 419
-- On lident shift to state 101
-- On anon_binder shift to state 573
## Reductions:
-- On COLON
--   reduce production list(param) ->

State 1093:
## Known stack suffix:
## attrs(lident_rich) params
## LR(1) items:
function_decl -> attrs(lident_rich) params . cast option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 1094
## Reductions:

State 1094:
## Known stack suffix:
## attrs(lident_rich) params cast
## LR(1) items:
function_decl -> attrs(lident_rich) params cast . option(preceded(EQUAL,term)) [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1006
-- On option(preceded(EQUAL,term)) shift to state 1095
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production option(preceded(EQUAL,term)) ->

State 1095:
## Known stack suffix:
## attrs(lident_rich) params cast option(preceded(EQUAL,term))
## LR(1) items:
function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term)) . [ WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production function_decl -> attrs(lident_rich) params cast option(preceded(EQUAL,term))

State 1096:
## Known stack suffix:
## EXCEPTION
## LR(1) items:
prog_decl -> EXCEPTION . attrs(uident_nq) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> EXCEPTION . attrs(uident_nq) return [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On CORE_UIDENT shift to state 648
-- On uident_nq shift to state 649
-- On attrs(uident_nq) shift to state 1097
## Reductions:

State 1097:
## Known stack suffix:
## EXCEPTION attrs(uident_nq)
## LR(1) items:
prog_decl -> EXCEPTION attrs(uident_nq) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
prog_decl -> EXCEPTION attrs(uident_nq) . return [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 723
-- On LEFTBRC shift to state 83
-- On GHOST shift to state 191
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 193
-- On return shift to state 1098
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production prog_decl -> EXCEPTION attrs(uident_nq)

State 1098:
## Known stack suffix:
## EXCEPTION attrs(uident_nq) return
## LR(1) items:
prog_decl -> EXCEPTION attrs(uident_nq) return . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production prog_decl -> EXCEPTION attrs(uident_nq) return

State 1099:
## Known stack suffix:
## CONSTANT
## LR(1) items:
pure_decl -> CONSTANT . constant_decl [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On constant_decl shift to state 1100
-- On attrs(lident_rich) shift to state 1101
## Reductions:

State 1100:
## Known stack suffix:
## CONSTANT constant_decl
## LR(1) items:
pure_decl -> CONSTANT constant_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production pure_decl -> CONSTANT constant_decl

State 1101:
## Known stack suffix:
## attrs(lident_rich)
## LR(1) items:
constant_decl -> attrs(lident_rich) . cast option(preceded(EQUAL,term)) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 132
-- On cast shift to state 1102
## Reductions:

State 1102:
## Known stack suffix:
## attrs(lident_rich) cast
## LR(1) items:
constant_decl -> attrs(lident_rich) cast . option(preceded(EQUAL,term)) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1006
-- On option(preceded(EQUAL,term)) shift to state 1103
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production option(preceded(EQUAL,term)) ->

State 1103:
## Known stack suffix:
## attrs(lident_rich) cast option(preceded(EQUAL,term))
## LR(1) items:
constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term)) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production constant_decl -> attrs(lident_rich) cast option(preceded(EQUAL,term))

State 1104:
## Known stack suffix:
## COINDUCTIVE
## LR(1) items:
pure_decl -> COINDUCTIVE . with_list1(inductive_decl) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_LIDENT shift to state 66
-- On with_list1(inductive_decl) shift to state 1105
-- On separated_nonempty_list(WITH,inductive_decl) shift to state 1065
-- On lident_rich shift to state 67
-- On lident_op_nq shift to state 73
-- On lident_nq shift to state 74
-- On lident_keyword shift to state 75
-- On inductive_decl shift to state 1066
-- On attrs(lident_rich) shift to state 1069
## Reductions:

State 1105:
## Known stack suffix:
## COINDUCTIVE with_list1(inductive_decl)
## LR(1) items:
pure_decl -> COINDUCTIVE with_list1(inductive_decl) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production pure_decl -> COINDUCTIVE with_list1(inductive_decl)

State 1106:
## Known stack suffix:
## CLONE
## LR(1) items:
use_clone -> CLONE . EXPORT tqualid clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
use_clone -> CLONE . boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On IMPORT shift to state 577
-- On EXPORT shift to state 1107
-- On boption(IMPORT) shift to state 1150
## Reductions:
-- On UIDENT STRING RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
--   reduce production boption(IMPORT) ->

State 1107:
## Known stack suffix:
## CLONE EXPORT
## LR(1) items:
use_clone -> CLONE EXPORT . tqualid clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 580
-- On tqualid shift to state 1108
-- On squalid shift to state 582
-- On sident shift to state 587
-- On lident_keyword shift to state 43
-- On lident shift to state 586
## Reductions:

State 1108:
## Known stack suffix:
## CLONE EXPORT tqualid
## LR(1) items:
use_clone -> CLONE EXPORT tqualid . clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 1109
-- On clone_subst shift to state 1149
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production clone_subst ->

State 1109:
## Known stack suffix:
## WITH
## LR(1) items:
clone_subst -> WITH . comma_list1(single_clone_subst) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On VAL shift to state 1110
-- On TYPE shift to state 1114
-- On PREDICATE shift to state 1119
-- On LEMMA shift to state 1123
-- On GOAL shift to state 1126
-- On FUNCTION shift to state 1129
-- On EXCEPTION shift to state 1133
-- On CONSTANT shift to state 1137
-- On AXIOM shift to state 1141
-- On single_clone_subst shift to state 1144
-- On separated_nonempty_list(COMMA,single_clone_subst) shift to state 1147
-- On comma_list1(single_clone_subst) shift to state 1148
## Reductions:

State 1110:
## Known stack suffix:
## VAL
## LR(1) items:
single_clone_subst -> VAL . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> VAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1111
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1111:
## Known stack suffix:
## VAL qualid
## LR(1) items:
single_clone_subst -> VAL qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> VAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1112
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> VAL qualid

State 1112:
## Known stack suffix:
## VAL qualid EQUAL
## LR(1) items:
single_clone_subst -> VAL qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1113
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1113:
## Known stack suffix:
## VAL qualid EQUAL qualid
## LR(1) items:
single_clone_subst -> VAL qualid EQUAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> VAL qualid EQUAL qualid

State 1114:
## Known stack suffix:
## TYPE
## LR(1) items:
single_clone_subst -> TYPE . qualid list(ty_var) EQUAL ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> TYPE . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1115
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1115:
## Known stack suffix:
## TYPE qualid
## LR(1) items:
single_clone_subst -> TYPE qualid . list(ty_var) EQUAL ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> TYPE qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On QUOTE_LIDENT shift to state 78
-- On ty_var shift to state 604
-- On quote_lident shift to state 605
-- On list(ty_var) shift to state 1116
-- On attrs(quote_lident) shift to state 608
## Reductions:
-- On EQUAL
--   reduce production list(ty_var) ->
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> TYPE qualid

State 1116:
## Known stack suffix:
## TYPE qualid list(ty_var)
## LR(1) items:
single_clone_subst -> TYPE qualid list(ty_var) . EQUAL ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1117
## Reductions:

State 1117:
## Known stack suffix:
## TYPE qualid list(ty_var) EQUAL
## LR(1) items:
single_clone_subst -> TYPE qualid list(ty_var) EQUAL . ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On QUOTE_LIDENT shift to state 78
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 82
-- On LEFTBRC shift to state 83
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 84
-- On uident shift to state 89
-- On ty_block shift to state 90
-- On ty_arg shift to state 91
-- On ty shift to state 1118
-- On quote_lident shift to state 96
-- On lqualid shift to state 97
-- On lident_keyword shift to state 43
-- On lident shift to state 101
## Reductions:

State 1118:
## Known stack suffix:
## TYPE qualid list(ty_var) EQUAL ty
## LR(1) items:
single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
ty -> ty . ARROW ty [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ARROW ]
## Transitions:
-- On ARROW shift to state 94
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> TYPE qualid list(ty_var) EQUAL ty

State 1119:
## Known stack suffix:
## PREDICATE
## LR(1) items:
single_clone_subst -> PREDICATE . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> PREDICATE . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1120
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1120:
## Known stack suffix:
## PREDICATE qualid
## LR(1) items:
single_clone_subst -> PREDICATE qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> PREDICATE qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1121
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> PREDICATE qualid

State 1121:
## Known stack suffix:
## PREDICATE qualid EQUAL
## LR(1) items:
single_clone_subst -> PREDICATE qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1122
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1122:
## Known stack suffix:
## PREDICATE qualid EQUAL qualid
## LR(1) items:
single_clone_subst -> PREDICATE qualid EQUAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> PREDICATE qualid EQUAL qualid

State 1123:
## Known stack suffix:
## LEMMA
## LR(1) items:
single_clone_subst -> LEMMA . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> LEMMA . DOT [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On DOT shift to state 1124
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1125
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1124:
## Known stack suffix:
## LEMMA DOT
## LR(1) items:
single_clone_subst -> LEMMA DOT . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> LEMMA DOT

State 1125:
## Known stack suffix:
## LEMMA qualid
## LR(1) items:
single_clone_subst -> LEMMA qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> LEMMA qualid

State 1126:
## Known stack suffix:
## GOAL
## LR(1) items:
single_clone_subst -> GOAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> GOAL . DOT [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On DOT shift to state 1127
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1128
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1127:
## Known stack suffix:
## GOAL DOT
## LR(1) items:
single_clone_subst -> GOAL DOT . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> GOAL DOT

State 1128:
## Known stack suffix:
## GOAL qualid
## LR(1) items:
single_clone_subst -> GOAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> GOAL qualid

State 1129:
## Known stack suffix:
## FUNCTION
## LR(1) items:
single_clone_subst -> FUNCTION . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> FUNCTION . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1130
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1130:
## Known stack suffix:
## FUNCTION qualid
## LR(1) items:
single_clone_subst -> FUNCTION qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> FUNCTION qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1131
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> FUNCTION qualid

State 1131:
## Known stack suffix:
## FUNCTION qualid EQUAL
## LR(1) items:
single_clone_subst -> FUNCTION qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1132
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1132:
## Known stack suffix:
## FUNCTION qualid EQUAL qualid
## LR(1) items:
single_clone_subst -> FUNCTION qualid EQUAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> FUNCTION qualid EQUAL qualid

State 1133:
## Known stack suffix:
## EXCEPTION
## LR(1) items:
single_clone_subst -> EXCEPTION . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> EXCEPTION . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1134
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1134:
## Known stack suffix:
## EXCEPTION qualid
## LR(1) items:
single_clone_subst -> EXCEPTION qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> EXCEPTION qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1135
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> EXCEPTION qualid

State 1135:
## Known stack suffix:
## EXCEPTION qualid EQUAL
## LR(1) items:
single_clone_subst -> EXCEPTION qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1136
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1136:
## Known stack suffix:
## EXCEPTION qualid EQUAL qualid
## LR(1) items:
single_clone_subst -> EXCEPTION qualid EQUAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> EXCEPTION qualid EQUAL qualid

State 1137:
## Known stack suffix:
## CONSTANT
## LR(1) items:
single_clone_subst -> CONSTANT . qualid EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> CONSTANT . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1138
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1138:
## Known stack suffix:
## CONSTANT qualid
## LR(1) items:
single_clone_subst -> CONSTANT qualid . EQUAL qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> CONSTANT qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On EQUAL shift to state 1139
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> CONSTANT qualid

State 1139:
## Known stack suffix:
## CONSTANT qualid EQUAL
## LR(1) items:
single_clone_subst -> CONSTANT qualid EQUAL . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1140
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1140:
## Known stack suffix:
## CONSTANT qualid EQUAL qualid
## LR(1) items:
single_clone_subst -> CONSTANT qualid EQUAL qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> CONSTANT qualid EQUAL qualid

State 1141:
## Known stack suffix:
## AXIOM
## LR(1) items:
single_clone_subst -> AXIOM . qualid [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
single_clone_subst -> AXIOM . DOT [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On DOT shift to state 1142
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid shift to state 1143
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1142:
## Known stack suffix:
## AXIOM DOT
## LR(1) items:
single_clone_subst -> AXIOM DOT . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> AXIOM DOT

State 1143:
## Known stack suffix:
## AXIOM qualid
## LR(1) items:
single_clone_subst -> AXIOM qualid . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
--   reduce production single_clone_subst -> AXIOM qualid

State 1144:
## Known stack suffix:
## single_clone_subst
## LR(1) items:
separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst . COMMA separated_nonempty_list(COMMA,single_clone_subst) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COMMA shift to state 1145
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst

State 1145:
## Known stack suffix:
## single_clone_subst COMMA
## LR(1) items:
separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA . separated_nonempty_list(COMMA,single_clone_subst) [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On VAL shift to state 1110
-- On TYPE shift to state 1114
-- On PREDICATE shift to state 1119
-- On LEMMA shift to state 1123
-- On GOAL shift to state 1126
-- On FUNCTION shift to state 1129
-- On EXCEPTION shift to state 1133
-- On CONSTANT shift to state 1137
-- On AXIOM shift to state 1141
-- On single_clone_subst shift to state 1144
-- On separated_nonempty_list(COMMA,single_clone_subst) shift to state 1146
## Reductions:

State 1146:
## Known stack suffix:
## single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)
## LR(1) items:
separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production separated_nonempty_list(COMMA,single_clone_subst) -> single_clone_subst COMMA separated_nonempty_list(COMMA,single_clone_subst)

State 1147:
## Known stack suffix:
## separated_nonempty_list(COMMA,single_clone_subst)
## LR(1) items:
comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production comma_list1(single_clone_subst) -> separated_nonempty_list(COMMA,single_clone_subst)

State 1148:
## Known stack suffix:
## WITH comma_list1(single_clone_subst)
## LR(1) items:
clone_subst -> WITH comma_list1(single_clone_subst) . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production clone_subst -> WITH comma_list1(single_clone_subst)

State 1149:
## Known stack suffix:
## CLONE EXPORT tqualid clone_subst
## LR(1) items:
use_clone -> CLONE EXPORT tqualid clone_subst . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production use_clone -> CLONE EXPORT tqualid clone_subst

State 1150:
## Known stack suffix:
## CLONE boption(IMPORT)
## LR(1) items:
use_clone -> CLONE boption(IMPORT) . tqualid option(preceded(AS,uident)) clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On STRING shift to state 579
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uident shift to state 580
-- On tqualid shift to state 1151
-- On squalid shift to state 582
-- On sident shift to state 587
-- On lident_keyword shift to state 43
-- On lident shift to state 586
## Reductions:

State 1151:
## Known stack suffix:
## CLONE boption(IMPORT) tqualid
## LR(1) items:
use_clone -> CLONE boption(IMPORT) tqualid . option(preceded(AS,uident)) clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On AS shift to state 592
-- On option(preceded(AS,uident)) shift to state 1152
## Reductions:
-- On WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production option(preceded(AS,uident)) ->

State 1152:
## Known stack suffix:
## CLONE boption(IMPORT) tqualid option(preceded(AS,uident))
## LR(1) items:
use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) . clone_subst [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On WITH shift to state 1109
-- On clone_subst shift to state 1153
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production clone_subst ->

State 1153:
## Known stack suffix:
## CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst
## LR(1) items:
use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production use_clone -> CLONE boption(IMPORT) tqualid option(preceded(AS,uident)) clone_subst

State 1154:
## Known stack suffix:
## AXIOM
## LR(1) items:
pure_decl -> AXIOM . attrs(ident_nq) COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 647
-- On RANGE shift to state 2
-- On LIDENT shift to state 60
-- On LEFTPAR shift to state 61
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 648
-- On CORE_LIDENT shift to state 66
-- On uident_nq shift to state 1055
-- On lident_op_nq shift to state 1056
-- On lident_nq shift to state 1057
-- On lident_keyword shift to state 75
-- On ident_nq shift to state 1058
-- On attrs(ident_nq) shift to state 1155
## Reductions:

State 1155:
## Known stack suffix:
## AXIOM attrs(ident_nq)
## LR(1) items:
pure_decl -> AXIOM attrs(ident_nq) . COLON term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On COLON shift to state 1156
## Reductions:

State 1156:
## Known stack suffix:
## AXIOM attrs(ident_nq) COLON
## LR(1) items:
pure_decl -> AXIOM attrs(ident_nq) COLON . term [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 1157
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 1157:
## Known stack suffix:
## AXIOM attrs(ident_nq) COLON term
## LR(1) items:
pure_decl -> AXIOM attrs(ident_nq) COLON term . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production pure_decl -> AXIOM attrs(ident_nq) COLON term

State 1158:
## Known stack suffix:
## use_clone
## LR(1) items:
module_decl -> use_clone . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production module_decl -> use_clone

State 1159:
## Known stack suffix:
## scope_head
## LR(1) items:
module_decl -> scope_head . list(module_decl) END [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On VAL shift to state 52
-- On USE shift to state 576
-- On TYPE shift to state 598
-- On SCOPE shift to state 997
-- On PREDICATE shift to state 1000
-- On META shift to state 1017
-- On LET shift to state 1041
-- On LEMMA shift to state 1054
-- On INDUCTIVE shift to state 1063
-- On IMPORT shift to state 1083
-- On GOAL shift to state 1085
-- On FUNCTION shift to state 1089
-- On EXCEPTION shift to state 1096
-- On CONSTANT shift to state 1099
-- On COINDUCTIVE shift to state 1104
-- On CLONE shift to state 1106
-- On AXIOM shift to state 1154
-- On use_clone shift to state 1158
-- On scope_head shift to state 1159
-- On pure_decl shift to state 1160
-- On prog_decl shift to state 1161
-- On module_decl shift to state 1162
-- On meta_decl shift to state 1163
-- On list(module_decl) shift to state 1165
## Reductions:
-- On END
--   reduce production list(module_decl) ->

State 1160:
## Known stack suffix:
## pure_decl
## LR(1) items:
module_decl -> pure_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production module_decl -> pure_decl

State 1161:
## Known stack suffix:
## prog_decl
## LR(1) items:
module_decl -> prog_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production module_decl -> prog_decl

State 1162:
## Known stack suffix:
## module_decl
## LR(1) items:
list(module_decl) -> module_decl . list(module_decl) [ END ]
## Transitions:
-- On VAL shift to state 52
-- On USE shift to state 576
-- On TYPE shift to state 598
-- On SCOPE shift to state 997
-- On PREDICATE shift to state 1000
-- On META shift to state 1017
-- On LET shift to state 1041
-- On LEMMA shift to state 1054
-- On INDUCTIVE shift to state 1063
-- On IMPORT shift to state 1083
-- On GOAL shift to state 1085
-- On FUNCTION shift to state 1089
-- On EXCEPTION shift to state 1096
-- On CONSTANT shift to state 1099
-- On COINDUCTIVE shift to state 1104
-- On CLONE shift to state 1106
-- On AXIOM shift to state 1154
-- On use_clone shift to state 1158
-- On scope_head shift to state 1159
-- On pure_decl shift to state 1160
-- On prog_decl shift to state 1161
-- On module_decl shift to state 1162
-- On meta_decl shift to state 1163
-- On list(module_decl) shift to state 1164
## Reductions:
-- On END
--   reduce production list(module_decl) ->

State 1163:
## Known stack suffix:
## meta_decl
## LR(1) items:
module_decl -> meta_decl . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production module_decl -> meta_decl

State 1164:
## Known stack suffix:
## module_decl list(module_decl)
## LR(1) items:
list(module_decl) -> module_decl list(module_decl) . [ END ]
## Transitions:
## Reductions:
-- On END
--   reduce production list(module_decl) -> module_decl list(module_decl)

State 1165:
## Known stack suffix:
## scope_head list(module_decl)
## LR(1) items:
module_decl -> scope_head list(module_decl) . END [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
-- On END shift to state 1166
## Reductions:

State 1166:
## Known stack suffix:
## scope_head list(module_decl) END
## LR(1) items:
module_decl -> scope_head list(module_decl) END . [ VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM ]
## Transitions:
## Reductions:
-- On VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
--   reduce production module_decl -> scope_head list(module_decl) END

State 1167:
## Known stack suffix:
## nonempty_list(module_decl)
## LR(1) items:
mlw_file -> nonempty_list(module_decl) . EOF [ # ]
## Transitions:
-- On EOF shift to state 1168
## Reductions:

State 1168:
## Known stack suffix:
## nonempty_list(module_decl) EOF
## LR(1) items:
mlw_file -> nonempty_list(module_decl) EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production mlw_file -> nonempty_list(module_decl) EOF

State 1169:
## Known stack suffix:
## module_head
## LR(1) items:
mlw_module -> module_head . list(module_decl) END [ THEORY MODULE EOF ]
## Transitions:
-- On VAL shift to state 52
-- On USE shift to state 576
-- On TYPE shift to state 598
-- On SCOPE shift to state 997
-- On PREDICATE shift to state 1000
-- On META shift to state 1017
-- On LET shift to state 1041
-- On LEMMA shift to state 1054
-- On INDUCTIVE shift to state 1063
-- On IMPORT shift to state 1083
-- On GOAL shift to state 1085
-- On FUNCTION shift to state 1089
-- On EXCEPTION shift to state 1096
-- On CONSTANT shift to state 1099
-- On COINDUCTIVE shift to state 1104
-- On CLONE shift to state 1106
-- On AXIOM shift to state 1154
-- On use_clone shift to state 1158
-- On scope_head shift to state 1159
-- On pure_decl shift to state 1160
-- On prog_decl shift to state 1161
-- On module_decl shift to state 1162
-- On meta_decl shift to state 1163
-- On list(module_decl) shift to state 1170
## Reductions:
-- On END
--   reduce production list(module_decl) ->

State 1170:
## Known stack suffix:
## module_head list(module_decl)
## LR(1) items:
mlw_module -> module_head list(module_decl) . END [ THEORY MODULE EOF ]
## Transitions:
-- On END shift to state 1171
## Reductions:

State 1171:
## Known stack suffix:
## module_head list(module_decl) END
## LR(1) items:
mlw_module -> module_head list(module_decl) END . [ THEORY MODULE EOF ]
## Transitions:
## Reductions:
-- On THEORY MODULE EOF
--   reduce production mlw_module -> module_head list(module_decl) END

State 1172:
## Known stack suffix:
## module_decl
## LR(1) items:
nonempty_list(module_decl) -> module_decl . [ EOF ]
nonempty_list(module_decl) -> module_decl . nonempty_list(module_decl) [ EOF ]
## Transitions:
-- On VAL shift to state 52
-- On USE shift to state 576
-- On TYPE shift to state 598
-- On SCOPE shift to state 997
-- On PREDICATE shift to state 1000
-- On META shift to state 1017
-- On LET shift to state 1041
-- On LEMMA shift to state 1054
-- On INDUCTIVE shift to state 1063
-- On IMPORT shift to state 1083
-- On GOAL shift to state 1085
-- On FUNCTION shift to state 1089
-- On EXCEPTION shift to state 1096
-- On CONSTANT shift to state 1099
-- On COINDUCTIVE shift to state 1104
-- On CLONE shift to state 1106
-- On AXIOM shift to state 1154
-- On use_clone shift to state 1158
-- On scope_head shift to state 1159
-- On pure_decl shift to state 1160
-- On prog_decl shift to state 1161
-- On nonempty_list(module_decl) shift to state 1173
-- On module_decl shift to state 1172
-- On meta_decl shift to state 1163
## Reductions:
-- On EOF
--   reduce production nonempty_list(module_decl) -> module_decl

State 1173:
## Known stack suffix:
## module_decl nonempty_list(module_decl)
## LR(1) items:
nonempty_list(module_decl) -> module_decl nonempty_list(module_decl) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production nonempty_list(module_decl) -> module_decl nonempty_list(module_decl)

State 1174:
## Known stack suffix:
## mlw_module
## LR(1) items:
list(mlw_module) -> mlw_module . list(mlw_module) [ EOF ]
## Transitions:
-- On THEORY shift to state 995
-- On MODULE shift to state 1015
-- On module_head shift to state 1169
-- On mlw_module shift to state 1174
-- On list(mlw_module) shift to state 1175
## Reductions:
-- On EOF
--   reduce production list(mlw_module) ->

State 1175:
## Known stack suffix:
## mlw_module list(mlw_module)
## LR(1) items:
list(mlw_module) -> mlw_module list(mlw_module) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production list(mlw_module) -> mlw_module list(mlw_module)

State 1176:
## Known stack suffix:
## mlw_file
## LR(1) items:
mlw_file' -> mlw_file . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept mlw_file

State 1177:
## Known stack suffix:
## list(mlw_module)
## LR(1) items:
mlw_file -> list(mlw_module) . EOF [ # ]
## Transitions:
-- On EOF shift to state 1178
## Reductions:

State 1178:
## Known stack suffix:
## list(mlw_module) EOF
## LR(1) items:
mlw_file -> list(mlw_module) EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production mlw_file -> list(mlw_module) EOF

State 1179:
## Known stack suffix:
##
## LR(1) items:
qualid_comma_list_eof' -> . qualid_comma_list_eof [ # ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On separated_nonempty_list(COMMA,qualid) shift to state 1180
-- On qualid_comma_list_eof shift to state 1181
-- On qualid shift to state 1182
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
-- On comma_list1(qualid) shift to state 1185
## Reductions:

State 1180:
## Known stack suffix:
## separated_nonempty_list(COMMA,qualid)
## LR(1) items:
comma_list1(qualid) -> separated_nonempty_list(COMMA,qualid) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production comma_list1(qualid) -> separated_nonempty_list(COMMA,qualid)

State 1181:
## Known stack suffix:
## qualid_comma_list_eof
## LR(1) items:
qualid_comma_list_eof' -> qualid_comma_list_eof . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept qualid_comma_list_eof

State 1182:
## Known stack suffix:
## qualid
## LR(1) items:
separated_nonempty_list(COMMA,qualid) -> qualid . [ EOF ]
separated_nonempty_list(COMMA,qualid) -> qualid . COMMA separated_nonempty_list(COMMA,qualid) [ EOF ]
## Transitions:
-- On COMMA shift to state 1183
## Reductions:
-- On EOF
--   reduce production separated_nonempty_list(COMMA,qualid) -> qualid

State 1183:
## Known stack suffix:
## qualid COMMA
## LR(1) items:
separated_nonempty_list(COMMA,qualid) -> qualid COMMA . separated_nonempty_list(COMMA,qualid) [ EOF ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On separated_nonempty_list(COMMA,qualid) shift to state 1184
-- On qualid shift to state 1182
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1184:
## Known stack suffix:
## qualid COMMA separated_nonempty_list(COMMA,qualid)
## LR(1) items:
separated_nonempty_list(COMMA,qualid) -> qualid COMMA separated_nonempty_list(COMMA,qualid) . [ EOF ]
## Transitions:
## Reductions:
-- On EOF
--   reduce production separated_nonempty_list(COMMA,qualid) -> qualid COMMA separated_nonempty_list(COMMA,qualid)

State 1185:
## Known stack suffix:
## comma_list1(qualid)
## LR(1) items:
qualid_comma_list_eof -> comma_list1(qualid) . EOF [ # ]
## Transitions:
-- On EOF shift to state 1186
## Reductions:

State 1186:
## Known stack suffix:
## comma_list1(qualid) EOF
## LR(1) items:
qualid_comma_list_eof -> comma_list1(qualid) EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production qualid_comma_list_eof -> comma_list1(qualid) EOF

State 1187:
## Known stack suffix:
##
## LR(1) items:
qualid_eof' -> . qualid_eof [ # ]
## Transitions:
-- On UIDENT shift to state 1
-- On RANGE shift to state 2
-- On LIDENT shift to state 3
-- On LEFTPAR shift to state 4
-- On FLOAT shift to state 37
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On uqualid shift to state 759
-- On uident shift to state 302
-- On qualid_eof shift to state 1188
-- On qualid shift to state 1189
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 44
-- On ident shift to state 355
## Reductions:

State 1188:
## Known stack suffix:
## qualid_eof
## LR(1) items:
qualid_eof' -> qualid_eof . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept qualid_eof

State 1189:
## Known stack suffix:
## qualid
## LR(1) items:
qualid_eof -> qualid . EOF [ # ]
## Transitions:
-- On EOF shift to state 1190
## Reductions:

State 1190:
## Known stack suffix:
## qualid EOF
## LR(1) items:
qualid_eof -> qualid EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production qualid_eof -> qualid EOF

State 1191:
## Known stack suffix:
##
## LR(1) items:
term_comma_list_eof' -> . term_comma_list_eof [ # ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_comma_list_eof shift to state 1192
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On single_term_ shift to state 321
-- On single_term shift to state 342
-- On separated_nonempty_list(COMMA,single_term) shift to state 388
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On comma_list1(single_term) shift to state 1193
-- On attr shift to state 356
## Reductions:

State 1192:
## Known stack suffix:
## term_comma_list_eof
## LR(1) items:
term_comma_list_eof' -> term_comma_list_eof . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept term_comma_list_eof

State 1193:
## Known stack suffix:
## comma_list1(single_term)
## LR(1) items:
term_comma_list_eof -> comma_list1(single_term) . EOF [ # ]
## Transitions:
-- On EOF shift to state 1194
## Reductions:

State 1194:
## Known stack suffix:
## comma_list1(single_term) EOF
## LR(1) items:
term_comma_list_eof -> comma_list1(single_term) EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production term_comma_list_eof -> comma_list1(single_term) EOF

State 1195:
## Known stack suffix:
##
## LR(1) items:
term_eof' -> . term_eof [ # ]
## Transitions:
-- On UIDENT shift to state 1
-- On TRUE shift to state 199
-- On REAL shift to state 200
-- On RANGE shift to state 2
-- On POSITION shift to state 68
-- On OPPREF shift to state 201
-- On OP4 shift to state 8
-- On OP3 shift to state 9
-- On OP2 shift to state 10
-- On OP1 shift to state 11
-- On OLD shift to state 209
-- On NOT shift to state 210
-- On MINUS shift to state 211
-- On MATCH shift to state 214
-- On LT shift to state 14
-- On LIDENT shift to state 3
-- On LET shift to state 215
-- On LEFTPAR shift to state 202
-- On LEFTBRC shift to state 205
-- On INTEGER shift to state 206
-- On IF shift to state 270
-- On GT shift to state 29
-- On FUN shift to state 271
-- On FORALL shift to state 292
-- On FLOAT shift to state 37
-- On FALSE shift to state 207
-- On EXISTS shift to state 293
-- On EPSILON shift to state 294
-- On CORE_UIDENT shift to state 38
-- On CORE_LIDENT shift to state 39
-- On BEGIN shift to state 208
-- On ATTRIBUTE shift to state 69
-- On uqualid shift to state 295
-- On uident shift to state 302
-- On term_sub_ shift to state 303
-- On term_eof shift to state 1196
-- On term_dot_ shift to state 304
-- On term_dot shift to state 305
-- On term_block_ shift to state 314
-- On term_arg_ shift to state 315
-- On term_arg shift to state 316
-- On term shift to state 1197
-- On single_term_ shift to state 321
-- On single_term shift to state 322
-- On quant shift to state 330
-- On qualid shift to state 345
-- On prefix_op shift to state 346
-- On op_symbol shift to state 348
-- On numeral shift to state 349
-- On mk_term(term_dot_) shift to state 350
-- On mk_term(term_arg_) shift to state 351
-- On mk_term(single_term_) shift to state 352
-- On lqualid shift to state 353
-- On lident_op shift to state 42
-- On lident_keyword shift to state 43
-- On lident shift to state 354
-- On ident shift to state 355
-- On attr shift to state 356
## Reductions:

State 1196:
## Known stack suffix:
## term_eof
## LR(1) items:
term_eof' -> term_eof . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept term_eof

State 1197:
## Known stack suffix:
## term
## LR(1) items:
term_eof -> term . EOF [ # ]
## Transitions:
-- On EOF shift to state 1198
## Reductions:

State 1198:
## Known stack suffix:
## term EOF
## LR(1) items:
term_eof -> term EOF . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production term_eof -> term EOF

